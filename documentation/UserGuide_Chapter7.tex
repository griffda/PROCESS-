\mychapter{Code Management Tools}
\label{chap:codetools}

This chapter will be of interest to people involved in the continuing
maintenance of the \process\ source code. As stated elsewhere, the source code
is maintained by CCFE, and resides in a Git repository on the CCFE servers.

\section{Environment set-up (developers only)}
\label{sec:run_environment_dev}

Please note that this section is only relevant for people actually developing the \process\/ code, i.e. if you are interested in running a copy of the code from your local directory on the fusion unix network. For normal users please refer to Chapter \ref{sec:run_environment}.

To set up the environment to run the code, the user interface and the associated utilities (see Chapter~\ref{chap:utilities}), add the following lines to your \texttt{.bashrc} file.  This is a file in the user's home directory, assuming the bash Unix shell is being used.  Although hidden, it can be opened by issuing the relevant command, for example \texttt{gedit .bashrc}.
\begin{quote}
\begin{verbatim}
module swap python
module unload NAG
module unload boost

If using default gfortran compiler instead of ifort:
(module unload ifort/10.0.023)
(module load gcc/4.8.2)

export PYTHONPATH=$PYTHONPATH:/PATH_TO_LOCAL_PROCESS_DIRECTORY/utilities
export PATH=$PATH:/PATH_TO_LOCAL_PROCESS_DIRECTORY
export PATH=$PATH:/PATH_TO_LOCAL_PROCESS_DIRECTORY/utilities
\end{verbatim}
\end{quote}

This loads and unloads the relevant modules and sets the path to the process and utilities executables as well as setting the correct path for the python libraries.


\section{The Makefile}
\label{sec:makefile}

In addition to its normal role for compilation, the makefile (named
\texttt{Makefile}) includes a number of utility functions that perform tasks
such as automatic generation of the code documentation, and the creation of a
tar file containing the entire source code, its documentation files, and the
input and output files. This has proved to be of great benefit in keeping all
of the data from a given run together for archival purposes.

\subsection{Compilation}

Compilation is trivially performed using the makefile. Currently, the
available options are (type the following on the command line):
\begin{tabbing}
123\=12345678901234567890\= \kill
\> \texttt{make ARCH=FUN} \> CCFE Fusion Unix Network (Intel Fortran ifort compiler) \\
\> \texttt{make ARCH=GFORT} \> GNU Fortran compiler (gfortran; N.B.\ only versions
4.6.3 or above) \\
\> \texttt{make ARCH=JAC} \> JET Analysis Cluster (pgf95 compiler)
\end{tabbing}
The GNU gfortran compiler is the default option, so typing simply
\texttt{make} will have the same effect as typing \texttt{make ARCH=GFORT}.

The code is almost trivial to port to new architectures, by adding extra
stanzas to the makefile as required.

To force a full recompilation, type \texttt{make clean}. N.B.\ This will
remove (without prompting) all ``backup'' files (\texttt{*\~}) as well as
certain other files from the working directory. For additionaly information
run \texttt{make help}.

Extra run-time diagnostics (array-bound checking, etc.) is turned on by
default at present; the code is sufficiently quick to run that the performance
penalty is barely noticeable. However, this can be turned off (beware\ldots
results can change!), by adding \texttt{DEBUG=NO} to the relevant command
above, i.e.\ type \verb+make ARCH=... DEBUG=NO+.  N.B.\ there must be no
spaces either side of the \texttt{=} characters in any of the above commands.

\subsection{Archiving utilities}

The makefile can be used in a number of ways to pack the various file sets
together into a single compressed tar file, for ease of portability and
archiving.

\begin{itemize}

\item \texttt{make tar}: Typing this command produces a file
  \texttt{process.tar.gz} that contains all of the source files, utility
  programs and documentation files necessary to run the program from scratch
  on a new machine or in a new directory. (Note that the input files \indat\
  and \texttt{device.dat} are not included.) This is useful for transferring
  new copies of source files, etc.\ into an existing directory already
  containing a previous \process\ run, as the pre-existing customised input
  files will not be overwritten. To extract the individual files again, copy
  the file to the destination working directory and type
  \verb+tar zxvf process.tar.gz+

\item \texttt{make archive}: Typing this command produces a file
  \texttt{process\_run.tar.gz} containing the working directory's input and
  output files (\indat, \outdat, \plotdat, \mfile\ and \texttt{device.dat}
  (which must exist to avoid an error message; see Section~\ref{sec:device}),
  together with all of the source files, utility programs and documentation
  files. These files together comprise the full set that define a given run,
  and so the file produced by this command is suitable for long-term storage
  for archival purposes. To extract the contents, type
  \verb+tar zxvf process_run.tar.gz+
\end{itemize}

Note that each of the above commands will overwrite the given named tar file
if one already exists in the working directory.

\subsection{Code documentation}

The makefile can also be used to produce source code documentation, as
described in the next section.

\section{Automatic Documentation}
\label{sec:autodoc}

The \process\ source code is self-documenting to a degree, using an included
parser program (\texttt{autodoc}) to generate html files for each subprogram
from specially-formatted comment lines within the code. It is the
responsibility of the programmer to keep the \texttt{autodoc} comments within
the source code relevant, comprehensive and up-to-date! Use the examples in
the code as a starting basis for new routines; the output section
corresponding to the various \texttt{autodoc} tags should be
self-explanatory. See also Section~\ref{sec:codemods}.

The following files are used:
\begin{verbatim}
   autodoc.f90
   adheader.src
   adfooter.src
\end{verbatim}
To create the ($\sim 430$) html files from the source code, type
\verb+make html+.  Then, point your favourite web browser to the file
\texttt{process.html} or \texttt{calling\_tree.html} in the working
directory. The variable descriptor file \texttt{vardes.html} (see
Section~\ref{sec:vardes}) is also produced at the same time (though it may be
helpful to modify the file manually afterwards to remove empty sections from
it).

In addition, a full \LaTeX\/ User Guide (this document!), contained within
\texttt{process.tex} and the other \texttt{.tex} files called from it, is
rigorously maintained to ensure its continuing strict agreement with the
evolving source code. To create an Adobe PDF file \texttt{process.pdf} from
\texttt{process.tex} (and the associated PostScript figures), type
\verb+make guide+.

Finally, to produce both the html files and the User Guide in one go, simply
type \verb+make doc+.

\section{Code Updates and Release Procedure}
\label{sec:code_release}

This section describes the procedures that should be followed whenever new
commits to the \texttt{develop} or \texttt{master} branches of the \process\
Git repository are to be made, and how new code releases are performed. It is
assumed that readers have a working knowledge of Git commands.


\subsection{Tagging}
\label{sec:tagging}
Tagging in \process\/ is used to document the version of the code any individual run has been performed with. This is necessary for proper provenance capture. Currently, only the gitlab commit number is unique, assuring full version control, but the \process\/ version tag documented in each output is not updated with each commit. From November 2016 onwards, we have changed our tagging system for the \process\/ versions (details see below). Any versions ending in {\bf .0} should be fully tested. How and when to tag versions is described in more detail in the upcoming sections detailing the code update and release procedures.

\subsubsection{Tagging in the development version}
Instead of having a single revision number - as was previously the case - we will be following the convention where the {\it development} version of \process\/ gets tagged according the format {\bf MasterRelease.MajorModel.MinorChange}, i.e. '1.3.29', corresponds to the 29th minor update since the implementation of the 3rd new major model after the 1st master release with the new tagging format.

\subsubsection{Tagging in the master version}
The {\it master} version of \process\/ will be tagged according to the format {\bf MasterRelease.0} and will correspond to the same code version as the development version with {\bf MasterRelease.0.0}.

\subsubsection{Tagging in a separate branch}
This section covers tagging in e.g. the separate DEMO1 baseline branch and assures that while this branch can develop independently of the development branch, it still has unique version tagging and provenance capture. Tagging of a separate branch should be started when it is forked from develop. Hence, the initial tag should be {\bf BID\_MasterRelease.MajorModel.MinorChange}, where {\bf BID} is a short but informative branch identifier consisting of letters only. This allows for branching from the development version at any point. Ideally it does start from a fully tested version though! \Red{Manoj, please check that both characters as well as the new dot format are possible options for the autodoc tool!}



\subsection{Initial access to the source code}
\label{sec:getsource}

To gain access to the \process\ source code Git repository, you need
to be given permission to do so via the CCFE \texttt{GitLab} server.
\begin{enumerate}

\item Use a web browser to go to
  \href{http://git.ccfe.ac.uk}{\texttt{http://git.ccfe.ac.uk}}

\item Login using your normal CCFE computer login details.

\item Assuming this is successful, contact the \texttt{GitLab} \process\
  ``Owner'' (currently James Morris james.morris2@ukaea.uk), who will add you to \texttt{GitLab} as a \process\ ``Developer''.

\item (If this is your first access to \texttt{GitLab}, you may have to set up
  SSH keys and a few other things; follow the instructions on screen.)

\item Login to a Fusion Unix Network machine.

\item \texttt{cd SomewhereAppropriate} (you choose!)

\item
\texttt{git clone git@git.ccfe.ac.uk:process/process.git -b develop my\_develop}
This copies the \texttt{develop} branch of the repository into a local folder \texttt{my\_develop}, which will be created if it does not already exist.
\item \texttt{cd my\_develop}

\item \texttt{git checkout develop}

The sequence of commands above will provide you with a full copy of the \texttt{develop} branch of the \process\ source code, Python utilities and all
the documentation files.

\item \texttt{make all}\\
This performs a full compilation and builds the executable, creates the User Guide, creates the python dictionaries and produces all the web-based documentation.

\end{enumerate}


\subsection{Git workflow}

The code management methodology is based on the so-called
\href{https://www.atlassian.com/git/workflows#!workflow-gitflow}{``gitflow''}
workflow. There are two main branches:
\begin{itemize}

\item \texttt{develop}, which is the basis for all code development work, and
  changes are committed to it frequently.

\item \texttt{master}, which contains official ``release'' versions of
  \process, and is updated on a roughly three-monthly timescale.

\end{itemize}

Development work on new models should use separate branches, named e.g.\
\texttt{dev\_mynewmodel}, split from the \texttt{develop} branch. It is a very
good idea to merge the \texttt{develop} branch into \texttt{dev\_mynewmodel}
frequently during the course of the work, so that changes to the main branch
are transferred to the new model's files with minimal effort.

Once the new model has been finished and tested successfully (complete with full
documentation --- see Section~\ref{sec:codemods}), the branch should be merged
back into the \texttt{develop} branch.

\Red{Note that typically development branches do not need version tagging as they should not be used in any production runs. However, e.g. for the DEMO baseline design a separate branch will be created to conserve the \process\/ output in the state when the baseline was fixed.}

\subsubsection{Branching from \texttt{develop}}

The following commands create a new branch in which to work on a new model. We
assume that you are already in the \texttt{process} directory created above
(Section~\ref{sec:getsource}).
\begin{enumerate}

\item \texttt{git checkout develop} (just to ensure that this is the branch
  \textit{from which}\/ you will be branching)

\item \texttt{git branch dev\_mynewmodel}

\item \texttt{git checkout dev\_mynewmodel}

\item \texttt{git push origin HEAD}  (updates the central \texttt{GitLab} repository)

\end{enumerate}

\subsubsection{Working on a new model}

Edit your local copies of the files as necessary. Whenever you want to save
the changes back to the repository (it is prudent to do this at the end of
each working day, as well as when the changes are complete, the code compiles
and all test runs are successful!), use the following commands:
\begin{enumerate}

\item \texttt{git status}  (this will show a list of modified files)

\item \texttt{git add changedfile1 changedfile2 ...}  \\
  (This `stages' the modified files marking them as ready for committing).  \\
  \texttt{git commit}

  Alternatively, just use\\
  \texttt{git commit -a} \\
  This commits all modified tracked files.

\item An editor window will open; add a line summarising the changes you have made, save and close the window. This will initiate the commit to your \textit{local}\ copy of the repository.

\item \texttt{git push} \\
Copies the changes you have made locally to the version in the central \texttt{GitLab} repository.  This uses a merging process, but if no-one else has changed your branch then the central version will simply become a copy of your local version.

\end{enumerate}

\subsubsection{Merging \texttt{develop} into working branch}

It is a good idea to periodically merge the \texttt{develop} branch into the branch in which you are working, to ensure that any changes made in \texttt{develop} are included in your working branch.
\begin{enumerate}

\item Firstly, make sure you have committed your latest changes into the
  central \texttt{GitLab} repository as described in the previous section.  Set the directory containing the working branch as your current directory.

\item \texttt{git pull}.  \\
Merges the version in the central repository into the local branch by copying over any changes that have been made in the version stored centrally.

\item \texttt{git checkout develop}  \\
This switches the "current branch" to \texttt{develop}.

\item \texttt{git pull} \\
Updates the current branch of the local repository to the same branch on the central repository.

\item \texttt{git checkout dev\_mynewmodel}  \\
This switches the "current branch" to \texttt{dev\_mynewmodel}.

\item \texttt{git merge develop} \\
Merges \texttt{develop} into the \texttt{dev\_mynewmodel} branch.

\item Look for messages on the screen containing the word "conflict" indicating that some files cannot be merged directly. This typically happens if the
  same (or very closely-spaced) lines have been edited in both the
  \texttt{develop} and \texttt{dev\_mynewmodel} branches.

  If any files are affected, they will be listed.  Edit them and look for any lines containing  \texttt{=======}. Such lines separate the changes made in the two branches, as in:
\begin{verbatim}
<<<<<<< HEAD
This line was edited in dev_mynewmodel branch
=======
This line was edited in develop branch
>>>>>>> develop
\end{verbatim}
  Resolve the conflict(s) as necessary. Then type \texttt{git add file1 file2 ...}, where
  \texttt{file1} etc.\ are the names of the files you removed conflicts
  from. Finally type \texttt{git commit} and edit the change log file.

\item \texttt{git push} \\
Updates the central repository.

\end{enumerate}

\subsubsection{Merging working branch back into \texttt{develop}}

Once the work on a model has been completed, fully tested and documented, the
working branch should be merged back into the \texttt{develop} branch. This is
done almost exactly as in the previous section, but there are a few crucial
differences:

\begin{enumerate}

\item Firstly, make sure you have committed your latest changes to the working
  branch into the central \texttt{GitLab} repository.

\item \texttt{git pull}\\
Merges the version in the central repository into the local branch by copying over any changes that have been made in the version stored centrally.

\item \texttt{git checkout dev\_mynewmodel}

\item \texttt{git checkout develop}

\item \texttt{git merge dev\_mynewmodel}

\item Look for any conflicts and resolve them as described in the previous
  section.

\item \texttt{git push}

\end{enumerate}

\subsubsection{Committing changes to \texttt{develop}}

Whenever a commit to the \texttt{develop} branch is to be made, the following
procedure should be followed. Ensure all documentation is up to date (see
Section~\ref{sec:codemods}) and the code is fully tested.
\begin{enumerate}

\item In routine \texttt{inform} of file \texttt{process.f90}, change the
  definition of \texttt{progver} by incrementing the \Red{last digit of the revision number by one e.g. from \texttt{1.3.26} to \texttt{1.3.27} for each minor commit or the second git for each fully tested major model that is included while setting the last digit to 0 e.g. from \texttt{1.3.26} to \texttt{1.4.0}}. Furthermore, update the Release Date. It is important to keep exactly the same format. 

\item Add a brief comment to the bottom of source file \texttt{process.f90}
  describing the changes made since the last commit in the same branch. Start
  the line with \texttt{! GIT XYZ: }, following the existing examples.

\item If any of the User Guide \texttt{.tex} files have been modified, edit
  the definition of \verb+\version+ in \texttt{process.tex} by changing the
  Revision \Red{(to e.g. \texttt{1.3.27})} and the date.

\item If you have changed any "use" statements in the code, or any compilation dependencies in the Makefile, run \\
\texttt{make clean}

\item \texttt{make all} \\
This ensures that all the code and documentation compiles successfully.

\item Run the input file(s) in the \texttt{tests} folder to ensure PROCESS runs correctly.

\item
Close all open editor windows.  The commit will not work otherwise.

\item   \texttt{git commit -a} \\
  This commits all modified tracked files.\\
  \\
  Alternatively, you can do this in two steps:\\
  \texttt{git add process.f90 process.tex changedfile1 changedfile2 ...}  \\
  (This `stages' the modified files marking them as ready for committing).  \\
  \texttt{git commit}

\item An editor window will open; add a line summarising the changes you have made.  Use a format like this:
\begin{verbatim}
1.3.27   A summary of the changes made
Further details. Changes due to Git issues can be described like this:
#270    Description
#273    Description
\end{verbatim}
Save and close the window. This will initiate the commit to your \textit{local}\ copy of the repository.

\item \texttt{git tag -a 1.3.27 -m `Revision 1.3.27'}

\item \texttt{git push}

\item \texttt{git push origin 1.3.27}

\end{enumerate}

The instructions given in Section~\ref{sec:fullrebuild} should now be followed to make the new \texttt{develop} release available to all users.

\subsubsection{Merging develop into master}

\Red{When merging develop into master, please note that the tagging changes as described in section \ref{sec:tagging}.}

\subsection{Full code rebuild}
\label{sec:fullrebuild}

The standard \process\ executables and the corresponding documentation
available to all users are stored in the functional account called
\texttt{PROCESS} on the CCFE Fusion Unix Network. Whenever the \texttt{master}
or \texttt{develop} branches are updated a full rebuild of the standard
executables and documentation should be performed. This is done as follows:
\begin{enumerate}

\item Ensure that all key users have been informed (using the commit message described above or directly).

\item \texttt{alter PROCESS}  (this changes your current login to that of the
  \texttt{PROCESS} user; only registered individuals are able to do this)

\item \texttt{cd develop}  (or \texttt{cd master}, as appropriate to the
  branch to be rebuilt)

\item \texttt{git pull}\\
Updates the version stored in this folder to the version stored centrally.

\item \texttt{make all}
This is essential because the Git repository does not include any of the files generated in the compilation process.

\item \texttt{exit}  (to return to your own username again)

\end{enumerate}

The \texttt{make all} step performs the rebuild of the \texttt{process.exe} executable
file, updates the User Guide and all the html files, and recreates the Python
dictionaries as required by the Python utilities.


