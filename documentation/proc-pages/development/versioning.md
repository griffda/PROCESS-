# Versioning
# Instructions on the new CHANGELOG procedure

## The New Process
From now onward, users who make changes to the Process code will no longer update these changes in the `CHANGELOG.md` file. Instead, each change will be documented in a `.yaml` (YAML) file inside the `changelog_update` directory. This is so there are no more CHANGELOG merge conflicts upon merging into develop from individual branches. This .yaml file that you have subseuqently created should be committed alongside other changes you have made.

## The Types of changes to be recorded
**Added**: For newly added features e.g. new models.

**Changed**: For documenting changes in the existing functionality.

**Deprecated**: For documenting soon-to-be removed features.

**Removed**: For listing now removed (previously deprecated) features.

**Fixed**: For documenting any bug fixes on features/changes made in a different release (i.e. do not add a bugfix to a feature or change that has not yet been released to master).



## How the YAML file will look
This is the general structure of the YAML file that will be generated by using the Python script (described below) and in turn will be translated ready for upload upon Process version upgrade which will be carried out by a RSE.

```yaml
Added:
  - List any new features you have added here
  - Another addition

Changed:
  - List any changes to existing functionality here

Deprecated:
  - List any soon-to-be removed features here

Removed:
  - List any features you have removed here
  - Another removal

Fixed:
  - List any bug fixes here
```

## Generating the YAML file with a Python script
An empty YAML file with the following structure wil be generated in the changelog_update directory (`process/changelog_update`) when the Python script is run. The Python script will automatically extract the issue number that proceeds your Git branch and use this as the name for your generated YAML file e.g:

Current branch: `9999-This-is-my-issue`

The YAML file name generated in the `changelog_update` directory will be: `9999.yaml`. If you dont have numbers at the start of your branch name, the name of your yaml file with be `my-branch-name.yaml`

### Step 1
In the terminal, run the python script `create_changelog.py`, e.g:

```bash
python changelog_update/create_changelog.py
```
This script will create a .yaml file in the changelog_update directory where the name is that of your current git branch issue number.yaml. 

### Step 2
Look in the changelog_update dir for your generated YAML file (determined by issue number)- This means your issue must have been created by a merge request. If you do NOT have an issue number in fornt of your current branch name, then you must create a merge request so your branch includes this issue number.

### Step 3
Open your generated YAML file which will look like below:
```BASH
Added:
-
Changed:
-
Deprecated:
-
Fixed:
-
Removed:
-
```

### Step 4
Now you must add your changes to the YAML file manually. As seen in the section ['How the YAML file will look'](#how-the-yaml-file-will-look), each entry of a change is split into the different headers depending on the nature of the change. You are able to have multiple entries per header, and this just requires you to add another bullet point (hyphen) to a given category.

An example of what the changes may look like if there is more than one entry can be seen below. **Syntax in the YAML file includes an important requirement for having a space between the hyphen and your text.** Also, no quotation marks are needed. 

At the end of each comment under each header, please add, in brackets, a hash followed by your issue number (see below). This is so it is possible to track at which point the changes were made. If you have made an entry that corresponds to multiple issues, please include these in the same format as seen in the example below.

```yaml
Added:
  - Added feature 1 (#1234)
  - Added feature 2 (#1234)
  - Added feature 3 (#1234)

Changed:
  - Changed feature 1 (#1234)
  - Changed feature 2 (#1234,#5678)

Deprecated:
  - 

Removed:
  - 

Fixed:
  - Fixed bug 1 (#1234)
```
Also, as seen above, if you haven't made changes, sections can be left empty. In this case we do not have a `Security` tag as there should be no changes invovled that would lead to any vulnerabilities. 

### Step 5
All you need to do now is save your YAML file once you have added the changes to it, commit these changes and that is all. No changes need to be made to the CHANGELOG.md as this will be done automatically upon Process upversioning. 

## What warrants a changelog entry?
You can see the current CHANGELOG.md in the process directory, which has previous examples of what should be included in the changelog. Using [Gitlab guides](https://docs.gitlab.com/ee/development/changelog.html), a few key changelog entries are:

- Any user-facing change must have a changelog entry
- Any developer-facing change (such as test suite changes) should **not** have a changelog entry
- A fix for regression introduced and then fixed in the same release (such as fixing a bug introduced during a monthly release candidate) should **not** have a changelog entry.

## Semantic Versioning
Process attempts to use [semantic versioning](https://semver.org/), which takes the form `MAJOR.MINOR.PATCH`. Increment the:

1. MAJOR version when you make incompatible API changes,
2. MINOR version when you add functionality in a backwards compatible manner, and
3. PATCH version when you make backwards compatible bug fixes.

## Upversioning
Process uses a `develop` and `master` release model. All development work is merged into `develop`, whereas users of the code use `master`. When a new version is required to be released to users, the version is incremented on `develop`, `develop` is merged into `master` and the merge commit tagged with the version number on `master`. Users will always use the latest tagged version on `master`.

To upversion Process:

1. Create a branch from `develop` and merge request for the upversion
2. Increment the version in `setup.py` according to the semver rules
3. Similarly increment the version in `main_module.f90`:`inform()`. This Fortran version step will be removed in time as the Python conversion progresses
4. Add an entry to the `CHANGELOG.md` for all notable changes since the previous version. Looking at merge commits (see "Extracting merge commits from git log" below) or merged merge requests since the previous version is a good way to do this
5. Push and merge into `develop`
6. Create a merge request to merge `develop` into `master`. Add a release note to the merge request, which should be a user-friendly summary of the changes in this version
7. Merge `develop` into `master`
8. Pull `master`, then tag the merge commit with `git tag -a vX.Y.Z -m "Version X.Y.Z"` (note the "v": see "Tagging a commit" below)
9. Push the tag to `master` with `git push origin vX.Y.Z`

### Extracting merge commits from git log
A useful command for getting merge commits from git log for writing the changelog is:
```bash
git log v2.1..HEAD --merges --first-parent develop --pretty=format:%Cblue%B%n >> mergeCommits.log
```
`v2.1..HEAD` is the log range: from the last tag (`v2.1`) to `HEAD`

`--merges` filters for merge commits

`--first-parent develop` filters for the branch you're merging into (`develop`): i.e. only include merges into `develop`

`%B` is subject and body together: full merge commit content

`>> mergeCommits.log` output to file (optional)

## Tags
### Tagging a commit
```
git tag -a vX.Y.Z -m "Version X.Y.Z"
```
`git tag -a vX.Y.Z` tags the current commit with an annotated (`-a`) tag of "vX.Y.Z". A message is specified with `-m`. `git show vX.Y.Z` will show the commit that has just been tagged.

The commit is only tagged locally, and `git push` won't transfer the tag to the remote.
```
git push origin vX.Y.Z
```
is required to transfer the tag to the remote.

### Working with tags
|Command|Description|
|--------|--------| 
|`git describe`|show the current tag| 
|`git tag`|list all tags|
|`git tag -l "1.0.*"`|list tags contained in `1.0.z`|
|`git checkout vX.Y.Z`|checkout a specific tag|

Between user tags `git` will create tags in the following format:
```
1.0.12-11-g3f1b433
```

- `1.0.12` is the last manually entered tag by the user
- `11` is the number of commits since that tag
- `g3f1b433` is a unique identifier for this specific commit

This allows the user to checkout a specific commit between tagged versions. PROCESS now outputs this information into the `OUT.DAT` and `MFILE.DAT` and is 
updated upon compilation. This way each output file is trackable to a specific commit.