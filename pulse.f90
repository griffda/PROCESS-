!  $Id::                                                                $
! !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!

subroutine pulse(outfile,iprint)

  !+ad_name  pulse
  !+ad_summ  Caller for the pulsed reactor model
  !+ad_type  Subroutine
  !+ad_auth  C A Gardner, AEA Fusion, Culham Laboratory
  !+ad_auth  P J Knight, CCFE, Culham Science Centre
  !+ad_cont  None
  !+ad_args  outfile : input integer : output file unit
  !+ad_args  iprint : input integer : switch for writing to output file (1=yes)
  !+ad_desc  This calls the routines relevant to a pulsed reactor scenario.
  !+ad_prob  None
  !+ad_call  physics_variables
  !+ad_call  pulse.h90
  !+ad_call  build.h90
  !+ad_call  fwblsh.h90
  !+ad_call  times.h90
  !+ad_call  thrmal
  !+ad_call  tohswg
  !+ad_call  burn
  !+ad_call  25/11/93 CAG/PJK Implementation within PROCESS
  !+ad_call  10/06/96 PJK Commented out call to STARTUP
  !+ad_hist  01/10/12 PJK Initial F90 version
  !+ad_hist  15/10/12 PJK Added physics_variables
  !+ad_stat  Okay
  !+ad_docs  Work File Notes F/MPE/MOD/CAG/PROCESS/PULSE
  !+ad_docs  AEA FUS 251: A User's Guide to the PROCESS Systems Code
  !
  ! !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!

  use physics_variables

  implicit none

  include 'pulse.h90'
  include 'build.h90'
  include 'fwblsh.h90'
  include 'times.h90'

  !  Arguments

  integer, intent(in) :: outfile,iprint

  !  Local variables

  ! !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!

  !  Thermal cycling package

  call thrmal(outfile,iprint)

  !  Evaluate minimum OH coil swing time

  call tohswg(outfile,iprint)

  !  Burn time calculation

  call burn(outfile,iprint)

end subroutine pulse

! !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!

subroutine thrmal(outfile,iprint)

  !+ad_name  thrmal
  !+ad_summ  Calculates the thermal and mechanical stresses induced
  !+ad_summ  in the first wall for the case of a pulsed reactor
  !+ad_type  Subroutine
  !+ad_auth  C A Gardner, AEA Fusion, Culham Laboratory
  !+ad_auth  P J Knight, CCFE, Culham Science Centre
  !+ad_cont  alpha
  !+ad_cont  costrm
  !+ad_cont  cycles
  !+ad_cont  eyung
  !+ad_cont  smt
  !+ad_cont  tk
  !+ad_cont  yield
  !+ad_args  outfile : input integer : output file unit
  !+ad_args  iprint : input integer : switch for writing to output file (1=yes)
  !+ad_desc  This routine calculates the thermal and mechanical stresses
  !+ad_desc  induced in the first wall for the case of a pulsed reactor.
  !+ad_desc  <P>It is assumed that the first wall is comprised from axisymmetric
  !+ad_desc  hollow cylindrical tubes which are packed one against the other in
  !+ad_desc  the poloidal direction.
  !+ad_desc  <P>The equivalent strains are calculated from the stresses
  !+ad_desc  with which a fatigue lifetime is estimated using the fatigue
  !+ad_desc  design curves generated by the ASME code.
  !+ad_desc  Presently the first wall material is assumed to be stainless
  !+ad_desc  steel.
  !+ad_desc  <P>The first wall thickness is constrained to lie between a lower
  !+ad_desc  limit that ensures that the first wall can withstand the internal
  !+ad_desc  coolant pressure, and an upper limit governed by the peak
  !+ad_desc  temperature and the neutron fluence.
  !+ad_prob  None
  !+ad_call  constants
  !+ad_call  physics_variables
  !+ad_call  process_output
  !+ad_call  pulse.h90
  !+ad_call  build.h90
  !+ad_call  fwblsh.h90
  !+ad_call  ineq.h90
  !+ad_call  alpha
  !+ad_call  costrm
  !+ad_call  cycles
  !+ad_call  eyung
  !+ad_call  oblnkl
  !+ad_call  ocmmnt
  !+ad_call  oheadr
  !+ad_call  ovarre
  !+ad_call  ovarrf
  !+ad_call  smt
  !+ad_call  tk
  !+ad_call  yield
  !+ad_hist  25/11/93 PJK Incorporation into PROCESS
  !+ad_hist  16/06/94 PJK Added error warning
  !+ad_hist  07/12/95 PJK Added D-He3 calculations
  !+ad_hist  10/06/96 PJK Moved first wall area calculation into RADIALB
  !+ad_hist  13/02/97 PJK Modified first wall lifetime calculation
  !+ad_hist  25/05/06 PJK Added SAVE statement
  !+ad_hist  01/10/12 PJK Initial F90 version
  !+ad_hist  09/10/12 PJK Modified to use new process_output module
  !+ad_hist  15/10/12 PJK Added physics_variables
  !+ad_hist  16/10/12 PJK Added constants
  !+ad_stat  Okay
  !+ad_docs  Work File Notes F/MPE/MOD/CAG/PROCESS/PULSE
  !+ad_docs  AEA FUS 251: A User's Guide to the PROCESS Systems Code
  !
  ! !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!

  use constants
  use physics_variables
  use process_output

  implicit none

  include 'pulse.h90'
  include 'build.h90'
  include 'fwblsh.h90'
  include 'ineq.h90'

  !  Arguments

  integer, intent(in) :: outfile,iprint

  !  Local variables

  real(kind(1.0D0)) :: boa,eptbar,eptrc,eptthc,eptzc,fboa,fwlifs, &
       fwndep,fwvol,masflx,mindif,min01,min02,min03,poissn,rad, &
       sigpm,sigpr,sigpth,sgpthn,sigpz,sigtr,sigtri,sigtrs,sgtshs, &
       sigtth,sgtthi,sgtths,temp,tfwav,tmax,tmpdif,tmthet,torlen,tpeakr
  real(kind(1.0D0)), dimension(3) :: delr,delth,delz,eptr,eptth, &
       eptz,equiv,mincyc,sigtz
  real(kind(1.0D0)), save :: flnce,hcoeff,qpp,qppp,tav,tmprop,vel

  integer :: k,n
  integer, dimension(3) :: ncyc

  real(kind(1.0D0)), dimension(8) :: cc,dd
  common/tmpcff/cc,dd

  ! !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!

  !  delr(3)  : radial strain range
  !  delth(3) : azimuthal strain range
  !  delz(3)  : axial strain range
  !  eptbar   : average thermal strain
  !  eptr(3)  : radial strain component from total stress
  !  eptrc    : radial strain component from mechanical stress
  !  eptth(3) : azimuthal strain component from total stress
  !  eptthc   : azimuthal strain component from mechanical stress
  !  eptz(3)  : axial strain component from total stress
  !  eptzc    : axial strain component from mechanical stress
  !  equiv(3) : Von Mises equivalent strain
  !  flnce    : neutron fluence
  !  fwndep   : neutron power deposition (W)
  !  fwvol    : first wall volume (m**3)
  !  hcoeff   : heat transfer coefficient (W/m**2/K)
  !  masflx   : coolant max flux (Kg/m**2/s)
  !  ncyc(3)  : number of allowable cycles
  !  poissn   : Poisson's ratio 
  !  mincyc(3): minimum allowable cycle length
  !  fwlifs   : first wall lifetime (s)
  !  qpp      : surface heat flux incident on first wall (W/m**2)
  !  qppp     : volumetric heat flux in first wall material (W/m**3)
  !  sgpthn   : primary stress in thin shell model (Pa)
  !  sgtshs   : shear stress component from surface heat flux (Pa)
  !  sgtthi   : azimuthal stress component from internal heat flux (Pa)
  !  sgtths   : azimuthal stress component from surface heat flux (Pa)
  !  sigpm    : equivalent mechanical stress (Pa)
  !  sigpr    : radial mechanical stress (Pa)
  !  sigpth   : azimuthal mechanical stress (Pa)
  !  sigpz    : axial mechanical stress (Pa)
  !  sigtr    : radial stress component from total heat flux (Pa)
  !  sigtri   : radial stress component from internal heat flux (Pa)
  !  sigtrs   : radial stress component from surface heat flux (Pa)
  !  sigtth   : azimuthal stress component from total heat flux (Pa)
  !  sigtz(3) : axial stress component from total heat flux (Pa)
  !  tav      : average first wall temperature (C)
  !  tmthet   : azimuthal temperature term (C)
  !  torlen   : section of toroidal extent of first wall elements (m)
  !  tpeakr   : peak temperature at a given radius (C)
  !  vel      : coolant velocity (m/s)

  !  Check to see if the pulsed reactor option is selected

  if (lpulse /= 1) return

  if (iprint /= 1) then

     !  Check valid input for pulsed reactor

     if (fhole == 0.0D0) then
        write(*,*) 'Error in routine THRMAL:'
        write(*,*) 'fhole should not be zero for a pulsed reactor -'
        write(*,*) 'a fraction fhole of the neutrons leaving the'
        write(*,*) 'plasma are assumed to interact in the first wall.'
        write(*,*) 'PROCESS stopping.'
        stop
     end if

     !  We will assume that 2*bfw is the average of the inboard and
     !  outboard first wall thicknesses (fwith and fwoth respectively).

     bfw = (fwith+fwoth)/4.0D0
     boa = bfw/afw

     !  Poisson's ratio

     poissn = 0.27D0

     !  Start of iteration of bfw - code returns to here
     !  if bfw has been altered to lie within constraints

     n = 0
     bfw_iteration: do ; n = n+1

        if (n > 100) then
           write(*,*) 'Warning in routine THRMAL:'
           write(*,*) 'Optimisation has failed within 100 iterations.'
           write(*,*) 'Possible NaN problems...'
           write(*,*) 'PROCESS continuing.'
           !return
           exit bfw_iteration
        end if

        !  Check to see if inner radius is greater than outer radius

        if (afw >= bfw) then
           write(*,*) 'Error in routine PULSE:'
           write(*,*) 'afw >= bfw'
           write(*,*) 'PROCESS stopping.'
           stop
        end if

        !  First wall lifetime in seconds

        fwlifs = 3.1536D7*fwlife

        !  First wall properties
        !  This assumes that the neutrons lost via fhole actually stop in
        !  the first wall, so are not lost at all...

        fwndep = (pneut*vol)*fhole*1.0D6

        !  Assume that the first wall volume is equal to its surface area
        !  multiplied by the external diameter of the hollow cylindrical
        !  tubes that make up the first wall.

        fwvol = fwarea*(2.0D0*bfw)

        !  Heat fluxes
        !  -----------
        !  qppp represents the heat generation in the first wall due to
        !  the neutron flux deposited in the material.
        !  qpp represents the heat flux incident on the first wall
        !  surface from the charge particle and electromagnetic radiation
        !  flux.

        qppp = fwndep/fwvol

        qpp = (palp+pcharge)*vol*1.0D6 / fwarea

        !  Heat transfer coefficient
        !  -------------------------
        !  The coolant is water and the heat transfer coefficient is 
        !  calculated on the inboard side of the first wall.
        !  specific heat capacity: 4190 (J/K/kg)
        !  mass density: 720 (kg/m**3)
        !  coolant velocity limit: 5 (m/s)
        !  fluid viscosity: 1.61D-4 (kg/m/s)
        !  viscosity at wall temperature: 1.39D-4 (kg/m/s)
        !  thermal conductivity: 0.69 (W/m/K)
        !  If the velocity limit is exceeded then the coolant velocity
        !  is set to the velocity limit and the temperature rise is
        !  calculated based upon this fixed velocity.
        !
        !  A toroidal length of 3 metres is assumed rather than
        !  the whole toroidal circumference as we were
        !  experiencing very high coolant temperature rises.
        !  This method is okay as it can be envisaged that the
        !  toroidal parts of the coolant pipes occur in 3 metre
        !  sections around the torus, instead of one long
        !  toroidal pipe.

        torlen = 3.0D0
        masflx = torlen*(qppp*(bfw**2-afw**2) + 2.0D0*qpp*bfw) &
             /afw**2 /4190.0D0 /tmprse
        vel = masflx/720.0D0

        if (vel >= 5.0D0) then
           vel = 5.0D0
           masflx = vel*720.0D0
           tmprse = torlen*(qppp*(bfw**2-afw**2) + 2.0D0*qpp*bfw) &
                /afw**2 /4190.0D0 /masflx
        end if

        hcoeff = 0.023D0*(0.69D0/2.0D0/afw)*(masflx*2.0D0*afw &
             /1.61D-4)**0.8D0 * (1.61D-4*4190.0D0/0.69D0)**0.4D0 &
             *(1.61D-4/1.39D-4)**0.14D0

        !  Average temperature
        !  -------------------
        !  There is a problem here because the expression for the
        !  average temperature in the first wall contains a term
        !  which involves the thermal conductivity which is in itself
        !  temperature dependent. How do we resolve this problem?
        !  Firstly we define a temperature range where the lower
        !  bound is defined to be the temperature on the inner
        !  wall (in contact with the coolant) and therefore
        !  equal to the bulk coolant temperature, and the
        !  upper bound is taken to be 800 degrees Celsius.
        !  Next we iterate over this range so that at each 
        !  step the average temperature can be calculated together 
        !  with the difference between the average temperature and 
        !  the iterated temperature. The average temperature
        !  at which this difference is minimised is taken 
        !  as the correct average temperature in the first wall.

        mindif = 1.0D30

        do k = 1,51

           temp = bctmp + (800.0D0-bctmp) * dble(k-1)/50.0D0
           tfwav = bfw/tk(temp)*(qpp/pi + qppp*bfw/2.0D0)*(bfw**2/ &
                (bfw**2-afw**2)*log(bfw/afw)-0.5D0) &
                - qppp/4.0D0/tk(temp)*((bfw**2-afw**2)/2.0D0) &
                + (pi*(bfw**2-afw**2)*qppp + 2.0D0*bfw*qpp)/ &
                (2.0D0*pi*afw*hcoeff) + bctmp
           tmpdif = abs(tfwav-temp)

           if (tmpdif <= mindif) then
              mindif = tmpdif
              tav = tfwav
              tmprop = temp
           end if

        end do

        !  Average thermal strain (integrated from 20 Celsius to 'tav')

        eptbar = 10.28D-6/1.093D0 * (tav**(1.093D0) - 20.0D0**(1.093D0))

        !  Limits on the first wall thickness
        !  ----------------------------------
        !  The upper limit on the first wall thickness is
        !  derived from the swelling limit which for stainless
        !  steel limits the temperature to 500 Celsius. This
        !  temperature limit is equivalent to limiting the neutron
        !  fluence to 5 MW yrs/m**2. The fluence is the product
        !  of the neutron wall loading (qppp*fwvol/fwarea) and
        !  the wall lifetime. This fluence limit is a conservative
        !  one, with the upper bound on the fluence set by the value
        !  10 MW-yr/m2
        !+**PJK 13/02/97 abktflnc should replace the fixed value 10 MW-yr/m2

        flnce = qppp*fwvol/fwarea * fwlife/1.0D6

        tmax = -1.0D30

        do k = 1,11

           rad = afw + (bfw-afw)*(dble(k-1)/10.0D0)

           call costrm(0.0D0,rad,qpp,hcoeff,tmprop,tmthet)

           !  Peak temperature occurs at (r,theta) = (rad,0)

           tpeak = bfw/tk(tmprop) * (qpp/pi + qppp*bfw/2.0D0) &
                * log(rad/afw) - qppp/4.0D0/tk(tmprop)*(rad**2-afw**2) &
                + (pi*(bfw**2-afw**2)*qppp + 2.0D0*bfw*qpp) / &
                (2.0D0*pi*afw*hcoeff) + bctmp + tmthet

           if ((tpeak > 500.0D0).or.(flnce > 10.0D0)) then
              !  Swelling limit exceeded

              fwlife = 10.0D0*1.0D6*fwarea/qppp/fwvol
              fwlifs = 3.1536D+7*fwlife

              !  fboa is chosen such that fboa**100 * (bfw/afw) = 1.001,
              !  i.e. after 100 iterations bfw is still just larger than afw.

              fboa = (1.001D0/boa)**0.01D0

              bfw = bfw*fboa
              if ((bfw/afw) <= 1.001D0) then
                 write(*,*) 'Warning in routine THRMAL:'
                 write(*,*) 'Swelling limit exceeded, and'
                 write(*,*) 'optimisation is failing to find a'
                 write(*,*) 'suitable first wall thickness...'
                 write(*,*) 'PROCESS continuing.'
                 exit bfw_iteration
              else
                 cycle bfw_iteration
              end if
           end if

           !  Find maximum temperature

           tmax = max(tpeak,tmax)

        end do

        tpeak = tmax

        !  The lower limit on the first wall thickness is
        !  derived from the constraint that the first wall
        !  must possess the ability to withstand the internal
        !  coolant pressure. The limit is written as
        !  hmin = p*(afw+bfw)/2/Smt

        sgpthn = (coolp*(afw+bfw)/2.0D0)/(bfw-afw)

        if (sgpthn <= smt(tpeak,fwlifs)) then
           exit bfw_iteration
        else
           !  First wall too thin
           !  Keep afw fixed and alter bfw so that the lower limit
           !  is satisfied

           bfw = afw * (smt(tpeak,fwlifs) + coolp/2.0D0) / &
                (smt(tpeak,fwlifs) - coolp/2.0D0)
        end if

     end do bfw_iteration

     !  Reset inboard and outboard first wall thicknesses

     fwith = 2.0D0*bfw
     fwoth = 2.0D0*bfw

     !  First wall coolant fraction

     fwclfr = (afw/bfw)**2

     min01 = 0.0D0
     min02 = 0.0D0
     min03 = 0.0D0

     !  Iterate from the inner first wall radius to the outer
     !  first wall radius

     do k = 1,11

        !  Peak temperature at this radius

        rad = afw + (bfw-afw)*(dble(k-1)/10.0D0)

        call costrm(0.0D0,rad,qpp,hcoeff,tmprop,tmthet)

        !  Peak temperature occurs at (r,theta) = (rad,0)

        tpeakr = bfw/tk(tmprop) * (qpp/pi + qppp*bfw/2.0D0) &
             *log(rad/afw) - qppp/4.0D0/tk(tmprop) * (rad**2-afw**2) &
             + (pi*(bfw**2 - afw**2)*qppp + 2.0D0*bfw*qpp) &
             / (2.0D0*pi*afw*hcoeff) + bctmp + tmthet

        !  Pressure, or mechanical stresses

        sigpr = -coolp*(afw**2/(bfw**2-afw**2))*(bfw**2/rad**2 - 1.0D0)
        sigpth = coolp*(afw**2/(bfw**2-afw**2))*(bfw**2/rad**2 + 1.0D0)
        sigpz =  coolp*(afw**2/(bfw**2-afw**2))

        !  Equivalent mechanical stress

        sigpm = sqrt(0.5D0*((sigpr-sigpth)**2 + (sigpr-sigpz)**2 &
             + (sigpth-sigpz)**2))

        !  Thermal stresses
        !  ----------------

        !  Thermal stress components from surface heat flux (i.e. qpp)

        sigtrs = alpha(tmprop)*eyung(tmprop)/2.0D0/(1.0D0-poissn) &
             * ( rad/(afw**2 + bfw**2)*(1.0D0 - afw**2/rad**2) &
             * (1.0D0 - bfw**2/rad**2)*cc(1) * cos(0.0D0) &
             + qpp*bfw/pi/tk(tmprop)/rad**2*(bfw**2*((rad**2 - afw**2) &
             / (bfw**2 - afw**2))*log(bfw/afw) - rad**2*log(rad/afw)) )
        sgtths = alpha(tmprop)*eyung(tmprop)/2.0D0/(1.0D0-poissn) &
             * ( rad/(afw**2 + bfw**2)*(3.0D0-(afw**2 + bfw**2)/rad**2 &
             - (afw**2*bfw**2)/rad**4) * cc(1)*cos(0.0D0) &
             + qpp*bfw/pi/tk(tmprop)/rad**2*(bfw**2*((rad**2 + afw**2) &
             / (bfw**2 - afw**2))*log(bfw/afw) - rad**2 &
             - rad**2*log(rad/afw)) )
        sgtshs = alpha(tmprop)*eyung(tmprop)/2.0D0/(1.0D0-poissn) &
             * ( rad/(afw**2 + bfw**2)*(1.0D0 - afw**2/rad**2) &
             * (1.0D0 - bfw**2/rad**2)*cc(1) * sin(0.0D0) )

        !  Thermal stress components from internal heat flux (i.e. qppp)

        sigtri = alpha(tmprop)*eyung(tmprop)*qppp/4.0D0/tk(tmprop) / &
             (1.0D0-poissn)/rad**2 * ( &
             (rad**2 - afw**2)/(bfw**2 - afw**2) &
             * bfw**4*log(bfw/afw) - (bfw**2 + afw**2)*rad**2/4.0D0 &
             + afw**2*bfw**2/4.0D0 - bfw**2*rad**2*log(rad/afw) &
             + rad**4/4.0D0 )
        sgtthi = alpha(tmprop)*eyung(tmprop)*qppp/4.0D0/tk(tmprop) / &
             (1.0D0-poissn)/rad**2 * ( &
             (rad**2 + afw**2)/(bfw**2 - afw**2) &
             * bfw**4*log(bfw/afw) - (5.0D0*bfw**2 + afw**2) &
             * rad**2/4.0D0 - afw**2*bfw**2/4.0D0 + 3.0d0*rad**4/4.0D0 &
             - bfw**2*rad**2*log(rad/afw) )

        !  Total thermal stresses

        sigtr = sigtrs + sigtri
        sigtth = sgtths + sgtthi

        !  Axial stresses, three different models are used:
        !  (1) total axial restraint and no bending
        !  (2) no axial restraints and no bending
        !  (3) no axial restraints and bending

        sigtz(1) = poissn*(sigtr + sigtth) &
             - eyung(tmprop)*(eptbar + alpha(tav)*(tpeakr-tav))
        sigtz(2) = poissn*(sigtr + sigtth) &
             - eyung(tmprop)*(alpha(tav)*(tpeakr-tav))
        sigtz(3) = sigtz(2) + eyung(tmprop)*rad*cos(0.0D0)*alpha(tav) &
             * (2.0D0*cc(1)/(afw**2 + bfw**2) + dd(1))

        !  Strains

        eptr(1) = 1.0D0/eyung(tmprop) * ( sigtr + sigpr &
             - poissn*(sigtth + sigpth + sigtz(1) + sigpz) )
        eptth(1) = 1.0D0/eyung(tmprop) * ( sigtth + sigpth &
             - poissn*(sigtr + sigpr + sigtz(1) + sigpz) )
        eptz(1) = 1.0D0/eyung(tmprop) * ( sigtz(1) + sigpz &
             - poissn*(sigtr + sigpr + sigtth + sigpth) )
        eptr(2) = 1.0D0/eyung(tmprop) * ( sigtr + sigpr &
             - poissn*(sigtth + sigpth + sigtz(2) + sigpz) )
        eptth(2) = 1.0D0/eyung(tmprop) * ( sigtth + sigpth &
             - poissn*(sigtr + sigpr + sigtz(2) + sigpz) )
        eptz(2) = 1.0D0/eyung(tmprop) * ( sigtz(2) + sigpz &
             - poissn*(sigtr + sigpr + sigtth + sigpth) )
        eptr(3) = 1.0D0/eyung(tmprop) * ( sigtr + sigpr &
             - poissn*(sigtth + sigpth + sigtz(3) + sigpz) )
        eptth(3) = 1.0D0/eyung(tmprop) * ( sigtth + sigpth &
             - poissn*(sigtr + sigpr + sigtz(3) + sigpz) )
        eptz(3) = 1.0D0/eyung(tmprop) * ( sigtz(3) + sigpz &
             - poissn*(sigtr + sigpr + sigtth + sigpth) )

        !  For the time being I will take the temperature during rejuvenation
        !  to be T(a,0) during burn and assume the accompanying strains are 
        !  mechanical in origin

        eptrc = 1.0D0/eyung(tmprop) * (sigpr - poissn*(sigpth + sigpz))
        eptthc = 1.0D0/eyung(tmprop) * (sigpth - poissn*(sigpr + sigpz))
        eptzc = 1.0D0/eyung(tmprop) * (sigpz - poissn*(sigpth + sigpr))

        !  Calculate strain ranges

        delr(1) = eptr(1) - eptrc
        delr(2) = eptr(2) - eptrc
        delr(3) = eptr(3) - eptrc
        delth(1) = eptth(1) - eptthc
        delth(2) = eptth(2) - eptthc
        delth(3) = eptth(3) - eptthc
        delz(1) = eptz(1) - eptzc
        delz(2) = eptz(2) - eptzc
        delz(3) = eptz(3) - eptzc

        !  Calculate Von Mises equivalent strain range

        equiv(1) = 1.0D0/3.0D0 * sqrt( 2.0D0*((delr(1) - delth(1))**2 &
             + (delth(1) - delz(1))**2 + (delz(1) - delr(1))**2) )
        equiv(2) = 1.0D0/3.0D0 * sqrt( 2.0D0*((delr(2) - delth(2))**2 &
             + (delth(2) - delz(2))**2 + (delz(2) - delr(2))**2) )
        equiv(3) = 1.0D0/3.0D0 * sqrt( 2.0D0*((delr(3) - delth(3))**2 &
             + (delth(3) - delz(3))**2 + (delz(3) - delr(3))**2) )

        !  Find allowable cycles

        call cycles(equiv,tpeakr,ncyc)

        !  Calculate minimum allowable cycle lengths

        mincyc(1) = fwlife / dble(ncyc(1))
        mincyc(2) = fwlife / dble(ncyc(2))
        mincyc(3) = fwlife / dble(ncyc(3))

        !  Overall minimum allowable cycle length for each model
        !  (we use the highest value to set correctly the limit on tcycle)

        min01 = max(min01, mincyc(1))
        min02 = max(min02, mincyc(2))
        min03 = max(min03, mincyc(3))

     end do

     !  Evaluate minimum cycle time using chosen model

     if (itcycl == 1) then
        tcycmn = min01
     else if (itcycl == 2) then
        tcycmn = min02
     else
        tcycmn = min03
     end if

     !  Convert from years to seconds

     tcycmn = tcycmn * 3.1536D7

  else

     !  Written output

     call oheadr(outfile,'Pulsed Reactor')

     call ocmmnt(outfile,'Thermal cycling considerations for first wall:')
     call oblnkl(outfile)

     call ovarrf(outfile,'Inner radius of first wall tubes (m)', &
          '(afw)',afw)
     call ovarrf(outfile,'Outer radius of first wall tubes (m)', &
          '(bfw)',bfw)
     call ovarre(outfile,'Bulk coolant temperature (C)','(bctmp)',bctmp)
     call ovarre(outfile,'Coolant internal pressure (Pa)','(coolp)',coolp)
     call ovarre(outfile,'Neutron fluence (MW-yr/m2)','(flnce)',flnce)
     call ovarre(outfile,'Neutron flux deposited in 1st wall (W/m3)', &
          '(qppp)',qppp)
     call ovarre(outfile,'Heat flux incident on first wall (W/m2)', &
          '(qpp)',qpp)
     call ovarre(outfile,'Heat transfer coefficient (W/m2/K)', &
          '(hcoeff)',hcoeff)

     if (vel == 5.0D0) then
        call ocmmnt(outfile, &
             'Calculation based upon fixed coolant velocity')
     else
        call ocmmnt(outfile, &
             'Calculation based upon fixed temperature rise')
     end if
     call ovarre(outfile,'Coolant velocity (m/s)','(vel)',vel)
     call ovarre(outfile,'Coolant temperature rise (K)','(tmprse)',tmprse)
     call ovarre(outfile,'Peak temperature in first wall (C)', &
          '(tpeak)',tpeak)
     call ovarre(outfile,'Average first wall temperature (C)','(tav)',tav)
     call ovarre(outfile,'Material property temperature (C)', &
          '(tmprop)',tmprop)
     call ovarre(outfile,'Youngs modulus','(eyung)',eyung(tmprop))
     call ovarre(outfile,'Thermal expansion coefficient (/K)', &
          '(alpha)',alpha(tmprop))
     call ovarre(outfile,'Thermal conductivity (W/m/K)','(tk)',tk(tmprop))
     call ovarre(outfile,'First wall lifetime (years)','(fwlife)',fwlife)
     call ovarre(outfile,'Minimum cycle time (s)','(tcycmn)',tcycmn)

  end if

contains

  ! !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!

  subroutine costrm(angle,rad,qpp,hcoeff,tmprop,tmthet)

    !+ad_name  costrm
    !+ad_summ  Calculates cosine terms in temperature distribution
    !+ad_type  Subroutine
    !+ad_auth  C A Gardner, AEA Fusion, Culham Laboratory
    !+ad_auth  P J Knight, CCFE, Culham Science Centre
    !+ad_cont  None
    !+ad_args  angle  : input real : azimuthal angle (radians)
    !+ad_args  rad    : input real : radial position within first wall tube (m)
    !+ad_args  qpp    : input real : surface heat flux incident on first wall (W/m**2)
    !+ad_args  hcoeff : input real : heat transfer coefficient (W/m**2/K)
    !+ad_args  tmprop : input real : property temperature (C)
    !+ad_args  tmthet : output real : azimuthal temperature term (C)
    !+ad_desc  This routine calculates the cosine terms in the temperature
    !+ad_desc  distribution. These terms are calculated with the material
    !+ad_desc  properties measured at the property temperature.
    !+ad_prob  None
    !+ad_call  pulse.h90
    !+ad_call  tk
    !+ad_hist  25/11/93 PJK Incorporation into PROCESS
    !+ad_hist  01/10/12 PJK Initial F90 version
    !+ad_stat  Okay
    !+ad_docs  Work File Notes F/MPE/MOD/CAG/PROCESS/PULSE
    !+ad_docs  AEA FUS 251: A User's Guide to the PROCESS Systems Code
    !
    ! !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!

    implicit none

    include 'pulse.h90'

    !  Arguments

    real(kind(1.0D0)), intent(in) :: angle,rad,qpp,hcoeff,tmprop
    real(kind(1.0D0)), intent(out) :: tmthet

    !  Local variables
    integer :: i,k

    real(kind(1.0D0)), dimension(8) :: cc,dd
    common/tmpcff/cc,dd

    ! !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!

    !  Lowest order terms

    cc(1) = qpp*afw**2*bfw**2/2.0D0/tk(tmprop) * &
         (tk(tmprop) - hcoeff*afw) / &
         ( tk(tmprop)*(bfw**2 - afw**2) + hcoeff*afw*(afw**2 + bfw**2) )
    dd(1) = qpp*bfw**2/2.0D0/tk(tmprop) * &
         (tk(tmprop) + hcoeff*afw) / &
         ( tk(tmprop)*(bfw**2 - afw**2) + hcoeff*afw*(afw**2 + bfw**2) )

    tmthet = (cc(1)/rad+dd(1)*rad)*cos(angle)

    !  Higher order even terms

    do i = 2,8,2
       k = i/2
       cc(i) = qpp/pi/tk(tmprop)/dble(k) * ( dble((-1)**(k+1)) / &
            ((2.0D0*dble(k))**2 - 1.0D0) ) &
            * ( bfw**(2*k+1)*(2.0D0*dble(k)*tk(tmprop) - hcoeff*afw) ) &
            / ( 2.0D0*dble(k)*tk(tmprop)*((bfw/afw)**(4*k)-1.0D0) &
            + hcoeff*afw*((bfw/afw)**(4*k)+1.0D0) )
       dd(i) = 1.0D0 / ((afw*10.0D0)**(4*k)) * (10.0D0)**(4*k) &
            * (2.0D0*dble(k)*tk(tmprop) + hcoeff*afw) / &
            (2.0D0*dble(k)*tk(tmprop) - hcoeff*afw)*cc(i)

       tmthet = tmthet + (cc(i)/rad**i + dd(i)*rad**i)*cos(dble(i)*angle)
    end do

  end subroutine costrm

  ! !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!

  function eyung(x)

    !+ad_name  eyung
    !+ad_summ  Calculates the Young's modulus of the first wall material
    !+ad_type  Function returning real
    !+ad_auth  C A Gardner, AEA Fusion, Culham Laboratory
    !+ad_auth  P J Knight, CCFE, Culham Science Centre
    !+ad_cont  None
    !+ad_args  x      : input real : property temperature (C)
    !+ad_desc  This routine calculates the Young's modulus of the
    !+ad_desc  first wall material, assumed to be stainless steel.
    !+ad_prob  None
    !+ad_call  None
    !+ad_hist  25/11/93 PJK Incorporation into PROCESS
    !+ad_hist  01/10/12 PJK Initial F90 version
    !+ad_stat  Okay
    !+ad_docs  Work File Notes F/MPE/MOD/CAG/PROCESS/PULSE
    !+ad_docs  AEA FUS 251: A User's Guide to the PROCESS Systems Code
    !
    ! !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!

    implicit none

    real(kind(1.0D0)) :: eyung

    !  Arguments

    real(kind(1.0D0)), intent(in) :: x

    !  Local variables

    ! !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!

    eyung = 465.0D0 * x**(-0.18D0) * 1.0D9

  end function eyung

  ! !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!

  function alpha(x)

    !+ad_name  alpha
    !+ad_summ  Calculates the thermal expansion coefficient of the first wall
    !+ad_type  Function returning real
    !+ad_auth  C A Gardner, AEA Fusion, Culham Laboratory
    !+ad_auth  P J Knight, CCFE, Culham Science Centre
    !+ad_cont  None
    !+ad_args  x      : input real : property temperature (C)
    !+ad_desc  This routine calculates the thermal expansion coefficient
    !+ad_desc  of the first wall material, assumed to be stainless steel.
    !+ad_prob  None
    !+ad_call  None
    !+ad_hist  25/11/93 PJK Incorporation into PROCESS
    !+ad_hist  01/10/12 PJK Initial F90 version
    !+ad_stat  Okay
    !+ad_docs  Work File Notes F/MPE/MOD/CAG/PROCESS/PULSE
    !+ad_docs  AEA FUS 251: A User's Guide to the PROCESS Systems Code
    !
    ! !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!

    implicit none

    real(kind(1.0D0)) :: alpha

    !  Arguments

    real(kind(1.0D0)), intent(in) :: x

    !  Local variables

    ! !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!

    alpha = 10.28D0 * x**0.093D0 * 1.0D-6

  end function alpha

  ! !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!

  function tk(x)

    !+ad_name  tk
    !+ad_summ  Calculates the thermal conductivity of the first wall
    !+ad_type  Function returning real
    !+ad_auth  C A Gardner, AEA Fusion, Culham Laboratory
    !+ad_auth  P J Knight, CCFE, Culham Science Centre
    !+ad_cont  None
    !+ad_args  x      : input real : property temperature (C)
    !+ad_desc  This routine calculates the thermal conductivity of the
    !+ad_desc  first wall. This gives a reasonable fit to 316 stainless steel
    !+ad_desc  for temperatures X between 300 and 800 degrees Celsius.
    !+ad_prob  None
    !+ad_call  None
    !+ad_hist  25/11/93 PJK Incorporation into PROCESS
    !+ad_hist  01/10/12 PJK Initial F90 version
    !+ad_stat  Okay
    !+ad_docs  Work File Notes F/MPE/MOD/CAG/PROCESS/PULSE
    !+ad_docs  AEA FUS 251: A User's Guide to the PROCESS Systems Code
    !
    ! !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!

    implicit none

    real(kind(1.0D0)) :: tk

    !  Arguments

    real(kind(1.0D0)), intent(in) :: x

    !  Local variables

    ! !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!

    tk = 3.78D0 * x**0.28D0

  end function tk

  ! !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!

  function yield(x)

    !+ad_name  yield
    !+ad_summ  Calculates the yield strength of the first wall
    !+ad_type  Function returning real
    !+ad_auth  C A Gardner, AEA Fusion, Culham Laboratory
    !+ad_auth  P J Knight, CCFE, Culham Science Centre
    !+ad_cont  None
    !+ad_args  x      : input real : property temperature (C)
    !+ad_desc  This routine calculates the yield strength of the
    !+ad_desc  first wall, assumed to be made of stainless steel.
    !+ad_prob  None
    !+ad_call  None
    !+ad_hist  25/11/93 PJK Incorporation into PROCESS
    !+ad_hist  01/10/12 PJK Initial F90 version
    !+ad_stat  Okay
    !+ad_docs  Work File Notes F/MPE/MOD/CAG/PROCESS/PULSE
    !+ad_docs  AEA FUS 251: A User's Guide to the PROCESS Systems Code
    !
    ! !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!

    implicit none

    real(kind(1.0D0)) :: yield

    !  Arguments

    real(kind(1.0D0)), intent(in) :: x

    !  Local variables

    ! !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!

    yield = 745.0D0 * x**(-0.31D0) * 1.0D6

  end function yield

  ! !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!

  function smt(x,fwlifs)

    !+ad_name  smt
    !+ad_summ  Calculates the maximum stress intensity for the first wall
    !+ad_type  Function returning real
    !+ad_auth  C A Gardner, AEA Fusion, Culham Laboratory
    !+ad_auth  P J Knight, CCFE, Culham Science Centre
    !+ad_cont  None
    !+ad_args  x      : input real : property temperature (C)
    !+ad_args  fwlifs : input real : first wall lifetime (s)
    !+ad_desc  This routine calculates the maximum stress intensity
    !+ad_desc  in the first wall, from fits via the ASME code.
    !+ad_prob  None
    !+ad_call  None
    !+ad_hist  25/11/93 PJK Incorporation into PROCESS
    !+ad_hist  01/10/12 PJK Initial F90 version
    !+ad_stat  Okay
    !+ad_docs  Work File Notes F/MPE/MOD/CAG/PROCESS/PULSE
    !+ad_docs  AEA FUS 251: A User's Guide to the PROCESS Systems Code
    !
    ! !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!

    implicit none

    real(kind(1.0D0)) :: smt

    !  Arguments

    real(kind(1.0D0)), intent(in) :: x,fwlifs

    !  Local variables

    real(kind(1.0D0)) :: smt400,smt500,smt600,lnpwr

    ! !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!

    smt400 = 109.0D0  !  smt at <= 400 degrees Celsius
    smt500 = 107.0D0  !  smt at 500 degrees Celsius
    smt600 = 102.0D0  !  smt at 600 degrees Celsius

    !  If x <= 400 smt = 109.
    !  If x <= 500 smt = smt400+(x-400)/100**smt500-smt400 
    !  (simple first order Taylor expansion).

    if (fwlifs >= 3000.0D0) then
       lnpwr = log(fwlifs)
       smt600 = -0.8139765D0*lnpwr**2 + 6.2849D0*lnpwr + 99.147D0
    end if

    !  Linear interpolation used within range 400 deg C to 600 deg C

    if (x <= 400.0D0) then
       smt = smt400
    else if (x <= 500.0D0) then
       smt = smt400 + (x-400.0D0)/100.0D0*(smt500-smt400)
    else if (x <= 600.0D0) then
       smt = smt500 + (x-500.0D0)/100.0D0*(smt600-smt500)
    else
       write(*,*) 'Error in routine SMT:'
       write(*,*) 'No reliable data for SMT stress for temperatures'
       write(*,*) 'exceeding 600 degrees Celsius'
       write(*,*) 'PROCESS stopping.'
       stop
    end if

    smt = smt*1.0D6

  end function smt

  ! !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!

  subroutine cycles(equiv,tpeak,ncyc)

    !+ad_name  cycles
    !+ad_summ  Calculates the number of allowable pulse cycles
    !+ad_type  Subroutine
    !+ad_auth  C A Gardner, AEA Fusion, Culham Laboratory
    !+ad_auth  P J Knight, CCFE, Culham Science Centre
    !+ad_cont  None
    !+ad_args  equiv(3) : input real array     : Von Mises equivalent strain
    !+ad_args  tpeak    : input real           : peak temperature (C)
    !+ad_args  ncyc(3)  : output integer array : number of allowable cycles
    !+ad_desc  This routine calculates the number of allowable cycles
    !+ad_desc  for a pulsed reactor from a fit of the ASME fatigue
    !+ad_desc  design data for the first wall.
    !+ad_prob  Uncommenting the initial tpeak test causes code output
    !+ad_prob  to change inexplicably...
    !+ad_call  None
    !+ad_hist  25/11/93 PJK Incorporation into PROCESS
    !+ad_hist  01/10/12 PJK Initial F90 version
    !+ad_stat  Okay
    !+ad_docs  Methods of first wall structural analysis ...,
    !+ad_docc  R.J. LeClaire, PFC/RR-84-9
    !+ad_docs  Work File Notes F/MPE/MOD/CAG/PROCESS/PULSE
    !+ad_docs  AEA FUS 251: A User's Guide to the PROCESS Systems Code
    !
    ! !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!

    implicit none

    !  Arguments

    real(kind(1.0D0)), dimension(3), intent(in) :: equiv
    real(kind(1.0D0)), intent(in) :: tpeak
    integer, dimension(3), intent(out) :: ncyc

    !  Local variables

    real(kind(1.0D0)) :: logstr,lgn426,lgn454,lgn482,lgn510,lgn649,logn
    real(kind(1.0D0)), dimension(5) :: bsqd
    integer :: k

    ! !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!

    !  Uncommenting this if-clause causes change to output!
    !if (tpeak > 649.0D0) then
    !   write(*,*) 'Error in routine CYCLES:'
    !   write(*,*) 'Fatigue data unreliable for T > 649 deg C'
    !   write(*,*) 'PROCESS stopping.'
    !   stop
    !end if

    !  logstr  : logarithm of equivalent strain
    !  lgnXXX  : logarithm of number of cycles at XXX Celsius
    !  logn    : logarithm of number of cycles at arbitrary temperature
    !  bsqd(5) : fitting coefficients

    do k = 1,3

       logstr = log(equiv(k))
       lgn426 = (logstr + 3.7587178D0) / (-0.198105441D0)
       lgn454 = (logstr + 4.2563621D0) / (-0.183711238D0)
       lgn482 = (logstr + 4.6637048D0) / (-0.17626645D0)
       lgn510 = (logstr + 5.1613625D0) / (-0.16112635D0)
       lgn649 = (logstr + 5.691763D0)  / (-0.14084195D0)

       bsqd(1) = (8.763D-3)**2 - 4.0D0*4.548D-4*(0.046D0-equiv(k))
       bsqd(2) = (4.941D-3)**2 - 4.0D0*2.525D-4*(0.02675D0-equiv(k))
       bsqd(3) = (2.537D-3)**2 - 4.0D0*1.2564D-4*(0.01459D0-equiv(k))
       bsqd(4) = (1.113D-3)**2 - 4.0D0*5.199D-5*(7.3355D-3-equiv(k))
       bsqd(5) = (6.558D-4)**2 - 4.0D0*3.09D-5*(4.3448D-3-equiv(k))

       bsqd(:) = max(bsqd(:), 0.0D0)

       !  This piece seems to be approximating the fatigue design curve by
       !  a quadratic - rather odd method...

       if (equiv(k) > 0.00376D0) &
            lgn426 = (8.763D-3 - sqrt(bsqd(1))) / (2.0D0*4.548D-4)
       if (equiv(k) > 0.00261D0) &
            lgn454 = (4.941D-3 - sqrt(bsqd(2))) / (2.0D0*2.525D-4)
       if (equiv(k) > 0.00186D0) &
            lgn482 = (2.537D-3 - sqrt(bsqd(3))) / (2.0D0*1.2564D-4)
       if (equiv(k) > 0.0013D0) &
            lgn510 = (1.133D-3 - sqrt(bsqd(4))) / (2.0D0*5.199D-5)
       if (equiv(k) > 0.000922D0)  &
            lgn649 = (6.558D-4 - sqrt(bsqd(5))) / (2.0D0*3.09D-5)

       !  Taylor expansion in temperature

       if (tpeak <= 426.0D0) then
          logn = lgn426
       else if (tpeak <= 454.0D0) then
          logn = lgn426 + (tpeak-426.0D0)*(lgn454-lgn426) / &
               (454.0D0-426.0D0)
       else if (tpeak <= 482.0D0) then
          logn = lgn454 + (tpeak-454.0D0)*(lgn482-lgn454) / &
               (482.0D0-454.0D0)
       else if (tpeak <= 510.0D0) then
          logn = lgn482 + (tpeak-482.0D0)*(lgn510-lgn482) / &
               (510.0D0-482.0D0)
       else if (tpeak <= 649.0D0) then
          logn = lgn510 + (tpeak-510.0D0)*(lgn649-lgn510) / &
               (649.0D0-510.0D0)
       else
          !  Shouldn't get here (trapped by initial test above)
          continue
       end if

       if (logn > 15.0D0) logn = 15.0D0

       ncyc(k) = int(exp(logn))

    end do

  end subroutine cycles

end subroutine thrmal

! !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!

subroutine tohswg(outfile,iprint)

  !+ad_name  tohswg
  !+ad_summ  Routine to calculate the minimum OH coil swing time
  !+ad_type  Subroutine
  !+ad_auth  C A Gardner, AEA Fusion, Culham Laboratory
  !+ad_auth  P J Knight, CCFE, Culham Science Centre
  !+ad_cont  None
  !+ad_args  outfile : input integer : output file unit
  !+ad_args  iprint : input integer : switch for writing to output file (1=yes)
  !+ad_desc  This routine calculates the minimum OH coil swing time
  !+ad_desc  for a pulsed reactor.
  !+ad_prob  None
  !+ad_call  physics_variables
  !+ad_call  process_output
  !+ad_call  pfcoil.h90
  !+ad_call  pwrcom.h90
  !+ad_call  vltcom.h90
  !+ad_call  ineq.h90
  !+ad_call  pulse.h90
  !+ad_call  osubhd
  !+ad_call  ovarre
  !+ad_hist  25/11/93 PJK Incorporation into PROCESS
  !+ad_hist  22/05/06 PJK Corrected error in tohsmn calculation
  !+ad_hist  01/10/12 PJK Initial F90 version
  !+ad_hist  09/10/12 PJK Modified to use new process_output module
  !+ad_hist  15/10/12 PJK Added physics_variables
  !+ad_stat  Okay
  !+ad_docs  Work File Note F/MPE/MOD/CAG/PROCESS/PULSE/0013
  !+ad_docs  Work File Note F/PL/PJK/PROCESS/CODE/050
  !+ad_docs  AEA FUS 251: A User's Guide to the PROCESS Systems Code
  !
  ! !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!

  use physics_variables
  use process_output

  implicit none

  include 'pfcoil.h90'
  include 'pwrcom.h90'
  include 'vltcom.h90'
  include 'ineq.h90'
  include 'pulse.h90'

  !  Arguments

  integer, intent(in) :: outfile,iprint

  !  Local variables

  real(kind(1.0D0)) :: ioht1,ioht2,r,rho,pfbusl,albusa,v,m,loh,ipdot

  ! !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!

  if (lpulse /= 1) return

  if (iprint /= 1) then

     !  Current/turn in OH coil at beginning of pulse (A/turn)

     ioht1 = cpt(nohc,2)

     !  Current/turn in OH coil at start of flat-top (A/turn)

     ioht2 = cpt(nohc,3)

     !  OH coil resistance (ohms)

     if (ipfres == 0) then
        r = 0.0D0
     else
        r = powohres/( 1.0D6*ric(nohc) )**2
     end if

     !  OH coil bus resistance (ohms) (assumed to include power supply)
     !  Bus parameters taken from routine PWRCONV.

     pfbusl = 8.0D0 * rmajor + 140.0D0
     albusa = abs(cptdin(nohc))/100.0D0

     rho = 1.5D0 * 2.62D-4 * pfbusl/albusa

     !  OH coil power source emf (volts)

     v = vpfskv * 1.0D3

     !  Mutual inductance between OH coil and plasma (H)

     m = sxlg(nohc,ncirt)

     !  Self inductance of OH coil (H)

     loh = sxlg(nohc,nohc)

     !  Maximum rate of change of plasma current (A/s)

     ipdot = 0.5D6

     !  Minimum OH coil swing time (s)

     tohsmn = loh*(ioht2 - ioht1) / &
          (ioht2*turns(nohc)*(r+rho) - v + m*ipdot)

  else

     call osubhd(outfile,'OH coil swing time considerations:')
     call ovarre(outfile,'Minimum OH coil swing time (s)', &
          '(tohsmn)',tohsmn)

  end if

end subroutine tohswg

! !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!

subroutine burn(outfile,iprint)

  !+ad_name  burn
  !+ad_summ  Routine to calculate the burn time for a pulsed reactor
  !+ad_type  Subroutine
  !+ad_auth  C A Gardner, AEA Fusion, Culham Laboratory
  !+ad_auth  P J Knight, CCFE, Culham Science Centre
  !+ad_cont  None
  !+ad_args  outfile : input integer : output file unit
  !+ad_args  iprint : input integer : switch for writing to output file (1=yes)
  !+ad_desc  This routine calculates the burn time for a pulsed reactor.
  !+ad_prob  None
  !+ad_call  physics_variables
  !+ad_call  process_output
  !+ad_call  pfcoil.h90
  !+ad_call  pulse.h90
  !+ad_call  vltcom.h90
  !+ad_call  cdriv.h90
  !+ad_call  times.h90
  !+ad_call  osubhd
  !+ad_call  ovarre
  !+ad_hist  25/11/93 PJK Incorporation into PROCESS
  !+ad_hist  25/05/06 PJK Corrected error in tohsmn calculation
  !+ad_hist  01/10/12 PJK Initial F90 version
  !+ad_hist  09/10/12 PJK Modified to use new process_output module
  !+ad_hist  15/10/12 PJK Added physics_variables
  !+ad_stat  Okay
  !+ad_docs  Work File Note F/MPE/MOD/CAG/PROCESS/PULSE/0012
  !+ad_docs  AEA FUS 251: A User's Guide to the PROCESS Systems Code
  !
  ! !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!

  use physics_variables
  use process_output

  implicit none

  include 'pfcoil.h90'
  include 'pulse.h90'
  include 'vltcom.h90'
  include 'cdriv.h90'
  include 'times.h90'

  !  Arguments

  integer, intent(in) :: outfile,iprint

  !  Local variables

  real(kind(1.0D0)) :: vburn
  real(kind(1.0D0)), save :: vsmax,vssoft

  ! !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!

  if (lpulse /= 1) return

  if (iprint /= 1) then

     !  Volt-seconds required to produce plasma current during start-up
     !  (i.e. up to start of flat top)

     vssoft = vsres + vsind

     !  Total volt-seconds available during burn (vstot is the total
     !  volt-second capability provided by the PF/OH coils)

     vsmax = abs(vstot) - vssoft

     !  Loop voltage during burn (including MHD sawtooth enhancement)

     vburn = plascur * rplas * facoh * csawth

     !  Burn time (s)

     tburn = vsmax/vburn

  else

     call osubhd(outfile,'Volt-second considerations:')

     call ovarre(outfile,'Total V-s capability of OH/PF coils (Wb)', &
          '(abs(vstot))',abs(vstot))
     call ovarre(outfile,'Required volt-seconds during start-up (Wb)', &
          '(vssoft)',vssoft)
     call ovarre(outfile,'Available volt-seconds during burn (Wb)', &
          '(vsmax)',vsmax)
     call ovarre(outfile,'Burn time (s)','(tburn)',tburn)

  end if

end subroutine burn

! !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!

subroutine startup(iprint)

  !+ad_name  startup
  !+ad_summ  Routine to find the minimum auxiliary power required for start-up
  !+ad_type  Subroutine
  !+ad_auth  C A Gardner, AEA Fusion, Culham Laboratory
  !+ad_auth  P J Knight, CCFE, Culham Science Centre
  !+ad_cont  constr
  !+ad_cont  cudrv1
  !+ad_cont  start1
  !+ad_cont  start2
  !+ad_args  iprint : input integer : switch for writing to output file (1=yes)
  !+ad_desc  This routine finds the minimum auxiliary power required in start-up.
  !+ad_desc  This is accomplished by calling the non-linear optimisation routine
  !+ad_desc  VMCON, so this subroutine simply sets up the equations to be solved.
  !+ad_desc  <P>PROCESS assumes that all the ion temperatures and profile
  !+ad_desc  parameters are identical and utilises charge neutrality in 
  !+ad_desc  order to calculate DENI.
  !+ad_desc  <P>ZEFF is assumed to remain constant, in other words the
  !+ad_desc  ion/electron ratios are invariant.
  !+ad_desc  <P>The most general form for the energy confinement time is :
  !+ad_desc  <PRE>
  !+ad_desc                              ptaue   qtaue                   rtaue
  !+ad_desc                          ____      __
  !+ad_desc  taue =  gtaue + ftaue   dene      te     ( <Paux>  +  alpmw )
  !+ad_desc        ____     __
  !+ad_desc  where DENE and TE are the electron density (10**20 m**-3) and
  !+ad_desc  electron temperature (10 keV) respectively.
  !+ad_desc  </PRE>
  !+ad_desc  The equation defining ignition has the form
  !+ad_desc  <PRE>
  !+ad_desc                       2   s                2   1/2      -3/2
  !+ad_desc   A n   T      =   B n   T    +  P    - C n   T    + D T
  !+ad_desc      e20 e10          e20 e10     aux      e20 e10      e10
  !+ad_desc  ----------
  !+ad_desc     tau
  !+ad_desc        E
  !+ad_desc                =    P         +  P    -  P         +  P
  !+ad_desc                      alpha        aux     rad          ohm
  !+ad_desc  
  !+ad_desc                      p   q                                  r
  !+ad_desc  tau    =  gg  + ff n   T    ( P      + P    + P    + P    )
  !+ad_desc     E                e20 e10    alpha    ohm    rad    ohm
  !+ad_desc  </PRE>
  !+ad_desc  We solve this equation for (ne20, Te10) subject to the constraints,
  !+ad_desc  <PRE>
  !+ad_desc            d P
  !+ad_desc               aux
  !+ad_desc            -----  =  0.
  !+ad_desc            d T
  !+ad_desc               e10
  !+ad_desc  </PRE>
  !+ad_desc  to find the minimum auxiliary power required in start-up.
  !+ad_prob  None
  !+ad_call  physics_variables
  !+ad_call  process_output
  !+ad_call  start.h90
  !+ad_call  cdriv.h90
  !+ad_call  ineq.h90
  !+ad_call  oheadr
  !+ad_call  ovarre
  !+ad_call  start1
  !+ad_call  start2
  !+ad_call  vmcon1
  !+ad_hist  25/11/93 PJK Incorporation into PROCESS
  !+ad_hist  02/10/12 PJK Initial F90 version
  !+ad_hist  09/10/12 PJK Modified to use new process_output module
  !+ad_hist  15/10/12 PJK Added physics_variables
  !+ad_stat  Not currently used
  !+ad_docs  Work File Notes F/MPE/MOD/CAG/PROCESS/PULSE
  !+ad_docs  AEA FUS 251: A User's Guide to the PROCESS Systems Code
  !
  ! !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!

  use physics_variables
  use process_output

  implicit none

  include 'start.h90'
  include 'cdriv.h90'
  include 'ineq.h90'

  !  Arguments

  integer, intent(in) :: iprint

  !  Local variables

  real(kind(1.0D0)) :: ne20,te10,ti10,fd,fdt,rrplas,objf,tol
  integer :: meq,maxfev,info,nfev,mode

  integer, parameter :: n = 2
  integer, parameter :: m = 2
  integer, parameter :: lcnorm = n+1
  integer, parameter :: lb = n+1
  integer, parameter :: ldel = 7*(n+1)
  integer, parameter :: lh = 2*(n+1)
  integer, parameter :: lwa = 2*(n+1)
  integer, parameter :: liwa = 6*(n+1)+m

  real(kind(1.0D0)), dimension(n) :: x,fgrd,glag,glaga,gamma1, &
       eta,xa,bdelta,bndl,bndu
  real(kind(1.0D0)), dimension(m) :: conf,cm
  real(kind(1.0D0)), dimension(lcnorm,m) :: cnorm
  real(kind(1.0D0)), dimension(lb,lb) :: b
  real(kind(1.0D0)), dimension(m+2*n+1) :: vlam1,vmu
  real(kind(1.0D0)), dimension(ldel) :: delta
  real(kind(1.0D0)), dimension(n+1) :: gm,bdl,bdu
  real(kind(1.0D0)), dimension(lh,lh) :: h
  real(kind(1.0D0)), dimension(lwa) :: wa
  integer, dimension(liwa) :: iwa
  integer, dimension(n) :: ilower,iupper

  ! !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!

  if (iprint /= 1) then

     !  Define normalised temperature and densities

     ne20 = dene/1.0D20
     te10 = te/10.0D0
     ti10 = ti/10.0D0

     aa = 0.24D0*(1.0D0 + (deni/dene + ralpne + rncne + rnone + rnfene)*ti/te)

     if ((ti10 > 0.4D0).and.(ti10 <= 1.0D0)) then
        s = 3
     else if ((ti10 > 1.0D0).and.(ti10 <= 2.0D0)) then
        s = 2

        !  Outside the above ranges of ti10, the value of s is not known
        !  (by PJK), so s is set according to whether ti10 is above
        !  or below unity...

     else if (ti10 <= 1.0D0) then
        s = 3
     else
        s = 2
     end if

     fd = 1.0D0 - ftr
     fdt = deni/dene

     !  Alpha power multiplier

     bb = 0.155D0 * (4.0D0*fd*(1.0D0 - fd)*fdt**2) * &
          (1.0D0 + alphan + alphat)**s / &
          ((1.0D0 + alphan)**(s-2) * (1.0D0 + 2.0D0*alphan + dble(s)*alphat))

     !  Radiation power multiplier

     cc = 1.68D-2 * ( sqrt((1.0D0 + alphan)**3) &
          * sqrt(1.0D0 + alphan + alphat) / &
          (1.0D0 + 2.0D0*alphan + 0.5D0*alphat) )*zeff

     !  Ohmic power multiplier
     !  If the ohmic power density calculated in subroutine POHM is
     !  changed in the future then the constant DD must be changed 
     !  accordingly.

     !  The following lines come directly from the formulae within
     !  routine POHM, but with t10 replaced by pcoef

     rrplas = 2.15D-9*zeff*rmajor/(kappa*rminor**2*pcoef**1.5D0)
     if (ires == 1) then
        rrplas = rrplas*rpfac
     end if

     dd = (facoh*plascur)**2 * rrplas * 1.0D-6/vol

     !  Multiply coefficients by plasma volume

     aa = aa*vol
     bb = bb*vol
     cc = cc*vol
     dd = dd*vol

     !  Initial values for the density and temperature

     x(1) = ne20
     x(2) = te10

     !  Initialise variables for VMCON

     meq = 1
     mode = 0
     tol = 1.0D-3
     maxfev = 100

     ilower(1) = 1
     ilower(2) = 1
     iupper(1) = 1
     iupper(2) = 1
     bndl(1) = 0.1D0
     bndl(2) = 0.5D0
     bndu(1) = 100.0D0
     bndu(2) = 50.0D0

     !  N.B. If the VMCON routine stored in minpac.f is used, then
     !  we have problems with recursive calls. Therefore we must call
     !  an almost identical version, VMCON1, instead.

     call vmcon1(start1,start2,mode,n,m,meq,x,objf,fgrd,conf, &
          cnorm,lcnorm,b,lb,tol,maxfev,info,nfev,vlam1,glag,vmu, &
          cm,glaga,gamma1,eta,xa,bdelta,delta,ldel,gm,bdl,bdu, &
          h,lh,wa,lwa,iwa,liwa,ilower,iupper,bndl,bndu)

     auxmin = objf
     nign = x(1)*1.0D20
     tign = x(2)*10.0D0

  else

     call oheadr(nout,'Start-up')

     call ovarre(nout,'Minimum auxiliary power requirement (MW)', &
          '(auxmin)',auxmin)
     call ovarre(nout,'Start-up electron density (/m3)', &
          '(x(1))',x(1)*1.0D20)
     call ovarre(nout,'Start-up electron temperature (keV)', &
          '(x(2))',x(2)*10.0D0)

  end if

contains

! !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!

subroutine start1(n,m,x,objf,conf,info)

  !+ad_name  start1
  !+ad_summ  Calculates the auxiliary power and the constraint equations
  !+ad_summ  relevant to the minimisation of the auxiliary power
  !+ad_type  Subroutine
  !+ad_auth  C A Gardner, AEA Fusion, Culham Laboratory
  !+ad_auth  P J Knight, CCFE, Culham Science Centre
  !+ad_cont  None
  !+ad_args  n       : input integer : number of equations
  !+ad_args  m       : input integer : number of constraints
  !+ad_args  x(n)    : input real array : current values of the density and temperature
  !+ad_args  objf    : output real : auxiliary power (MW)
  !+ad_args  conf(m) : output real array : contraints
  !+ad_args  info    : in/out integer : error status flag
  !+ad_desc  This routine calculates the auxiliary power and the
  !+ad_desc  constraint equations relevant to its minimisation.
  !+ad_prob  None
  !+ad_call  constr
  !+ad_call  cudrv1
  !+ad_hist  25/11/93 PJK Incorporation into PROCESS
  !+ad_hist  02/10/12 PJK Initial F90 version
  !+ad_stat  Okay
  !+ad_docs  Work File Notes F/MPE/MOD/CAG/PROCESS/PULSE
  !+ad_docs  AEA FUS 251: A User's Guide to the PROCESS Systems Code
  !
  ! !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!

  implicit none

  !  Arguments

  integer, intent(in) :: n,m
  integer, intent(inout) :: info
  real(kind(1.0D0)), dimension(n), intent(in) :: x
  real(kind(1.0D0)), dimension(m), intent(out) :: conf
  real(kind(1.0D0)), intent(out) :: objf

  !  Local variables

  ! !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!

  call cudrv1(n,x,objf)
  call constr(n,m,x,objf,conf)

  info = info*1

end subroutine start1

! !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!

subroutine start2(n,m,x,fgrd,cnorm,lcnorm,info)

  !+ad_name  start2
  !+ad_summ  Calculates the first derivative of the auxiliary power
  !+ad_summ  and the constraint equations relevant to the minimisation
  !+ad_summ  of the auxiliary power
  !+ad_type  Subroutine
  !+ad_auth  C A Gardner, AEA Fusion, Culham Laboratory
  !+ad_auth  P J Knight, CCFE, Culham Science Centre
  !+ad_cont  None
  !+ad_args  n       : input integer : number of equations
  !+ad_args  m       : input integer : number of constraints
  !+ad_args  x(n)    : input real array : current values of the density and temperature
  !+ad_args  fgrd(n) : output real array : first derivative of auxiliary power
  !+ad_args  cnorm(m,lcnorm) : output real array : constraints
  !+ad_args  lcnorm  : input integer : array index
  !+ad_args  info    : in/out integer : error status flag
  !+ad_desc  This routine calculates the first derivative of the
  !+ad_desc  auxiliary power and the constraint equations relevant
  !+ad_desc  to the minimisation of the auxiliary power.
  !+ad_prob  None
  !+ad_call  constr
  !+ad_call  cudrv1
  !+ad_hist  25/11/93 PJK Incorporation into PROCESS
  !+ad_hist  02/10/12 PJK Initial F90 version
  !+ad_hist  10/10/12 PJK Hardwired local value of epsfcn
  !+ad_stat  Okay
  !+ad_docs  Work File Notes F/MPE/MOD/CAG/PROCESS/PULSE
  !+ad_docs  AEA FUS 251: A User's Guide to the PROCESS Systems Code
  !
  ! !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!

  implicit none

  !  Arguments

  integer, intent(in) :: n,m,lcnorm
  integer, intent(inout) :: info
  real(kind(1.0D0)), dimension(n), intent(in) :: x
  real(kind(1.0D0)), dimension(n), intent(out) :: fgrd
  real(kind(1.0D0)), dimension(lcnorm,m), intent(out) :: cnorm

  !  Local variables

  real(kind(1.0D0)), dimension(2) :: xfor,xbac,cfor,cbac
  real(kind(1.0D0)) :: ffor,fbac
  real(kind(1.0D0)) :: epsfcn = 1.0D-3
  integer :: i,j

  ! !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!

  do i = 1,n
     do j = 1,n
        xfor(j) = x(j)
        xbac(j) = x(j)
        if (i == j) then
           xfor(i) = x(j) * (1.0D0 + epsfcn)
           xbac(i) = x(j) * (1.0D0 - epsfcn)
        end if
     end do

     call cudrv1(n,xfor,ffor)
     call constr(n,m,xfor,ffor,cfor)

     call cudrv1(n,xbac,fbac)
     call constr(n,m,xbac,fbac,cbac)

     fgrd(i) = (ffor-fbac)/(xfor(i)-xbac(i))

     do j = 1,m
        cnorm(i,j) = (cfor(j)-cbac(j)) / (xfor(i)-xbac(i))
     end do
  end do

  info = info*1

end subroutine start2

! !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!

subroutine cudrv1(n,x,paux)

  !+ad_name  cudrv1
  !+ad_summ  Routine acting as interface between the start-up routines
  !+ad_summ  and CUDRIV
  !+ad_type  Subroutine
  !+ad_auth  C A Gardner, AEA Fusion, Culham Laboratory
  !+ad_auth  P J Knight, CCFE, Culham Science Centre
  !+ad_cont  None
  !+ad_args  n       : input integer : number of equations
  !+ad_args  x(n)    : input real array : current values of the density and temperature
  !+ad_args  paux    : output real : auxiliary power (MW)
  !+ad_desc  This routine acts as the interface between the start-up routines
  !+ad_desc  and <A HREF="cudriv.html">CUDRIV</A>.
  !+ad_prob  None
  !+ad_call  physics_module
  !+ad_call  physics_variables
  !+ad_call  cdriv.h90
  !+ad_call  physics
  !+ad_call  cudrv1
  !+ad_hist  25/11/93 PJK Incorporation into PROCESS
  !+ad_hist  02/10/12 PJK Initial F90 version
  !+ad_hist  15/10/12 PJK Added physics_variables
  !+ad_hist  16/10/12 PJK Added physics_module
  !+ad_stat  Okay
  !+ad_docs  Work File Notes F/MPE/MOD/CAG/PROCESS/PULSE
  !+ad_docs  AEA FUS 251: A User's Guide to the PROCESS Systems Code
  !
  ! !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!

  use physics_module
  use physics_variables

  implicit none

  include 'cdriv.h90'

  !  Arguments

  integer, intent(in) :: n
  real(kind(1.0D0)), dimension(n), intent(in) :: x
  real(kind(1.0D0)), intent(out) :: paux

  !  Local variables

  real(kind(1.0D0)) :: storen,storet

  ! !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!

  !  Set electron density, temperature for this iteration, but
  !  store original values to allow them to be reset later

  storen = dene
  storet = te

  dene = x(1)*1.0D20
  te   = x(2)*10.0D0

  !  Call the physics routines with these values - PHYSICS calls
  !  routine CUDRIV itself.

  call physics

  !  Total injection power (MW)

  paux = (pinje + pinji)*1.0D-6

  !  Reset density and temperature to pre-call values

  dene = storen
  te = storet

  !  Call physics routines again to reset all values

  call physics

end subroutine cudrv1

! !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!

subroutine constr(n,m,x,paux,conf)

  !+ad_name  constr
  !+ad_summ  Calculates the constraint equations relevant to the
  !+ad_summ  minimisation of the auxiliary power
  !+ad_type  Subroutine
  !+ad_auth  C A Gardner, AEA Fusion, Culham Laboratory
  !+ad_auth  P J Knight, CCFE, Culham Science Centre
  !+ad_cont  None
  !+ad_args  n       : input integer : number of equations
  !+ad_args  m       : input integer : number of constraints
  !+ad_args  x(n)    : input real array : current values of the density and temperature
  !+ad_args  paux    : input real : auxiliary power (MW)
  !+ad_args  conf(m) : output real array : constraints
  !+ad_desc  This routine calculates the constraint equations relevant
  !+ad_desc  to the minimisation of the auxiliary power.
  !+ad_prob  None
  !+ad_call  start.h90
  !+ad_hist  25/11/93 PJK Incorporation into PROCESS
  !+ad_hist  02/10/12 PJK Initial F90 version
  !+ad_stat  Okay
  !+ad_docs  Work File Notes F/MPE/MOD/CAG/PROCESS/PULSE
  !+ad_docs  AEA FUS 251: A User's Guide to the PROCESS Systems Code
  !
  ! !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!

  implicit none

  include 'start.h90'

  !  Arguments

  integer, intent(in) :: n,m
  real(kind(1.0D0)), intent(in) :: paux
  real(kind(1.0D0)), dimension(n), intent(in) :: x
  real(kind(1.0D0)), dimension(m), intent(out) :: conf

  !  Local variables

  real(kind(1.0D0)) :: eta,detadt

  ! !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!

  eta = bb*x(1)**2*x(2)**s + paux - cc*x(1)**2*sqrt(x(2)) &
       + dd / sqrt(x(2)**3)
  detadt = dble(s)*bb*x(1)**2*x(2)**(s-1) - 0.5D0*cc*x(1)**2 &
       / sqrt(x(2)) - 1.5D0*dd/sqrt(x(2)**5)

  conf(1) = aa*x(1) - (gtaue + ftaue*(1.0D0+rtaue)*x(1)**ptaue &
       * x(2)**qtaue*eta**rtaue)*detadt &
       - qtaue*ftaue*x(1)**ptaue*x(2)**(qtaue-1.0D0)*eta**(rtaue+1.0D0)
  conf(2) = paux

end subroutine constr

end subroutine startup

!______________________________________________________________________
!+**PJK 25/11/93 The following has been added to help STARTUP run.
!+**PJK 02/10/12 Not yet converted to full F90
!______________________________________________________________________
SUBROUTINE VMCON1( &
     start1,start2,mode,n,m,meq,x,objf,fgrd,conf,cnorm,lcnorm, &
     b,lb,tol,maxfev,info,nfev,vlam,glag,vmu,cm,glaga,gamma,eta, &
     xa,bdelta,delta,ldel,gm,bdl,bdu,h,lh,wa,lwa,iwa,liwa,ilower, &
     iupper,bndl,bndu)

  !+**PJK 25/11/93 This routine is identical to subroutine VMCON
  !+**PJK 25/11/93 stored in minpac.f, but calls different routines
  !+**PJK 25/11/93 start1,  start2  and qpsub1, instead of
  !+**PJK 25/11/93 fcnvmc1, fcnvmc2 and qpsub, respectively.

  !  This subroutine calculates the least value of a function of
  !  several variables subject to linear and/or nonlinear equality
  !  and inequality constraints.  More particularly, it solves the
  !  problem
  !
  !            minimize f(x)
  !
  !     subject to c (x) =  0.0 ,  i = 1,...,meq
  !                 i
  !
  !            and c (x) >= 0.0 ,  i = meq+1,...,m
  !                 i
  !
  !            and l <= x <= u  ,  i = 1,...n
  !                 i    i    i
  !
  !
  !  The subroutine implements a variable metric method for
  !  constrained optimization developed by M.J.D. Powell.
  !
  !  The subroutine statement is
  !
  !    subroutine vmcon1(start1,start2,mode,n,m,meq,x,objf,fgrd,conf,
  !                     cnorm,lcnorm,b,lb,tol,maxfev,info,
  !                     nfev,vlam,glag,vmu,cm,glaga,gamma,eta,xa,
  !                     bdelta,delta,ldel,gm,bdl,bdu,h,lh,wa,lwa,iwa,
  !                     liwa)
  !
  !  where
  !
  !  START1 is the name of the user supplied subroutine which
  !  calculates the objective and constraint functions. START1
  !  should be declared in an external statement in the user
  !  calling program, and should be written as follows:
  !
  !   subroutine start1(n,m,x,objf,conf,info)
  !   integer n,m,info
  !   real objf
  !   real x(n),fgrd(n),conf(m)
  !   ---------------
  !   statements to calculate the objective and constraint at x.
  !   the objective and constraint functions and must be returned in
  !   objf, conf. note that the equality
  !   constraints must precede the inequality constraints in conf.
  !   ---------------
  !   return
  !   end
  !
  !  START2 is the name of the user supplied subroutine which
  !  calculates the gradients (first derivative vectors)
  !  of the objective and constraint functions. START2 should be
  !  declared in an external statement in the user calling
  !  program, and should be written as follows :
  !
  !   subroutine start2(n,m,x,fgrd,cnorm,lcnorm,info)
  !   integer n,m,lcnorm,info
  !   real objf
  !   real x(n),cnorm(lcnorm,m)
  !   ---------------
  !   statements to calculate the gradients of the objective and
  !   constraint functions at x. the gradient of the objective
  !   function must be returned in fgrd. note that the equality
  !   constraints must precede the inequality constraints in conf.
  !   the constraint gradients or normals must be returned as the
  !   columns of cnorm.
  !   ---------------
  !   return
  !   end
  !
  !  The value of INFO should not be changed by START2 unless the
  !  user wants to terminate execution of VMCON1. In this case
  !  set INFO to a negative integer.
  !
  !  MODE is a non-negative integer input variable set to 1 if the
  !  second derivative matrix in b (see below) is provided by the
  !  user, and to 0 if it is to be initialized to the identity
  !  matrix.
  !
  !  N is a positive integer input variable set to the number of
  !  variables.
  !
  !  M is a positive integer input variable set to the number of
  !  constraints.
  !
  !  MEQ is a non-negative integer input variable set to the number
  !  of equality constraints. MEQ must be less than or equal to N.
  !
  !  X is a real array of length N. On input it must contain an
  !  initial estimate of the solution vector. On output X
  !  contains the final estimate of the solution vector.
  !
  !  OBJF is a real output variable that contains the value of the
  !  objective function at the output x.
  !
  !  FGRD is a real output array of length N which contains the
  !  components of the gradient of the objective function at
  !  the output X.
  !
  !  CONF is a real output array of length M which contains the
  !  values of the constraint functions at the output X. The
  !  equality constraints must precede the inequality constraints.
  !
  !  CNORM is a real LCNORM by M array whose columns contain the
  !  constraint normals at the output X in the first N positions.
  !
  !  LCNORM is a positive integer input variable set to the row
  !  dimension of CNORM which is at least N+1.  The (N+1)st row
  !  of CNORM is used for work space.
  !
  !  B is a real LB by LB array whose first N rows and columns
  !  contain the approximation to the second derivative matrix
  !  of the Lagrangian function. Often, an adequate initial
  !  B matrix can be obtained by approximating the hessian
  !  of the objective function.  On input, the approximation is
  !  provided by the user if MODE = 1 and is set to the identity
  !  matrix if MODE = 0. the (N+1)st row and column are used for
  !  work space.
  !
  !  LB is a positive integer input variable set to the row
  !  dimension of B which is at least N+1.
  !
  !  TOL is a non-negative input variable. A normal return occurs
  !  when the objective function plus suitably weighted multiples
  !  of the constraint functions are predicted to differ from
  !  their optimal values by at most TOL.
  !
  !  MAXFEV is a positive integer input variable set to the limit
  !  on the number of calls to START1.
  !
  !  INFO is an integer output variable set as follows
  !
  !   if INFO is negative then user termination. otherwise
  !
  !   INFO = 0  improper input parameters. Tests are made to ensure
  !             that N and M are positive, TOL is non-negative,
  !             MEQ is less than or equal to N, and that LCNORM,
  !             LB, LDEL, LH, LWA, and LIWA are sufficiently large.
  !
  !   INFO = 1  a normal return. see description of TOL.
  !
  !   INFO = 2  number of calls to START1 is at least MAXFEV.
  !
  !   INFO = 3  line search required ten calls of START1.
  !
  !   INFO = 4  uphill search direction was calculated.
  !
  !   INFO = 5  quadratic programming technique was unable to find
  !             a feasible point.
  !
  !   INFO = 6  quadratic programming technique was restricted by
  !             an artificial bound or failed due to a singular
  !             matrix.
  !
  !  NFEV is an integer output variable set to the number of calls
  !  to START1.
  !
  !  VLAM is a real output array of length M+2N+1 which contains
  !  the Lagrange multipliers at the output X.  The Lagrange
  !  multipliers provide the sensitivity of the objective
  !  function to changes in the constraint functions.
  !  note that VLAM(M+I), I=1,...,N gives the multipliers for
  !  the lower bound constraints.  VLAM(M+N+1+I), I=1,...,N
  !  gives the multipliers for the upper bound constraints.
  !
  !  GLAG is a real output array of length N which contains the
  !  components of the gradient of the Lagrangian function at
  !  the output x.
  !
  !  CM is a real work array of length M.
  !
  !  VMU is a real work array of length M+2N+1.
  !
  !  GLAGA, GAMMA, ETA, XA, BDELTA are real work arrays of
  !  length N.
  !
  !  DELTA is a real work array of length LDEL.
  !
  !  LDEL is a positive integer input variable set equal to the
  !  length of DELTA which is at least MAX(7*(N+1),4*(N+1)+M).
  !
  !  GM, BDL, BDU are real work arrays of length N+1.
  !
  !  H is a real LH by LH work array.
  !
  !  LH is a positive integer input variable set to the dimension
  !  of the square array H which is at least 2*(N+1).
  !
  !  WA is a real work array of length LWA.
  !
  !  LWA is a positive integer input variable set equal to the
  !  dimension of WA which is at least 2*(N+1).
  !
  !  IWA is an integer work array of length LIWA.
  !
  !  LIWA is a positive integer input variable set equal to the
  !  dimension of IWA which is at least 6*(N+1) + M.
  !
  !  ILOWER is an integer array of length N.
  !  If X(I) has a lower bound, ILOWER(I) is set to 1
  !  on input.  If no bound is provided, ILOWER(i) should
  !  be 0 (the default value).
  !
  !  BNDL is a real array of length N.
  !  If X(I) has a lower bound, it should be given in BNDL(I).
  !
  !  IUPPER is an integer array of length N.
  !  If X(I) has an upper bound, IUPPER(I) is set to 1
  !  on input.  If no bound is provided, IUPPER(I) should
  !  be 0 (the default value).
  !
  !  BNDU is a real array of length N.
  !  If X(I) has a upper bound, it should be given in BNDU(I).
  !
  !  Algorithm version of June 1979.
  !
  !  Roger L. Crane, Kenneth E. Hillstrom, Michael Minkoff
  !  Modified for simple bounds, M. Minkoff (10/26/82)
  !  Modified for separate function and gradient evaluation,
  !  M. Minkoff (11/18/83)
  !  Modified to pass ILOWER, IUPPER,BNDL,BDNU through argument
  !  list instead of through common block, and remove write
  !  capability J. Galambos (5/21/91)
  !  Modified for separate START1 and START2 functions to avoid passing
  !  info via a common block. J. Galambos (5/21/91)

  use maths_library

  IMPLICIT NONE

  INTEGER mode,n,m,meq,lcnorm,lb,maxfev,info,nfev,ldel,lh,lwa,liwa
  INTEGER iwa(liwa),ilower(n),iupper(n)
  INTEGER i,j,k,mact,nfinit,nls,np1,np1j,npp,nqp,nsix,nsixi
  INTEGER inx,ki,ml,mlp1,mcon,mp1,mpn,mpnpp1,mpnppn

  real(kind(1.0D0)) objf,tol
  real(kind(1.0D0)) x(n),fgrd(n),conf(m),cnorm(lcnorm,m),b(lb,lb), &
       vlam(*),glag(n),vmu(*),cm(m),glaga(n),gamma(n), &
       eta(n),xa(n),bdelta(n),delta(ldel),gm(*), &
       bdl(*),bdu(*),h(lh,lh),wa(lwa),bndl(n),bndu(n)
  real(kind(1.0D0)) alpha,aux,auxa,calpha,cp1,cp2,cp5,dbd,dflsa,dg, &
       fls,flsa,one,spgdel,sum,temp,thcomp,theta,zero

  EXTERNAL start1,start2

  zero = 0.0D0
  cp1 = 0.1D0
  cp2 = 0.2D0
  cp5 = 0.5D0
  one = 1.0D0

  np1 = n + 1
  npp = 2*np1
  info = 0

  !  Check input parameters for errors

  if ( &
       (n.le.0)           .or. &
       (m.le.0)           .or. &
       (meq.gt.n)         .or. &
       (lcnorm.lt.(n+1))  .or. &
       (lb.lt.(n+1))      .or. &
       (tol.lt.zero)      .or. &
       (ldel.lt.max(7*(n+1),4*(n+1)+m)).or. &
       (lh.lt.(2*(n+1)))  .or. &
       (lwa.lt.(2*(n+1))) .or. &
       (liwa.lt.(6*(n+1)+m)) &
       ) goto 450

  !  Set the initial elements of b and vmu. vmu is the weighting
  !  vector to be used in the line search.
  !  Use hessian estimate provided by user if mode = 1 on input

  if (mode .eq. 1) goto 25

  !  Use identity matrix for hessian estimate

  do j = 1, n
     do i = 1, n
        b(i,j) = zero
     end do
     b(j,j) = one
  end do

25 continue

  !  Set m + 1 to mp1
  !  Set m + n to mpn (these are limits for lower bound indices)
  !  Set m + np1 + 1 to mpnpp1
  !  Set m + np1 + n to mpnppn (these are limits for upper bound
  !  indices)

  mp1 = m + 1
  mpn = m + n
  mpnpp1 = m + np1 + 1
  mpnppn = m + np1 + n

  !  Set mcon to total number of actual constraints

  mcon = m
  do i = 1, n
     if (ilower(i) .eq. 1) mcon = mcon + 1
  end do

  !  Set ml to m + number of lower bounds

  ml = mcon

  !  Set mlp1 to ml + 1

  mlp1 = ml + 1
  do i = 1, n
     if (iupper(i) .eq. 1) mcon = mcon + 1
  end do
  do k = 1, mpnppn
     vmu(k) = zero
  end do

  !  Set initial values of some variables
  !  nfev is the number of calls of start1
  !  nsix is the length of an array
  !  nqp is the number of quadratic subproblems

  nfev = 1
  nsix = 6*np1
  nqp = 0

  !  Calculate the initial functions and gradients

  call start1(n,m,x,objf,conf,info)

  if (info .lt. 0) goto 450

  call start2(n,m,x,fgrd,cnorm,lcnorm,info)

  if (info .lt. 0) goto 450

  !  Start the iteration by calling the quadratic programming
  !  subroutine

40 continue

  !  Increment the quadratic subproblem counter

  nqp = nqp + 1

  !  Set the linear term of the quadratic problem objective function
  !  to the negative gradient of objf

  do i = 1, n
     gm(i) = -fgrd(i)
  end do
  do i = 1, mpnppn
     vlam(i) = zero
  end do

  !+**PJK 15/11/11      call qpsub1(
  call qpsub( &
       n,m,meq,conf,cnorm,lcnorm,b,lb,gm,bdl,bdu,info,x,delta, &
       ldel,cm,h,lh,mact,wa,lwa,iwa,liwa,ilower,iupper, &
       bndl,bndu)

  !  The following return is made if the quadratic problem solver
  !  failed to find a feasible point, if an artificial bound was
  !  active, or if a singular matrix was detected

  if ((info .eq. 5) .or. (info .eq. 6)) goto 450

  !  Initialize the line search iteration counter

  nls = 0

  !  Calculate the Lagrange multipliers

  do j = 1, mact
     k = iwa(j) - npp
     if (k .gt. 0) goto 59
     ki = iwa(j)
     k = ki + m
     if (ki .gt. np1) goto 58
     if (ki .eq. np1) goto 70
     if (ilower(ki) .eq. 1) goto 59
     goto 70
58   continue
     ki = iwa(j) - np1
     k = ki + m + np1
     if (ki .eq. np1) goto 70
     if (iupper(ki) .eq. 1) goto 59
     goto 70
59   continue
     do i = 1, n
        np1j = np1 + j
        nsixi = nsix + i
        vlam(k) = vlam(k) + h(np1j,i)*delta(nsixi)
     end do
70   continue
  end do

  !  Calculate the gradient of the Lagrangian function
  !  nfinit is the value of nfev at the start of an iteration

  nfinit = nfev
  do i = 1, n
     glag(i) = fgrd(i)
  end do
  do k = 1, m
     if (vlam(k) .eq. zero) goto 100
     do i = 1, n
        glag(i) = glag(i) - cnorm(i,k)*vlam(k)
     end do
100  continue
  end do
  do k = mp1, mpn
     if (vlam(k) .eq. zero) goto 105
     inx = k - m
     if (ilower(inx) .eq. 0) goto 105
     glag(inx) = glag(inx) - vlam(k)
105  continue
  end do
  do k = mpnpp1, mpnppn
     if (vlam(k) .eq. zero) goto 106
     inx = k - m - np1
     if (iupper(inx) .eq. 0) goto 106
     glag(inx) = glag(inx) + vlam(k)
106  continue
  end do

  !  Set spgdel to the scalar product of fgrd and delta
  !  Store the elements of glag and x

  spgdel = zero
  do i = 1, n
     spgdel = spgdel + fgrd(i)*delta(i)
     glaga(i) = glag(i)
     xa(i) = x(i)
  end do

  !  Revise the vector vmu and test for convergence

  sum = abs(spgdel)
  do k = 1, mpnppn
     aux = abs(vlam(k))
     vmu(k) = max(aux,cp5*(aux + vmu(k)))
     temp = 0.00D0
     if (k .gt. m) goto 111
     temp = conf(k)
     goto 119
111  continue
     if (k .gt. mpn) goto 112
     inx = k - m
     if (ilower(inx) .eq. 0) goto 120
     temp = x(inx) - bndl(inx)
     goto 119
112  continue
     inx = k - m - np1
     if ((inx .eq. 0) .or. (inx .gt. n)) goto 120
     if (iupper(inx) .eq. 0) goto 120
     temp = bndu(inx) - x(inx)
119  continue
     sum = sum + abs(vlam(k)*temp)
120  continue
  end do

  !  Exit if convergence criterion is satisfied

  if (sum .le. tol) goto 450

  !  Set sum to the weighted sum of infeasibilities
  !  Set fls to the line search objective function

130 continue

  !  Increment the line search iteration counter

  nls = nls + 1
  sum = zero
  do k = 1, mpnppn
     aux = 0.0D0
     if (k .le. meq) aux = conf(k)
     temp = 0.0D0
     if (k .gt. m) goto 131
     temp = conf(k)
     goto 139
131  continue
     if (k .gt. mpn) goto 132
     inx = k - m
     if (ilower(inx) .eq. 0) goto 140
     temp = x(inx) - bndl(inx)
     goto 139
132  continue
     inx = k - m - np1
     if ((inx .eq. 0) .or. (inx .gt. n)) goto 140
     if (iupper(inx) .eq. 0) goto 140
     temp = bndu(inx) - x(inx)
139  continue
     sum = sum + vmu(k)*max(aux,-temp)
140  continue
  end do
  fls = objf + sum

  if (nfev .ne. nfinit) goto 150

  !  Set the initial conditions for the line search
  !  flsa is the initial value of the line search function
  !  dflsa is its first derivative (if delta(np1) = 1)
  !  alpha is the next reduction in the step-length

  flsa = fls
  dflsa = spgdel - delta(np1)*sum
  if (dflsa .ge. zero) goto 420

  !  Set initial multiplying factor for stepsize
  !  Set initial value of stepsize for output

  alpha = one
  calpha = one
  goto 210

  !  Test whether line search is complete

150 continue
  aux = fls - flsa

  !  Exit line search if function difference is small

  if (aux .le. (cp1*dflsa)) goto 260

  !  Exit if the line search requires ten or more function
  !  evaluations

  if (nfev .ge. (nfinit + 10)) goto 380

  !  Calculate next reduction in the line step assuming a quadratic
  !  fit.

  alpha = max(cp1,cp5*dflsa/(dflsa - aux))

  !  Multiply delta by alpha and calculate the new x

210 continue
  calpha = alpha*calpha

  do i = 1, n
     delta(i) = alpha*delta(i)
     x(i) = xa(i) + delta(i)
  end do

  dflsa = alpha*dflsa

  !  Test nfev against maxfev, call start1 and resume line search

  if (nfev .ge. maxfev) goto 380
  nfev = nfev + 1

  call start1(n,m,x,objf,conf,info)

  if (info .lt. 0) goto 450
  goto 130

  !  Line search is complete. Calculate gradient of Lagrangian
  !  function for use in updating hessian of Lagrangian

260 continue

  call start1(n,m,x,objf,conf,info)
  call start2(n,m,x,fgrd,cnorm,lcnorm,info)

  if (info .lt. 0) goto 450
  do i = 1, n
     glag(i) = fgrd(i)
  end do
  do k = 1, m
     if (vlam(k) .eq. zero) goto 290
     do i = 1, n
        glag(i) = glag(i) - cnorm(i,k)*vlam(k)
     end do
290  continue
  end do
  do k = mp1, mpn
     if (vlam(k) .eq. zero) goto 291
     inx = k - m
     if (ilower(inx) .eq. 0) goto 291
     glag(inx) = glag(inx) - vlam(k)
291  continue
  end do
  do k = mpnpp1, mpnppn
     if (vlam(k) .eq. zero) goto 292
     inx = k - m - np1
     if (iupper(inx) .eq. 0) goto 292
     glag(inx) = glag(inx) + vlam(k)
292  continue
  end do

  !  Calculate gamma and bdelta in order to revise b
  !  Set dg to the scalar product of delta and gamma
  !  Set dbd to the scalar product of delta and bdelta

  dg = zero
  dbd = zero
  do i = 1, n
     gamma(i) = glag(i) - glaga(i)
     bdelta(i) = zero
     do j = 1, n
        bdelta(i) = bdelta(i) + b(i,j)*delta(j)
     end do
     dg = dg + delta(i)*gamma(i)
     dbd = dbd + delta(i)*bdelta(i)
  end do

  !  Calculate the vector eta for the b-f-g-s formula
  !  replace dg by the scalar product of delta and eta

  aux = cp2*dbd
  theta = one
  if (dg .lt. aux) theta = (dbd - aux)/(dbd - dg)
  thcomp = one - theta
  do i = 1, n
     eta(i) = theta*gamma(i) + thcomp*bdelta(i)
  end do
  if (dg .lt. aux) dg = aux

  !  Revise the matrix b and begin new iteration

  do i = 1, n
     aux = bdelta(i)/dbd
     auxa = eta(i)/dg
     do j = i, n
        b(i,j) = b(i,j) - aux*bdelta(j) + auxa*eta(j)
        b(j,i) = b(i,j)
     end do
  end do
  goto 40

  !  Error returns. restore previous solution

380 continue
  do i = 1, n
     x(i) = xa(i)
  end do
  if (nfev .ge. maxfev) goto 400
  nfev = nfev + 1

  call start1(n,m,x,objf,conf,info)

  if (info .lt. 0) goto 450
  goto 410

  !  Error return because there have been maxfev calls of start1

400 continue
  info = 2
  goto 450

  !  Error return because line search required 10 calls of start1

410 continue
  info = 3
  goto 450

  !  Error return because uphill search direction was calculated

420 continue
  info = 4

450 continue

  return
end SUBROUTINE VMCON1
