!  $Id:: pulse.f90 258 2014-04-24 12:28:55Z pknight                     $
! !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!

module pulse_module

  !+ad_name  pulse_module
  !+ad_summ  Module containing pulsed reactor device routines
  !+ad_type  Module
  !+ad_auth  P J Knight, CCFE, Culham Science Centre
  !+ad_cont  pulse
  !+ad_cont  thrmal
  !+ad_cont  tohswg
  !+ad_cont  burn
  !+ad_args  N/A
  !+ad_desc  This module contains routines for calculating the
  !+ad_desc  parameters of a pulsed fusion power plant.
  !+ad_prob  None
  !+ad_call  build_variables
  !+ad_call  constants
  !+ad_call  constraint_variables
  !+ad_call  current_drive_variables
  !+ad_call  fwbs_variables
  !+ad_call  pf_power_variables
  !+ad_call  pfcoil_variables
  !+ad_call  physics_variables
  !+ad_call  process_output
  !+ad_call  pulse_variables
  !+ad_call  times_variables
  !+ad_hist  05/11/12 PJK Initial version of module
  !+ad_stat  Okay
  !+ad_docs  AEA FUS 251: A User's Guide to the PROCESS Systems Code
  !
  ! !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!

  use build_variables
  use constants
  use constraint_variables
  use current_drive_variables
  use fwbs_variables
  use pf_power_variables
  use pfcoil_variables
  use physics_variables
  use process_output
  use pulse_variables
  use times_variables

  implicit none

  private
  public :: pulse

contains

  ! !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!

  subroutine pulse(outfile,iprint)

    !+ad_name  pulse
    !+ad_summ  Caller for the pulsed reactor model
    !+ad_type  Subroutine
    !+ad_auth  C A Gardner, AEA Fusion, Culham Laboratory
    !+ad_auth  P J Knight, CCFE, Culham Science Centre
    !+ad_cont  None
    !+ad_args  outfile : input integer : output file unit
    !+ad_args  iprint : input integer : switch for writing to output file (1=yes)
    !+ad_desc  This calls the routines relevant to a pulsed reactor scenario.
    !+ad_prob  None
    !+ad_call  thrmal
    !+ad_call  tohswg
    !+ad_call  burn
    !+ad_call  25/11/93 CAG/PJK Implementation within PROCESS
    !+ad_call  10/06/96 PJK Commented out call to STARTUP
    !+ad_hist  01/10/12 PJK Initial F90 version
    !+ad_hist  15/10/12 PJK Added physics_variables
    !+ad_hist  18/10/12 PJK Added fwbs_variables
    !+ad_hist  30/10/12 PJK Added times_variables
    !+ad_hist  30/10/12 PJK Added build_variables
    !+ad_hist  05/11/12 PJK Added pulse_variables
    !+ad_hist  27/06/13 PJK Comment change
    !+ad_stat  Okay
    !+ad_docs  Work File Notes F/MPE/MOD/CAG/PROCESS/PULSE
    !+ad_docs  AEA FUS 251: A User's Guide to the PROCESS Systems Code
    !
    ! !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!

    implicit none

    !  Arguments

    integer, intent(in) :: outfile,iprint

    !  Local variables

    ! !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!

    !  Thermal cycling package

    call thrmal(outfile,iprint)

    !  Evaluate minimum plasma current ramp-up time

    call tohswg(outfile,iprint)

    !  Burn time calculation

    call burn(outfile,iprint)

  end subroutine pulse

  ! !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!

  subroutine thrmal(outfile,iprint)

    !+ad_name  thrmal
    !+ad_summ  Calculates the thermal and mechanical stresses induced
    !+ad_summ  in the first wall for the case of a pulsed reactor
    !+ad_type  Subroutine
    !+ad_auth  C A Gardner, AEA Fusion, Culham Laboratory
    !+ad_auth  P J Knight, CCFE, Culham Science Centre
    !+ad_cont  alpha
    !+ad_cont  costrm
    !+ad_cont  cycles
    !+ad_cont  eyung
    !+ad_cont  smt
    !+ad_cont  tk
    !+ad_cont  yield
    !+ad_args  outfile : input integer : output file unit
    !+ad_args  iprint : input integer : switch for writing to output file (1=yes)
    !+ad_desc  This routine calculates the thermal and mechanical stresses
    !+ad_desc  induced in the first wall for the case of a pulsed reactor.
    !+ad_desc  <P>It is assumed that the first wall is comprised from axisymmetric
    !+ad_desc  hollow cylindrical tubes which are packed one against the other in
    !+ad_desc  the poloidal direction.
    !+ad_desc  <P>The equivalent strains are calculated from the stresses
    !+ad_desc  with which a fatigue lifetime is estimated using the fatigue
    !+ad_desc  design curves generated by the ASME code.
    !+ad_desc  Presently the first wall material is assumed to be stainless
    !+ad_desc  steel.
    !+ad_desc  <P>The first wall thickness is constrained to lie between a lower
    !+ad_desc  limit that ensures that the first wall can withstand the internal
    !+ad_desc  coolant pressure, and an upper limit governed by the peak
    !+ad_desc  temperature and the neutron fluence.
    !+ad_prob  None
    !+ad_call  alpha
    !+ad_call  costrm
    !+ad_call  cycles
    !+ad_call  eyung
    !+ad_call  oblnkl
    !+ad_call  ocmmnt
    !+ad_call  oheadr
    !+ad_call  ovarre
    !+ad_call  ovarrf
    !+ad_call  smt
    !+ad_call  tk
    !+ad_call  yield
    !+ad_hist  25/11/93 PJK Incorporation into PROCESS
    !+ad_hist  16/06/94 PJK Added error warning
    !+ad_hist  07/12/95 PJK Added D-He3 calculations
    !+ad_hist  10/06/96 PJK Moved first wall area calculation into RADIALB
    !+ad_hist  13/02/97 PJK Modified first wall lifetime calculation
    !+ad_hist  25/05/06 PJK Added SAVE statement
    !+ad_hist  01/10/12 PJK Initial F90 version
    !+ad_hist  09/10/12 PJK Modified to use new process_output module
    !+ad_hist  15/10/12 PJK Added physics_variables
    !+ad_hist  16/10/12 PJK Added constants
    !+ad_hist  18/10/12 PJK Added fwbs_variables
    !+ad_hist  30/10/12 PJK Added build_variables
    !+ad_hist  31/10/12 PJK Added constraint_variables
    !+ad_hist  15/04/13 PJK Changed approximation for first wall nuclear heating
    !+ad_hist  24/04/14 PJK Calculation always proceeds irrespective of iprint
    !+ad_stat  Okay
    !+ad_docs  Work File Notes F/MPE/MOD/CAG/PROCESS/PULSE
    !+ad_docs  AEA FUS 251: A User's Guide to the PROCESS Systems Code
    !
    ! !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!

    implicit none

    !  Arguments

    integer, intent(in) :: outfile,iprint

    !  Local variables

    real(kind(1.0D0)) :: boa,decay,eptbar,eptrc,eptthc,eptzc,fboa,fwlifs, &
         fwndep,fwvol,masflx,mindif,min01,min02,min03,poissn,rad, &
         sigpm,sigpr,sigpth,sgpthn,sigpz,sigtr,sigtri,sigtrs,sgtshs, &
         sigtth,sgtthi,sgtths,temp,tfwav,tmax,tmpdif,tmthet,torlen,tpeakr
    real(kind(1.0D0)), dimension(3) :: delr,delth,delz,eptr,eptth, &
         eptz,equiv,mincyc,sigtz
    real(kind(1.0D0)), save :: flnce,hcoeff,qpp,qppp,tav,tmprop,vel

    integer :: k,n
    integer, dimension(3) :: ncyc

    real(kind(1.0D0)), dimension(8) :: cc,dd
    common/tmpcff/cc,dd

    ! !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!

    !  delr(3)  : radial strain range
    !  delth(3) : azimuthal strain range
    !  delz(3)  : axial strain range
    !  eptbar   : average thermal strain
    !  eptr(3)  : radial strain component from total stress
    !  eptrc    : radial strain component from mechanical stress
    !  eptth(3) : azimuthal strain component from total stress
    !  eptthc   : azimuthal strain component from mechanical stress
    !  eptz(3)  : axial strain component from total stress
    !  eptzc    : axial strain component from mechanical stress
    !  equiv(3) : Von Mises equivalent strain
    !  flnce    : neutron fluence
    !  fwndep   : neutron power deposition (W)
    !  fwvol    : first wall volume (m**3)
    !  hcoeff   : heat transfer coefficient (W/m**2/K)
    !  masflx   : coolant max flux (Kg/m**2/s)
    !  ncyc(3)  : number of allowable cycles
    !  poissn   : Poisson's ratio 
    !  mincyc(3): minimum allowable cycle length
    !  fwlifs   : first wall lifetime (s)
    !  qpp      : surface heat flux incident on first wall (W/m**2)
    !  qppp     : volumetric heat flux in first wall material (W/m**3)
    !  sgpthn   : primary stress in thin shell model (Pa)
    !  sgtshs   : shear stress component from surface heat flux (Pa)
    !  sgtthi   : azimuthal stress component from internal heat flux (Pa)
    !  sgtths   : azimuthal stress component from surface heat flux (Pa)
    !  sigpm    : equivalent mechanical stress (Pa)
    !  sigpr    : radial mechanical stress (Pa)
    !  sigpth   : azimuthal mechanical stress (Pa)
    !  sigpz    : axial mechanical stress (Pa)
    !  sigtr    : radial stress component from total heat flux (Pa)
    !  sigtri   : radial stress component from internal heat flux (Pa)
    !  sigtrs   : radial stress component from surface heat flux (Pa)
    !  sigtth   : azimuthal stress component from total heat flux (Pa)
    !  sigtz(3) : axial stress component from total heat flux (Pa)
    !  tav      : average first wall temperature (C)
    !  tmthet   : azimuthal temperature term (C)
    !  torlen   : section of toroidal extent of first wall elements (m)
    !  tpeakr   : peak temperature at a given radius (C)
    !  vel      : coolant velocity (m/s)

    !  Check to see if the pulsed reactor option is selected

    if (lpulse /= 1) return

    !  We will assume that 2*bfw is the average of the inboard and
    !  outboard first wall thicknesses (fwith and fwoth respectively).

    bfw = (fwith+fwoth)/4.0D0
    boa = bfw/afw

    !  Poisson's ratio

    poissn = 0.27D0

    !  Start of iteration of bfw - code returns to here
    !  if bfw has been altered to lie within constraints

    n = 0
    bfw_iteration: do ; n = n+1

       if (n > 100) then
          write(*,*) 'Warning in routine THRMAL:'
          write(*,*) 'Optimisation has failed within 100 iterations.'
          write(*,*) 'Possible NaN problems...'
          write(*,*) 'PROCESS continuing.'
          !return
          exit bfw_iteration
       end if

       !  Check to see if inner radius is greater than outer radius

       if (afw >= bfw) then
          write(*,*) 'Error in routine PULSE:'
          write(*,*) 'afw >= bfw'
          write(*,*) 'PROCESS stopping.'
          stop
       end if

       !  First wall lifetime in seconds

       fwlifs = 3.1536D7*fwlife

       !  First wall properties

       !  Heating power due to neutron deposition (W)
       !  The previous method assumed that the neutrons lost via fhole
       !  actually stop in the first wall, so are not lost at all...
       !fwndep = (pneut*vol)*fhole*1.0D6

       !  New method based on that for nuclear heating in the blanket
       !  in fwbs.f90. A neutron decay length of 0.075m is assumed, and
       !  the TART centrepost term is ignored.

       decay = 0.075D0 / (1.0D0 - afw*afw/(bfw*bfw))  !  a2/b2 = coolant fraction

       fwndep = (1.0D6*pneut*vol) * (1.0D0-fhole) * &
            ( 1.0D0 - exp( -(2.0D0*bfw)/decay) )

       !  Assume that the first wall volume is equal to its surface area
       !  multiplied by the external diameter of the hollow cylindrical
       !  tubes that make up the first wall.

       fwvol = fwarea*(2.0D0*bfw)

       !  Heat fluxes
       !  -----------
       !  qppp represents the heat generation in the first wall due to
       !  the neutron flux deposited in the material.
       !  qpp represents the heat flux incident on the first wall
       !  surface from the charge particle and electromagnetic radiation
       !  flux.

       qppp = fwndep/fwvol

       qpp = (palp+pcharge)*vol*1.0D6 / fwarea

       !  Heat transfer coefficient
       !  -------------------------
       !  The coolant is water and the heat transfer coefficient is 
       !  calculated on the inboard side of the first wall.
       !  specific heat capacity: 4190 (J/K/kg)
       !  mass density: 720 (kg/m**3)
       !  coolant velocity limit: 5 (m/s)
       !  fluid viscosity: 1.61D-4 (kg/m/s)
       !  viscosity at wall temperature: 1.39D-4 (kg/m/s)
       !  thermal conductivity: 0.69 (W/m/K)
       !  If the velocity limit is exceeded then the coolant velocity
       !  is set to the velocity limit and the temperature rise is
       !  calculated based upon this fixed velocity.
       !
       !  A toroidal length of 3 metres is assumed rather than
       !  the whole toroidal circumference as we were
       !  experiencing very high coolant temperature rises.
       !  This method is okay as it can be envisaged that the
       !  toroidal parts of the coolant pipes occur in 3 metre
       !  sections around the torus, instead of one long
       !  toroidal pipe.

       torlen = 3.0D0
       masflx = torlen*(qppp*(bfw**2-afw**2) + 2.0D0*qpp*bfw) &
            /afw**2 /4190.0D0 /tmprse
       vel = masflx/720.0D0

       if (vel >= 5.0D0) then
          vel = 5.0D0
          masflx = vel*720.0D0
          tmprse = torlen*(qppp*(bfw**2-afw**2) + 2.0D0*qpp*bfw) &
               /afw**2 /4190.0D0 /masflx
       end if

       hcoeff = 0.023D0*(0.69D0/2.0D0/afw)*(masflx*2.0D0*afw &
            /1.61D-4)**0.8D0 * (1.61D-4*4190.0D0/0.69D0)**0.4D0 &
            *(1.61D-4/1.39D-4)**0.14D0

       !  Average temperature
       !  -------------------
       !  There is a problem here because the expression for the
       !  average temperature in the first wall contains a term
       !  which involves the thermal conductivity which is in itself
       !  temperature dependent. How do we resolve this problem?
       !  Firstly we define a temperature range where the lower
       !  bound is defined to be the temperature on the inner
       !  wall (in contact with the coolant) and therefore
       !  equal to the bulk coolant temperature, and the
       !  upper bound is taken to be 800 degrees Celsius.
       !  Next we iterate over this range so that at each 
       !  step the average temperature can be calculated together 
       !  with the difference between the average temperature and 
       !  the iterated temperature. The average temperature
       !  at which this difference is minimised is taken 
       !  as the correct average temperature in the first wall.

       mindif = 1.0D30

       do k = 1,51

          temp = bctmp + (800.0D0-bctmp) * dble(k-1)/50.0D0
          tfwav = bfw/tk(temp)*(qpp/pi + qppp*bfw/2.0D0)*(bfw**2/ &
               (bfw**2-afw**2)*log(bfw/afw)-0.5D0) &
               - qppp/4.0D0/tk(temp)*((bfw**2-afw**2)/2.0D0) &
               + (pi*(bfw**2-afw**2)*qppp + 2.0D0*bfw*qpp)/ &
               (2.0D0*pi*afw*hcoeff) + bctmp
          tmpdif = abs(tfwav-temp)

          if (tmpdif <= mindif) then
             mindif = tmpdif
             tav = tfwav
             tmprop = temp
          end if

       end do

       !  Average thermal strain (integrated from 20 Celsius to 'tav')

       eptbar = 10.28D-6/1.093D0 * (tav**(1.093D0) - 20.0D0**(1.093D0))

       !  Limits on the first wall thickness
       !  ----------------------------------
       !  The upper limit on the first wall thickness is
       !  derived from the swelling limit which for stainless
       !  steel limits the temperature to 500 Celsius. This
       !  temperature limit is equivalent to limiting the neutron
       !  fluence to 5 MW yrs/m**2. The fluence is the product
       !  of the neutron wall loading (qppp*fwvol/fwarea) and
       !  the wall lifetime. This fluence limit is a conservative
       !  one, with the upper bound on the fluence set by the value
       !  10 MW-yr/m2
       !+**PJK 13/02/97 abktflnc should replace the fixed value 10 MW-yr/m2

       flnce = qppp*fwvol/fwarea * fwlife/1.0D6

       tmax = -1.0D30

       do k = 1,11

          rad = afw + (bfw-afw)*(dble(k-1)/10.0D0)

          call costrm(0.0D0,rad,qpp,hcoeff,tmprop,tmthet)

          !  Peak temperature occurs at (r,theta) = (rad,0)

          tpeak = bfw/tk(tmprop) * (qpp/pi + qppp*bfw/2.0D0) &
               * log(rad/afw) - qppp/4.0D0/tk(tmprop)*(rad**2-afw**2) &
               + (pi*(bfw**2-afw**2)*qppp + 2.0D0*bfw*qpp) / &
               (2.0D0*pi*afw*hcoeff) + bctmp + tmthet

          if ((tpeak > 500.0D0).or.(flnce > 10.0D0)) then
             !  Swelling limit exceeded

             fwlife = 10.0D0*1.0D6*fwarea/qppp/fwvol
             fwlifs = 3.1536D+7*fwlife

             !  fboa is chosen such that fboa**100 * (bfw/afw) = 1.001,
             !  i.e. after 100 iterations bfw is still just larger than afw.

             fboa = (1.001D0/boa)**0.01D0

             bfw = bfw*fboa
             if ((bfw/afw) <= 1.001D0) then
                write(*,*) 'Warning in routine THRMAL:'
                write(*,*) 'Swelling limit exceeded, and'
                write(*,*) 'optimisation is failing to find a'
                write(*,*) 'suitable first wall thickness...'
                write(*,*) 'PROCESS continuing.'
                exit bfw_iteration
             else
                cycle bfw_iteration
             end if
          end if

          !  Find maximum temperature

          tmax = max(tpeak,tmax)

       end do

       tpeak = tmax

       !  The lower limit on the first wall thickness is
       !  derived from the constraint that the first wall
       !  must possess the ability to withstand the internal
       !  coolant pressure. The limit is written as
       !  hmin = p*(afw+bfw)/2/Smt

       sgpthn = (coolp*(afw+bfw)/2.0D0)/(bfw-afw)

       if (sgpthn <= smt(tpeak,fwlifs)) then
          exit bfw_iteration
       else
          !  First wall too thin
          !  Keep afw fixed and alter bfw so that the lower limit
          !  is satisfied

          bfw = afw * (smt(tpeak,fwlifs) + coolp/2.0D0) / &
               (smt(tpeak,fwlifs) - coolp/2.0D0)
       end if

    end do bfw_iteration

    !  Reset inboard and outboard first wall thicknesses

    fwith = 2.0D0*bfw
    fwoth = 2.0D0*bfw

    !  First wall coolant fraction

    fwclfr = (afw/bfw)**2

    min01 = 0.0D0
    min02 = 0.0D0
    min03 = 0.0D0

    !  Iterate from the inner first wall radius to the outer
    !  first wall radius

    do k = 1,11

       !  Peak temperature at this radius

       rad = afw + (bfw-afw)*(dble(k-1)/10.0D0)

       call costrm(0.0D0,rad,qpp,hcoeff,tmprop,tmthet)

       !  Peak temperature occurs at (r,theta) = (rad,0)

       tpeakr = bfw/tk(tmprop) * (qpp/pi + qppp*bfw/2.0D0) &
            *log(rad/afw) - qppp/4.0D0/tk(tmprop) * (rad**2-afw**2) &
            + (pi*(bfw**2 - afw**2)*qppp + 2.0D0*bfw*qpp) &
            / (2.0D0*pi*afw*hcoeff) + bctmp + tmthet

       !  Pressure, or mechanical stresses

       sigpr = -coolp*(afw**2/(bfw**2-afw**2))*(bfw**2/rad**2 - 1.0D0)
       sigpth = coolp*(afw**2/(bfw**2-afw**2))*(bfw**2/rad**2 + 1.0D0)
       sigpz =  coolp*(afw**2/(bfw**2-afw**2))

       !  Equivalent mechanical stress

       sigpm = sqrt(0.5D0*((sigpr-sigpth)**2 + (sigpr-sigpz)**2 &
            + (sigpth-sigpz)**2))

       !  Thermal stresses
       !  ----------------

       !  Thermal stress components from surface heat flux (i.e. qpp)

       sigtrs = alpha(tmprop)*eyung(tmprop)/2.0D0/(1.0D0-poissn) &
            * ( rad/(afw**2 + bfw**2)*(1.0D0 - afw**2/rad**2) &
            * (1.0D0 - bfw**2/rad**2)*cc(1) * cos(0.0D0) &
            + qpp*bfw/pi/tk(tmprop)/rad**2*(bfw**2*((rad**2 - afw**2) &
            / (bfw**2 - afw**2))*log(bfw/afw) - rad**2*log(rad/afw)) )
       sgtths = alpha(tmprop)*eyung(tmprop)/2.0D0/(1.0D0-poissn) &
            * ( rad/(afw**2 + bfw**2)*(3.0D0-(afw**2 + bfw**2)/rad**2 &
            - (afw**2*bfw**2)/rad**4) * cc(1)*cos(0.0D0) &
            + qpp*bfw/pi/tk(tmprop)/rad**2*(bfw**2*((rad**2 + afw**2) &
            / (bfw**2 - afw**2))*log(bfw/afw) - rad**2 &
            - rad**2*log(rad/afw)) )
       sgtshs = alpha(tmprop)*eyung(tmprop)/2.0D0/(1.0D0-poissn) &
            * ( rad/(afw**2 + bfw**2)*(1.0D0 - afw**2/rad**2) &
            * (1.0D0 - bfw**2/rad**2)*cc(1) * sin(0.0D0) )

       !  Thermal stress components from internal heat flux (i.e. qppp)

       sigtri = alpha(tmprop)*eyung(tmprop)*qppp/4.0D0/tk(tmprop) / &
            (1.0D0-poissn)/rad**2 * ( &
            (rad**2 - afw**2)/(bfw**2 - afw**2) &
            * bfw**4*log(bfw/afw) - (bfw**2 + afw**2)*rad**2/4.0D0 &
            + afw**2*bfw**2/4.0D0 - bfw**2*rad**2*log(rad/afw) &
            + rad**4/4.0D0 )
       sgtthi = alpha(tmprop)*eyung(tmprop)*qppp/4.0D0/tk(tmprop) / &
            (1.0D0-poissn)/rad**2 * ( &
            (rad**2 + afw**2)/(bfw**2 - afw**2) &
            * bfw**4*log(bfw/afw) - (5.0D0*bfw**2 + afw**2) &
            * rad**2/4.0D0 - afw**2*bfw**2/4.0D0 + 3.0d0*rad**4/4.0D0 &
            - bfw**2*rad**2*log(rad/afw) )

       !  Total thermal stresses

       sigtr = sigtrs + sigtri
       sigtth = sgtths + sgtthi

       !  Axial stresses, three different models are used:
       !  (1) total axial restraint and no bending
       !  (2) no axial restraints and no bending
       !  (3) no axial restraints and bending

       sigtz(1) = poissn*(sigtr + sigtth) &
            - eyung(tmprop)*(eptbar + alpha(tav)*(tpeakr-tav))
       sigtz(2) = poissn*(sigtr + sigtth) &
            - eyung(tmprop)*(alpha(tav)*(tpeakr-tav))
       sigtz(3) = sigtz(2) + eyung(tmprop)*rad*cos(0.0D0)*alpha(tav) &
            * (2.0D0*cc(1)/(afw**2 + bfw**2) + dd(1))

       !  Strains

       eptr(1) = 1.0D0/eyung(tmprop) * ( sigtr + sigpr &
            - poissn*(sigtth + sigpth + sigtz(1) + sigpz) )
       eptth(1) = 1.0D0/eyung(tmprop) * ( sigtth + sigpth &
            - poissn*(sigtr + sigpr + sigtz(1) + sigpz) )
       eptz(1) = 1.0D0/eyung(tmprop) * ( sigtz(1) + sigpz &
            - poissn*(sigtr + sigpr + sigtth + sigpth) )
       eptr(2) = 1.0D0/eyung(tmprop) * ( sigtr + sigpr &
            - poissn*(sigtth + sigpth + sigtz(2) + sigpz) )
       eptth(2) = 1.0D0/eyung(tmprop) * ( sigtth + sigpth &
            - poissn*(sigtr + sigpr + sigtz(2) + sigpz) )
       eptz(2) = 1.0D0/eyung(tmprop) * ( sigtz(2) + sigpz &
            - poissn*(sigtr + sigpr + sigtth + sigpth) )
       eptr(3) = 1.0D0/eyung(tmprop) * ( sigtr + sigpr &
            - poissn*(sigtth + sigpth + sigtz(3) + sigpz) )
       eptth(3) = 1.0D0/eyung(tmprop) * ( sigtth + sigpth &
            - poissn*(sigtr + sigpr + sigtz(3) + sigpz) )
       eptz(3) = 1.0D0/eyung(tmprop) * ( sigtz(3) + sigpz &
            - poissn*(sigtr + sigpr + sigtth + sigpth) )

       !  For the time being I will take the temperature during rejuvenation
       !  to be T(a,0) during burn and assume the accompanying strains are 
       !  mechanical in origin

       eptrc = 1.0D0/eyung(tmprop) * (sigpr - poissn*(sigpth + sigpz))
       eptthc = 1.0D0/eyung(tmprop) * (sigpth - poissn*(sigpr + sigpz))
       eptzc = 1.0D0/eyung(tmprop) * (sigpz - poissn*(sigpth + sigpr))

       !  Calculate strain ranges

       delr(1) = eptr(1) - eptrc
       delr(2) = eptr(2) - eptrc
       delr(3) = eptr(3) - eptrc
       delth(1) = eptth(1) - eptthc
       delth(2) = eptth(2) - eptthc
       delth(3) = eptth(3) - eptthc
       delz(1) = eptz(1) - eptzc
       delz(2) = eptz(2) - eptzc
       delz(3) = eptz(3) - eptzc

       !  Calculate Von Mises equivalent strain range

       equiv(1) = 1.0D0/3.0D0 * sqrt( 2.0D0*((delr(1) - delth(1))**2 &
            + (delth(1) - delz(1))**2 + (delz(1) - delr(1))**2) )
       equiv(2) = 1.0D0/3.0D0 * sqrt( 2.0D0*((delr(2) - delth(2))**2 &
            + (delth(2) - delz(2))**2 + (delz(2) - delr(2))**2) )
       equiv(3) = 1.0D0/3.0D0 * sqrt( 2.0D0*((delr(3) - delth(3))**2 &
            + (delth(3) - delz(3))**2 + (delz(3) - delr(3))**2) )

       !  Find allowable cycles

       call cycles(equiv,tpeakr,ncyc)

       !  Calculate minimum allowable cycle lengths

       mincyc(1) = fwlife / dble(ncyc(1))
       mincyc(2) = fwlife / dble(ncyc(2))
       mincyc(3) = fwlife / dble(ncyc(3))

       !  Overall minimum allowable cycle length for each model
       !  (we use the highest value to set correctly the limit on tcycle)

       min01 = max(min01, mincyc(1))
       min02 = max(min02, mincyc(2))
       min03 = max(min03, mincyc(3))

    end do

    !  Evaluate minimum cycle time using chosen model

    if (itcycl == 1) then
       tcycmn = min01
    else if (itcycl == 2) then
       tcycmn = min02
    else
       tcycmn = min03
    end if

    !  Convert from years to seconds

    tcycmn = tcycmn * 3.1536D7

    !  Written output

    if (iprint == 1) then

       call oheadr(outfile,'Pulsed Reactor')

       call ocmmnt(outfile,'Thermal cycling considerations for first wall:')
       call oblnkl(outfile)

       call ovarrf(outfile,'Inner radius of first wall tubes (m)', &
            '(afw)',afw)
       call ovarrf(outfile,'Outer radius of first wall tubes (m)', &
            '(bfw)',bfw)
       call ovarre(outfile,'Bulk coolant temperature (C)','(bctmp)',bctmp)
       call ovarre(outfile,'Coolant internal pressure (Pa)','(coolp)',coolp)
       call ovarre(outfile,'Neutron fluence (MW-yr/m2)','(flnce)',flnce)
       call ovarre(outfile,'Neutron flux deposited in 1st wall (W/m3)', &
            '(qppp)',qppp)
       call ovarre(outfile,'Heat flux incident on first wall (W/m2)', &
            '(qpp)',qpp)
       call ovarre(outfile,'Heat transfer coefficient (W/m2/K)', &
            '(hcoeff)',hcoeff)

       if (vel == 5.0D0) then
          call ocmmnt(outfile, &
               'Calculation based upon fixed coolant velocity')
       else
          call ocmmnt(outfile, &
               'Calculation based upon fixed temperature rise')
       end if
       call ovarre(outfile,'Coolant velocity (m/s)','(vel)',vel)
       call ovarre(outfile,'Coolant temperature rise (K)','(tmprse)',tmprse)
       call ovarre(outfile,'Peak temperature in first wall (C)', &
            '(tpeak)',tpeak)
       call ovarre(outfile,'Average first wall temperature (C)','(tav)',tav)
       call ovarre(outfile,'Material property temperature (C)', &
            '(tmprop)',tmprop)
       call ovarre(outfile,'Youngs modulus','(eyung)',eyung(tmprop))
       call ovarre(outfile,'Thermal expansion coefficient (/K)', &
            '(alpha)',alpha(tmprop))
       call ovarre(outfile,'Thermal conductivity (W/m/K)','(tk)',tk(tmprop))
       call ovarre(outfile,'First wall lifetime (years)','(fwlife)',fwlife)
       call ovarre(outfile,'Minimum cycle time (s)','(tcycmn)',tcycmn)

    end if

  contains

    ! !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!

    subroutine costrm(angle,rad,qpp,hcoeff,tmprop,tmthet)

      !+ad_name  costrm
      !+ad_summ  Calculates cosine terms in temperature distribution
      !+ad_type  Subroutine
      !+ad_auth  C A Gardner, AEA Fusion, Culham Laboratory
      !+ad_auth  P J Knight, CCFE, Culham Science Centre
      !+ad_cont  None
      !+ad_args  angle  : input real : azimuthal angle (radians)
      !+ad_args  rad    : input real : radial position within first wall tube (m)
      !+ad_args  qpp    : input real : surface heat flux incident on first wall (W/m**2)
      !+ad_args  hcoeff : input real : heat transfer coefficient (W/m**2/K)
      !+ad_args  tmprop : input real : property temperature (C)
      !+ad_args  tmthet : output real : azimuthal temperature term (C)
      !+ad_desc  This routine calculates the cosine terms in the temperature
      !+ad_desc  distribution. These terms are calculated with the material
      !+ad_desc  properties measured at the property temperature.
      !+ad_prob  None
      !+ad_call  tk
      !+ad_hist  25/11/93 PJK Incorporation into PROCESS
      !+ad_hist  01/10/12 PJK Initial F90 version
      !+ad_stat  Okay
      !+ad_docs  Work File Notes F/MPE/MOD/CAG/PROCESS/PULSE
      !+ad_docs  AEA FUS 251: A User's Guide to the PROCESS Systems Code
      !
      ! !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!

      implicit none

      !  Arguments

      real(kind(1.0D0)), intent(in) :: angle,rad,qpp,hcoeff,tmprop
      real(kind(1.0D0)), intent(out) :: tmthet

      !  Local variables
      integer :: i,k

      real(kind(1.0D0)), dimension(8) :: cc,dd
      common/tmpcff/cc,dd

      ! !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!

      !  Lowest order terms

      cc(1) = qpp*afw**2*bfw**2/2.0D0/tk(tmprop) * &
           (tk(tmprop) - hcoeff*afw) / &
           ( tk(tmprop)*(bfw**2 - afw**2) + hcoeff*afw*(afw**2 + bfw**2) )
      dd(1) = qpp*bfw**2/2.0D0/tk(tmprop) * &
           (tk(tmprop) + hcoeff*afw) / &
           ( tk(tmprop)*(bfw**2 - afw**2) + hcoeff*afw*(afw**2 + bfw**2) )

      tmthet = (cc(1)/rad+dd(1)*rad)*cos(angle)

      !  Higher order even terms

      do i = 2,8,2
         k = i/2
         cc(i) = qpp/pi/tk(tmprop)/dble(k) * ( dble((-1)**(k+1)) / &
              ((2.0D0*dble(k))**2 - 1.0D0) ) &
              * ( bfw**(2*k+1)*(2.0D0*dble(k)*tk(tmprop) - hcoeff*afw) ) &
              / ( 2.0D0*dble(k)*tk(tmprop)*((bfw/afw)**(4*k)-1.0D0) &
              + hcoeff*afw*((bfw/afw)**(4*k)+1.0D0) )
         dd(i) = 1.0D0 / ((afw*10.0D0)**(4*k)) * (10.0D0)**(4*k) &
              * (2.0D0*dble(k)*tk(tmprop) + hcoeff*afw) / &
              (2.0D0*dble(k)*tk(tmprop) - hcoeff*afw)*cc(i)

         tmthet = tmthet + (cc(i)/rad**i + dd(i)*rad**i)*cos(dble(i)*angle)
      end do

    end subroutine costrm

    ! !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!

    function eyung(x)

      !+ad_name  eyung
      !+ad_summ  Calculates the Young's modulus of the first wall material
      !+ad_type  Function returning real
      !+ad_auth  C A Gardner, AEA Fusion, Culham Laboratory
      !+ad_auth  P J Knight, CCFE, Culham Science Centre
      !+ad_cont  None
      !+ad_args  x      : input real : property temperature (C)
      !+ad_desc  This routine calculates the Young's modulus of the
      !+ad_desc  first wall material, assumed to be stainless steel.
      !+ad_prob  None
      !+ad_call  None
      !+ad_hist  25/11/93 PJK Incorporation into PROCESS
      !+ad_hist  01/10/12 PJK Initial F90 version
      !+ad_stat  Okay
      !+ad_docs  Work File Notes F/MPE/MOD/CAG/PROCESS/PULSE
      !+ad_docs  AEA FUS 251: A User's Guide to the PROCESS Systems Code
      !
      ! !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!

      implicit none

      real(kind(1.0D0)) :: eyung

      !  Arguments

      real(kind(1.0D0)), intent(in) :: x

      !  Local variables

      ! !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!

      eyung = 465.0D0 * x**(-0.18D0) * 1.0D9

    end function eyung

    ! !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!

    function alpha(x)

      !+ad_name  alpha
      !+ad_summ  Calculates the thermal expansion coefficient of the first wall
      !+ad_type  Function returning real
      !+ad_auth  C A Gardner, AEA Fusion, Culham Laboratory
      !+ad_auth  P J Knight, CCFE, Culham Science Centre
      !+ad_cont  None
      !+ad_args  x      : input real : property temperature (C)
      !+ad_desc  This routine calculates the thermal expansion coefficient
      !+ad_desc  of the first wall material, assumed to be stainless steel.
      !+ad_prob  None
      !+ad_call  None
      !+ad_hist  25/11/93 PJK Incorporation into PROCESS
      !+ad_hist  01/10/12 PJK Initial F90 version
      !+ad_stat  Okay
      !+ad_docs  Work File Notes F/MPE/MOD/CAG/PROCESS/PULSE
      !+ad_docs  AEA FUS 251: A User's Guide to the PROCESS Systems Code
      !
      ! !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!

      implicit none

      real(kind(1.0D0)) :: alpha

      !  Arguments

      real(kind(1.0D0)), intent(in) :: x

      !  Local variables

      ! !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!

      alpha = 10.28D0 * x**0.093D0 * 1.0D-6

    end function alpha

    ! !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!

    function tk(x)

      !+ad_name  tk
      !+ad_summ  Calculates the thermal conductivity of the first wall
      !+ad_type  Function returning real
      !+ad_auth  C A Gardner, AEA Fusion, Culham Laboratory
      !+ad_auth  P J Knight, CCFE, Culham Science Centre
      !+ad_cont  None
      !+ad_args  x      : input real : property temperature (C)
      !+ad_desc  This routine calculates the thermal conductivity of the
      !+ad_desc  first wall. This gives a reasonable fit to 316 stainless steel
      !+ad_desc  for temperatures X between 300 and 800 degrees Celsius.
      !+ad_prob  None
      !+ad_call  None
      !+ad_hist  25/11/93 PJK Incorporation into PROCESS
      !+ad_hist  01/10/12 PJK Initial F90 version
      !+ad_stat  Okay
      !+ad_docs  Work File Notes F/MPE/MOD/CAG/PROCESS/PULSE
      !+ad_docs  AEA FUS 251: A User's Guide to the PROCESS Systems Code
      !
      ! !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!

      implicit none

      real(kind(1.0D0)) :: tk

      !  Arguments

      real(kind(1.0D0)), intent(in) :: x

      !  Local variables

      ! !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!

      tk = 3.78D0 * x**0.28D0

    end function tk

    ! !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!

    function yield(x)

      !+ad_name  yield
      !+ad_summ  Calculates the yield strength of the first wall
      !+ad_type  Function returning real
      !+ad_auth  C A Gardner, AEA Fusion, Culham Laboratory
      !+ad_auth  P J Knight, CCFE, Culham Science Centre
      !+ad_cont  None
      !+ad_args  x      : input real : property temperature (C)
      !+ad_desc  This routine calculates the yield strength of the
      !+ad_desc  first wall, assumed to be made of stainless steel.
      !+ad_prob  None
      !+ad_call  None
      !+ad_hist  25/11/93 PJK Incorporation into PROCESS
      !+ad_hist  01/10/12 PJK Initial F90 version
      !+ad_stat  Okay
      !+ad_docs  Work File Notes F/MPE/MOD/CAG/PROCESS/PULSE
      !+ad_docs  AEA FUS 251: A User's Guide to the PROCESS Systems Code
      !
      ! !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!

      implicit none

      real(kind(1.0D0)) :: yield

      !  Arguments

      real(kind(1.0D0)), intent(in) :: x

      !  Local variables

      ! !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!

      yield = 745.0D0 * x**(-0.31D0) * 1.0D6

    end function yield

    ! !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!

    function smt(x,fwlifs)

      !+ad_name  smt
      !+ad_summ  Calculates the maximum stress intensity for the first wall
      !+ad_type  Function returning real
      !+ad_auth  C A Gardner, AEA Fusion, Culham Laboratory
      !+ad_auth  P J Knight, CCFE, Culham Science Centre
      !+ad_cont  None
      !+ad_args  x      : input real : property temperature (C)
      !+ad_args  fwlifs : input real : first wall lifetime (s)
      !+ad_desc  This routine calculates the maximum stress intensity
      !+ad_desc  in the first wall, from fits via the ASME code.
      !+ad_prob  None
      !+ad_call  None
      !+ad_hist  25/11/93 PJK Incorporation into PROCESS
      !+ad_hist  01/10/12 PJK Initial F90 version
      !+ad_stat  Okay
      !+ad_docs  Work File Notes F/MPE/MOD/CAG/PROCESS/PULSE
      !+ad_docs  AEA FUS 251: A User's Guide to the PROCESS Systems Code
      !
      ! !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!

      implicit none

      real(kind(1.0D0)) :: smt

      !  Arguments

      real(kind(1.0D0)), intent(in) :: x,fwlifs

      !  Local variables

      real(kind(1.0D0)) :: smt400,smt500,smt600,lnpwr

      ! !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!

      smt400 = 109.0D0  !  smt at <= 400 degrees Celsius
      smt500 = 107.0D0  !  smt at 500 degrees Celsius
      smt600 = 102.0D0  !  smt at 600 degrees Celsius

      !  If x <= 400 smt = 109.
      !  If x <= 500 smt = smt400+(x-400)/100**smt500-smt400 
      !  (simple first order Taylor expansion).

      if (fwlifs >= 3000.0D0) then
         lnpwr = log(fwlifs)
         smt600 = -0.8139765D0*lnpwr**2 + 6.2849D0*lnpwr + 99.147D0
      end if

      !  Linear interpolation used within range 400 deg C to 600 deg C

      if (x <= 400.0D0) then
         smt = smt400
      else if (x <= 500.0D0) then
         smt = smt400 + (x-400.0D0)/100.0D0*(smt500-smt400)
      else if (x <= 600.0D0) then
         smt = smt500 + (x-500.0D0)/100.0D0*(smt600-smt500)
      else
         write(*,*) 'Error in routine SMT:'
         write(*,*) 'No reliable data for SMT stress for temperatures'
         write(*,*) 'exceeding 600 degrees Celsius'
         write(*,*) 'PROCESS stopping.'
         stop
      end if

      smt = smt*1.0D6

    end function smt

    ! !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!

    subroutine cycles(equiv,tpeak,ncyc)

      !+ad_name  cycles
      !+ad_summ  Calculates the number of allowable pulse cycles
      !+ad_type  Subroutine
      !+ad_auth  C A Gardner, AEA Fusion, Culham Laboratory
      !+ad_auth  P J Knight, CCFE, Culham Science Centre
      !+ad_cont  None
      !+ad_args  equiv(3) : input real array     : Von Mises equivalent strain
      !+ad_args  tpeak    : input real           : peak temperature (C)
      !+ad_args  ncyc(3)  : output integer array : number of allowable cycles
      !+ad_desc  This routine calculates the number of allowable cycles
      !+ad_desc  for a pulsed reactor from a fit of the ASME fatigue
      !+ad_desc  design data for the first wall.
      !+ad_prob  Uncommenting the initial tpeak test causes code output
      !+ad_prob  to change inexplicably...
      !+ad_call  None
      !+ad_hist  25/11/93 PJK Incorporation into PROCESS
      !+ad_hist  01/10/12 PJK Initial F90 version
      !+ad_stat  Okay
      !+ad_docs  Methods of first wall structural analysis ...,
      !+ad_docc  R.J. LeClaire, PFC/RR-84-9
      !+ad_docs  Work File Notes F/MPE/MOD/CAG/PROCESS/PULSE
      !+ad_docs  AEA FUS 251: A User's Guide to the PROCESS Systems Code
      !
      ! !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!

      implicit none

      !  Arguments

      real(kind(1.0D0)), dimension(3), intent(in) :: equiv
      real(kind(1.0D0)), intent(in) :: tpeak
      integer, dimension(3), intent(out) :: ncyc

      !  Local variables

      real(kind(1.0D0)) :: logstr,lgn426,lgn454,lgn482,lgn510,lgn649,logn
      real(kind(1.0D0)), dimension(5) :: bsqd
      integer :: k

      ! !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!

      !  Uncommenting this if-clause causes change to output!
      !if (tpeak > 649.0D0) then
      !   write(*,*) 'Error in routine CYCLES:'
      !   write(*,*) 'Fatigue data unreliable for T > 649 deg C'
      !   write(*,*) 'PROCESS stopping.'
      !   stop
      !end if

      !  logstr  : logarithm of equivalent strain
      !  lgnXXX  : logarithm of number of cycles at XXX Celsius
      !  logn    : logarithm of number of cycles at arbitrary temperature
      !  bsqd(5) : fitting coefficients

      do k = 1,3

         logstr = log(equiv(k))
         lgn426 = (logstr + 3.7587178D0) / (-0.198105441D0)
         lgn454 = (logstr + 4.2563621D0) / (-0.183711238D0)
         lgn482 = (logstr + 4.6637048D0) / (-0.17626645D0)
         lgn510 = (logstr + 5.1613625D0) / (-0.16112635D0)
         lgn649 = (logstr + 5.691763D0)  / (-0.14084195D0)

         bsqd(1) = (8.763D-3)**2 - 4.0D0*4.548D-4*(0.046D0-equiv(k))
         bsqd(2) = (4.941D-3)**2 - 4.0D0*2.525D-4*(0.02675D0-equiv(k))
         bsqd(3) = (2.537D-3)**2 - 4.0D0*1.2564D-4*(0.01459D0-equiv(k))
         bsqd(4) = (1.113D-3)**2 - 4.0D0*5.199D-5*(7.3355D-3-equiv(k))
         bsqd(5) = (6.558D-4)**2 - 4.0D0*3.09D-5*(4.3448D-3-equiv(k))

         bsqd(:) = max(bsqd(:), 0.0D0)

         !  This piece seems to be approximating the fatigue design curve by
         !  a quadratic - rather odd method...

         if (equiv(k) > 0.00376D0) &
              lgn426 = (8.763D-3 - sqrt(bsqd(1))) / (2.0D0*4.548D-4)
         if (equiv(k) > 0.00261D0) &
              lgn454 = (4.941D-3 - sqrt(bsqd(2))) / (2.0D0*2.525D-4)
         if (equiv(k) > 0.00186D0) &
              lgn482 = (2.537D-3 - sqrt(bsqd(3))) / (2.0D0*1.2564D-4)
         if (equiv(k) > 0.0013D0) &
              lgn510 = (1.133D-3 - sqrt(bsqd(4))) / (2.0D0*5.199D-5)
         if (equiv(k) > 0.000922D0)  &
              lgn649 = (6.558D-4 - sqrt(bsqd(5))) / (2.0D0*3.09D-5)

         !  Taylor expansion in temperature

         if (tpeak <= 426.0D0) then
            logn = lgn426
         else if (tpeak <= 454.0D0) then
            logn = lgn426 + (tpeak-426.0D0)*(lgn454-lgn426) / &
                 (454.0D0-426.0D0)
         else if (tpeak <= 482.0D0) then
            logn = lgn454 + (tpeak-454.0D0)*(lgn482-lgn454) / &
                 (482.0D0-454.0D0)
         else if (tpeak <= 510.0D0) then
            logn = lgn482 + (tpeak-482.0D0)*(lgn510-lgn482) / &
                 (510.0D0-482.0D0)
         else if (tpeak <= 649.0D0) then
            logn = lgn510 + (tpeak-510.0D0)*(lgn649-lgn510) / &
                 (649.0D0-510.0D0)
         else
            !  Shouldn't get here (trapped by initial test above)
            continue
         end if

         if (logn > 15.0D0) logn = 15.0D0

         ncyc(k) = int(exp(logn))

      end do

    end subroutine cycles

  end subroutine thrmal

  ! !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!

  subroutine tohswg(outfile,iprint)

    !+ad_name  tohswg
    !+ad_summ  Routine to calculate the plasma current ramp-up time
    !+ad_type  Subroutine
    !+ad_auth  C A Gardner, AEA Fusion, Culham Laboratory
    !+ad_auth  P J Knight, CCFE, Culham Science Centre
    !+ad_cont  None
    !+ad_args  outfile : input integer : output file unit
    !+ad_args  iprint : input integer : switch for writing to output file (1=yes)
    !+ad_desc  This routine calculates the plasma current ramp-up time
    !+ad_desc  for a pulsed reactor.
    !+ad_prob  None
    !+ad_call  osubhd
    !+ad_call  ovarre
    !+ad_hist  25/11/93 PJK Incorporation into PROCESS
    !+ad_hist  22/05/06 PJK Corrected error in tohsmn calculation
    !+ad_hist  01/10/12 PJK Initial F90 version
    !+ad_hist  09/10/12 PJK Modified to use new process_output module
    !+ad_hist  15/10/12 PJK Added physics_variables
    !+ad_hist  18/10/12 PJK Added pfcoil_variables
    !+ad_hist  29/10/12 PJK Added pf_power_variables
    !+ad_hist  31/10/12 PJK Added constraint_variables
    !+ad_hist  04/02/13 PJK Comment change
    !+ad_hist  11/06/13 PJK Modified ipdot and tohsmn equations
    !+ad_hist  27/06/13 PJK Modified output heading
    !+ad_hist  24/04/14 PJK Calculation always proceeds irrespective of iprint
    !+ad_stat  Okay
    !+ad_docs  Work File Note F/MPE/MOD/CAG/PROCESS/PULSE/0013
    !+ad_docs  Work File Note F/PL/PJK/PROCESS/CODE/050
    !+ad_docs  AEA FUS 251: A User's Guide to the PROCESS Systems Code
    !
    ! !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!

    implicit none

    !  Arguments

    integer, intent(in) :: outfile,iprint

    !  Local variables

    real(kind(1.0D0)) :: albusa,ioht1,ioht2,ipdot,loh,m,pfbusl,r,rho,v

    ! !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!

    if (lpulse /= 1) return

    !  Current/turn in OH coil at beginning of pulse (A/turn)

    ioht1 = cpt(nohc,2)

    !  Current/turn in OH coil at start of flat-top (A/turn)

    ioht2 = cpt(nohc,3)

    !  OH coil resistance (ohms)

    if (ipfres == 0) then
       r = 0.0D0
    else
       r = powohres/( 1.0D6*ric(nohc) )**2
    end if

    !  OH coil bus resistance (ohms) (assumed to include power supply)
    !  Bus parameters taken from routine PFPWR.

    pfbusl = 8.0D0 * rmajor + 140.0D0
    albusa = abs(cptdin(nohc))/100.0D0

    rho = 1.5D0 * 2.62D-4 * pfbusl/albusa

    !  OH coil power source emf (volts)

    v = vpfskv * 1.0D3

    !  Mutual inductance between OH coil and plasma (H)

    m = sxlg(nohc,ncirt)

    !  Self inductance of OH coil (H)

    loh = sxlg(nohc,nohc)

    !  Maximum rate of change of plasma current (A/s)
    !  - now a function of the plasma current itself (previously just 0.5D6)

    ipdot = 0.0455D0*plascur

    !  Minimum plasma current ramp-up time (s)
    !  - corrected (bus resistance is not a function of turns)

    tohsmn = loh*(ioht2 - ioht1) / &
         (ioht2*(r*turns(nohc) + rho) - v + m*ipdot)

    !  Output section

    if (iprint == 1) then

       call osubhd(outfile,'OH coil considerations:')
       call ovarre(outfile,'Minimum plasma current ramp-up time (s)', &
            '(tohsmn)',tohsmn)

    end if

  end subroutine tohswg

  ! !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!

  subroutine burn(outfile,iprint)

    !+ad_name  burn
    !+ad_summ  Routine to calculate the burn time for a pulsed reactor
    !+ad_type  Subroutine
    !+ad_auth  C A Gardner, AEA Fusion, Culham Laboratory
    !+ad_auth  P J Knight, CCFE, Culham Science Centre
    !+ad_auth  R Kemp, CCFE, Culham Science Centre
    !+ad_cont  None
    !+ad_args  outfile : input integer : output file unit
    !+ad_args  iprint : input integer : switch for writing to output file (1=yes)
    !+ad_desc  This routine calculates the burn time for a pulsed reactor.
    !+ad_prob  None
    !+ad_call  osubhd
    !+ad_call  ovarre
    !+ad_hist  25/11/93 PJK Incorporation into PROCESS
    !+ad_hist  25/05/06 PJK Corrected error in tohsmn calculation
    !+ad_hist  01/10/12 PJK Initial F90 version
    !+ad_hist  09/10/12 PJK Modified to use new process_output module
    !+ad_hist  15/10/12 PJK Added physics_variables
    !+ad_hist  16/10/12 PJK Added current_drive_variables
    !+ad_hist  18/10/12 PJK Added pfcoil_variables
    !+ad_hist  30/10/12 PJK Added times_variables
    !+ad_hist  17/12/12 PJK Modified burn volt-seconds calculation (RK)
    !+ad_hist  27/11/13 PJK Deducted theat from tburn
    !+ad_hist  24/04/14 PJK Calculation always proceeds irrespective of iprint
    !+ad_hist  19/05/14 PJK Added warning if tburn is negative
    !+ad_stat  Okay
    !+ad_docs  Work File Note F/MPE/MOD/CAG/PROCESS/PULSE/0012
    !+ad_docs  AEA FUS 251: A User's Guide to the PROCESS Systems Code
    !
    ! !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!

    implicit none

    !  Arguments

    integer, intent(in) :: outfile,iprint

    !  Local variables

    real(kind(1.0D0)) :: tb,vburn,vsmax,vssoft

    ! !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!

    if (lpulse /= 1) return

    !  Volt-seconds required to produce plasma current during start-up
    !  (i.e. up to start of flat top)

    vssoft = vsres + vsind

    !  Total volt-seconds available during flat-top (heat + burn)
    !  (Previously calculated as (abs(vstot) - vssoft) )

    vsmax = abs(vsbn)

    !  Loop voltage during flat-top (including MHD sawtooth enhancement)

    vburn = plascur * rplas * facoh * csawth

    !  Burn time (s)

    tb = vsmax/vburn - theat
    if (tb < 0.0D0) then
       write(*,*) 'Warning in routine BURN:'
       write(*,*) 'Negative burn time available: ',tb
       write(*,*) 'Reduce theat or increase PF coil V-s capability'
       write(*,*) 'tburn set to zero...'
    end if
    tburn = max(0.0D0, tb)

    !  Output section

    if (iprint == 1) then

       call osubhd(outfile,'Volt-second considerations:')

       call ovarre(outfile,'Total V-s capability of OH/PF coils (Wb)', &
            '(abs(vstot))',abs(vstot))
       call ovarre(outfile,'Required volt-seconds during start-up (Wb)', &
            '(vssoft)',vssoft)
       call ovarre(outfile,'Available volt-seconds during burn (Wb)', &
            '(vsmax)',vsmax)
       call ovarre(outfile,'Burn time (s)','(tburn)',tburn)

    end if

  end subroutine burn

end module pulse_module
