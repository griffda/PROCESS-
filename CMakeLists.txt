#  CMake file for PROCESS
#  J. Morris
#  UKAEA

# Specify the minimum version for CMake
# 3.12 is required due to use of list TRANSFORM commands
cmake_minimum_required(VERSION 3.12)

# Project's name
project(PROCESS LANGUAGES Fortran)

# Questionable stuff to help the compiler handle preprocessor directives
# TODO Review if these directives are necessary now
# -cpp for preprocessor directives
set(CMAKE_Fortran_FLAGS -cpp)

# Define directories
set(FORTRAN_SOURCE_DIR ${CMAKE_SOURCE_DIR}/source/fortran)
# Set PLASMOD source code directory
set(PLASMOD_SOURCE_DIR ${CMAKE_SOURCE_DIR}/lib/PLASMOD)
# Set the REFPROP source code directory
set(REFPROP_SOURCE_DIR ${CMAKE_SOURCE_DIR}/lib/REFPROP)
# Set the Python source directory for exporting interface extension modules
set(PYTHON_SOURCE_DIR ${CMAKE_SOURCE_DIR}/process)

# Define files to compile
file(GLOB FORTRAN_LIB_SOURCES ${FORTRAN_SOURCE_DIR}/*.f90 ${FORTRAN_SOURCE_DIR}/*.f)
list(APPEND FORTRAN_LIB_SOURCES ${PLASMOD_SOURCE_DIR}/e3m.f)
list(APPEND FORTRAN_LIB_SOURCES ${PLASMOD_SOURCE_DIR}/equil.f90)
list(APPEND FORTRAN_LIB_SOURCES ${PLASMOD_SOURCE_DIR}/grad_func.f90)
list(APPEND FORTRAN_LIB_SOURCES ${PLASMOD_SOURCE_DIR}/structs.f90)
list(APPEND FORTRAN_LIB_SOURCES ${PLASMOD_SOURCE_DIR}/transport_solver.f90)
list(APPEND FORTRAN_LIB_SOURCES ${PLASMOD_SOURCE_DIR}/trmodel.f90)
list(APPEND FORTRAN_LIB_SOURCES ${REFPROP_SOURCE_DIR}/refprop.f)
list(APPEND FORTRAN_LIB_SOURCES ${REFPROP_SOURCE_DIR}/refprop_interface.f90)

# Define interface source filenames to wrap
list(APPEND FORTRAN_INTERFACE_SOURCE_NAMES global_variables.f90
  init_module.f90
  main_module.f90
  div_kal_vars.f90
  kallenbach_module.f90
  numerics.f90
  scan.f90
  final_module.f90
  error_handling.f90
  availability.f90
  cost_variables.f90
  divertor_variables.f90
  fwbs_variables.f90
  physics.f90
  physics_variables.f90
  tfcoil_variables.f90
  times_variables.f90
  ife_variables.f90
  ife.f90
  )
# Create the interface source paths from this
list(TRANSFORM FORTRAN_INTERFACE_SOURCE_NAMES PREPEND ${FORTRAN_SOURCE_DIR}/ OUTPUT_VARIABLE FORTRAN_INTERFACE_SOURCE_PATHS)
# Define the f90wrap filenames
list(TRANSFORM FORTRAN_INTERFACE_SOURCE_NAMES PREPEND f90wrap_ OUTPUT_VARIABLE FORTRAN_INTERFACE_F90WRAP_NAMES)
# Create the f90wrap source paths from this
list(TRANSFORM FORTRAN_INTERFACE_F90WRAP_NAMES PREPEND ${CMAKE_BINARY_DIR}/ OUTPUT_VARIABLE FORTRAN_INTERFACE_F90WRAP_PATHS)

# Set names and paths for the produced Fortran interface modules
# These are the names of the products of f90wrap and f2py
set(FORTRAN_INTERFACE_NAME "fortran")
set(FORTRAN_INTERFACE_NAME_UNDER _${FORTRAN_INTERFACE_NAME})
# The "Pythonic" Python module to import as the Fortran interface 
# (e.g. fortran.py), created by f90wrap
set(FORTRAN_INTERFACE_MODULE ${CMAKE_BINARY_DIR}/${FORTRAN_INTERFACE_NAME}.py)
# The underlying un-Pythonic Python module relied on by fortran.py 
# (e.g. _fortran.py), created by f2py
set(FORTRAN_INTERFACE_MODULE_UNDER ${FORTRAN_SOURCE_DIR}/${FORTRAN_INTERFACE_NAME_UNDER}.py)

# Build targets
# Stage 1: Compile Fortran sources to a shared library
# (libprocess_lib.so on Linux)
add_library(process_lib SHARED ${FORTRAN_LIB_SOURCES})
set_target_properties(process_lib PROPERTIES LINKER_LANGUAGE Fortran)

# Stage 2: Run f90wrap
add_custom_target(f90wrap DEPENDS ${FORTRAN_INTERFACE_F90WRAP_PATHS})

# Run f90wrap for the above f90wrap target
# This wraps the interface Fortran .f90 files to generate f90wrap_*.f90 files
# It also creates the Fortran interface Python module (fortran.py)
# TODO Add variable for the kind map
add_custom_command(OUTPUT ${FORTRAN_INTERFACE_F90WRAP_PATHS}
  COMMAND f90wrap -k ${FORTRAN_SOURCE_DIR}/kind_map ${FORTRAN_INTERFACE_SOURCE_PATHS} -m ${FORTRAN_INTERFACE_NAME})

# Stage 3: Run f2py
# Builds every time to make sure the libprocess_lib.so file is up-to-date
# TODO Convert .so to non-platform specific
add_custom_target(f2py ALL
  DEPENDS ${FORTRAN_INTERFACE_NAME_UNDER}.so)

add_custom_command(OUTPUT ${FORTRAN_INTERFACE_NAME_UNDER}.so
  COMMAND LDFLAGS=-Wl,-rpath=${CMAKE_BINARY_DIR} f2py -c -m ${FORTRAN_INTERFACE_NAME_UNDER} -I${CMAKE_BINARY_DIR} -L${CMAKE_BINARY_DIR} -lprocess_lib ${FORTRAN_INTERFACE_F90WRAP_PATHS})
# LDFLAGS=-Wl,-rpath=${CMAKE_BINARY_DIR} embeds the RPATH (run path, list of 
# directories to search for shared library dependencies) into the shared object
# library ${FORTRAN_INTERFACE_NAME_UNDER}.so. This allows the dynamic linker to 
# find libprocess_lib.so when loading ${FORTRAN_INTERFACE_NAME_UNDER}.so. This 
# is a workaround when using f2py to link two shared libraries, as the linking
# can't be controlled by cmake in this case.

# Depends on process_lib, because we're linking to the libprocess_lib.so shared
# library with the -lprocess_lib option
# Depends on f90wrap because f90wrap_*.f90 source files are used, which are
# generated by f90wrap
add_dependencies(f2py process_lib f90wrap)

# Need to change the _fortran import path in fortran.py
# Uses the f90wrap_interface_import_modifier.py script
# TODO Might want to find python interpreter first
# TODO Remove hardcoding of python script: set as variable above
add_custom_target(modify_so_python_import_path ALL
  COMMAND python ${CMAKE_SOURCE_DIR}/scripts/f90wrap_interface_import_modifier.py ${FORTRAN_INTERFACE_MODULE}
)

add_dependencies(modify_so_python_import_path f90wrap)

# Export the required modules to the Python package
# These are _fortran.cpython....so (f2py) and fortran.py (f90wrap)
# TODO Not sure that the Python package source dir is the right place for these
# Perhaps /bin?
# TODO Should only require one "ALL"?
add_custom_target(export_modules ALL
  COMMAND ${CMAKE_COMMAND} -E copy ${FORTRAN_INTERFACE_MODULE} ${PYTHON_SOURCE_DIR}
  COMMAND ${CMAKE_COMMAND} -E copy ${CMAKE_BINARY_DIR}/${FORTRAN_INTERFACE_NAME_UNDER}*.so ${PYTHON_SOURCE_DIR}
)

# Only run once f2py has finished
add_dependencies(export_modules modify_so_python_import_path f2py)