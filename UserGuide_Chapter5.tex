\mychapter{Changing the Source Code: New Models, Variables and Constraints}
\label{chap:modify}

It is often useful to add extra features to the code in order to model new
situations. This chapter provides instructions on how to do this, with
specific details on how to add various numerics related items to \process.

Please remember to modify the relevant sections and table(s) in this User
Guide if changes are made to the source code!

\section{Source Code Modification}
\label{sec:codemods}

Described here are the general rules that apply when the Fortran source code
is modified. See Section~\ref{sec:code_release} for instructions on how to
commit changes to the \process\ Git repository and produce new releases. The variable descriptor file is generated from specially-formatted comment lines within the source code (see Section~\ref{sec:autodoc} for more details). Therefore, it is exceedingly important to keep these lines relevant and in sync with the variables they describe.

\subsection{Changing the Fortran code}

Please ensure that the following rules are adhered to when modifying the
\process\ source code:

\begin{enumerate}

\item Keep the layout consistent in with the existing code,
  including indentation of clauses (\texttt{if}-statements, \texttt{do}-loops,
  etc.).

\item Use the standard routine header (see below).

\item Always use \verb+implicit none+ and declare all local variables
  explicitly.

\item Declare all `real' (i.e.\ floating-point) variables as
  \texttt{real(kind(1.0D0))}.

\item Ensure all routine arguments have the appropriate attribute \texttt{intent(in)},
  \texttt{intent(out)} or \texttt{intent(inout)}, as necessary.

\item Always write explicit real constants using the scientific \texttt{D}
  notation, e.g.\ \texttt{1.0D0}, \texttt{2.3D0}, \texttt{-1.23D6}. That is to
  say, use \texttt{1.0D0} and not \texttt{1.0} or \texttt{1.} or \texttt{1} when the
  expression should be using floating-point arithmetic.

\end{enumerate}

A Fortran 90/95 manual, complete with guidelines for good Fortran 90/95
practice, may be found at the following webpage:
\begin{center}
\texttt{
\href{http://fusweb1.fusion.ccfe.ac.uk/~pknight/f95notebook.html}
{http://fusweb1.fusion.ccfe.ac.uk/$\sim$pknight/f95notebook.html}
}
\end{center}

\subsection{Source code documentation}

It is critically important to keep the documentation in the source code itself
up-to-date, relevant and tidy. Please keep to the following guidelines
whenever the source code is modified.
\begin{enumerate}

\item Use comments copiously in the code.

\item Use the standard header layout, and do not omit any of the
  sections. Here is an example subprogram header:
\footnotesize
\begin{verbatim}
  ! !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!

  subroutine culblm(bt,dnbeta,plascur,rminor,betalim)

    !+ad_name  culblm
    !+ad_summ  Beta scaling limit
    !+ad_type  Subroutine
    !+ad_auth  P J Knight, CCFE, Culham Science Centre
    !+ad_cont  N/A
    !+ad_args  bt      : input real :  toroidal B-field on plasma axis (T)
    !+ad_args  dnbeta  : input real :  Troyon-like g coefficient
    !+ad_args  plascur : input real :  plasma current (A)
    !+ad_args  rminor  : input real :  plasma minor axis (m)
    !+ad_args  betalim : output real : beta limit as defined below
    !+ad_desc  This subroutine calculates the beta limit, using
    !+ad_desc  the algorithm documented in AEA FUS 172.
    !+ad_desc  <P>The limit applies to beta defined with respect to the total B-field.
    !+ad_desc  Switch ICULBL determines which components of beta to include (see
    !+ad_desc  routine <A HREF="constraints.html">constraints</A> for coding):
    !+ad_desc  <UL>
    !+ad_desc  <P><LI>If ICULBL = 0, then the limit is applied to the total beta
    !+ad_desc  <P><LI>If ICULBL = 1, then the limit is applied to the thermal beta only
    !+ad_desc  <P><LI>If ICULBL = 2, then the limit is applied to the thermal +
    !+ad_desc                        neutral beam beta components
    !+ad_desc  </UL>
    !+ad_desc  The default value for the g coefficient is DNBETA = 3.5
    !+ad_prob  None
    !+ad_call  None
    !+ad_hist  21/06/94 PJK Upgrade to higher standard of coding
    !+ad_hist  09/11/11 PJK Initial F90 version
    !+ad_hist  27/06/13 PJK Modified header comments
    !+ad_stat  Okay
    !+ad_docs  AEA FUS 172: Physics Assessment for the European Reactor Study
    !+ad_docs  AEA FUS 251: A User's Guide to the PROCESS Systems Code
    !
    ! !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
\end{verbatim}
\normalsize
  A description of all the available automatic documentation marker tags
  (these all start with \verb.!+ad_.) may be found by examining the main
  program header of the (self-documenting!) automatic documentation program
  itself (in file \texttt{autodoc.f90}).

\item After \textbf{every}\ change within a routine, add a new history line
  (using \verb.!+ad_hist., and \verb.!+ad_hisc. for continuation lines) to its
  header. Ensure that all routines called are listed via
  \verb.!+ad_call. lines.  Update the description lines as necessary. You may
  use html tags and hyperlinks (some are shown in the example above) as
  required; to be sure that they have been added correctly, type \texttt{make
    html} to create the web documentation and examine the relevant html file
  (i.e.\ \texttt{culblm.html} for the example above) using your favourite web
  browser.

\item If you add a new routine to a module, remember to modify the header of the module as well as that of the new routine (add a \verb.!+ad_cont. line to it).

\item Add suitable documentation to this User Guide whenever a
  model is added or modified. This should be done immediately to ensure that
  the Guide remains consistent with the source code. Change the code's revision
  number and the date in \texttt{process.tex}.
  
\item Add a new file to the folder \texttt{release\_notes}.  It is particularly important to describe here any changes to the required IN.DAT - especially any change that makes previous IN.DAT files unusable.  

\end{enumerate}

\section{Input Parameters}

Input parameters (see Section~\ref{sec:inpars}) are added to the code in the
following way:

\begin{enumerate}

\item Choose the most relevant module (usually one of those in source file
  \texttt{global\_variables.f90}). Keeping everything in alphabetical order
  (or possibly within a group of variables closely-related to a particular
  switch), add a declaration statement for the new variable, specifying a
  ``sensible'' default value, and a correctly formatted comment line to
  describe the variable. Copy the examples already present, such as
\begin{verbatim}
  !+ad_vars  abktflnc /5.0/ : allowable first wall/blanket neutron
  !+ad_varc                   fluence (MW-yr/m2) (blktmodel=0)
  real(kind(1.0D0)) :: abktflnc = 5.0D0
\end{verbatim}
  Note that the automatic documentation marker tag \verb.!+ad_vars. tells the
  \texttt{autodoc} utility (Section~\ref{sec:autodoc}) that the line is (the
  first line of) a variable description, while \verb.!+ad_varc. specifies any
  continuation lines. Also note that the colon (:) on the first line is
  necessary, as it is assumed to exist by the dictionary-building Python
  utility for the GUI\@.

\item Add a dated comment (using \verb.!+ad_hist.) to the header of the
  relevant module.

\item Ensure that all the modules that use the new variable reference the
  relevant module via the Fortran \texttt{use} statement.

\item Add the parameter to routine \texttt{PARSE\_INPUT\_FILE} in source file
  \texttt{input.f90} in a suitable place --- keep to alphabetical order. The
  existing examples provide guidance on how to do this. Note that real (i.e.\
  double precision) and integer variables are treated differently, as are
  scalar quantities and arrays.

%\item Modify \texttt{process\_dicts.py} and \texttt{write\_constraints.conf}
%  accordingly.

\end{enumerate}

\section{Iteration Variables}

New iteration variables (see Section~\ref{sec:itvars}) are added in the
same way as input parameters, with the following additions:

\begin{enumerate}

\item Increment the parameter \texttt{ipnvars} in module \texttt{numerics} in
  source file \texttt{numerics.f90} in order to accommodate the new iteration
  variable.

\item Add an additional line to the initialisation of the array \texttt{ixc}
  in module \texttt{numerics} in source file \texttt{numerics.f90}.

\item Assign sensible values for the variable's bounds to the relevant
  elements in arrays \texttt{boundl} and \texttt{boundu} in module
  \texttt{numerics} in source file \texttt{numerics.f90}.

\item Assign the relevant element of character array \texttt{lablxc} to the
  name of the variable, in module \texttt{numerics} in source file
  \texttt{numerics.f90}.

\item Add the variable to routines \texttt{LOADXC} and \texttt{CONVXC} in
  source file \texttt{iteration\_variables.f90}, mimicking the way that the
  existing iteration variables are coded.

\item Modify the variable's description in its declaring module (which is
  likely to be in source file \texttt{global\_variables.f90}), to say that it
  is ``(iteration variable XXX)''

\item Add dated comments (using \verb.!+ad_hist.) to the headers of
  all affected routines and modules.

\item Modify Table~\ref{tab:itvars3} of this User Guide
  (\texttt{UserGuide\_Chapter2.tex}).

%\item Modify \texttt{process\_dicts.py} and \texttt{write\_constraints.conf}
%  accordingly.

\end{enumerate}

If an existing input parameter is now required to be an iteration variable,
then simply carry out the tasks mentioned here.

It should be noted that iteration variables must not be reset elsewhere in the
code. That is, they may only be assigned new values when originally
initialised (in the relevant module, or in the input file if required), and in
routine \texttt{CONVXC} where the iteration process itself is performed.
Otherwise, the numerical procedure cannot adjust the value as it requires, and
the program will fail.

\section{Other Global Variables}

This type of variable embraces all those present in the modules in
\texttt{global\_variables.f90} (and some others elsewhere) which do not need
to be given initial values or to be input, as they are calculated within the
code. These should be added to the code in the following way:

\begin{enumerate}

\item Choose the most relevant module (usually one of those in source file
  \texttt{global\_variables.f90}). Keeping everything in alphabetical order
  (or possibly within a group of variables closely-related to a particular
  switch), add a declaration statement for the new variable, specifying the
  initial value \texttt{0.0D0}, and a correctly formatted comment line to
  describe the variable (copying the examples already present --- see also
  ``Input Parameters'' above).

\item Ensure that all the modules that use the new variable reference the
  relevant module via the Fortran \texttt{use} statement.

\end{enumerate}

\section{Constraint Equations}

Constraint equations (see Section~\ref{sec:constraints}) are added to
\process\ in the following way:

\begin{enumerate}

\item Increment the parameter \texttt{ipeqns} in module \texttt{numerics} in
  source file \texttt{numerics.f90} in order to accommodate the new constraint.

\item Add an additional line to the initialisation of the array \texttt{icc}
  in module \texttt{numerics} in source file \texttt{numerics.f90}.

\item Assign a description of the new constraint to the relevant element of
  array \texttt{lablcc}, in module \texttt{numerics} in source file
  \texttt{numerics.f90}.

\item Add a new Fortran \texttt{case} statement containing the new constraint
  equation to routine \texttt{CONSTRAINT\_EQNS} in source file
  \texttt{constraint\_equations.f90}, ensuring that all the variables used in
  the formula are contained in the modules specified via \texttt{use}
  statements present at the start of this file.  Use a similar formulation to
  that used for the existing constraint equations, remembering that the code
  will try to force \texttt{cc(i)} to be zero.

\item Add dated comments (using \verb.!+ad_hist.) to the headers of
  all affected routines and modules.

\item Modify Table~\ref{tab:eqns2} of this User Guide
  (\texttt{UserGuide\_Chapter2.tex}).

\end{enumerate}

Remember that if a limit equation is being added, a new f-value iteration
variable may also need to be added to the code.

\section{Figures of Merit}

New figures of merit (see Section~\ref{sec:foms}) are added to \process\ in
the following way:

\begin{enumerate}

\item Increment the parameter \texttt{ipnfoms} in module \texttt{numerics} in
  source file \texttt{numerics.f90} to accommodate the new figure of merit.

\item Assign a description of the new figure of merit to the relevant element
  of array \texttt{lablmm} in module \texttt{numerics} in source file
  \texttt{numerics.f90}.

\item Add the new figure of merit equation to routine \texttt{FUNFOM} in
  source file \texttt{evaluators.f90}, following the method used in the
  existing examples. The value of \texttt{fc} should be of order unity, so
  select a reasonable scaling factor if necessary. Ensure that all the
  variables used in the new equation are contained in the modules specified
  via \texttt{use} statements present at the start of this file.

\item Add dated comments (using \verb.!+ad_hist.) to the headers of
  all affected routines and modules.

\item Modify Table~\ref{tab:foms} of this User Guide
  (\texttt{UserGuide\_Chapter2.tex}).

%\item Modify \texttt{process\_dicts.py} accordingly.

\end{enumerate}

\section{Scanning Variables}

Scanning variables (see Section~\ref{sec:scans}) are added to \process\ in
the following way:

\begin{enumerate}

\item Increment the parameter \texttt{ipnscnv} in module \texttt{scan\_module}
  in source file \texttt{scan.f90} to accommodate the new scanning variable.

\item Add a short description of the new scanning variable to the
  \texttt{nsweep} entry in source file \texttt{scan.f90}.

\item Add a new assignment to the relevant part of routine \texttt{SCAN} in
  source file \texttt{scan.f90}, following the examples already present,
  including the inclusion of a short description of the new scanning variable
  in variable \texttt{xlabel}.

\item Ensure that the scanning variable used in the assignment is contained in
  one of the modules specified via \texttt{use} statements present at the
  start of this routine.

\item Add dated comments (using \verb.!+ad_hist.) to the headers of
  all affected routines and modules.

\item Modify Table~\ref{tab:scans} of this User Guide
  (\texttt{UserGuide\_Chapter2.tex}).

%\item Modify \texttt{process\_dicts.py} if necessary.

\end{enumerate}

\section{Submission of New Models}

The \process\ source code is maintained by CCFE, and resides in a
\textit{Git}~\cite{git} repository on the CCFE servers. We welcome
contributions of alternative or improved models and algorithms.

We request that contributors provide the following information for any new models that they provide:

\begin{itemize}

\item A comprehensive description of the model; please provide a full list of
  references.

\item A list of all inputs and outputs: descriptions, default (input) values,
  allowed ranges, units.

\item If possible, please cross-reference any input/output variables to
  existing global variables listed in the variable descriptor file (see
  Section~\ref{sec:vardes}).

\item Any new input parameters, iteration variables, constraint equations, figures of merit etc.

\item A definition of any pre-requisites.

\item Any available test data, code examples or test programs in any language.

\end{itemize}

\section{Code Structure}

\subsection{Numerics modules}
\label{sec:numerics_modules}

These modules contain the equation solvers, their calling routines and other
relevant procedures. Various mathematical routines from a number of standard
libraries are also incorporated into these files. Table~\ref{tab:numerics}
summarises the numerics source files.

% Table summarising numerics modules in PROCESS
\begin{table}[tbph]
\footnotesize
\begin{center}
\begin{tabular}{||l||l||} \hline
source file   & description \\ \hline
\texttt{caller.f90} & calls physics, engineering, building and cost routines \\
\texttt{constraint\_equations.f90} & defines the constraint equations \\
\texttt{evaluators.f90} & function evaluators for HYBRD and \vmcon\ packages \\
\texttt{iteration\_variables.f90} & adjusts values of iteration variables \\
\texttt{maths\_library.f90} & miscellaneous `black-box' maths routines,
including HYBRD and \vmcon \\
\texttt{numerics.f90} & numerics array definitions, and calling routines for
HYBRD and \vmcon\ packages \\
\texttt{scan.f90} & performs a parameter scan \\
\hline
\end{tabular}
\end{center}
\caption[Summary of numerics modules]
{\label{tab:numerics}
  \textit{Summary of the numerics modules in \process.}
}
\end{table}

\subsection{Physics modules}

These modules contain the main physics routines that evaluate the plasma and
fusion parameters. Also included here are the routines describing the current
drive and divertor systems. Table~\ref{tab:physics} summarises the main physics
source files.

% Table summarising physics modules in PROCESS
\begin{table}[tbph]
\begin{center}

\begin{tabular}{||l||l||} \hline
source file   & description \\ \hline
\texttt{current\_drive.f90} & current drive efficiency calculations \\
\texttt{divertor.f90} & divertor model calculations\\
\texttt{fispact.f90} & nuclide inventory/activation calculations \\
\texttt{ife.f90} & inertial fusion energy physics/engineering \\
\texttt{impurity\_radiation.f90} & radiation power calculations \\
\texttt{physics.f90} & tokamak plasma and fusion calculations \\
\texttt{plasma\_geometry.f90} & plasma geometry algorithms \\
\texttt{plasma\_profiles.f90} & plasma density and temperature profile calculations \\
\texttt{rfp.f90} & reversed field pinch physics/engineering \\
\texttt{startup.f90} & plasma start-up auxiliary power requirements \\
\texttt{stellarator.f90 } & stellarator-relevant physics/engineering \\
\hline
\end{tabular}
\end{center}
\caption[Summary of physics modules]
{\label{tab:physics}
  \textit{Summary of the physics modules in \process.}
}
\end{table}

\subsection{Engineering modules}

These modules contain the description of the machine geometry and its major
systems, including the PF and TF coil sets, the first wall, blanket and
shield, and other items such as the buildings, vacuum system, power conversion
and the structural components.  Table~\ref{tab:engineering} summarises the main
engineering source files.

% Table summarising engineering modules in PROCESS
\begin{table}[tbph]
\begin{center}

\begin{tabular}{||l||l||} \hline
source file     & description \\ \hline
\texttt{availability.f90} & plant component lifetimes and overall availability \\
\texttt{buildings.f90} & buildings calculations \\
\texttt{fwbs.f90} & first wall, blanket and shield calculations \\
\texttt{machine\_build.f90} & machine build calculations \\
\texttt{pfcoil.f90} & PF coil calculations \\
\texttt{plant\_power.f90} & heat transport and power balance calculations \\
\texttt{pulse.f90} & pulsed power plant calculations \\
\texttt{safety.f90} & steady-state temperatures after a LOCA event \\
\texttt{sctfcoil.f90} & superconducting TF coil calculations \\
\texttt{structure.f90} & support structure calculations \\
\texttt{tfcoil.f90} & resistive TF coil calculations \\
\texttt{vacuum.f90} & vacuum system calculations \\
\hline
\end{tabular}
\end{center}
\caption[Summary of engineering modules]
{\label{tab:engineering}
  \textit{Summary of the engineering modules in \process.}
}
\end{table}

\subsection{Costing module}

The costing module, \texttt{costs.f90}, performs all the cost calculations,
including values in M\$ for each machine system, and the cost of electricity
in m\$/kWh. Normally, the machine costs are written to the output file; if
this is not required set switch \texttt{output\_costs = 0}.

\subsection{Other modules}

These modules perform miscellaneous tasks, such as initialisation of variables
and file input / output. File \texttt{process.f90} contains the main program,
and includes the overall controlling loop.

Table~\ref{tab:other_modules} summarises these modules.

% Table summarising miscellaneous modules in PROCESS
\begin{table}[tbph]
\begin{center}

\begin{tabular}{||l||l||} \hline
source file     & description \\ \hline
\texttt{error\_handling.f90} & centralised error handling module \\
\texttt{fson\_library.f90} & library used to read in data from JSON-format files \\
\texttt{global\_variables.f90} & defines and initialises most shared variables \\
\texttt{initial.f90} & checks self-consistency of input variables and switches \\
\texttt{input.f90} & reads in user-defined settings from input file \\
\texttt{output.f90} & utility routines to format output to file \\
\texttt{process.f90} & main program and top-level calling routines \\
\hline
\end{tabular}
\end{center}
\caption[Summary of other modules]
{\label{tab:other_modules}
  \textit{Summary of the remaining modules in \process.}
}
\end{table}

