\mychapter{Changing the Source Code: New Models, Variables and Constraints}
\label{chap:modify}

It is often useful to add extra features to the code in order to model new
situations. This chapter provides instructions on how to do this, with
specific details on how to add various numerics related items to \process.

Please remember to modify the relevant sections and table(s) in this User
Guide if changes are made to the source code!

\section{Source Code Modification}
\label{sec:codemods}

Described here are the general rules that apply when the Fortran source code
is modified. See Section~\ref{sec:code_release} for instructions on how to
commit changes to the \process\ Git repository and produce new releases.

\subsection{Changing the Fortran code}

Please ensure that the following rules are adhered to when modifying the
\process\ source code:

\begin{enumerate}

\item Keep the layout consistent in `look' and style with the existing code,
  including indentation of clauses (\texttt{if}-statements, \texttt{do}-loops,
  etc.).

\item Use the standard routine header (see below).

\item Always use \verb+implicit none+ and declare all local variables
  explicitly.

\item Declare all `real' (i.e.\ floating-point) variables as
  \texttt{real(kind(1.0D0))}.

\item Ensure all routine arguments have the appropriate attribute \texttt{intent(in)},
  \texttt{intent(out)} or \texttt{intent(inout)}, as necessary.

\item Always write explicit real constants using the scientific \texttt{D}
  notation, e.g.\ \texttt{1.0D0}, \texttt{2.3D0}, \texttt{-1.23D6}. That is to
  say, use \texttt{1.0D0} and not \texttt{1.0} or \texttt{1.} or \texttt{1} when the
  expression should be using floating-point arithmetic.

\end{enumerate}

A Fortran 90/95 manual, complete with guidelines for good Fortran 90/95
practice, may be found at the following webpage:
\begin{center}
\texttt{
\href{http://fusweb1.fusion.ccfe.ac.uk/~pknight/f95notebook.html}
{http://fusweb1.fusion.ccfe.ac.uk/$\sim$pknight/f95notebook.html}
}
\end{center}

\subsection{Source code documentation}

It is critically important to keep the documentation in the source code itself
up-to-date, relevant and tidy. Please keep to the following guidelines
whenever the source code is modified.
\begin{enumerate}

\item Use comments copiously, and in keeping with the existing code.

\item Use the standard header layout, and do not omit any of the
  sections. Here is an example subprogram header:
\footnotesize
\begin{verbatim}
  ! !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!

  subroutine culblm(bt,dnbeta,plascur,rminor,betalim)

    !+ad_name  culblm
    !+ad_summ  Beta scaling limit
    !+ad_type  Subroutine
    !+ad_auth  P J Knight, CCFE, Culham Science Centre
    !+ad_cont  N/A
    !+ad_args  bt      : input real :  toroidal B-field on plasma axis (T)
    !+ad_args  dnbeta  : input real :  Troyon-like g coefficient
    !+ad_args  plascur : input real :  plasma current (A)
    !+ad_args  rminor  : input real :  plasma minor axis (m)
    !+ad_args  betalim : output real : beta limit as defined below
    !+ad_desc  This subroutine calculates the beta limit, using
    !+ad_desc  the algorithm documented in AEA FUS 172.
    !+ad_desc  <P>The limit applies to beta defined with respect to the total B-field.
    !+ad_desc  Switch ICULBL determines which components of beta to include (see
    !+ad_desc  routine <A HREF="constraints.html">constraints</A> for coding):
    !+ad_desc  <UL>
    !+ad_desc  <P><LI>If ICULBL = 0, then the limit is applied to the total beta
    !+ad_desc  <P><LI>If ICULBL = 1, then the limit is applied to the thermal beta only
    !+ad_desc  <P><LI>If ICULBL = 2, then the limit is applied to the thermal +
    !+ad_desc                        neutral beam beta components
    !+ad_desc  </UL>
    !+ad_desc  The default value for the g coefficient is DNBETA = 3.5
    !+ad_prob  None
    !+ad_call  None
    !+ad_hist  21/06/94 PJK Upgrade to higher standard of coding
    !+ad_hist  09/11/11 PJK Initial F90 version
    !+ad_hist  27/06/13 PJK Modified header comments
    !+ad_stat  Okay
    !+ad_docs  AEA FUS 172: Physics Assessment for the European Reactor Study
    !+ad_docs  AEA FUS 251: A User's Guide to the PROCESS Systems Code
    !
    ! !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
\end{verbatim}
\normalsize
  A description of all the available automatic documentation marker tags
  (these all start with \verb.!+ad_.) may be found by examining the main
  program header of the (self-documenting!) automatic documentation program
  itself (in file \texttt{autodoc.f90}).

\item After \textbf{every}\ change within a routine, add a new history line
  (using \verb.!+ad_hist., and \verb.!+ad_hisc. for continuation lines) to its
  header. Ensure that all routines called are listed via
  \verb.!+ad_call. lines.  Update the description lines as necessary. You may
  use html tags and hyperlinks (some are shown in the example above) as
  required; to be sure that they have been added correctly, type \texttt{make
    html} to create the web documentation and examine the relevant html file
  (i.e.\ \texttt{culblm.html} for the example above) using your favourite web
  browser.

\item If you add a new routine to a module, remember to modify the module's
  header as well as the routine's (add a \verb.!+ad_cont. line to it).

\item Add a suitable level of documentation to this User Guide whenever a
  model is added or modified. This should be done immediately to ensure that
  the Guide remains consistent with the source code. Change the code's revision
  number and the date in \texttt{process.tex}.

\end{enumerate}

\section{Input Parameters}

Input parameters (see Section~\ref{sec:inpars}) are added to the code in the
following way:

\begin{enumerate}

\item Choose the most relevant module (usually one of those in source file
  \texttt{global\_variables.f90}). Keeping everything in alphabetical order
  (or possibly within a group of variables closely-related to a particular
  switch), add a declaration statement for the new variable, specifying a
  ``sensible'' default value, and a correctly formatted comment line to
  describe the variable. Copy the examples already present, such as
\begin{verbatim}
  !+ad_vars  abktflnc /5.0/ : allowable first wall/blanket neutron
  !+ad_varc                   fluence (MW-yr/m2) (blktmodel=0)
  real(kind(1.0D0)) :: abktflnc = 5.0D0
\end{verbatim}
  Note that the automatic documentation marker tag \verb.!+ad_vars. tells the
  \texttt{autodoc} utility (Section~\ref{sec:autodoc}) that the line is (the
  first line of) a variable description, while \verb.!+ad_varc. specifies any
  continuation lines. Also note that the colon (:) on the first line is
  necessary, as it is assumed to exist by the dictionary-building Python
  utility for the GUI\@.

\item Add a dated comment (using \verb.!+ad_hist.) to the header of the
  relevant module.

\item Ensure that all the modules that use the new variable reference the
  relevant module via the Fortran \texttt{use} statement.

\item Add the parameter to routine \texttt{PARSE\_INPUT\_FILE} in source file
  \texttt{input.f90} in a suitable place --- keep to alphabetical order. The
  existing examples provide guidance on how to do this. Note that real (i.e.\
  double precision) and integer variables are treated differently, as are
  scalar quantities and arrays.

%\item Modify \texttt{process\_dicts.py} and \texttt{write\_constraints.conf}
%  accordingly.

\end{enumerate}

\section{Iteration Variables}

New iteration variables (see Section~\ref{sec:itvars}) are added in the
same way as input parameters, with the following additions:

\begin{enumerate}

\item Increment the parameter \texttt{ipnvars} in module \texttt{numerics} in
  source file \texttt{numerics.f90} in order to accommodate the new iteration
  variable.

\item Add an additional line to the initialisation of the array \texttt{ixc}
  in module \texttt{numerics} in source file \texttt{numerics.f90}.

\item Assign sensible values for the variable's bounds to the relevant
  elements in arrays \texttt{boundl} and \texttt{boundu} in module
  \texttt{numerics} in source file \texttt{numerics.f90}.

\item Assign the relevant element of character array \texttt{lablxc} to the
  name of the variable, in module \texttt{numerics} in source file
  \texttt{numerics.f90}.

\item Add the variable to routines \texttt{LOADXC} and \texttt{CONVXC} in
  source file \texttt{iteration\_variables.f90}, mimicking the way that the
  existing iteration variables are coded.

\item Modify the variable's description in its declaring module (which is
  likely to be in source file \texttt{global\_variables.f90}), to say that it
  is ``(iteration variable XXX)''

\item Add dated comments (using \verb.!+ad_hist.) to the headers of
  all affected routines and modules.

\item Modify Table~\ref{tab:itvars2} of this User Guide
  (\texttt{UserGuide\_Chapter2.tex}).

%\item Modify \texttt{process\_dicts.py} and \texttt{write\_constraints.conf}
%  accordingly.

\end{enumerate}

If an existing input parameter is now required to be an iteration variable,
then simply carry out the tasks mentioned here.

It should be noted that iteration variables must not be reset elsewhere in the
code. That is, they may only be assigned new values when originally
initialised (in the relevant module, or in the input file if required), and in
routine \texttt{CONVXC} where the iteration process itself is performed.
Otherwise, the numerical procedure cannot adjust the value as it requires, and
the program will fail.

\section{Other Global Variables}

This type of variable embraces all those present in the modules in
\texttt{global\_variables.f90} (and some others elsewhere) which do not need
to be given initial values or to be input, as they are calculated within the
code. These should be added to the code in the following way:

\begin{enumerate}

\item Choose the most relevant module (usually one of those in source file
  \texttt{global\_variables.f90}). Keeping everything in alphabetical order
  (or possibly within a group of variables closely-related to a particular
  switch), add a declaration statement for the new variable, specifying the
  initial value \texttt{0.0D0}, and a correctly formatted comment line to
  describe the variable (copying the examples already present --- see also
  ``Input Parameters'' above).

\item Ensure that all the modules that use the new variable reference the
  relevant module via the Fortran \texttt{use} statement.

\end{enumerate}

\section{Constraint Equations}

Constraint equations (see Section~\ref{sec:constraints}) are added to
\process\ in the following way:

\begin{enumerate}

\item Increment the parameter \texttt{ipeqns} in module \texttt{numerics} in
  source file \texttt{numerics.f90} in order to accommodate the new constraint.

\item Add an additional line to the initialisation of the array \texttt{icc}
  in module \texttt{numerics} in source file \texttt{numerics.f90}.

\item Assign a description of the new constraint to the relevant element of
  array \texttt{lablcc}, in module \texttt{numerics} in source file
  \texttt{numerics.f90}.

\item Add a new Fortran \texttt{case} statement containing the new constraint
  equation to routine \texttt{CONSTRAINT\_EQNS} in source file
  \texttt{constraint\_equations.f90}, ensuring that all the variables used in
  the formula are contained in the modules specified via \texttt{use}
  statements present at the start of this file.  Use a similar formulation to
  that used for the existing constraint equations, remembering that the code
  will try to force \texttt{cc(i)} to be zero.

\item Add dated comments (using \verb.!+ad_hist.) to the headers of
  all affected routines and modules.

\item Modify Table~\ref{tab:eqns2} of this User Guide
  (\texttt{UserGuide\_Chapter2.tex}).

\end{enumerate}

Remember that if a limit equation is being added, a new f-value iteration
variable may also need to be added to the code.

\section{Figures of Merit}

New figures of merit (see Section~\ref{sec:foms}) are added to \process\ in
the following way:

\begin{enumerate}

\item Increment the parameter \texttt{ipnfoms} in module \texttt{numerics} in
  source file \texttt{numerics.f90} to accommodate the new figure of merit.

\item Assign a description of the new figure of merit to the relevant element
  of array \texttt{lablmm} in module \texttt{numerics} in source file
  \texttt{numerics.f90}.

\item Add the new figure of merit equation to routine \texttt{FUNFOM} in
  source file \texttt{evaluators.f90}, following the method used in the
  existing examples. The value of \texttt{fc} should be of order unity, so
  select a reasonable scaling factor if necessary. Ensure that all the
  variables used in the new equation are contained in the modules specified
  via \texttt{use} statements present at the start of this file.

\item Add dated comments (using \verb.!+ad_hist.) to the headers of
  all affected routines and modules.

\item Modify Table~\ref{tab:foms} of this User Guide
  (\texttt{UserGuide\_Chapter2.tex}).

%\item Modify \texttt{process\_dicts.py} accordingly.

\end{enumerate}

\section{Scanning Variables}

Scanning variables (see Section~\ref{sec:scans}) are added to \process\ in
the following way:

\begin{enumerate}

\item Increment the parameter \texttt{ipnscnv} in module \texttt{scan\_module}
  in source file \texttt{scan.f90} to accommodate the new scanning variable.

\item Add a short description of the new scanning variable to the
  \texttt{nsweep} entry in source file \texttt{scan.f90}.

\item Add a new assignment to the relevant part of routine \texttt{SCAN} in
  source file \texttt{scan.f90}, following the examples already present,
  including the inclusion of a short description of the new scanning variable
  in variable \texttt{xlabel}.

\item Ensure that the scanning variable used in the assignment is contained in
  one of the modules specified via \texttt{use} statements present at the
  start of this routine.

\item Add dated comments (using \verb.!+ad_hist.) to the headers of
  all affected routines and modules.

\item Modify Table~\ref{tab:scans} of this User Guide
  (\texttt{UserGuide\_Chapter2.tex}).

%\item Modify \texttt{process\_dicts.py} if necessary.

\end{enumerate}

\section{Submission of New Models}

The \process\ source code is maintained by CCFE, and resides in a
\textit{Git}~\cite{git} repository on the CCFE servers. We welcome
contributions of alternative or improved models and algorithms.

The Fortran~90/95 source code has a uniform visual style and structural
layout. CCFE will transfer any contributed models into \process, in order for
us to maintain its present coding standard. To simplify this task, we request
that contributors provide the following information for any new models that
they provide:

\begin{itemize}

\item A comprehensive description of the model; please provide a full list of
  references.

\item A list of all inputs and outputs: descriptions, default (input) values,
  allowed ranges, units.

\item If possible, please cross-reference any input/output variables to
  existing global variables listed in the variable descriptor file (see
  Section~\ref{sec:vardes}).

\item A description of any new numerics requirements (input parameters,
  iteration variables, constraint equations, figures of merit etc.).

\item A definition of any pre-requisites.

\item A description of any side-effects.

\item Any available test data, code examples or test programs (in Fortran or
  other language) would be useful.

\end{itemize}

