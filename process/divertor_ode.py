from typing import Callable
import numpy as np
from scipy.integrate import solve_ivp

from process.fortran import (
    build_variables,
    div_kal_vars,
    divertor_variables,
    divertor_ode,
    constants,
    read_and_get_atomic_data,
    read_radiation,
    physics_variables,
    divertor_ode_var,
    impurity_radiation_module,
    process_output as po,
    numerics,
)

STEP_NUM = 200


class DivertorOde:
    def __init__(self):
        self.outfile = constants.nout

        divertor_ode.impurities_present[:] = False
        # Set entire array to false
        divertor_ode.aplas = 2.5e0
        divertor_ode.fluxdens_to_pa = 1.0e0 / 1.55e23
        divertor_ode.kappa0 = 2390.0e0
        divertor_ode.mi = 0.0e0
        divertor_ode.eightemi = 0.0e0
        divertor_ode.eightemi48 = 0.0e0
        divertor_ode.eleion = 0.0e0
        divertor_ode.v01 = 0.0e0
        divertor_ode.v02 = 0.0e0
        divertor_ode.circumference_omp = 0.0e0
        divertor_ode.circumference_target = 0.0e0
        divertor_ode.circumf_bu = 0.0e0
        divertor_ode.area_target = 0.0e0
        divertor_ode.area_omp = 0.0e0
        divertor_ode.zeff_div = 0.0e0
        divertor_ode.sol_broadening = 0.0e0
        divertor_ode.lengthofwidesol = 0.0e0

    def run(self, output: bool = False):
        (
            div_kal_vars.psep_kallenbach,
            div_kal_vars.teomp,
            div_kal_vars.neomp,
        ) = self.divertor_kallenbach(
            rmajor=physics_variables.rmajor,
            rminor=physics_variables.rminor,
            bt=physics_variables.bt,
            plascur=physics_variables.plascur,
            q=physics_variables.q,
            ttarget=div_kal_vars.ttarget,
            qtargettotal=div_kal_vars.qtargettotal,
            targetangle=div_kal_vars.targetangle,
            bp=physics_variables.bp,
            output=output,
        )

    def divertor_kallenbach(
        self,
        rmajor,
        rminor,
        bt,
        plascur,
        q,
        ttarget,
        qtargettotal,
        targetangle,
        bp,
        output: bool = False,
    ):
        """calculate radiative loss and plasma profiles along a flux tube including momentum losses
        author: M Kovari, CCFE, Culham Science Centre
        Calculate radiative loss and plasma profiles along a flux tube including momentum losses.
        Description in A. Kallenbach et al., PPCF 58 (2016) 045013, this version based on that
        sent by Arne 17.5.2016.
        Note this solver is not suitable for stiff equations - which these are. Instead I have
        set the neutral density derivatives to zero when the neutral density is small.
        https://people.sc.fsu.edu/~jburkardt/f_src/ode/ode.html
        """

        # Electron sheath energy transmission coefficient
        gammae = 5.5e0
        # Ion energy reflection coefficient
        energyreflection = 0.5e0
        # Ion sheath energy transmission coefficient
        # Issue #500 item 3. Adjust sheath heat transmission coefficient for ion reflection.
        gammai = 2.5e0 * (1e0 - energyreflection)
        # Sheath energy transmission coefficient (kallenbach paper pg. 4)
        gammasheath = gammae + gammai

        degree = np.pi / 180

        # Initialise local variables
        element = "**"
        step0 = 0.0002

        # Major radius at outer midplane [m]
        romp = rmajor + rminor

        # Typical SOL temperature, used only for estimating zeffective in the SOL [eV]
        ttypical = 1000.0e0 * physics_variables.tesep / 2.0e0
        # B theta at OMP
        Bt_omp = -bt * rmajor / romp  # OK
        # B theta at target
        # On the first iteration build_variables.rspo may still have its initial value of zero:
        if build_variables.rspo < 1.0e0:
            build_variables.rspo = rmajor
        Bt_target = -bt * rmajor / build_variables.rspo  # OK

        # Cylindrical approximation for field at OMP due to plasma current
        # BpPlasmaOmp = constants.rmu0 * plascur / (2.0e0 * np.pi * rminor)

        # At the OMP the vertical field generated by the equilibrium field coils
        # (assumed approximately constant), adds to the field generated by the plasma.
        # This formula not used as it doesn't seem to agree with the eqdsk data.
        # Bp_omp = BpPlasmaOmp + abs(bvert)
        # Bp_target = 0.35e0 * bp / 0.956e0     Obsolete

        # At the target the poloidal field is much smaller, as it is near the X-point.
        # Issue #500 item 6, comparing the poloidal field at the target given in a
        # DEMO eqdsk file, with the nominal Bpoloidal from PROCESS.  2018/6/14
        Bp_target = 0.5e0 * bp / 0.921e0
        Bp_omp = 1.35e0 * bp / 0.921e0

        Btotal_omp = np.sqrt(Bp_omp**2 + Bt_omp**2)  # OK
        #   Btotal_target = sqrt(Bp_omp**2 + Bt_target**2)  NOT OK
        Btotal_target = np.sqrt(Bp_target**2 + Bt_target**2)  # 2018/06/14

        # Sine of pitch angle
        sin_pitch_angle = abs(Bp_target / Btotal_target)
        # Ratio: target area perp to B / target wetted area
        sinfact = 1.0e0 / (np.sin(targetangle * degree) * sin_pitch_angle)
        # Angle between B and the surface normal (deg)
        # psi = 90.0e0 - acos(1.0e0/sinfact)/degree  NOT OK
        # Equation 19.
        psi = (
            np.arccos(np.sin(targetangle * degree) * abs(Bp_target / Btotal_target))
            / degree
        )  # 2018/06/14

        # Connection length from OMP to target
        # MDK Issues #494, #497
        # div_kal_vars.lambda_q_omp is taken to be the relevant radial distance from the separatrix at the OMP.
        # `lcon_factor` is still available but not recommended.
        lcon = (
            div_kal_vars.lcon_factor
            * (np.pi * q * rmajor / 93.2)
            * (21.25 * np.log(1 / div_kal_vars.lambda_q_omp) - 8.7)
        )

        divertor_ode.lengthofwidesol = div_kal_vars.fractionwidesol * lcon
        # lambda_q_target is no longer an input.
        lambda_q_target = div_kal_vars.lambda_q_omp + div_kal_vars.target_spread
        divertor_ode.sol_broadening = lambda_q_target / div_kal_vars.lambda_q_omp

        # Populate array that says which impurities are present
        # Helium is always present (even if ralpne is initially zero)
        divertor_ode.impurities_present[1] = True

        # Loop over the remaining PROCESS impurities
        for i in range(2, impurity_radiation_module.nimp):
            if impurity_radiation_module.impurity_arr_frac[i] > 1.0e-10:
                divertor_ode.impurities_present[i] = True

        # Get impurity concentrations every time, as they can change
        for i in range(1, impurity_radiation_module.nimp):
            if divertor_ode.impurities_present[i]:
                divertor_ode_var.impurity_concs[i] = (
                    impurity_radiation_module.impurity_arr_frac[i]
                    * div_kal_vars.impurity_enrichment[i]
                )
            else:
                divertor_ode_var.impurity_concs[i] = 0.0e0

        # ion mass [kg]
        divertor_ode.mi = constants.umass * divertor_ode.aplas

        # Dissociation energy, T2 to 2T = 4.59 eV
        # Ionization energy, T to T+ e- = 13.55 eV
        # http://energy.gov/sites/prod/files/2013/07/f2/hdbk1129.pdf
        # D2: Experimental Ionization Energy is 13.603 eV
        # Dissociation energy, D2 to 2e = 4.52 eV
        # Use approx mean values: dissociation: 4.6 eV per molecule, ionization 13.6 eV.
        # Energy released at the target from surface recombination of ions and association (per ion)
        # = 13.6 +  4.6/2 = 15.9 eV
        # Note Kallenbach figure was 15.0 eV.

        # See Figure 7, which uses target heat load, "not counting recombination energy".
        Erecomb = 15.9e0

        # volume recombination energy (assumed to be lost as radiation) [eV]
        # Evolrec = 13.6e0

        # I think this term is the influence of recombination on the energy balance,
        # which is neglected in the paper

        # electron energy loss due to ionization [eV]
        Eion = 15.0e0

        # includes some dissociation. H radiation treated explicitly  [eV].  eq 4.  Ref?
        # kinetic energy [eV] for the first group of neutrals (p. 4)
        Eneutrals = 5.0e0

        # set up relative distribution between 2 neutral particle classes, p. 4.
        neutfrac1 = 0.5e0
        neutfrac2 = 1.0e0 - neutfrac1

        # factor by which neutral penetration is enhanced to simulate 1/20 fieldline
        # pitch at target this is just the the velocity ratio on page 4
        neutpenfact2 = 10.0e0

        # useful parameter combinations
        divertor_ode.eightemi = 8.0e0 * constants.echarge * divertor_ode.mi
        divertor_ode.eightemi48 = divertor_ode.eightemi * 1.0e48
        divertor_ode.eleion = constants.echarge * Eion

        # (Stangeby NF 51 (2011), equation 1 of Kallenbach)
        # bu = sin(atan(abs(Bp_omp/Bt_omp)))  Simplify this:
        # bu = Bp_omp / Btotal_omp   # 2018/06/14

        # Actual circumference at OMP and target [m]
        divertor_ode.circumference_omp = 2.0e0 * np.pi * romp  # OK
        divertor_ode.circumference_target = 2.0e0 * np.pi * build_variables.rspo  # OK

        # Poloidal flux through flux tube at OMP 2018/6/15
        # psi_p_omp = Bp_omp * divertor_ode.circumference_omp * div_kal_vars.lambda_q_omp
        # Poloidal flux through flux tube at target 2018/6/15
        # Remember that 'lambda_q_target' (so-called) is mapped to the OMP.
        psi_p_target = Bp_omp * divertor_ode.circumference_omp * lambda_q_target

        # Circumference measured normal to B at OMP [m]
        # divertor_ode.circumf_bu = divertor_ode.circumference_omp*bu  Simplify:
        divertor_ode.circumf_bu = (
            divertor_ode.circumference_omp * Bp_omp / Btotal_omp
        )  # 2018/4/16
        # Flux bundle area perp. to B at omp [m2]
        divertor_ode.area_omp = (
            divertor_ode.circumf_bu * div_kal_vars.lambda_q_omp
        )  # OK

        # neutral velocity along the flux bundle, group 1 [m/s]
        v0 = 0.25e0 * np.sqrt(
            8.0e0 / np.pi * constants.echarge * Eneutrals / divertor_ode.mi
        )
        # Rename this for consistency
        divertor_ode.v01 = v0
        # neutral velocity along the flux bundle, group 2 [m/s]
        divertor_ode.v02 = v0 * neutpenfact2

        # Sound speed [m/s]
        cs0 = np.sqrt(2.0e0 * constants.echarge * ttarget / divertor_ode.mi)
        # To prevent division by zero at the target, insert a factor just less than 1.
        cs0minus = cs0 * div_kal_vars.mach0

        # Chodura sheath width (m).  Sin psi taken = 1.
        # Stangeby Equation 2.112
        lchodura = np.sqrt(6) * ttarget / (Btotal_target * cs0)

        # Flux bundle area perp. to B at target [m2]
        # Include total flux expansion here (but not consistently) 2018/6/15
        divertor_ode.area_target = (
            divertor_ode.area_omp
            * divertor_ode.sol_broadening
            * Btotal_omp
            / Btotal_target
        )
        # Wetted area on target [m2]
        WettedArea = divertor_ode.area_target * sinfact
        # Wetted length on target measured in poloidal plane [m]
        WettedLength = WettedArea / divertor_ode.circumference_target
        # Simplify, using poloidal flux
        WettedAreaComparison = (
            psi_p_target / Bp_target / np.sin(targetangle * degree)
        )  # 2018/6/16
        WettedLengthComparison = (
            WettedAreaComparison / divertor_ode.circumference_target
        )  # 2018/6/16

        # Area on which the power due to isotropic losses from SOL energy is incident [m2]
        # Issue #497 Change romp to build_variables.rspo
        # receiving_area = divertor_ode.circumference_target * 2.0e0 * WettedLength

        # The connection length used for calculating the "near zone":
        sab = (
            2.0e0
            * WettedLength
            / np.cos(targetangle * degree)
            * Btotal_target
            / Bp_target
        )

        # Calculate the power density carried by the plasma from the total power density
        # on the target which includes surface recombination and association [W/m2]
        qtarget = qtargettotal / (1.0 + Erecomb / gammasheath / ttarget)

        # Mach=1 is assumed as boundary condition at the target
        # This equation not stated explicitly in the paper.
        # Plasma density near target [m-3]
        nel0 = (
            qtarget * sinfact / (gammasheath * constants.echarge * ttarget * cs0minus)
        )

        # Ion flux density perp to B at target [m-2.s-1]
        partfluxtar = nel0 * cs0minus

        # Estimate of corresponding neutral pressure, assuming conservation of flux densities the
        # factor converts the flux density at the target into a molecular pressure at room temperature.
        # This is a conventional quantity only.
        # Nominal neutral pressure at target [p0partflux] [Pa]
        p0partflux = partfluxtar * divertor_ode.fluxdens_to_pa / sinfact

        # Find mean Z and mean Z^2 at a typical temperature 'ttypical' for each impurity
        # Sum + 1 to get Zeffective
        divertor_ode.zeff_div = 1.0e0
        for i in range(1, impurity_radiation_module.nimp):
            if divertor_ode.impurities_present[i]:
                element = impurity_radiation_module.imp_label[i]
                z = read_radiation.read_lz(
                    element,
                    ttypical,
                    div_kal_vars.netau_sol,
                    mean_z=True,
                    mean_qz=False,
                    verbose=False,
                )
                qz = read_radiation.read_lz(
                    element,
                    ttypical,
                    div_kal_vars.netau_sol,
                    mean_z=False,
                    mean_qz=True,
                    verbose=False,
                )
                divertor_ode.zeff_div = (
                    divertor_ode.zeff_div
                    + divertor_ode_var.impurity_concs[i] * (qz - z)
                )

        # Initialise independent variables for differential equations
        # neutral density in group 1 [m-3]
        n010 = partfluxtar * neutfrac1 / divertor_ode.v01

        # neutral density in group 2 [m-3]
        n020 = partfluxtar * neutfrac2 / divertor_ode.v02

        # electron temperature [eV]
        te0 = ttarget

        # n*v [m-2.s-1]
        nv0 = -nel0 * cs0minus

        # Pressure  (Kallenbach paper equation 6) [Pa]
        div_kal_vars.pressure0 = (
            divertor_ode.mi * nv0**2.0e0 / nel0
            + nel0 * 2.0e0 * constants.echarge * te0
        )

        # n*T [eV.m-3]
        nete0 = nel0 * te0

        # Total power running along SOL [W]
        Power0 = qtarget * WettedArea

        # Power deposited on target by recombination of hydrogenic ions [W]
        ptarget_recomb = (
            Erecomb * constants.echarge * nel0 * cs0minus * divertor_ode.area_target
        )

        # Power density on target due to surface recombination [W/m2]
        qtargetrecomb = ptarget_recomb / WettedArea

        # Total power on target [W]
        # powertargettotal = Power0 + ptarget_recomb

        y0 = [
            n010 * 1.0e-20,  # y(1) = neutral density (group 1) [1e20 m-3]
            n020 * 1.0e-20,  # y(2) = neutral density (group 2) [1e20 m-3]
            te0,  # y(3) = temperature [eV]
            nv0 * 1.0e-24,  # y(4) = ion flux [1e24 m-3 s-1]
            div_kal_vars.pressure0,
            Power0 / 1.0e6,  # y(6) = power in SOL [MW]
            1.0e0,  # Y(7) = 1 + integral of impurity radiation loss [MW]
            1.0e0,  # Y(8) = 1 + integral of radiation loss from hydrogenic species [MW]
            1.0e0,  # Y(9) = 1 + integral of power loss due to charge exchange [MW]
            1.0e0,  # Y(10)= 1 + integral of power loss due to electron impact ionisation [MW]
        ]
        # Use logarithmic spacing for the x values along the SOL
        factor = 10.0e0 ** (np.log10(lcon / step0) / STEP_NUM)
        time_steps = [step0 * factor**i for i in range(STEP_NUM + 1)]
        f = self._get_differential(
            divertor_ode.eightemi48,
            div_kal_vars.netau_sol,
            divertor_ode.lengthofwidesol,
            divertor_ode.area_target,
            divertor_ode.area_omp,
            divertor_ode.mi,
            divertor_ode.aplas,
            divertor_ode.eleion,
            divertor_ode.v01,
            divertor_ode.v02,
            divertor_ode.zeff_div,
            divertor_ode_var.impurity_concs,
        )

        # Radau algorithm chosen because it provides the closest values
        # to the Fortran ODE solver. This tracks with the fact Radau is
        # appropriate for stiff problems, of which this is.
        # BDF is another algorithm that appears to work equally as well.
        # However, Radau is marginally quicker in my testing.

        # Allowing the solver to choose its own "method", again, works
        # but slows the solving process down by about 3x.
        ode_solution = solve_ivp(
            f,
            (0, time_steps[-1]),
            y0,
            t_eval=time_steps,
            method="Radau",
            rtol=1e-4,
            atol=1e-4,
        )

        # we want the following variables to be set within the loop
        # and be available after the loop as their value in the last
        # iteration of the loop
        raddensspecies = np.zeros(14)

        a_cross = (
            divertor_ode.area_target
            if 0 < divertor_ode.lengthofwidesol
            else divertor_ode.area_omp
        )

        neutral_target0 = n010 + n020
        bracket0 = max(
            div_kal_vars.pressure0**2 - divertor_ode.eightemi48 * te0 * nv0**2, 0
        )
        n0 = (div_kal_vars.pressure0 + np.sqrt(bracket0)) / (
            4 * constants.echarge * te0
        )
        v0 = nv0 / n0
        qperp_conv0 = (
            -(5 * constants.echarge * te0 + 0.5 * divertor_ode.mi * v0**2) * nv0
        )  # Convective heat flux is positive [W/m2]
        qperp_total0 = Power0 / a_cross
        qperp_conducted0 = qperp_total0 - qperp_conv0  # Conducted heat flux [W/m2]
        ptarget_conv0 = qperp_conv0 * a_cross
        ptarget_cond0 = qperp_conducted0 * a_cross

        y = ode_solution.y[:, -1]

        # Derived quantities need to be recalculated at each data point and converted to SI units
        n01 = y[0] * 1e20
        n02 = y[1] * 1e20
        te = y[2]
        nv24 = y[3]
        # nv = nv24 * 1e24
        pressure = y[4]
        power = y[5] * 1e6

        # Calculate density [m-3]
        bracket = max(pressure**2 - divertor_ode.eightemi48 * te * nv24**2, 0)
        n = (pressure + np.sqrt(bracket)) / (4 * constants.echarge * te)
        # nel20 = n / 1e20
        nelsquared = n**2

        # pthermal = 2 * n * te * constants.echarge  # Thermal pressure [Pa]

        # v = nv / n
        # n0e20 = y[0] + y[1]  # Neutral density [1e20.m-3]
        # qperp_total = (
        # power / a_cross
        # )  # Heat flux perpendicular to flux tube cross section [W/m2]

        # cs = np.sqrt(2 * constants.echarge * te / divertor_ode.mi)
        # mach = -v / cs
        nete = n * te

        n0 = n01 + n02  # Neutral density

        (s, _, rcx, _, _) = read_and_get_atomic_data.get_h_rates(
            n, te, divertor_ode.aplas, verbose=False
        )

        # cxrate = rcx * n * n0  # charge exchange rate
        # ionrate1 = s * n * n01  # ionisation of neutrals: velocity group 1
        # ionrate2 = s * n * n02  # ionisation of neutrals: velocity group 2
        # recrate = al * nelsquared  # volume recombination rate
        # plossdenscx = (
        #     constants.echarge * te * cxrate
        # )  # energy conservation: equation 4, charge exchange term
        # plossion = (
        #     ionrate1 + ionrate2
        # ) * divertor_ode.eleion  # energy conservation: equation 4, ionisation term
        # radHdens = (
        #     (plt + prb) * n0 * n
        # )  # radiation loss density for neutral hydrogenic species

        raddens = 0

        for i in range(1, 14):
            if divertor_ode_var.impurity_concs[i] == 0:
                continue

            lz = read_radiation.read_lz(
                impurity_radiation_module.imp_label[i],
                te,
                div_kal_vars.netau_sol,
                mean_z=False,
                mean_qz=False,
                verbose=False,
            )
            raddensspecies[i] = (
                lz * divertor_ode_var.impurity_concs[i] * nelsquared
            )  # Store species-specific radiation loss density
            raddens += raddensspecies[i]  # Total impurity radiation loss density

        y7 = y[6] - 1
        y8 = y[7] - 1
        y9 = y[8] - 1
        y10 = y[9] - 1

        qtarget_isotropic = 0
        tmp_x = 0
        for (i, tmp_xout) in enumerate(ode_solution.t):

            if tmp_x < sab and tmp_xout > sab:
                tmp_y7 = ode_solution.y[6, i] - 1
                tmp_y8 = ode_solution.y[7, i] - 1
                tmp_y9 = ode_solution.y[8, i] - 1
                qtarget_isotropic = (
                    0.5
                    * 1e6
                    * (tmp_y7 + tmp_y8 + tmp_y9 * (1 - energyreflection))
                    / (2 * WettedArea)
                )

            tmp_x = tmp_xout

        psep_kallenbach = (
            2.3 * power
        )  # Power conducted through the separatrix, calculated by divertor model [W]

        totalpowerlost = (
            y7 + y8 + y9 + y10
        ) * 1e6  # Total power lost due to radiation, ionisation and recombination [W]
        balance = (
            y[6] * 1e6 - totalpowerlost - Power0
        )  # Power balance - should be zero [W]

        # Midplane (upstream) and integrated quantities
        ptarget_isotropic = qtarget_isotropic * WettedArea
        # This total is for checking only
        ptarget_total = (
            ptarget_conv0 + ptarget_cond0 + ptarget_recomb + ptarget_isotropic
        )

        div_kal_vars.fmom = 2 * nete0 / nete  # momentum factor [-]

        divertor_variables.hldiv = (qtargettotal + qtarget_isotropic) * 1e-6

        # Ion flux density on target [m-2s-1]
        ionfluxtarget = partfluxtar / sinfact

        if output:
            impuritypowerlost = y7 * 1.0e6
            hydrogenicpowerlost = y8 * 1.0e6
            exchangepowerlost = y9 * 1.0e6
            ionisationpowerlost = y10 * 1.0e6

            pitch_angle = np.arcsin(sin_pitch_angle) / degree
            poloidal_flux_expansion = Bp_omp / Bp_target
            qtargetcomplete = qtargettotal + qtarget_isotropic
            # Just to check
            ptarget_complete = qtargetcomplete * WettedArea

            po.oheadr(self.outfile, "Divertor: Kallenbach 1D Model")
            po.ocmmnt(self.outfile, "For graphical output use kallenbach_plotting.py")

            po.osubhd(self.outfile, "Global SOL properties and geometry:")
            po.ovarre(self.outfile, "Connection length:  [m]", "(lcon)", lcon, "OP ")
            po.ovarre(
                self.outfile,
                "Parameter for approach to local equilibrium  [ms.1e20/m3]",
                "(netau_sol)",
                div_kal_vars.netau_sol,
            )
            po.ovarre(
                self.outfile,
                "Typical SOL temperature, used only for estimating zeff_div [eV] ",
                "(ttypical)",
                ttypical,
                "OP ",
            )
            po.ocmmnt(
                self.outfile,
                "The zeff_div is used only for estimating thermal conductivity of the SOL plasma.",
            )
            po.ovarre(
                self.outfile,
                "Z effective [W] ",
                "(zeff_div)",
                divertor_ode.zeff_div,
                "OP ",
            )

            po.ovarre(
                self.outfile, "Plasma major radius [m]  ", "(rmajor)", rmajor, "OP "
            )
            po.ovarre(
                self.outfile, "Outboard midplane radius [m]  ", "(romp)", romp, "OP "
            )
            po.ovarre(
                self.outfile,
                "Outboard strike point radius [m]  ",
                "(rspo)",
                build_variables.rspo,
                "OP ",
            )

            po.ovarre(
                self.outfile,
                "Toroidal field at outboard midplane [T] ",
                "(Bt_omp)",
                Bt_omp,
                "OP ",
            )
            po.ovarre(
                self.outfile,
                "Poloidal field at outboard midplane [T] ",
                "(Bp_omp)",
                Bp_omp,
                "OP ",
            )
            po.ovarre(
                self.outfile,
                "Total field at outboard midplane [T]  ",
                "(Btotal_omp)",
                Btotal_omp,
                "OP ",
            )
            po.ovarre(
                self.outfile,
                "Toroidal field at strike point [T]   ",
                "(Bt_target)",
                Bt_target,
                "OP ",
            )
            po.ovarre(
                self.outfile,
                "Poloidal field at strike point [T]   ",
                "(Bp_target)",
                Bp_target,
                "OP ",
            )
            po.ovarre(
                self.outfile,
                "Poloidal flux expansion: Bp_omp/Bp_target",
                "(poloidal_flux_expansion)",
                poloidal_flux_expansion,
                "OP ",
            )

            po.osubhd(self.outfile, "Properties of SOL plasma :")
            po.ovarre(
                self.outfile,
                "SOL power fall-off length at the outer midplane [m]",
                "(lambda_q_omp)",
                div_kal_vars.lambda_q_omp,
            )
            po.ovarre(
                self.outfile,
                "SOL radial thickness at the target, mapped to OMP [m]",
                "(lambda_q_target)",
                lambda_q_target,
            )
            po.ovarre(
                self.outfile,
                "SOL area (normal to B) at outer midplane [m2]",
                "(area_omp)",
                divertor_ode.area_omp,
                "OP ",
            )
            po.ovarre(
                self.outfile,
                "SOL area (normal to B) at target [m2]",
                "(area_target)",
                divertor_ode.area_target,
                "OP ",
            )
            po.ovarre(
                self.outfile,
                "Plasma temperature at outer midplane [eV]",
                "(teomp)",
                te,
                "OP ",
            )
            po.ovarre(
                self.outfile,
                "Plasma density at outer midplane [m-3]",
                "(neomp)",
                n,
                "OP ",
            )
            if numerics.active_constraints[70]:
                po.ocmmnt(self.outfile, "Constraint 71 is applied as follows.")
                po.ovarre(
                    self.outfile,
                    ". Ratio: SOL density at OMP / separatrix density",
                    "(neratio)",
                    div_kal_vars.neratio,
                )
            else:
                po.ocmmnt(
                    self.outfile,
                    "Separatrix density consistency constraint 71 is NOT applied",
                )

            po.ovarre(
                self.outfile,
                ". COMPARISON: Plasma density at separatrix [m-3]",
                "(nesep.)",
                physics_variables.nesep,
                "OP ",
            )

            po.ovarre(
                self.outfile,
                "Poloidal field at outer midplane [T]",
                "(Bp_omp)",
                Bp_omp,
                "OP ",
            )
            po.ovarre(
                self.outfile,
                "Power at outer midplane [W] ",
                "(Powerup)",
                power,
                "OP ",
            )
            po.ovarre(
                self.outfile,
                "Power conducted through the separatrix, calculated by divertor model [W] ",
                "(psep_kallenbach)",
                psep_kallenbach,
                "OP ",
            )
            if numerics.active_constraints[68]:
                po.ocmmnt(
                    self.outfile,
                    "Separatrix power consistency constraint 69 is applied",
                )
            else:
                po.ocmmnt(
                    self.outfile,
                    "Separatrix power consistency constraint 69 is NOT applied",
                )

            po.ovarre(
                self.outfile,
                ". COMPARISON: Separatrix power from main plasma model [MW]",
                "(pdivt.)",
                physics_variables.pdivt,
                "OP ",
            )

            po.ovarre(
                self.outfile,
                "Ratio: psep_kallenbach / Powerup ",
                "(seppowerratio)",
                2.3,
            )

            po.osubhd(
                self.outfile, "Properties of SOL plasma adjacent to divertor sheath :"
            )
            po.ovarre(
                self.outfile, "Ion sound speed near target [m/s] ", "(cs0)", cs0, "OP "
            )
            po.ovarre(
                self.outfile, "Plasma density near target [m-3] ", "(nel0)", nel0, "OP "
            )
            po.ovarre(
                self.outfile,
                "Ion flux density perp to B at target m-2s-1 ",
                "(partfluxtar)",
                partfluxtar,
                "OP ",
            )
            po.ovarre(
                self.outfile,
                "Ion flux density on target [partfluxtar/sinfact]  m-2s-1 ",
                "(ionfluxtarget)",
                ionfluxtarget,
                "OP ",
            )
            po.ovarre(
                self.outfile,
                "Neutral density at target [m-3] ",
                "(neutral_target)",
                neutral_target0,
                "OP ",
            )
            po.ovarre(
                self.outfile,
                "Nominal neutral pressure at target [Pa] ",
                "(p0partflux)",
                p0partflux,
                "OP ",
            )
            po.ovarre(
                self.outfile,
                "Plasma temperature near target [eV] ",
                "(ttarget)",
                ttarget,
            )

            po.ovarre(
                self.outfile,
                "Total plasma pressure near target (thermal+dynamic) [Pa] ",
                "(pressure0)",
                div_kal_vars.pressure0,
                "OP ",
            )
            po.ovarre(
                self.outfile, "momentum factor [-] ", "(fmom)", div_kal_vars.fmom, "OP "
            )
            po.ovarre(
                self.outfile,
                "Nominal Chodura sheath width [m] ",
                "(lchodura)",
                lchodura,
                "OP ",
            )

            po.osubhd(self.outfile, "Divertor target parameters :")
            po.ovarre(
                self.outfile,
                "Angle between flux surface and normal to divertor target [deg]",
                "(targetangle)",
                targetangle,
            )
            po.ovarre(
                self.outfile,
                "Pitch angle of field line at target [deg]",
                "(pitch_angle)",
                pitch_angle,
                "OP ",
            )
            po.ovarre(
                self.outfile,
                "Angle between B and the normal to divertor target [deg]",
                "(psi)",
                psi,
                "OP ",
            )

            po.ovarre(
                self.outfile,
                "Ratio: area of flux tube perpendicular to B / target wetted area  ",
                "(sinfact)",
                sinfact,
                "OP ",
            )

            po.ovarre(
                self.outfile,
                "Total power on target [W]",
                "(ptarget_total)",
                ptarget_total,
                "OP ",
            )
            po.ovarre(
                self.outfile,
                "Total power on target [W]",
                "(ptarget_complete)",
                ptarget_complete,
                "OP ",
            )
            po.ocmmnt(self.outfile, "These should be equal.")

            po.ovarre(
                self.outfile,
                "Power on target due to convection [W]",
                "(ptarget_conv)",
                ptarget_conv0,
                "OP ",
            )
            po.ovarre(
                self.outfile,
                "Power on target due to conduction [W]",
                "(ptarget_cond)",
                ptarget_cond0,
                "OP ",
            )
            po.ovarre(
                self.outfile,
                "Power on target due to surface recombination [W]",
                "(ptarget_recomb)",
                ptarget_recomb,
                "OP ",
            )
            po.ovarre(
                self.outfile,
                "Power on target due to isotropic losses [W]",
                "(ptarget_isotropic)",
                ptarget_isotropic,
                "OP ",
            )

            po.ovarre(
                self.outfile,
                '"Wetted area" of target [m2]',
                "(WettedArea)",
                WettedArea,
                "OP ",
            )
            po.ovarre(
                self.outfile,
                '"Wetted length" of target measured in poloidal plane [m]',
                "(WettedLength)",
                WettedLength,
                "OP ",
            )
            po.ocmmnt(self.outfile, "Alternative calculation:")

            po.ovarre(
                self.outfile,
                '"Wetted area" of target [m2]',
                "(WettedAreaComparison)",
                WettedAreaComparison,
                "OP ",
            )
            po.ovarre(
                self.outfile,
                '"Wetted length" of target measured in poloidal plane [m]',
                "(WettedLengthComparison)",
                WettedLengthComparison,
                "OP ",
            )

            po.ovarre(
                self.outfile,
                "Total power density on target [W/m2]",
                "(qtargetcomplete)",
                qtargetcomplete,
            )
            po.ovarre(
                self.outfile,
                "Power density on target due to conduction and convection [W/m2]",
                "(qtarget)",
                qtarget,
                "OP ",
            )
            po.ovarre(
                self.outfile,
                "Power density on target due to surface recombination [W/m2]",
                "(qtargetrecomb)",
                qtargetrecomb,
                "OP ",
            )
            po.ovarre(
                self.outfile,
                "Power density on target due to isotropic losses from SOL [W/m2]",
                "(qtarget_isotropic)",
                qtarget_isotropic,
                "OP ",
            )
            po.ocmmnt(
                self.outfile,
                '(Based on 1/2 x (radiation + CX) in first "sab" of flux line.)',
            )
            po.ovarre(
                self.outfile,
                'Connection length used for "near zone" (m)',
                "(sab)",
                sab,
                "OP ",
            )
            po.ovarre(
                self.outfile,
                "Length of broadened downstream part of SOL [m]",
                "(lengthofwidesol)",
                divertor_ode.lengthofwidesol,
                "OP ",
            )

            po.osubhd(self.outfile, "Integrated powers :")
            po.ovarre(
                self.outfile,
                "Power lost due to impurity radiation [W] ",
                "(impuritypowerlost)",
                impuritypowerlost,
                "OP ",
            )
            po.ovarre(
                self.outfile,
                "Power lost due to hydrogenic radiation [W] ",
                "(hydrogenicpowerlost)",
                hydrogenicpowerlost,
                "OP ",
            )
            po.ovarre(
                self.outfile,
                "Power lost due to charge exchange  [W] ",
                "(exchangepowerlost)",
                exchangepowerlost,
                "OP ",
            )
            po.ovarre(
                self.outfile,
                "Power lost due to electron impact ionisation [W] ",
                "(ionisationpowerlost)",
                ionisationpowerlost,
                "OP ",
            )
            po.ovarre(
                self.outfile,
                "Total power lost due to radiation, ionisation and recombination [W] ",
                "(totalpowerlost)",
                totalpowerlost,
                "OP ",
            )
            po.ovarre(
                self.outfile, "Power balance error [W] ", "(balance)", balance, "OP "
            )

            po.ocmmnt(
                self.outfile, "The following impurities are used in the divertor model:"
            )
            # write(self.outfile, '(a17, 13a9)')'',(imp_label(i), i=2,14)
            # write(self.outfile, '(a17, 13es9.1)')'Fraction in SOL', (impurity_concs(i), i=2,14)
            # write(self.outfile, '(a17, 13es9.1)')'Enrichment', (impurity_enrichment(i), i=2,14)
        return psep_kallenbach, te, n

    def _get_differential(
        self,
        eightemi48,
        netau_sol,
        lengthofwidesol,
        area_target,
        area_omp,
        mi,
        aplas,
        eleion,
        v01,
        v02,
        zeff_div,
        impurity_concs,
    ) -> Callable[[np.floating, np.ndarray], np.ndarray]:
        """Creates the differential equation to solve.

        It does this by taking parameters as inputs to this function
        and injecting them into the nested `differential`. This means
        the differential only has to take `t` and `y` as inputs, as
        stipulated by the SciPy ODE solver API.

        :param eightemi48: 8 * electron charge * mi * 10^48
        :type eightemi48: float
        :param netau_sol: Parameter describing the departure from local ionisation equilibrium in the SOL.
        :type netau_sol: float
        :param lengthofwidesol: Length of broadened downstream part of SOL [m]
        :type lengthofwidesol: float
        :param area_target: SOL area (normal to B) at target [m2]
        :type area_target: float
        :param area_omp: SOL area (normal to B) at outer midplane [m2]
        :type area_omp: float
        :param mi: ion mass [kg]
        :type mi: float
        :param aplas: relative ion mass
        :type aplas: float
        :param eleion: Eion (electron energy loss due to ionization) * electron charge
        :type eleion: float
        :param v01: eutral velocity along the flux bundle for group 1
        :type v01: float
        :param v02: eutral velocity along the flux bundle for group 2
        :type v02: float
        :param zeff_div: Zeff for divertor region
        :type zeff_div: float
        :param impurity_concs: The concentrations of each impurity in the divertor region
        :type impurity_concs: ndarray[float]
        """

        def differential(t, y):
            # output vector
            yp = np.zeros((len(y),))

            # Rescale to SI units
            n01 = y[0] * 1e20
            n02 = y[1] * 1e20
            te = y[2]
            nv = y[3] * 1e24
            pressure = y[4]
            power = y[5] * 1e6
            nv24 = y[3]

            bracket = max(pressure**2 - eightemi48 * te * nv24**2, 0)

            n = (pressure + np.sqrt(bracket)) / (4 * constants.echarge * te)

            v = nv / n  # plasma velocity
            n0 = n01 + n02  # neutral density = sum of the two velocity groups

            lz_total = 0
            for i in range(1, impurity_radiation_module.nimp):
                if impurity_concs[i] == 0:
                    continue

                lz = read_radiation.read_lz(
                    impurity_radiation_module.imp_label[i],
                    te,
                    netau_sol,
                    mean_z=False,
                    mean_qz=False,
                    verbose=False,
                )
                lz_total += lz * impurity_concs[i]

            # impurity radiation loss density
            raddens = lz_total * n**2

            # The area of the flux tube, measured perpendicular to B
            # This is set to a step function as in Kallenbach

            A_cross = area_target if t < lengthofwidesol else area_omp

            qperp_total = power / A_cross
            # Convective heat flux is positive
            qperp_conv = -(5 * constants.echarge * te + 0.5 * mi * v**2) * nv
            # conducted heat flux
            qperp_conducted = qperp_total - qperp_conv

            (s, al, rcx, plt, prb) = read_and_get_atomic_data.get_h_rates(
                n, te, aplas, verbose=False
            )

            cxrate = rcx * n * n0  # charge exchange rate
            ionrate1 = s * n * n01  # ionisation of neutrals: velocity group 1
            ionrate2 = s * n * n02  # ionisation of neutrals: velocity group 2
            recrate = al * n**2  # volume recombination rate
            plossdenscx = (
                constants.echarge * te * cxrate
            )  # energy conservation: equation 4, charge exchange term
            plossion = (
                ionrate1 + ionrate2
            ) * eleion  # energy conservation: equation 4, ionisation term
            radHdens = (
                (plt + prb) * n0 * n
            )  # radiation loss density for neutral hydrogenic species

            yp[0] = 1e-20 * (-ionrate1 + recrate) / v01  # dn01dx - neutral continuity

            # TODO: why isnt it (-ionrate2 + recrate) as above? TN
            yp[1] = 1e-20 * (-ionrate2) / v02  # dn02dx - neutral continuity
            dnvdx = ionrate1 + ionrate2 - recrate  # dnvdx - ion continuity
            yp[3] = 1e-24 * dnvdx
            # dpdx = (
            #     -(cxrate / n + recrate / n) * nv * mi
            # )  # dpressuredx - momentum conservation

            # Parallel thermal conductivity! Issue #497
            # Revised formula from Huber and Chankin.
            kappa0 = (8788 / zeff_div) * (zeff_div + 0.21) / (zeff_div + 4.2)
            # dtedx Equation 5 - thermal conduction equation
            dtdx = qperp_conducted / te**2.5 / kappa0
            yp[2] = dtdx

            yp[4] = -(cxrate / n + al * n) * nv * mi
            yp[5] = (
                1e-6 * (raddens + radHdens + plossdenscx + plossion) * A_cross
            )  # dPowerdx - energy conservation

            # Derivatives of the power loss integrals - these are for information only.
            # They don't affect the results Y(1-6)
            yp[6] = 1e-6 * raddens * A_cross  # integral of impurity radiation loss [MW]
            yp[7] = (
                1e-6 * radHdens * A_cross
            )  # integral of radiation loss from hydrogenic species [MW]
            yp[8] = (
                1e-6 * plossdenscx * A_cross
            )  # integral of power loss due to charge exchange [MW]
            yp[9] = (
                1e-6 * plossion * A_cross
            )  # integral of power loss due to electron impact ionisation [MW]

            return yp

        return differential
