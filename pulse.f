C----------------------------------------------------------------------
C--SCCS information
C  Module         : $Id$
C  Module name    : $RCSfile: pulse.f,v $
C  Version no.    : $Revision: 1.13 $
C  Creation date  : $Date: 2006/05/25 09:27:02 $
C  Creation time  : 
C  SCCS file      :
C  %P%
C----------------------------------------------------------------------
      SUBROUTINE PULSE(nout,iprint)
CCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCC
C--Version number 1.001
C
C--Description
C  Calls the routines relevant to a pulsed reactor scenario
C
C--Author
C  Chris Gardner, c/o
C  Peter Knight D3/G12 Culham Laboratory, ext.3330
C
C--Date
C  10 June 1996
C
C--Reference
C  Work File Notes in F/MPE/MOD/CAG/PROCESS/PULSE
C  
C--History
C  25/11/93 PJK 1.000 Implementation within PROCESS
C  10/06/96 PJK 1.001 Commented out call to STARTUP
C
C--Arguments
C  nout   : (INPUT)  Fortran output unit identifier
C  iprint : (INPUT)  Flag to turn on/off (1/0) output to file
C
CCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCC

      IMPLICIT NONE

C  INCLUDE files
      INCLUDE 'param.h'
      INCLUDE 'pulse.h'
      INCLUDE 'build.h'
      INCLUDE 'phydat.h'
      INCLUDE 'fwblsh.h'
      INCLUDE 'times.h'

C  Arguments
      INTEGER nout,iprint

C  External routines
      EXTERNAL thrmal,tohswg,burn,startup

C--End of preamble--CCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCC

C *** Thermal cycling package

      call thrmal(nout,iprint)

C *** Evaluate minimum OH coil swing time

      call tohswg(nout,iprint)

C *** Burn time calculation

      call burn(nout,iprint)

C *** Start-up model to minimise auxiliary power requirement

C+**PJK 10/06/96 Comment out start-up option as it takes a long time
C+**PJK 10/06/96      if (iprint.eq.1) call startup(iprint)

      return
      end
C----------------------------------------------------------------------
      SUBROUTINE THRMAL(nout,iprint)
CCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCC
C--Version number 1.130
C
C--Description
C  This subroutine calculates the thermal and mechanical stresses
C  induced in the first wall for the case of a pulsed reactor.
C  It is assumed that the first wall is comprised from axisymmetric
C  hollow cylindrical tubes which are packed one against the other in
C  the poloidal direction.
C 
C  The equivalent strains are calculated from the stresses
C  with which a fatigue lifetime is estimated using the fatigue
C  design curves generated by the ASME code.
C 
C  Presently the first wall material is assumed to be stainless
C  steel.
C  
C  The first wall thickness is constrained to lie between a lower
C  limit that ensures that the first wall can withstand the internal
C  coolant pressure, and an upper limit governed by the peak
C  temperature and the neutron fluence.
C
C--Author
C  Chris Gardner, c/o
C  Peter Knight D3/162a Culham, ext.6368
C
C--Date
C  13 February 1997
C
C--Reference
C  Work File Notes in F/MPE/MOD/CAG/PROCESS/PULSE
C  
C--History
C  25/11/93 PJK 1.000 Incorporation into PROCESS.
C  16/06/94 PJK 1.010 Added error warning
C  07/12/95 PJK 1.100 Added D-He3 calculations
C  10/06/96 PJK 1.110 Moved first wall area calculation into RADIALB
C  13/02/97 PJK 1.120 Modified first wall lifetime calculation
C  25/05/06 PJK 1.130 Added SAVE statement
C
C--Arguments
C  nout   : (INPUT)  Fortran output unit identifier
C  iprint : (INPUT)  Flag to turn on/off (1/0) output to file
C
C--Global variables passed via COMMON
C  cc(8) : angular coefficients
C  dd(8) : angular coefficients
C
CCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCC

C  INCLUDE files
      INCLUDE 'param.h'
      INCLUDE 'pulse.h'
      INCLUDE 'build.h'
      INCLUDE 'phydat.h'
      INCLUDE 'fwblsh.h'
      INCLUDE 'ineq.h'
      INCLUDE 'cost.h'

C  Arguments
      INTEGER nout,iprint

C  Global variables
      DOUBLE PRECISION cc(8),dd(8)
      COMMON/tmpcff/cc,dd

C  Local variables
      DOUBLE PRECISION boa,delr(3),delth(3),delz(3),eptbar,eptr(3),
     +     eptrc,eptth(3),eptthc,eptz(3),eptzc,equiv(3),fboa,flnce,
     +     fwlifs,fwndep,fwvol,hcoeff,masflx,mincyc(3),mindif,min01,
     +     min02,min03,poissn,qpp,qppp,rad,sigpm,sigpr,sigpth,sgpthn,
     +     sigpz,sigtr,sigtri,sigtrs,sgtshs,sigtth,sgtthi,sgtths,
     +     sigtz(3),tav,temp,tfwav,tmax,tmpdif,tmprop,tmthet,torlen,
     +     tpeakr,vel

      SAVE flnce,hcoeff,qpp,qppp,tav,tmprop,vel

      INTEGER ncyc(3),k,n

C  External functions
      DOUBLE PRECISION alpha,eyung,smt,tk,yield
      EXTERNAL         alpha,eyung,smt,tk,yield

C  External routines
      EXTERNAL costrm,cycles,oheadr,ocmmnt,oblnkl,ovarrf,ovarre

C--End of preamble--CCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCC

C *** delr(3)  : radial strain range
C *** delth(3) : azimuthal strain range
C *** delz(3)  : axial strain range
C *** eptbar   : average thermal strain
C *** eptr(3)  : radial strain component from total stress
C *** eptrc    : radial strain component from mechanical stress
C *** eptth(3) : azimuthal strain component from total stress
C *** eptthc   : azimuthal strain component from mechanical stress
C *** eptz(3)  : axial strain component from total stress
C *** eptzc    : axial strain component from mechanical stress
C *** equiv(3) : Von Mises equivalent strain
C *** flnce    : neutron fluence
C *** fwndep   : neutron power deposition (W)
C *** fwvol    : first wall volume (m**3)
C *** hcoeff   : heat transfer coefficient (W/m**2/K)
C *** masflx   : coolant max flux (Kg/m**2/s)
C *** ncyc(3)  : number of allowable cycles
C *** poissn   : Poisson's ratio 
C *** mincyc(3): minimum allowable cycle length
C *** fwlifs   : first wall lifetime (s)
C *** qpp      : surface heat flux incident on first wall (W/m**2)
C *** qppp     : volumetric heat flux in first wall material (W/m**3)
C *** sgpthn   : primary stress in thin shell model (Pa)
C *** sgtshs   : shear stress component from surface heat flux (Pa)
C *** sgtthi   : azimuthal stress component from internal heat flux (Pa)
C *** sgtths   : azimuthal stress component from surface heat flux (Pa)
C *** sigpm    : equivalent mechanical stress (Pa)
C *** sigpr    : radial mechanical stress (Pa)
C *** sigpth   : azimuthal mechanical stress (Pa)
C *** sigpz    : axial mechanical stress (Pa)
C *** sigtr    : radial stress component from total heat flux (Pa)
C *** sigtri   : radial stress component from internal heat flux (Pa)
C *** sigtrs   : radial stress component from surface heat flux (Pa)
C *** sigtth   : azimuthal stress component from total heat flux (Pa)
C *** sigtz(3) : axial stress component from total heat flux (Pa)
C *** tav      : average first wall temperature (C)
C *** tmthet   : azimuthal temperature term (C)
C *** torlen   : section of toroidal extent of first wall elements (m)
C *** tpeakr   : peak temperature at a given radius (C)
C *** vel      : coolant velocity (m/s)

C *** Check to see if the pulsed reactor option is selected

      if (lpulse.ne.1) goto 1000

      if (iprint.eq.1) goto 90

C *** Check valid input for pulsed reactor

      if (fhole.eq.0.0D0) then
         write(*,*) 'Error in routine THRMAL:'
         write(*,*) 'fhole should not be zero for a pulsed reactor -'
         write(*,*) 'a fraction fhole of the neutrons leaving the'
         write(*,*) 'plasma are assumed to interact in the first wall.'
         write(*,*) 'PROCESS stopping.'
         STOP
      end if

C *** We will assume that 2*bfw is the average of the inboard and
C *** outboard first wall thicknesses (fwith and fwoth respectively).

      bfw = (fwith+fwoth)/4.0D0
      boa = bfw/afw

C *** Poisson's ratio

      poissn = 0.27d0

C *** Open output file

      open(unit=4,status='unknown',file='thermal.dat')

      n = 0

C *** Start of iteration of bfw - code returns to here...
 10   continue
C *** ...if bfw has been altered to lie within constraints

C *** Check to see if inner radius is greater than outer radius

      if (afw.ge.bfw) then
         write(*,*) 'Error in routine PULSE:'
         write(*,*) 'afw.ge.bfw'
         write(*,*) 'PROCESS stopping.'
         STOP
      end if

C *** Check progress

      n = n+1
      if (n.gt.100) then
C+**PJK 27/04/94 write(4,*) 'Optimisation has failed in routine PULSE'
C+**PJK 16/06/94 Added error warning
         write(*,*) 'Warning in routine THRMAL:'
         write(*,*) 'Optimisation has failed within 100 iterations.'
         write(*,*) 'Possible NaN problems...'
         write(*,*) 'PROCESS continuing.'
         goto 1000
      end if

C *** First wall lifetime in seconds

      fwlifs = 3.1536d+7*fwlife

C *** First wall properties
C *** This assumes that the neutrons lost via fhole actually stop in
C *** the first wall, so are not lost at all...

C+**PJK 07/12/95 fwndep = (14.1d0/17.6d0)*powfmw*fhole*1.0d+6
      fwndep = (pneut*vol)*fhole*1.0d+6

C *** Assume that the first wall volume is equal to its surface area
C *** multiplied by the external diameter of the hollow cylindrical
C *** tubes that make up the first wall.

      fwvol = fwarea*(2.0d0*bfw)

C *** Heat fluxes
C *** -----------
C *** qppp represents the heat generation in the first wall due to
C *** the neutron flux deposited in the material.
C *** qpp represents the heat flux incident on the first wall
C *** surface from the charge particle and electromagnetic radiation
C *** flux.

      qppp = fwndep/fwvol

C+**PJK 07/12/95 qpp = (1.d0-(14.1d0/17.6d0))*powfmw*1.0d6/fwarea
      qpp = (palp+pcharge)*vol*1.0d6/fwarea

C *** Heat transfer coefficient
C *** -------------------------
C *** The coolant is water and the heat transfer coefficient is 
C *** calculated on the inboard side of the first wall.
C *** specific heat capacity: 4190 (J/K/Kg)
C *** mass density: 720 (kg/m**3)
C *** coolant velocity limit: 5 (m/s)
C *** fluid viscosity: 1.61d-4 (Kg/m/s)
C *** viscosity at wall temperature: 1.39d-4 (Kg/m/s)
C *** thermal conductivity: 0.69 (W/m/K)
C *** If the velocity limit is exceeded then the coolant velocity
C *** is set to the velocity limit and the temperature rise is
C *** calculated based upon this fixed velocity.

C+**PJK 23/12/93 Commented out : torlen = 2.0d0*pi*(rmajor-rminor)
c+**PJK 23/12/93 A toroidal length of 3 metres is assumed rather than
C+**PJK 23/12/93 the whole toroidal circumference as we were
C+**PJK 23/12/93 experiencing very high coolant temperature rises.
C+**PJK 23/12/93 This method is okay as it can be envisaged that the
C+**PJK 23/12/93 toroidal parts of the coolant pipes occur in 3 metre
C+**PJK 23/12/93 sections around the torus, instead of one long
C+**PJK 23/12/93 toroidal pipe.

      torlen = 3.0d0
      masflx = torlen*(qppp*(bfw**2-afw**2)+2.0D0*qpp*bfw)
     +     /afw**2/4190.0d0/tmprse
      vel = masflx/720.0d0

      if (vel.ge.5.0d0) then
         vel = 5.0d0
         masflx = vel*720.0d0
         tmprse = torlen*(qppp*(bfw**2-afw**2)+2.0D0*qpp*bfw)
     +        /afw**2/4190.0d0/masflx
      end if

      hcoeff = 0.023d0*(0.69d0/2.0d0/afw)*(masflx*2.0d0*afw
     +     /1.61d-4)**0.8d0*(1.61d-4*4190.0d0/0.69d0)**0.4d0
     +     *(1.61d-4/1.39d-4)**0.14d0

C *** Average temperature
C *** -------------------
C *** There is a problem here because the expression for the
C *** average temperature in the first wall contains a term
C *** which involves the thermal conductivity which is in itself
C *** temperature dependent. How do we resolve this problem?
C *** Firstly we define a temperature range where the lower
C *** bound is defined to be the temperature on the inner
C *** wall (in contact with the coolant) and therefore
C *** equal to the bulk coolant temperature, and the
C *** upper bound is taken to be 800 degrees Celsius.
C *** Next we iterate over this range so that at each 
C *** step the average temperature can be calculated together 
C *** with the difference between the average temperature and 
C *** the iterated temperature. The average temperature
C *** at which this difference is minimised is taken 
C *** as the correct average temperature in the first wall.

      mindif = 1.0d+30

      do 20 k = 1,51

         temp = bctmp+(800.0d0-bctmp)*dble(k-1)/50.0d0
         tfwav = bfw/tk(temp)*(qpp/pi+qppp*bfw/2.d0)*(bfw**2/
     +        (bfw**2-afw**2)*log(bfw/afw)-0.5d0)-
     +        qppp/4.0d0/tk(temp)*((bfw**2-afw**2)/2.0d0)
     +        +(pi*(bfw**2-afw**2)*qppp+2.0d0*bfw*qpp)/
     +        (2.0d0*pi*afw*hcoeff)+ bctmp
         tmpdif = abs(tfwav-temp)
         if (tmpdif.le.mindif) then
            mindif = tmpdif
            tav = tfwav
            tmprop = temp
         end if

 20   continue  

C *** Average thermal strain (integrated from 20 Celsius to `tav').

      eptbar = 10.28d-6/1.093d0*(tav**(1.093d0)-20.0d0**(1.093d0))

C *** Limits on the first wall thickness
C *** ----------------------------------
C *** The upper limit on the first wall thickness is
C *** derived from the swelling limit which for stainless
C *** steel limits the temperature to 500 Celsius. This
C *** temperature limit is equivalent to limiting the neutron
C *** fluence to 5 MW yrs/m**2. The fluence is the product
C *** of the neutron wall loading (qppp*fwvol/fwarea) and
C *** the wall lifetime. This fluence limit is a conservative
C *** one, with the upper bound on the fluence set by the value
C *** 10 MW-yr/m2
C+**PJK 13/02/97 abktflnc should replace the fixed value 10 MW-yr/m2

      flnce = qppp*fwvol/fwarea*fwlife/1.0d6

      tmax = -1.0d+30

      do 40 k = 1,11

         rad = afw+(bfw-afw)*(dble(k-1)/10.0d0)

         call costrm(0.0d0,rad,qpp,hcoeff,tmprop,tmthet)

C *** Peak temperature occurs at (r,theta) = (rad,0)
         tpeak = bfw/tk(tmprop)*(qpp/pi+qppp*bfw/2.d0)*log(rad/afw)-
     +        qppp/4.0d0/tk(tmprop)*(rad**2-afw**2)
     +        +(pi*(bfw**2-afw**2)*qppp+2.0d0*bfw*qpp)/
     +        (2.0d0*pi*afw*hcoeff)+ bctmp + tmthet

         if ((tpeak.gt.500.0d0).or.(flnce.gt.10.0d0)) then
C+**PJK 27/04/94 write(4,*)  'Swelling limit exceeded'
C+**PJK 27/04/94 write(4,30) 'First wall temperature = ',tpeak,' C'
C+**PJK 27/04/94 write(4,30) 'Neutron fluence = ',flnce,' MW/m**2 yrs'

            fwlife = 10.0d0*1.0d6*fwarea/qppp/fwvol
            fwlifs = 3.1536d+7*fwlife

C *** fboa is chosen such that fboa**100 * (bfw/afw) = 1.001,
C *** i.e. after 100 iterations bfw is still just larger than afw.

            fboa = (1.001D0/boa)**0.01D0

            bfw = bfw*fboa
            if ((bfw/afw).le.1.001D0) n = 100
C+**PJK 27/04/94  write(4,30) 'First wall thickness = ',(bfw-afw)*1.0d3,
C+**PJK 27/04/94 +           ' mm'
            goto 10
         end if

 30      format(1x,a,f10.4,a)

C *** Find maximum temperature

         tmax = max(tpeak,tmax)

 40   continue

      tpeak = tmax

C *** The lower limit on the first wall thickness is
C *** derived from the constraint that the first wall
C *** must possess the ability to withstand the internal
C *** coolant pressure. The limit is written as
C *** hmin = p*(afw+bfw)/2/Smt

      sgpthn = (coolp*(afw+bfw)/2.0d0)/(bfw-afw)

      if (sgpthn.gt.smt(tpeak,fwlifs)) then
C+**PJK 27/04/94 write(4,*) 'First wall too thin'
C+**PJK 27/04/94 write(4,50) sgpthn
C+**PJK 27/04/94 write(4,60) smt(tpeak,fwlifs)

 50      format(1x,'Primary stress in first wall = ',e10.4, ' Pa')
 60      format(1x,'Maximum stress intensity = ',e10.4, ' Pa')

C *** Keep `afw' fixed and alter`bfw' so that the lower limit 
C *** is satisfied.

         bfw = (smt(tpeak,fwlifs)+coolp/2.d0)/
     +        (smt(tpeak,fwlifs)-coolp/2.d0)*afw
         goto 10
      end if

C *** Reset inboard and outboard first wall thicknesses

      fwith = 2.0D0*bfw
      fwoth = 2.0D0*bfw

C *** First wall coolant fraction

      fwclfr = (afw/bfw)**2

      min01 = 0.0D0
      min02 = 0.0D0
      min03 = 0.0D0

C *** Iterate from the inner first wall radius to the outer
C *** first wall radius.

      do 70 k = 1,11

C *** Peak temperature at this radius

         rad = afw+(bfw-afw)*(dble(k-1)/10.0d0)

         call costrm(0.0d0,rad,qpp,hcoeff,tmprop,tmthet)

C *** Peak temperature occurs at (r,theta) = (rad,0)

         tpeakr = bfw/tk(tmprop)*(qpp/pi+qppp*bfw/2.d0)*log(rad/afw)-
     +        qppp/4.0d0/tk(tmprop)*(rad**2-afw**2)
     +        +(pi*(bfw**2-afw**2)*qppp+2.0d0*bfw*qpp)/
     +        (2.0d0*pi*afw*hcoeff)+ bctmp + tmthet

C *** Pressure, or mechanical stresses

         sigpr = -coolp*(afw**2/(bfw**2-afw**2))*(bfw**2/rad**2-1.0d0)
         sigpth = coolp*(afw**2/(bfw**2-afw**2))*(bfw**2/rad**2+1.0d0)
         sigpz = coolp*(afw**2/(bfw**2-afw**2))

C *** Equivalent mechanical stress

         sigpm = sqrt(0.5d0*((sigpr-sigpth)**2+(sigpr-sigpz)**2+
     +        (sigpth-sigpz)**2))

C *** Thermal stresses
C *** ----------------

C *** Thermal stress components from surface heat flux (i.e. qpp)

         sigtrs = alpha(tmprop)*eyung(tmprop)/2.0d0/(1.0d0-poissn)*(
     +        rad/(afw**2+bfw**2)*(1.0d0-afw**2/rad**2)*(1.0d0-
     +        bfw**2/rad**2)*cc(1)*cos(0.0d0)+
     +        qpp*bfw/pi/tk(tmprop)/rad**2*(bfw**2*((rad**2-afw**2)/
     +        (bfw**2-afw**2))*log(bfw/afw)-rad**2*log(rad/afw)))
         sgtths = alpha(tmprop)*eyung(tmprop)/2.0d0/(1.0d0-poissn)*(
     +        rad/(afw**2+bfw**2)*(3.0d0-(afw**2+bfw**2)/rad**2-
     +        (afw**2*bfw**2)/rad**4)*cc(1)*cos(0.0d0)+
     +        qpp*bfw/pi/tk(tmprop)/rad**2*(bfw**2*((rad**2+afw**2)/
     +        (bfw**2-afw**2))*log(bfw/afw)-rad**2-
     +        rad**2*log(rad/afw)))
         sgtshs = alpha(tmprop)*eyung(tmprop)/2.0d0/(1.0d0-poissn)*(
     +        rad/(afw**2+bfw**2)*(1.0d0-afw**2/rad**2)*(1.0d0-
     +        bfw**2/rad**2)*cc(1)*sin(0.0d0))

C *** Thermal stress components from internal heat flux (i.e. qppp)

         sigtri = alpha(tmprop)*eyung(tmprop)*qppp/4.0d0/tk(tmprop)/
     +        (1.0d0-poissn)/rad**2*((rad**2-afw**2)/(bfw**2-afw**2)*
     +        bfw**4*log(bfw/afw)-(bfw**2+afw**2)*rad**2/4.0d0
     +        +afw**2*bfw**2/4.0d0-bfw**2*rad**2*log(rad/afw)
     +        +rad**4/4.0d0)
         sgtthi = alpha(tmprop)*eyung(tmprop)*qppp/4.0d0/tk(tmprop)/
     +        (1.0d0-poissn)/rad**2*((rad**2+afw**2)/(bfw**2-afw**2)*
     +        bfw**4*log(bfw/afw)-(5.0d0*bfw**2+afw**2)*rad**2/4.0d0-
     +        afw**2*bfw**2/4.0d0+3.0d0*rad**4/4.0d0
     +        -bfw**2*rad**2*log(rad/afw))

C *** Total thermal stresses

         sigtr = sigtrs+sigtri
         sigtth = sgtths+sgtthi

C *** Axial stresses, three different models are used:
C *** (1) total axial restraint and no bending
C *** (2) no axial restraints and no bending
C *** (3) no axial restraints and bending

C+**PJK 03/11/93 This region commented out by CAG
C ***     aap = alpha(tmprop)*eyung(tmprop)*qppp*bfw**2/
C *** +        4.0d0/tk(tmprop)/(1.0d0-poissn)
C ***     bbp = alpha(tmprop)*eyung(tmprop)*qpp*bfw/
C *** +        2.0d0/pi/tk(tmprop)/(1.0d0-poissn)
C ***     aa = aap*(2.0d0*bfw**2*log(bfw/afw)/(bfw**2-afw**2)-
C *** +        afw**2/2.0d0/bfw**2-3.0d0/2.0d0)
C ***     bb = bbp*(2.0d0*bfw**2*log(bfw/afw)/(bfw**2-afw**2)-1)
C ***     bigi = (aa+bb)*(bfw**2-afw**2)-(aap+bbp)*(2.0d0*bfw**2*
C *** +        log(bfw/afw)-(bfw**2-afw**2))+aap/2.0d0/bfw**2*
C *** +        (bfw**4-afw**4)
C+**PJK

         sigtz(1) = poissn*(sigtr+sigtth)-eyung(tmprop)*
     +        (eptbar+alpha(tav)*(tpeakr-tav))
         sigtz(2) = poissn*(sigtr+sigtth)-eyung(tmprop)*
     +        (alpha(tav)*(tpeakr-tav))
c+**CAG     +        -poissn*bigi/(bfw**2-afw**2)
         sigtz(3) = sigtz(2)+eyung(tmprop)*rad*cos(0.0d0)*alpha(tav)*
     +        (2.0d0*cc(1)/(afw**2+bfw**2)+dd(1))

C *** Strains
C *** -------

         eptr(1) = 1.0d0/eyung(tmprop)*(sigtr+sigpr-poissn*(sigtth+
     +        sigpth+sigtz(1)+sigpz))
         eptth(1) = 1.0d0/eyung(tmprop)*(sigtth+sigpth-poissn*(sigtr+
     +        sigpr+sigtz(1)+sigpz))
         eptz(1) = 1.0d0/eyung(tmprop)*(sigtz(1)+sigpz-poissn*(sigtr+
     +        sigpr+sigtth+sigpth))
         eptr(2) = 1.0d0/eyung(tmprop)*(sigtr+sigpr-poissn*(sigtth+
     +        sigpth+sigtz(2)+sigpz))
         eptth(2) = 1.0d0/eyung(tmprop)*(sigtth+sigpth-poissn*(sigtr+
     +        sigpr+sigtz(2)+sigpz))
         eptz(2) = 1.0d0/eyung(tmprop)*(sigtz(2)+sigpz-poissn*(sigtr+
     +        sigpr+sigtth+sigpth))
         eptr(3) = 1.0d0/eyung(tmprop)*(sigtr+sigpr-poissn*(sigtth+
     +        sigpth+sigtz(3)+sigpz))
         eptth(3) = 1.0d0/eyung(tmprop)*(sigtth+sigpth-poissn*(sigtr+
     +        sigpr+sigtz(3)+sigpz))
         eptz(3) = 1.0d0/eyung(tmprop)*(sigtz(3)+sigpz-poissn*(sigtr+
     +        sigpr+sigtth+sigpth))


C *** For the time being I will take the temperature during rejuvenation
C *** to be T(a,0) during burn and assume the accompanying strains are 
C *** mechanical in origin.

         eptrc = 1.0d0/eyung(tmprop)*(sigpr-poissn*(sigpth+sigpz))
         eptthc = 1.0d0/eyung(tmprop)*(sigpth-poissn*(sigpr+sigpz))
         eptzc = 1.0d0/eyung(tmprop)*(sigpz-poissn*(sigpth+sigpr))

C *** Calculate strain ranges

         delr(1) = eptr(1)-eptrc
         delr(2) = eptr(2)-eptrc
         delr(3) = eptr(3)-eptrc
         delth(1) = eptth(1)-eptthc
         delth(2) = eptth(2)-eptthc
         delth(3) = eptth(3)-eptthc
         delz(1) = eptz(1)-eptzc
         delz(2) = eptz(2)-eptzc
         delz(3) = eptz(3)-eptzc

C *** Calculate Von Mises equivalent strain range

         equiv(1) = 1.0d0/3.0d0*sqrt(2.0d0*((delr(1)-delth(1))**2+
     +        (delth(1)-delz(1))**2+(delz(1)-delr(1))**2))
         equiv(2) = 1.0d0/3.0d0*sqrt(2.0d0*((delr(2)-delth(2))**2+
     +        (delth(2)-delz(2))**2+(delz(2)-delr(2))**2))
         equiv(3) = 1.0d0/3.0d0*sqrt(2.0d0*((delr(3)-delth(3))**2+
     +        (delth(3)-delz(3))**2+(delz(3)-delr(3))**2))

C *** Find allowable cycles

         call cycles(equiv,tpeakr,ncyc)

C *** Calculate minimum allowable cycle lengths

         mincyc(1) = fwlife/dble(ncyc(1))
         mincyc(2) = fwlife/dble(ncyc(2))
         mincyc(3) = fwlife/dble(ncyc(3))

C+**PJK 27/04/94 write(4,80) 'Rest cycle length = ',mincyc(1),' yrs ',
C    +        'at r = ',rad*1.0d3,' mm'
C             write(4,80) 'No bend cycle length = ',mincyc(2),' yrs ',
C    +        'at r = ',rad*1.0d3,' mm'
C             write(4,80) 'With bend cycle length = ',mincyc(3),' yrs ',
C+**PJK 27/04/94+        'at r = ',rad*1.0d3,' mm'

C *** Overall minimum allowable cycle length for each model
C *** (we use the highest value to set correctly the limit on tcycle)

         min01 = max(min01,mincyc(1))
         min02 = max(min02,mincyc(2))
         min03 = max(min03,mincyc(3))

 70   continue
      close(unit=4)

 80   format(1x,a,f10.4,a,a,f10.4,a)

C *** Evaluate minimum cycle time using chosen model

      if (itcycl.eq.1) then
         tcycmn = min01
      else if (itcycl.eq.2) then
         tcycmn = min02
      else
         tcycmn = min03
      end if

C *** Convert from years to seconds

      tcycmn = tcycmn * 3.1536D7

      if (iprint.eq.0) goto 1000

 90   continue

C *** Written output
C *** --------------
      call oheadr(nout,'Pulsed Reactor')

      call ocmmnt(nout,'Thermal cycling considerations for first wall:')
      call oblnkl(nout)

      call ovarrf(nout,'Inner radius of first wall tubes (m)',
     +     '(afw)',afw)
      call ovarrf(nout,'Outer radius of first wall tubes (m)',
     +     '(bfw)',bfw)
      call ovarre(nout,'Bulk coolant temperature (C)','(bctmp)',bctmp)
      call ovarre(nout,'Coolant internal pressure (Pa)','(coolp)',coolp)
      call ovarre(nout,'Neutron fluence (MW-yr/m2)','(flnce)',flnce)
      call ovarre(nout,'Neutron flux deposited in 1st wall (W/m3)',
     +     '(qppp)',qppp)
      call ovarre(nout,'Heat flux incident on first wall (W/m2)',
     +     '(qpp)',qpp)
      call ovarre(nout,'Heat transfer coefficient (W/m2/K)',
     +     '(hcoeff)',hcoeff)

      if (vel.eq.5.0d0) then
         call ocmmnt(nout,
     +        'Calculation based upon fixed coolant velocity')
      else
         call ocmmnt(nout,
     +        'Calculation based upon fixed temperature rise')
      end if
      call ovarre(nout,'Coolant velocity (m/s)','(vel)',vel)
      call ovarre(nout,'Coolant temperature rise (K)','(tmprse)',tmprse)
      call ovarre(nout,'Peak temperature in first wall (C)',
     +     '(tpeak)',tpeak)
      call ovarre(nout,'Average first wall temperature (C)','(tav)',tav)
      call ovarre(nout,'Material property temperature (C)',
     +     '(tmprop)',tmprop)
      call ovarre(nout,'Youngs modulus','(eyung)',eyung(tmprop))
      call ovarre(nout,'Thermal expansion coefficient (/K)',
     +     '(alpha)',alpha(tmprop))
      call ovarre(nout,'Thermal conductivity (W/m/K)','(tk)',tk(tmprop))
      call ovarre(nout,'First wall lifetime (years)','(fwlife)',fwlife)
      call ovarre(nout,'Minimum cycle time (s)','(tcycmn)',tcycmn)

 1000 continue

      return
      end

C----------------------------------------------------------------------
      SUBROUTINE COSTRM(angle,rad,qpp,hcoeff,tmprop,tmthet)
CCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCC
C--Version number 1.000
C
C--Description
C  Calculate cosine terms in temperature distribution
C  These terms are calculated with the material properties
C  measured at the property temperature.
C
C--Author
C  Chris Gardner, c/o
C  Peter Knight D3/G12 Culham Laboratory, ext.3330
C
C--Date
C  25 November 1993
C
C--Reference
C  Work File Notes in F/MPE/MOD/CAG/PROCESS/PULSE
C  
C--History
C  25/11/93 PJK 1.000 Initial version
C
C--Arguments
C  angle  : (INPUT)  azimuthal angle (radians)
C  rad    : (INPUT)  radial position within first wall tube (m)
C  qpp    : (INPUT)  surface heat flux incident on first wall (W/m**2)
C  hcoeff : (INPUT)  heat transfer coefficient (W/m**2/K)
C  tmprop : (INPUT)  property temperature (C)
C  tmthet : (OUTPUT) azimuthal temperature term (C)
C 
C--Global variables passed via COMMON
C  cc(8)  : angular coefficients
C  dd(8)  : angular coefficients
C
CCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCC

      IMPLICIT NONE

C  Parameters

C  INCLUDE files
      INCLUDE 'param.h'
      INCLUDE 'pulse.h'

      INCLUDE 'phydat.h'

C  Arguments
      DOUBLE PRECISION angle,rad,qpp,hcoeff,tmprop,tmthet

C  Global variables
      DOUBLE PRECISION cc(8),dd(8)
      COMMON/tmpcff/cc,dd

C  Local variables
      INTEGER l,k

C  External functions
      DOUBLE PRECISION tk
      EXTERNAL tk

C--End of preamble--CCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCC

C *** Lowest order terms

      cc(1) = qpp*afw**2*bfw**2/2.d0/tk(tmprop)*(tk(tmprop)-hcoeff*afw)/
     +     (tk(tmprop)*(bfw**2-afw**2)+hcoeff*afw*(afw**2+bfw**2))
      dd(1) = qpp*bfw**2/2.d0/tk(tmprop)*(tk(tmprop)+hcoeff*afw)/
     +     (tk(tmprop)*(bfw**2-afw**2)+hcoeff*afw*(afw**2+bfw**2))

      tmthet = (cc(1)/rad+dd(1)*rad)*cos(angle)

C *** Higher order even terms

      do 10 l = 2,8,2
         k = l/2
         cc(l) = qpp/pi/tk(tmprop)/dble(k)*(dble((-1)**(k+1))/
     +        ((2.0d0*dble(k))**2-1.0d0))*(bfw**(2*k+1)*(2.0d0*dble(k)*
     +        tk(tmprop)-hcoeff*afw))/(2.0d0*dble(k)*tk(tmprop)*
     +        ((bfw/afw)**(4*k)-1.0d0)+hcoeff*afw*((bfw/afw)**(4*k)
     +        +1.0d0))
         dd(l) = 1.0d0/((afw*10.0d0)**(4*k))*(10.0d0)**(4*k)*
     +        (2.0d0*dble(k)*tk(tmprop)+hcoeff*afw)/
     +        (2.0d0*dble(k)*tk(tmprop)-hcoeff*afw)*cc(l)

         tmthet = tmthet+(cc(l)/rad**l+dd(l)*rad**l)*cos(dble(l)*angle)

 10   continue   

      return
      end

C----------------------------------------------------------------------
      DOUBLE PRECISION FUNCTION EYUNG(X)
CCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCC
C--Version number 1.000
C
C--Description
C  Calculate the Young's modulus of the first wall material
C  (stainless steel)
C
C--Author
C  Chris Gardner, c/o
C  Peter Knight D3/G12 Culham Laboratory, ext.3330
C
C--Date
C  25 November 1993
C
C--Reference
C  Work File Notes in F/MPE/MOD/CAG/PROCESS/PULSE
C  
C--History
C  25/11/93 PJK 1.000 Initial version
C
C--Arguments
C  X      : (INPUT)  property temperature (C)
C
CCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCC

      IMPLICIT NONE

C  Arguments
      DOUBLE PRECISION X

C--End of preamble--CCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCC

      EYUNG = 465.0D0*(X)**(-0.18D0)*1.0D9

      RETURN
      END

C----------------------------------------------------------------------
      DOUBLE PRECISION FUNCTION ALPHA(X)
CCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCC
C--Version number 1.000
C
C--Description
C  Calculate the thermal expansion coefficient of the first wall
C  (stainless steel)
C
C--Author
C  Chris Gardner, c/o
C  Peter Knight D3/G12 Culham Laboratory, ext.3330
C
C--Date
C  25 November 1993
C
C--Reference
C  Work File Notes in F/MPE/MOD/CAG/PROCESS/PULSE
C  
C--History
C  25/11/93 PJK 1.000 Initial version
C
C--Arguments
C  X      : (INPUT)  property temperature (C)
C
CCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCC

      IMPLICIT NONE

C  Arguments
      DOUBLE PRECISION X

C--End of preamble--CCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCC

      ALPHA = 10.28D0*(X)**(0.093D0)*1.0D-6

      RETURN
      END

C----------------------------------------------------------------------
      DOUBLE PRECISION FUNCTION TK(X)
CCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCC
C--Version number 1.000
C
C--Description
C  Calculate the thermal conductivity of the first wall.
C  This gives a reasonable fit to 316 stainless steel for
C  temperatures X between 300 and 800 degrees Celsius.
C
C--Author
C  Chris Gardner, c/o
C  Peter Knight D3/G12 Culham Laboratory, ext.3330
C
C--Date
C  25 November 1993
C
C--Reference
C  Work File Notes in F/MPE/MOD/CAG/PROCESS/PULSE
C  
C--History
C  25/11/93 PJK 1.000 Initial version
C
C--Arguments
C  X      : (INPUT)  property temperature (C)
C
CCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCC

      IMPLICIT NONE

C  Arguments
      DOUBLE PRECISION X

C--End of preamble--CCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCC

      TK = 3.78D0*(X)**(0.28D0)

      RETURN
      END

C----------------------------------------------------------------------
      DOUBLE PRECISION FUNCTION YIELD(X)
CCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCC
C--Version number 1.000
C
C--Description
C  Calculate the yield strength of the first wall
C  (stainless steel)
C
C--Author
C  Chris Gardner, c/o
C  Peter Knight D3/G12 Culham Laboratory, ext.3330
C
C--Date
C  25 November 1993
C
C--Reference
C  Work File Notes in F/MPE/MOD/CAG/PROCESS/PULSE
C  
C--History
C  25/11/93 PJK 1.000 Initial version
C
C--Arguments
C  X      : (INPUT)  property temperature (C)
C
CCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCC

      IMPLICIT NONE

C  Arguments
      DOUBLE PRECISION X

C--End of preamble--CCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCC

      YIELD = 745.0D0*(X)**(-0.31D0)*1.0D6

      RETURN
      END

C----------------------------------------------------------------------
      DOUBLE PRECISION FUNCTION SMT(X,FWLIFS)
CCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCC
C--Version number 1.000
C
C--Description
C  Calculate the maximum stress intensity from ASME code.
C
C--Author
C  Chris Gardner, c/o
C  Peter Knight D3/G12 Culham Laboratory, ext.3330
C
C--Date
C  25 November 1993
C
C--Reference
C  Work File Notes in F/MPE/MOD/CAG/PROCESS/PULSE
C  
C--History
C  25/11/93 PJK 1.000 Initial version
C
C--Arguments
C  X      : (INPUT)  property temperature (C)
C  FWLIFS : (INPUT)  first wall lifetime (s)
C
CCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCC

      IMPLICIT NONE

C  Arguments
      DOUBLE PRECISION X,FWLIFS

C  Local variables
      DOUBLE PRECISION smt400,smt500,smt600,lnpwr

C--End of preamble--CCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCC

C *** smt400 : smt at 400 degrees Celsius
C *** smt500 : smt at 500 degrees Celsius
C *** smt600 : smt at 600 degrees Celsius
C *** lnpwr  : logarithm of first wall lifetime 

      lnpwr = log(fwlifs)
      smt400 = 109.0d0
      smt500 = 107.0d0
      smt600 = 102.0d0

C *** If x <= 400 smt = 109.
C *** If x <= 500 smt = smt400+(x-400)/100**smt500-smt400 
C *** (simple first order Taylor expansion).

      if (fwlifs.ge.3000) smt600 = -0.8139765d0*lnpwr**2+
     +     6.2849d0*lnpwr+99.147d0

      if (x.le.400) then
         smt = 109.0d0
      else if (x.le.500) then
         smt = smt400+(x-400.0d0)/100.0d0*(smt500-smt400)
      else if (x.le.600) then
         smt = smt500+(x-500.0d0)/100.0d0*(smt600-smt500)
      else
C+**PJK 27/04/94
C      write(4,*) 'No reliable data for SMT stress for temperatures ',
C+**PJK 27/04/94     +        'exceeding 600 degrees Celsius'
         STOP
      end if

      smt = smt*1.0d+6

      return
      end

C----------------------------------------------------------------------
      SUBROUTINE CYCLES(EQUIV,TEMP,NCYC)
CCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCC
C--Version number 1.000
C
C--Description
C  Calculate the number of allowable cycles from a fit of the
C  ASME fatigue design data.
C
C--Author
C  Chris Gardner, c/o
C  Peter Knight D3/G12 Culham Laboratory, ext.3330
C
C--Date
C  25 November 1993
C
C--Reference
C  'Methods of first wall structural analysis .....', R.J. LeClaire,
C     PFC/RR-84-9.
C  Work File Notes in F/MPE/MOD/CAG/PROCESS/PULSE
C  
C--History
C  25/11/93 PJK 1.000 Initial version
C
C--Arguments
C  equiv(3) : (INPUT)  Von Mises equivalent strain
C  temp     : (INPUT)  peak temperature (C)
C  ncyc(3)  : (OUTPUT) number of allowable cycles
C
CCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCC

      IMPLICIT NONE

C  Arguments
      DOUBLE PRECISION equiv(3),temp
      INTEGER ncyc(3)

C  Local variables
      DOUBLE PRECISION logstr,lgn426,lgn454,lgn482
      DOUBLE PRECISION lgn510,lgn649,logn
      DOUBLE PRECISION bsqd(5)
      INTEGER k,l

C--End of preamble--CCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCC

C *** logstr  : logarithm of equivalent strain
C *** lgn426  : logarithm of number of cycles at 426 Celsius
C *** lgn454  : logarithm of number of cycles at 454 Celsius
C *** lgn482  : logarithm of number of cycles at 482 Celsius
C *** lgn510  : logarithm of number of cycles at 510 Celsius
C *** lgn649  : logarithm of number of cycles at 649 Celsius
C *** logn    : logarithm of number of cycles at arbitrary temperature
C *** bsqd(5) : fitting coefficients

      do 20 k = 1,3

         logstr = log(equiv(k))
         lgn426 = (logstr+3.7587178d0)/(-0.198105441d0)
         lgn454 = (logstr+4.2563621d0)/(-0.183711238d0)
         lgn482 = (logstr+4.6637048d0)/(-0.17626645d0)
         lgn510 = (logstr+5.1613625d0)/(-0.16112635d0)
         lgn649 = (logstr+5.691763d0)/(-0.14084195d0)

         bsqd(1) = (8.763d-3)**2-4.0d0*4.548d-4*(0.046d0-equiv(k))
         bsqd(2) = (4.941d-3)**2-4.0d0*2.525d-4*(0.02675d0-equiv(k))
         bsqd(3) = (2.537d-3)**2-4.0d0*1.2564d-4*(0.01459d0-equiv(k))
         bsqd(4) = (1.113d-3)**2-4.0d0*5.199d-5*(7.3355d-3-equiv(k))
         bsqd(5) = (6.558d-4)**2-4.0d0*3.09d-5*(4.3448d-3-equiv(k))

         do 10 l = 1,5
            if (bsqd(l).lt.0.d0) bsqd(l) = 0.d0
 10      continue

C *** This piece seems to be approximating the fatigue design curve by
C *** a quadratic.

         if (equiv(k).gt.0.00376d0)
     +        lgn426 = (8.763d-3-sqrt(bsqd(1)))/(2.0d0*4.548d-4)
         if (equiv(k).gt.0.00261d0)
     +        lgn454 = (4.941d-3-sqrt(bsqd(2)))/(2.0d0*2.525d-4)
         if (equiv(k).gt.0.00186d0)
     +        lgn482 = (2.537d-3-sqrt(bsqd(3)))/(2.0d0*1.2564d-4)
         if (equiv(k).gt.0.0013d0)
     +        lgn510 = (1.133d-3-sqrt(bsqd(4)))/(2.0d0*5.199d-5)
         if (equiv(k).gt.0.000922d0) 
     +        lgn649 = (6.558d-4-sqrt(bsqd(5)))/(2.0d0*3.09d-5)

C *** Taylor expansion in temperature

         if (temp.le.426) then
            logn = lgn426
         else if (temp.le.454) then
            logn = lgn426+(temp-426.0d0)*(lgn454-lgn426)/
     +           (454.0d0-426.0d0)
         else if (temp.le.482) then
            logn = lgn454+(temp-454.0d0)*(lgn482-lgn454)/
     +           (482.0d0-454.0d0)
         else if (temp.le.510) then
            logn = lgn482+(temp-482.0d0)*(lgn510-lgn482)/
     +           (510.0d0-482.0d0)
         else if (temp.le.649) then
            logn = lgn510+(temp-510.0d0)*(lgn649-lgn510)/
     +           (649.0d0-510.0d0)
         else
C+**PJK 27/04/94 write(4,*) 'Fatigue data unreliable for T > 649 (C)'
C+**PJK 27/04/94 write(4,30) temp
            goto 1000
         end if   

         if (logn.gt.15.0D0) logn = 15.0D0
         ncyc(k) = int(exp(logn))

 20   continue

 30   format(1x,'First wall temperature  ',f10.4)

 1000 continue

      return
      end
C----------------------------------------------------------------------
      SUBROUTINE TOHSWG(nout,iprint)
CCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCC
C--Version number 1.100
C
C--Description
C  Routine to calculate the minimum OH coil swing time
C
C--Author
C  Chris Gardner, c/o
C  Peter Knight D3/162a Culham, ext.6368
C
C--Date
C  22 May 2006
C
C--Reference
C  F/MPE/MOD/CAG/PROCESS/PULSE/0013
C  F/PL/PJK/PROCESS/CODE/050
C  
C--History
C  25/11/93 PJK 1.000 Initial version
C  22/05/06 PJK 1.100 Corrected error in tohsmn calculation
C
C--Arguments
C  nout   : (INPUT)  Fortran output unit identifier
C  iprint : (INPUT)  Flag to turn on/off (1/0) output to file
C
CCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCC

      IMPLICIT NONE

C  INCLUDE files
      INCLUDE 'param.h'
      INCLUDE 'pfcoil.h'
      INCLUDE 'pwrcom.h'
      INCLUDE 'vltcom.h'
      INCLUDE 'phydat.h'
      INCLUDE 'ineq.h'
      INCLUDE 'pulse.h'

C  Arguments
      INTEGER nout,iprint

C  Local variables
      DOUBLE PRECISION ioht1,ioht2,r,rho,pfbusl,albusa,v,m,loh,ipdot

C  External routines
      EXTERNAL osubhd,ovarre

C--End of preamble--CCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCC

      if (lpulse.ne.1) goto 1000

      if (iprint.eq.1) goto 10

C *** Current/turn in OH coil at beginning of pulse (A/turn)

      ioht1 = cpt(nohc,2)

C *** Current/turn in OH coil at start of flat-top (A/turn)

      ioht2 = cpt(nohc,3)

C *** OH coil resistance (ohms)

      if (ipfres.eq.0) then
         r = 0.0D0
      else
         r = powohres/( 1.0D6*ric(nohc) )**2
      end if

C *** OH coil bus resistance (ohms) (assumed to include power supply)
C *** Bus parameters taken from routine PWRCONV.

      pfbusl = 8.0D0 * rmajor + 140.0D0
      albusa = abs(cptdin(nohc))/100.0D0

      rho = 1.5D0 * 2.62D-4 * pfbusl/albusa

C *** OH coil power source emf (volts)

      v = vpfskv * 1.0D3

C *** Mutual inductance between OH coil and plasma (H)

      m = sxlg(nohc,ncirt)

C *** Self inductance of OH coil (H)

      loh = sxlg(nohc,nohc)

C *** Maximum rate of change of plasma current (A/s)

      ipdot = 0.5D6

C *** Minimum OH coil swing time (s)

      tohsmn = loh*(ioht2 - ioht1) /
     +     (ioht2*turns(nohc)*(r+rho) - v + m*ipdot)

      if (iprint.eq.0) goto 1000

 10   continue

      call osubhd(nout,'OH coil swing time considerations:')
      call ovarre(nout,'Minimum OH coil swing time (s)',
     +     '(tohsmn)',tohsmn)

 1000 continue

      return
      end
C----------------------------------------------------------------------
      SUBROUTINE BURN(nout,iprint)
CCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCC
C--Version number 1.001
C
C--Description
C  Routine to calculate the burn time for a pulsed reactor.
C
C--Author
C  Chris Gardner, c/o
C  Peter Knight D3/162a Culham, ext.6368
C
C--Date
C  25 May 2006
C
C--Reference
C  F/MPE/MOD/CAG/PROCESS/PULSE/0012
C  
C--History
C  25/11/93 PJK 1.000 Initial version
C  25/05/06 PJK 1.001 Added SAVE statement
C
C--Arguments
C  nout   : (INPUT)  Fortran output unit identifier
C  iprint : (INPUT)  Flag to turn on/off (1/0) output to file
C
CCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCC

      IMPLICIT NONE

C  INCLUDE files
      INCLUDE 'param.h'
      INCLUDE 'pfcoil.h'
      INCLUDE 'pulse.h'
      INCLUDE 'vltcom.h'
      INCLUDE 'phydat.h'
      INCLUDE 'cdriv.h'
      INCLUDE 'times.h'

C  Arguments
      INTEGER nout,iprint

C  Local variables
      DOUBLE PRECISION vburn,vsmax,vssoft
      SAVE vsmax,vssoft

C  External routines
      EXTERNAL osubhd,ovarre

C--End of preamble--CCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCC

      if (lpulse.ne.1) goto 1000

      if (iprint.eq.1) goto 10

C *** Volt-seconds required to produce plasma current during start-up
C *** (i.e. up to start of flat top)

      vssoft = vsres + vsind

C *** Total volt-seconds available during burn (vstot is the total
C *** volt-second capability provided by the PF/OH coils)

      vsmax = abs(vstot) - vssoft

C *** Loop voltage during burn (including MHD sawtooth enhancement)

      vburn = plascur * rplas * facoh * csawth

C *** Burn time (s)

C+**PJK 29/03/94 Removed ... tburn = max(1.0D-3,vsmax/vburn)
      tburn = vsmax/vburn

      if (iprint.eq.0) goto 1000

 10   continue

      call osubhd(nout,'Volt-second considerations:')
      call ovarre(nout,'Total V-s capability of OH/PF coils (Wb)',
     +     '(abs(vstot))',abs(vstot))
      call ovarre(nout,'Required volt-seconds during start-up (Wb)',
     +     '(vssoft)',vssoft)
      call ovarre(nout,'Available volt-seconds during burn (Wb)',
     +     '(vsmax)',vsmax)
      call ovarre(nout,'Burn time (s)','(tburn)',tburn)

 1000 continue

      return
      end
C----------------------------------------------------------------------
      SUBROUTINE STARTUP(iprint)
CCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCC
C--Version number 1.000
C
C--Description
C  Routine to find the minimum auxiliary power required in start-up.
C  This is accomplished by calling the non-linear optimisation routine
C  VMCON, so this subroutine simply sets up the equations to be solved.
C
C  PROCESS assumes that all the ion temperatures and profile
C  parameters are identical and utilises charge neutrality in 
C  order to calculate DENI.
C
C  ZEFF is assumed to remain constant, in other words the
C  ion/electron ratios are invariant.
C
C  The most general form for the energy confinement time is :
C
C                              ptaue   qtaue                   rtaue
C                          ____      __
C  taue =  gtaue + ftaue   dene      te     ( <Paux>  +  alpmw )
C        ____     __
C  where DENE and TE are the electron density (10**20 m**-3) and
C  electron temperature (10 keV) respectively.
C 
C  The equation defining ignition has the form
C                       2   s                2   1/2      -3/2
C   A n   T      =   B n   T    +  P    - C n   T    + D T
C      e20 e10          e20 e10     aux      e20 e10      e10
C  ----------
C     tau
C        E
C                =    P         +  P    -  P         +  P
C                      alpha        aux     rad          ohm
C 
C                      p   q                                  r
C  tau    =  gg  + ff n   T    ( P      + P    + P    + P    )
C     E                e20 e10    alpha    ohm    rad    ohm
C 
C  We solve this equation for (n   , T   ) subject to the constraints,
C                               e20   e10
C 
C            d P
C               aux
C            -----  =  0.
C            d T
C               e10
C 
C  to find the minimum auxiliary power required in start-up.
C
C--Author
C  Chris Gardner, c/o
C  Peter Knight D3/G12 Culham Laboratory, ext.3330
C
C--Date
C  25 November 1993
C
C--Reference
C  Work File Notes in F/MPE/MOD/CAG/PROCESS/PULSE
C  
C--History
C  25/11/93 PJK 1.000 Initial version
C
C--Arguments
C  iprint : (INPUT)  Flag to turn on/off (1/0) output to file
C
CCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCC

      IMPLICIT NONE

C  Parameters
      INTEGER n,m,meq,lcnorm,lb,ldel,lh,lwa,liwa
      PARAMETER(
     +     n = 2,
     +     m = 2,
     +     lcnorm = n+1,
     +     lb = n+1,
     +     ldel = 7*(n+1),
     +     lh = 2*(n+1),
     +     lwa = 2*(n+1),
     +     liwa = 6*(n+1)+m)

C  INCLUDE files
      INCLUDE 'param.h'
      INCLUDE 'numer.h'
      INCLUDE 'start.h'
      INCLUDE 'phydat.h'
      INCLUDE 'cdriv.h'
      INCLUDE 'ineq.h'

C  Arguments
      INTEGER iprint

C  Local variables
      DOUBLE PRECISION x(n),fgrd(n),conf(m),cnorm(lcnorm,m)
      DOUBLE PRECISION b(lb,lb),vlam1(m+2*n+1),glag(n),cm(m)
      DOUBLE PRECISION vmu(m+2*n+1),glaga(n),gamma1(n)
      DOUBLE PRECISION eta(n),xa(n),bdelta(n),delta(ldel)
      DOUBLE PRECISION gm(n+1),bdl(n+1),bdu(n+1),h(lh,lh)
      DOUBLE PRECISION wa(lwa),bndl(n),bndu(n)
      DOUBLE PRECISION objf,tol
      INTEGER maxfev,info,nfev,mode
      INTEGER iwa(liwa),ilower(n),iupper(n)

      DOUBLE PRECISION ne20,te10,ti10
      DOUBLE PRECISION fD,fDT
      DOUBLE PRECISION rrplas

C  External routines
      EXTERNAL start1,start2,vmcon1,oheadr,ovarre

C--End of preamble--CCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCC

      if (iprint.eq.1) goto 10

c *** ne20 : volume averaged electron density (10**20 m**-3)
c *** te10 : volume averaged electron temperature (10 keV)
c *** ti10 : volume averaged D-T temperature (10 keV)

c *** Define normalised temperature and densities.

      ne20 = dene/1.0d20
      te10 = te/10.0d0
      ti10 = ti/10.0d0

      aa = 0.24d0*(1.d0+(deni/dene+ralpne+rncne+rnone+rnfene)*ti/te)

      if ((ti10.gt.0.4d0).and.(ti10.le.1.0d0)) then
         s = 3
      else if ((ti10.gt.1.0d0).and.(ti10.le.2.0d0)) then
         s = 2

C *** Outside the above ranges of ti10, the value of s is not known
C *** (by PJK), so s is set according to whether ti10 is above
C *** or below unity...

      else if (ti10.le.1.0d0) then
         s = 3
      else
         s = 2

      end if   

      fD = (1.d0-ftr)
      fDT = deni/dene

C *** Alpha power multiplier

      bb = 0.155d0*(4.0d0*fD*(1.d0-fD)*fDT**2)*(1.d0+alphan+alphat)**s/
     +     ((1.d0+alphan)**(s-2)*(1.0d0+2.d0*alphan+dble(s)*alphat))

C *** Radiation power multiplier

      cc = 1.68d-2*(sqrt((1.0d0+alphan)**3)*sqrt(1.0d0+alphan+alphat)/
     +     (1.0d0+2.0d0*alphan+0.5d0*alphat))*zeff

C *** Ohmic power multiplier
C *** If the ohmic power density calculated in subroutine POHM is
C *** changed in the future then the constant DD must be changed 
C *** accordingly.

C *** The following lines come directly from the formulae within
C *** routine POHM, but with t10 replaced by pcoef

      rrplas = 2.15D-9*zeff*rmajor/(kappa*rminor**2*pcoef**1.5D0)
      if (ires.eq.1) then
         rrplas = rrplas*rpfac
      end if

      dd = (facoh*plascur)**2 * rrplas * 1.0D-6/vol

C *** Multiply coefficients by plasma volume

      aa = aa*vol
      bb = bb*vol
      cc = cc*vol
      dd = dd*vol

C *** Initial values for the density and temperature.

      x(1) = ne20
      x(2) = te10

C *** Initialise variables for VMCON

      meq = 1
      mode = 0
      tol = 1.0d-3
      maxfev = 100

      ilower(1) = 1
      ilower(2) = 1
      iupper(1) = 1
      iupper(2) = 1
      bndl(1) = 0.1d0
      bndl(2) = 0.5d0
      bndu(1) = 100.0d0
      bndu(2) = 50.0d0

C *** N.B. If the VMCON routine stored in minpac.f is used, then
C *** we have problems with recursive calls. Therefore we must call
C *** an almost identical version, VMCON1, instead.

      call vmcon1(start1,start2,mode,n,m,meq,x,objf,fgrd,conf,
     +     cnorm,lcnorm,b,lb,tol,maxfev,info,nfev,vlam1,glag,vmu,
     +     cm,glaga,gamma1,eta,xa,bdelta,delta,ldel,gm,bdl,bdu,
     +     h,lh,wa,lwa,iwa,liwa,ilower,iupper,bndl,bndu)

      auxmin = objf
      nign = x(1)*1.0D20
      tign = x(2)*10.0D0

      if (iprint.eq.0) goto 1000

 10   continue

      call oheadr(nout,'Start-up')

      call ovarre(nout,'Minimum auxiliary power requirement (MW)',
     +     '(auxmin)',auxmin)
      call ovarre(nout,'Start-up electron density (/m3)',
     +     '(x(1))',x(1)*1.0D20)
      call ovarre(nout,'Start-up electron temperature (keV)',
     +     '(x(2))',x(2)*10.0D0)

 1000 continue

      return
      end
C----------------------------------------------------------------------
      SUBROUTINE START1(n,m,x,objf,conf,info)
CCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCC
C--Version number 1.000
C
C--Description
C  Calculates the auxiliary power and the constraint equations
C  relevant to the minimisation of the auxiliary power.
C
C--Author
C  Chris Gardner, c/o
C  Peter Knight D3/G12 Culham Laboratory, ext.3330
C
C--Date
C  25 November 1993
C
C--Reference
C  Work File Notes in F/MPE/MOD/CAG/PROCESS/PULSE
C  
C--History
C  25/11/93 PJK 1.000 Initial version
C
C--Arguments
C  n       : (INPUT)  number of equations
C  m       : (INPUT)  number of constraints
C  x(n)    : (INPUT)  current values of the density and temperature
C  objf    : (OUTPUT) auxiliary power (MW)
C  conf(m) : (OUTPUT) contraints
C  info    : (IN/OUT) error status flag
C
CCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCC

      IMPLICIT NONE

C  Arguments
      INTEGER n,m,info
      DOUBLE PRECISION x(n),conf(m),objf

C  External routines
      EXTERNAL constr,cudrv1

C--End of preamble--CCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCC

      call cudrv1(n,x,objf)
      call constr(n,m,x,objf,conf)

C+**PJK 27/04/94      write(4,*) x(1),x(2)
C+**PJK 27/04/94      write(4,*) conf(1),conf(2)

      info = info*1

      return
      end
C----------------------------------------------------------------------
      SUBROUTINE START2(n,m,x,fgrd,cnorm,lcnorm,info)
CCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCC
C--Version number 1.000
C
C--Description
C  Calculates the first derivative of the auxiliary power
C  and the constraint equations relevant to the minimisation of
C  the auxiliary power
C
C--Author
C  Chris Gardner, c/o
C  Peter Knight D3/G12 Culham Laboratory, ext.3330
C
C--Date
C  25 November 1993
C
C--Reference
C  Work File Notes in F/MPE/MOD/CAG/PROCESS/PULSE
C  
C--History
C  25/11/93 PJK 1.000 Initial version
C
C--Arguments
C  n       : (INPUT)  number of equations
C  m       : (INPUT)  number of constraints
C  x(n)    : (INPUT)  current values of density and temperature
C  fgrd(n) : (OUTPUT) first derivative of auxiliary power
C  cnorm(m,lcnorm) : (INPUT)  constraints
C  lcnorm  : (INPUT)  array index
C  info    : (IN/OUT) error status flag
C
CCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCC

      IMPLICIT NONE

C  INCLUDE files
      INCLUDE 'param.h'
      INCLUDE 'numer.h'

C  Arguments
      INTEGER n,m,lcnorm,info
      DOUBLE PRECISION x(n),fgrd(n),cnorm(lcnorm,m)

C  Local variables
      DOUBLE PRECISION xfor(2),xbac(2),cfor(2),cbac(2)
      DOUBLE PRECISION ffor,fbac
      INTEGER i,j

C  External routines
      EXTERNAL constr,cudrv1

C--End of preamble--CCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCC

      do 30 i = 1,n
         do 10 j = 1,n
            xfor(j) = x(j)
            xbac(j) = x(j)
            if (i.eq.j) then
               xfor(i) = x(j)*(1.0d0+epsfcn)
               xbac(i) = x(j)*(1.0d0-epsfcn)
            end if
 10      continue

         call cudrv1(n,xfor,ffor)
         call constr(n,m,xfor,ffor,cfor)
         call cudrv1(n,xbac,fbac)
         call constr(n,m,xbac,fbac,cbac)

         fgrd(i) = (ffor-fbac)/(xfor(i)-xbac(i))

         do 20 j = 1,m
            cnorm(i,j) = (cfor(j)-cbac(j))/(xfor(i)-xbac(i))
 20      continue
 30   continue

      info = info*1

      return
      end
C----------------------------------------------------------------------
      SUBROUTINE cudrv1(n,x,paux)
CCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCC
C--Version number 1.000
C
C--Description
C  Routine acting as interface between the start-up routines
C  and CUDRIV.
C
C--Author
C  Chris Gardner, c/o
C  Peter Knight D3/G12 Culham Laboratory, ext.3330
C
C--Date
C  25 November 1993
C
C--Reference
C  Work File Notes in F/MPE/MOD/CAG/PROCESS/PULSE
C  
C--History
C  25/11/93 PJK 1.000 Initial version
C
C--Arguments
C  n      : (INPUT)  number of equations
C  x(n)   : (INPUT)  current values of the density and temperature
C  paux   : (OUTPUT) auxiliary power (MW)
C
CCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCC

      IMPLICIT NONE

C  INCLUDE files
      INCLUDE 'param.h'
      INCLUDE 'numer.h'
      INCLUDE 'phydat.h'
      INCLUDE 'cdriv.h'

C  Arguments
      INTEGER n
      DOUBLE PRECISION x(n),paux

C  Local variables
      DOUBLE PRECISION storen,storet

C  External routines
      EXTERNAL physics

C--End of preamble--CCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCC

C *** Set electron density, temperature for this iteration, but
C *** store original values to allow them to be reset later

      storen = dene
      storet = te

      dene = x(1)*1.0D20
      te = x(2)*10.0D0

C *** Call the physics routines with these values - PHYSICS calls
C *** routine CUDRIV itself.

      call physics

C *** Total injection power (MW)

      paux = (pinje + pinji)*1.0D-6

C *** Reset density and temperature to pre-call values

      dene = storen
      te = storet

C *** Call physics routines again to reset all values

      call physics

      return
      end
C----------------------------------------------------------------------
      SUBROUTINE constr(n,m,x,paux,conf)
CCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCC
C--Version number 1.000
C
C--Description
C  Calculate the constraint equations relevant to the minimisation of
C  the auxiliary power.
C
C--Author
C  Chris Gardner, c/o
C  Peter Knight D3/G12 Culham Laboratory, ext.3330
C
C--Date
C  25 November 1993
C
C--Reference
C  Work File Notes in F/MPE/MOD/CAG/PROCESS/PULSE
C  
C--History
C  25/11/93 PJK 1.000 Initial version
C
C--Arguments
C  n       : (INPUT)  number of equations
C  m       : (INPUT)  number of constraints
C  x(n)    : (INPUT)  current values of the density and temperature
C  paux    : (INPUT)  auxiliary power (MW)
C  conf(m) : (OUTPUT) constraints
C
CCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCC

      IMPLICIT NONE

C  INCLUDE files
      INCLUDE 'start.h'

C  Arguments
      INTEGER n,m
      DOUBLE PRECISION x(n),conf(m),paux

C  Local variables
      DOUBLE PRECISION eta,detadt

C--End of preamble--CCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCC

      eta = bb*x(1)**2*x(2)**s+paux-cc*x(1)**2*sqrt(x(2))+dd/
     +     sqrt(x(2)**3)
      detadt = dble(s)*bb*x(1)**2*x(2)**(s-1)-0.5d0*cc*x(1)**2/
     +     sqrt(x(2))-1.5d0*dd/sqrt(x(2)**5)

      conf(1) = aa*x(1)-(gtaue+ftaue*(1.d0+rtaue)*x(1)**ptaue*
     +     x(2)**qtaue*eta**rtaue)*detadt-qtaue*ftaue*
     +     x(1)**ptaue*x(2)**(qtaue-1.0D0)*eta**(rtaue+1.0D0)
      conf(2) = paux

      return
      end
c______________________________________________________________________
C+**PJK 25/11/93 The following has been added to help STARTUP run.
c______________________________________________________________________
      SUBROUTINE VMCON1(
     +     start1,start2,mode,n,m,meq,x,objf,fgrd,conf,cnorm,lcnorm,
     +     b,lb,tol,maxfev,info,nfev,vlam,glag,vmu,cm,glaga,gamma,eta,
     +     xa,bdelta,delta,ldel,gm,bdl,bdu,h,lh,wa,lwa,iwa,liwa,ilower,
     +     iupper,bndl,bndu)

C+**PJK 25/11/93 This routine is identical to subroutine VMCON
C+**PJK 25/11/93 stored in minpac.f, but calls different routines
C+**PJK 25/11/93 start1,  start2  and qpsub1, instead of
C+**PJK 25/11/93 fcnvmc1, fcnvmc2 and qpsub, respectively.

c  This subroutine calculates the least value of a function of
c  several variables subject to linear and/or nonlinear equality
c  and inequality constraints.  More particularly, it solves the
c  problem
c
c            minimize f(x)
c
c     subject to c (x) =  0.0 ,  i = 1,...,meq
c                 i
c
c            and c (x) >= 0.0 ,  i = meq+1,...,m
c                 i
c
c            and l <= x <= u  ,  i = 1,...n
c                 i    i    i
c
c
c  The subroutine implements a variable metric method for
c  constrained optimization developed by M.J.D. Powell.
c
c  The subroutine statement is
c
c    subroutine vmcon1(start1,start2,mode,n,m,meq,x,objf,fgrd,conf,
c                     cnorm,lcnorm,b,lb,tol,maxfev,info,
c                     nfev,vlam,glag,vmu,cm,glaga,gamma,eta,xa,
c                     bdelta,delta,ldel,gm,bdl,bdu,h,lh,wa,lwa,iwa,
c                     liwa)
c
c  where
c
c  START1 is the name of the user supplied subroutine which
c  calculates the objective and constraint functions. START1
c  should be declared in an external statement in the user
c  calling program, and should be written as follows:
c
c   subroutine start1(n,m,x,objf,conf,info)
c   integer n,m,info
c   real objf
c   real x(n),fgrd(n),conf(m)
c   ---------------
c   statements to calculate the objective and constraint at x.
c   the objective and constraint functions and must be returned in
c   objf, conf. note that the equality
c   constraints must precede the inequality constraints in conf.
c   ---------------
c   return
c   end
c
c  START2 is the name of the user supplied subroutine which
c  calculates the gradients (first derivative vectors)
c  of the objective and constraint functions. START2 should be
c  declared in an external statement in the user calling
c  program, and should be written as follows :
c
c   subroutine start2(n,m,x,fgrd,cnorm,lcnorm,info)
c   integer n,m,lcnorm,info
c   real objf
c   real x(n),cnorm(lcnorm,m)
c   ---------------
c   statements to calculate the gradients of the objective and
c   constraint functions at x. the gradient of the objective
c   function must be returned in fgrd. note that the equality
c   constraints must precede the inequality constraints in conf.
c   the constraint gradients or normals must be returned as the
c   columns of cnorm.
c   ---------------
c   return
c   end
c
c  The value of INFO should not be changed by START2 unless the
c  user wants to terminate execution of VMCON1. In this case
c  set INFO to a negative integer.
c
c  MODE is a non-negative integer input variable set to 1 if the
c  second derivative matrix in b (see below) is provided by the
c  user, and to 0 if it is to be initialized to the identity
c  matrix.
c
c  N is a positive integer input variable set to the number of
c  variables.
c
c  M is a positive integer input variable set to the number of
c  constraints.
c
c  MEQ is a non-negative integer input variable set to the number
c  of equality constraints. MEQ must be less than or equal to N.
c
c  X is a real array of length N. On input it must contain an
c  initial estimate of the solution vector. On output X
c  contains the final estimate of the solution vector.
c
c  OBJF is a real output variable that contains the value of the
c  objective function at the output x.
c
c  FGRD is a real output array of length N which contains the
c  components of the gradient of the objective function at
c  the output X.
c
c  CONF is a real output array of length M which contains the
c  values of the constraint functions at the output X. The
c  equality constraints must precede the inequality constraints.
c
c  CNORM is a real LCNORM by M array whose columns contain the
c  constraint normals at the output X in the first N positions.
c
c  LCNORM is a positive integer input variable set to the row
c  dimension of CNORM which is at least N+1.  The (N+1)st row
c  of CNORM is used for work space.
c
c  B is a real LB by LB array whose first N rows and columns
c  contain the approximation to the second derivative matrix
c  of the Lagrangian function. Often, an adequate initial
c  B matrix can be obtained by approximating the hessian
c  of the objective function.  On input, the approximation is
c  provided by the user if MODE = 1 and is set to the identity
c  matrix if MODE = 0. the (N+1)st row and column are used for
c  work space.
c
c  LB is a positive integer input variable set to the row
c  dimension of B which is at least N+1.
c
c  TOL is a non-negative input variable. A normal return occurs
c  when the objective function plus suitably weighted multiples
c  of the constraint functions are predicted to differ from
c  their optimal values by at most TOL.
c
c  MAXFEV is a positive integer input variable set to the limit
c  on the number of calls to START1.
c
c  INFO is an integer output variable set as follows
c
c   if INFO is negative then user termination. otherwise
c
c   INFO = 0  improper input parameters. Tests are made to ensure
c             that N and M are positive, TOL is non-negative,
c             MEQ is less than or equal to N, and that LCNORM,
c             LB, LDEL, LH, LWA, and LIWA are sufficiently large.
c
c   INFO = 1  a normal return. see description of TOL.
c
c   INFO = 2  number of calls to START1 is at least MAXFEV.
c
c   INFO = 3  line search required ten calls of START1.
c
c   INFO = 4  uphill search direction was calculated.
c
c   INFO = 5  quadratic programming technique was unable to find
c             a feasible point.
c
c   INFO = 6  quadratic programming technique was restricted by
c             an artificial bound or failed due to a singular
c             matrix.
c
c  NFEV is an integer output variable set to the number of calls
c  to START1.
c
c  VLAM is a real output array of length M+2N+1 which contains
c  the Lagrange multipliers at the output X.  The Lagrange
c  multipliers provide the sensitivity of the objective
c  function to changes in the constraint functions.
c  note that VLAM(M+I), I=1,...,N gives the multipliers for
c  the lower bound constraints.  VLAM(M+N+1+I), I=1,...,N
c  gives the multipliers for the upper bound constraints.
c
c  GLAG is a real output array of length N which contains the
c  components of the gradient of the Lagrangian function at
c  the output x.
c
c  CM is a real work array of length M.
c
c  VMU is a real work array of length M+2N+1.
c
c  GLAGA, GAMMA, ETA, XA, BDELTA are real work arrays of
c  length N.
c
c  DELTA is a real work array of length LDEL.
c
c  LDEL is a positive integer input variable set equal to the
c  length of DELTA which is at least MAX(7*(N+1),4*(N+1)+M).
c
c  GM, BDL, BDU are real work arrays of length N+1.
c
c  H is a real LH by LH work array.
c
c  LH is a positive integer input variable set to the dimension
c  of the square array H which is at least 2*(N+1).
c
c  WA is a real work array of length LWA.
c
c  LWA is a positive integer input variable set equal to the
c  dimension of WA which is at least 2*(N+1).
c
c  IWA is an integer work array of length LIWA.
c
c  LIWA is a positive integer input variable set equal to the
c  dimension of IWA which is at least 6*(N+1) + M.
c
c  ILOWER is an integer array of length N.
c  If X(I) has a lower bound, ILOWER(I) is set to 1
c  on input.  If no bound is provided, ILOWER(i) should
c  be 0 (the default value).
c
c  BNDL is a real array of length N.
c  If X(I) has a lower bound, it should be given in BNDL(I).
c
c  IUPPER is an integer array of length N.
c  If X(I) has an upper bound, IUPPER(I) is set to 1
c  on input.  If no bound is provided, IUPPER(I) should
c  be 0 (the default value).
c
c  BNDU is a real array of length N.
c  If X(I) has a upper bound, it should be given in BNDU(I).
c
c  Algorithm version of June 1979.
c
c  Roger L. Crane, Kenneth E. Hillstrom, Michael Minkoff
c  Modified for simple bounds, M. Minkoff (10/26/82)
c  Modified for separate function and gradient evaluation,
c  M. Minkoff (11/18/83)
c  Modified to pass ILOWER, IUPPER,BNDL,BDNU through argument
c  list instead of through common block, and remove write
c  capability J. Galambos (5/21/91)
c  Modified for separate START1 and START2 functions to avoid passing
c  info via a common block. J. Galambos (5/21/91)

      IMPLICIT NONE

      INTEGER mode,n,m,meq,lcnorm,lb,maxfev,info,nfev,ldel,lh,lwa,liwa
      INTEGER iwa(liwa),ilower(n),iupper(n)
      INTEGER i,j,k,mact,nfinit,nls,np1,np1j,npp,nqp,nsix,nsixi
      INTEGER inx,ki,ml,mlp1,mcon,mp1,mpn,mpnpp1,mpnppn

      DOUBLE PRECISION objf,tol
      DOUBLE PRECISION x(n),fgrd(n),conf(m),cnorm(lcnorm,m),b(lb,lb),
     +     vlam(*),glag(n),vmu(*),cm(m),glaga(n),gamma(n),
     +     eta(n),xa(n),bdelta(n),delta(ldel),gm(*),
     +     bdl(*),bdu(*),h(lh,lh),wa(lwa),bndl(n),bndu(n)
      DOUBLE PRECISION alpha,aux,auxa,calpha,cp1,cp2,cp5,dbd,dflsa,dg,
     +     fls,flsa,one,spgdel,sum,temp,thcomp,theta,zero

      EXTERNAL start1,start2

      zero = 0.0D0
      cp1 = 0.1D0
      cp2 = 0.2D0
      cp5 = 0.5D0
      one = 1.0D0

      np1 = n + 1
      npp = 2*np1
      info = 0

c  Check input parameters for errors

      if (
     +     (n.le.0)           .or.
     +     (m.le.0)           .or.
     +     (meq.gt.n)         .or.
     +     (lcnorm.lt.(n+1))  .or.
     +     (lb.lt.(n+1))      .or.
     +     (tol.lt.zero)      .or.
     +     (ldel.lt.max(7*(n+1),4*(n+1)+m)).or.
     +     (lh.lt.(2*(n+1)))  .or.
     +     (lwa.lt.(2*(n+1))) .or.
     +     (liwa.lt.(6*(n+1)+m))
     +     ) goto 450

c  Set the initial elements of b and vmu. vmu is the weighting
c  vector to be used in the line search.
c  Use hessian estimate provided by user if mode = 1 on input

      if (mode .eq. 1) goto 25

c  Use identity matrix for hessian estimate

      do 20 j = 1, n
         do 10 i = 1, n
            b(i,j) = zero
 10      continue
         b(j,j) = one
 20   continue

 25   continue

c  Set m + 1 to mp1
c  Set m + n to mpn (these are limits for lower bound indices)
c  Set m + np1 + 1 to mpnpp1
c  Set m + np1 + n to mpnppn (these are limits for upper bound
c  indices)

      mp1 = m + 1
      mpn = m + n
      mpnpp1 = m + np1 + 1
      mpnppn = m + np1 + n

c  Set mcon to total number of actual constraints

      mcon = m
      do 26 i = 1, n
         if (ilower(i) .eq. 1) mcon = mcon + 1
 26   continue

c  Set ml to m + number of lower bounds

      ml = mcon

c  Set mlp1 to ml + 1

      mlp1 = ml + 1
      do 27 i = 1, n
         if (iupper(i) .eq. 1) mcon = mcon + 1
 27   continue
      do 30 k = 1, mpnppn
         vmu(k) = zero
 30   continue

c  Set initial values of some variables
c  nfev is the number of calls of start1
c  nsix is the length of an array
c  nqp is the number of quadratic subproblems

      nfev = 1
      nsix = 6*np1
      nqp = 0

c  Calculate the initial functions and gradients

      call start1(n,m,x,objf,conf,info)

      if (info .lt. 0) goto 450

      call start2(n,m,x,fgrd,cnorm,lcnorm,info)

      if (info .lt. 0) goto 450

c  Start the iteration by calling the quadratic programming
c  subroutine

 40   continue

c  Increment the quadratic subproblem counter

      nqp = nqp + 1

c  Set the linear term of the quadratic problem objective function
c  to the negative gradient of objf

      do 50 i = 1, n
         gm(i) = -fgrd(i)
 50   continue
      do 55 i = 1, mpnppn
         vlam(i) = zero
 55   continue

C+**PJK 15/11/11      call qpsub1(
      call qpsub(
     +     n,m,meq,conf,cnorm,lcnorm,b,lb,gm,bdl,bdu,info,x,delta,
     +     ldel,cm,h,lh,mact,wa,lwa,iwa,liwa,ilower,iupper,
     +     bndl,bndu)

c  The following return is made if the quadratic problem solver
c  failed to find a feasible point, if an artificial bound was
c  active, or if a singular matrix was detected

      if ((info .eq. 5) .or. (info .eq. 6)) goto 450

c  Initialize the line search iteration counter

      nls = 0

c  Calculate the Lagrange multipliers

      do 70 j = 1, mact
         k = iwa(j) - npp
         if (k .gt. 0) goto 59
         ki = iwa(j)
         k = ki + m
         if (ki .gt. np1) goto 58
         if (ki .eq. np1) goto 70
         if (ilower(ki) .eq. 1) goto 59
         goto 70
 58      continue
         ki = iwa(j) - np1
         k = ki + m + np1
         if (ki .eq. np1) goto 70
         if (iupper(ki) .eq. 1) goto 59
         goto 70
 59      continue
         do 60 i = 1, n
            np1j = np1 + j
            nsixi = nsix + i
            vlam(k) = vlam(k) + h(np1j,i)*delta(nsixi)
 60      continue
 70   continue

c  Calculate the gradient of the Lagrangian function
c  nfinit is the value of nfev at the start of an iteration

      nfinit = nfev
      do 80 i = 1, n
         glag(i) = fgrd(i)
 80   continue
      do 100 k = 1, m
         if (vlam(k) .eq. zero) goto 100
         do 90 i = 1, n
            glag(i) = glag(i) - cnorm(i,k)*vlam(k)
 90      continue
 100  continue
      do 105 k = mp1, mpn
         if (vlam(k) .eq. zero) goto 105
         inx = k - m
         if (ilower(inx) .eq. 0) goto 105
         glag(inx) = glag(inx) - vlam(k)
 105  continue
      do 106 k = mpnpp1, mpnppn
         if (vlam(k) .eq. zero) goto 106
         inx = k - m - np1
         if (iupper(inx) .eq. 0) goto 106
         glag(inx) = glag(inx) + vlam(k)
 106  continue

c  Set spgdel to the scalar product of fgrd and delta
c  Store the elements of glag and x

      spgdel = zero
      do 110 i = 1, n
         spgdel = spgdel + fgrd(i)*delta(i)
         glaga(i) = glag(i)
         xa(i) = x(i)
 110  continue

c  Revise the vector vmu and test for convergence

      sum = abs(spgdel)
      do 120 k = 1, mpnppn
         aux = abs(vlam(k))
         vmu(k) = max(aux,cp5*(aux + vmu(k)))
         temp = 0.00D0
         if (k .gt. m) goto 111
         temp = conf(k)
         goto 119
 111     continue
         if (k .gt. mpn) goto 112
         inx = k - m
         if (ilower(inx) .eq. 0) goto 120
         temp = x(inx) - bndl(inx)
         goto 119
 112     continue
         inx = k - m - np1
         if ((inx .eq. 0) .or. (inx .gt. n)) goto 120
         if (iupper(inx) .eq. 0) goto 120
         temp = bndu(inx) - x(inx)
 119     continue
         sum = sum + abs(vlam(k)*temp)
 120  continue

c  Exit if convergence criterion is satisfied

      if (sum .le. tol) goto 450

c  Set sum to the weighted sum of infeasibilities
c  Set fls to the line search objective function

 130  continue

c  Increment the line search iteration counter

      nls = nls + 1
      sum = zero
      do 140 k = 1, mpnppn
         aux = 0.0D0
         if (k .le. meq) aux = conf(k)
         temp = 0.0D0
         if (k .gt. m) goto 131
         temp = conf(k)
         goto 139
 131     continue
         if (k .gt. mpn) goto 132
         inx = k - m
         if (ilower(inx) .eq. 0) goto 140
         temp = x(inx) - bndl(inx)
         goto 139
 132     continue
         inx = k - m - np1
         if ((inx .eq. 0) .or. (inx .gt. n)) goto 140
         if (iupper(inx) .eq. 0) goto 140
         temp = bndu(inx) - x(inx)
 139     continue
         sum = sum + vmu(k)*max(aux,-temp)
 140  continue
      fls = objf + sum

      if (nfev .ne. nfinit) goto 150

c  Set the initial conditions for the line search
c  flsa is the initial value of the line search function
c  dflsa is its first derivative (if delta(np1) = 1)
c  alpha is the next reduction in the step-length

      flsa = fls
      dflsa = spgdel - delta(np1)*sum
      if (dflsa .ge. zero) goto 420

c  Set initial multiplying factor for stepsize
c  Set initial value of stepsize for output

      alpha = one
      calpha = one
      goto 210

c  Test whether line search is complete

 150  continue
      aux = fls - flsa

c  Exit line search if function difference is small

      if (aux .le. (cp1*dflsa)) goto 260

c  Exit if the line search requires ten or more function
c  evaluations

      if (nfev .ge. (nfinit + 10)) goto 380

c  Calculate next reduction in the line step assuming a quadratic
c  fit.

      alpha = max(cp1,cp5*dflsa/(dflsa - aux))

c  Multiply delta by alpha and calculate the new x

 210  continue
      calpha = alpha*calpha

      do 220 i = 1, n
         delta(i) = alpha*delta(i)
         x(i) = xa(i) + delta(i)
 220  continue

      dflsa = alpha*dflsa

c  Test nfev against maxfev, call start1 and resume line search

      if (nfev .ge. maxfev) goto 380
      nfev = nfev + 1

      call start1(n,m,x,objf,conf,info)

      if (info .lt. 0) goto 450
      goto 130

c  Line search is complete. Calculate gradient of Lagrangian
c  function for use in updating hessian of Lagrangian

 260  continue

      call start1(n,m,x,objf,conf,info)
      call start2(n,m,x,fgrd,cnorm,lcnorm,info)

      if (info .lt. 0) goto 450
      do 270 i = 1, n
         glag(i) = fgrd(i)
 270  continue
      do 290 k = 1, m
         if (vlam(k) .eq. zero) goto 290
         do 280 i = 1, n
            glag(i) = glag(i) - cnorm(i,k)*vlam(k)
 280     continue
 290  continue
      do 291 k = mp1, mpn
         if (vlam(k) .eq. zero) goto 291
         inx = k - m
         if (ilower(inx) .eq. 0) goto 291
         glag(inx) = glag(inx) - vlam(k)
 291  continue
      do 292 k = mpnpp1, mpnppn
         if (vlam(k) .eq. zero) goto 292
         inx = k - m - np1
         if (iupper(inx) .eq. 0) goto 292
         glag(inx) = glag(inx) + vlam(k)
 292  continue

c  Calculate gamma and bdelta in order to revise b
c  Set dg to the scalar product of delta and gamma
c  Set dbd to the scalar product of delta and bdelta

      dg = zero
      dbd = zero
      do 340 i = 1, n
         gamma(i) = glag(i) - glaga(i)
         bdelta(i) = zero
         do 330 j = 1, n
            bdelta(i) = bdelta(i) + b(i,j)*delta(j)
 330     continue
         dg = dg + delta(i)*gamma(i)
         dbd = dbd + delta(i)*bdelta(i)
 340  continue

c  Calculate the vector eta for the b-f-g-s formula
c  replace dg by the scalar product of delta and eta

      aux = cp2*dbd
      theta = one
      if (dg .lt. aux) theta = (dbd - aux)/(dbd - dg)
      thcomp = one - theta
      do 350 i = 1, n
         eta(i) = theta*gamma(i) + thcomp*bdelta(i)
 350  continue
      if (dg .lt. aux) dg = aux

c  Revise the matrix b and begin new iteration

      do 375 i = 1, n
         aux = bdelta(i)/dbd
         auxa = eta(i)/dg
         do 370 j = i, n
            b(i,j) = b(i,j) - aux*bdelta(j) + auxa*eta(j)
            b(j,i) = b(i,j)
 370     continue
 375  continue
      goto 40

c  Error returns. restore previous solution

 380  continue
      do 390 i = 1, n
         x(i) = xa(i)
 390  continue
      if (nfev .ge. maxfev) goto 400
      nfev = nfev + 1

      call start1(n,m,x,objf,conf,info)

      if (info .lt. 0) goto 450
      goto 410

c  Error return because there have been maxfev calls of start1

 400  continue
      info = 2
      goto 450

c  Error return because line search required 10 calls of start1

 410  continue
      info = 3
      goto 450

c  Error return because uphill search direction was calculated

 420  continue
      info = 4

 450  continue

      return
      end
c$$$c______________________________________________________________________
c$$$      SUBROUTINE QPSUB1(
c$$$     +     n,m,meq,conf,cnorm,lcnorm,b,lb,gm,bdl,bdu,info,
c$$$     +     x,delta,ldel,cm,h,lh,mact,wa,lwa,iwa,liwa,
c$$$     +     ilower,iupper,bndl,bndu)
c$$$
c$$$c  This subroutine finds the value of the solution vector which
c$$$c  minimizes a quadratic function of several variables subject to
c$$$c  equality and inequality constraints. This is accomplished
c$$$c  by invoking subroutine harwqp, a modified version of subroutine
c$$$c  ve02ad, the Harwell Library subroutine for general quadratic
c$$$c  programming.
c$$$c
c$$$c  The subroutine statement is
c$$$c
c$$$c  subroutine qpsub1(n,m,meq,conf,cnorm,lcnorm,b,lb,gm,bdl,bdu,
c$$$c                   info,delta,ldel,cm,h,lh,mact,wa,lwa,iwa,liwa)
c$$$c
c$$$c  where
c$$$c
c$$$c  N is a positive integer input variable set to the number of
c$$$c  variables.
c$$$c
c$$$c  M is a positive integer input variable set to the number of
c$$$c  constraints.
c$$$c
c$$$c  MEQ is a non-negative integer input variable set to the number
c$$$c  of equality constraints. MEQ must be less than or equal to N.
c$$$c
c$$$c  CONF is a real input array of length M which contains the
c$$$c  constraint functions.
c$$$c
c$$$c  CNORM is a real LCNORM by M array whose columns contain the
c$$$c  constraint normals in the first N positions.  The (N+1)st
c$$$c  row of CNORM is used for work space.
c$$$c
c$$$c  LCNORM is a positive integer input variable set to the row
c$$$c  dimension of CNORM which is at least N+1.
c$$$c
c$$$c  B is a real LB by LB array whose first N rows and columns
c$$$c  contain the hessian approximation on input.  The (N+1)st
c$$$c  row and column are used for work space.
c$$$c
c$$$c  LB is a positive integer input variable set to the row
c$$$c  dimension of B which is at least N+1.
c$$$c
c$$$c  GM is a real array of length N+1 which, on input, contains
c$$$c  the negative components of the function gradient in the
c$$$c  first N elements. The (N+1)st element is used for work space.
c$$$c
c$$$c  BDL, BDU are real work arrays of length N+1.
c$$$c
c$$$c  INFO is an integer variable. It must be set to zero before
c$$$c  the initial call to qpsub1 and should not otherwise be
c$$$c  changed.  On output, INFO is set as follows
c$$$c
c$$$c   INFO = 1  a normal return.
c$$$c
c$$$c   INFO = 5  a feasible point was not found.
c$$$c
c$$$c   INFO = 6  solution is restricted by an artificial bound or
c$$$c             failed due to a singular matrix.
c$$$c
c$$$c  DELTA is a real array of length LDEL.  It need not be set
c$$$c  before the first call to QPSUB1, but before each subsequent
c$$$c  call, the first N locations should contain an estimate of
c$$$c  the solution vector. (Zero is used as the estimate for the
c$$$c  first call.)  On output, the value of the solution vector
c$$$c  which minimizes the quadratic function is contained in the
c$$$c  first N locations.  The remainder of the array is used for
c$$$c  work space.
c$$$c
c$$$c  LDEL is a positive integer input variable set to the length
c$$$c  of DELTA which is at least MAX(7*(N+1),4*(N+1)+M).
c$$$c
c$$$c  CM is a real work array of length M.
c$$$c
c$$$c  H is a real LH by LH work array.
c$$$c
c$$$c  LH is a positive integer input variable set to the dimension
c$$$c  of the square array H which is at least 2*(N+1).
c$$$c
c$$$c  MACT is an integer output variable set to the number of
c$$$c  constraints in the basis.
c$$$c
c$$$c  WA is a real work array of length LWA.
c$$$c
c$$$c  LWA is a positive integer input variable set equal to the
c$$$c  dimension of WA which is at least 2*(N+1).
c$$$c
c$$$c  IWA is an integer work array of length LIWA.
c$$$c
c$$$c  LIWA is a positive integer input variable set to the length
c$$$c  of IWA which is at least 6*(N+1) + M.
c$$$c
c$$$c  ILOWER is an integer array of length N.
c$$$c  If X(I) has a lower bound, ILOWER(I) is set to 1
c$$$c  on input.  If no bound is provided, ILOWER(I) should
c$$$c  be 0 (the default value).
c$$$c
c$$$c  BNDL is a real array of length N.
c$$$c  If X(I) has a lower bound, it should be given in BNDL(I).
c$$$c
c$$$c  IUPPER is an integer array of length N.
c$$$c  If X(I) has a upper bound, IUPPER(I) is set to 1
c$$$c  on input.  If no bound is provided, IUPPER(I) should
c$$$c  be 0 (the default value).
c$$$c
c$$$c  BNDU is a real array of length N.
c$$$c  If X(I) has a upper bound, it should be given in BNDU(I).
c$$$c
c$$$c  Roger L. Crane, Kenneth E. Hillstrom, Michael Minkoff
c$$$c  Modified for simple bounds, M. Minkoff (10/26/82)
c$$$c
c$$$c  Modified to pass ILOWER,IUPPER, BNDL,BNDU in through argument list
c$$$c  instead of through COMMON, J. Galambos, (5/21/91)
c$$$
c$$$      IMPLICIT NONE
c$$$
c$$$      INTEGER n,m,meq,lcnorm,lb,info,ldel,lh,mact,lwa,liwa
c$$$      INTEGER iwa(liwa),ilower(n),iupper(n)
c$$$      INTEGER i,iflag,j,k,mode,mtotal,np1,npp
c$$$      INTEGER inx
c$$$
c$$$      DOUBLE PRECISION conf(m),cnorm(lcnorm,m),b(lb,lb),gm(*),bdl(*),
c$$$     +     bdu(*),delta(ldel),cm(m),h(lh,lh),wa(lwa)
c$$$      DOUBLE PRECISION x(n),bndu(n),bndl(n)
c$$$      DOUBLE PRECISION cd6,cdm6,cp9,one,zero
c$$$
c$$$      cd6 = 1.0D6
c$$$      cdm6 = 1.0D-6
c$$$      cp9 = 0.9D0
c$$$      one = 1.0D0
c$$$      zero = 0.0D0
c$$$
c$$$      np1 = n + 1
c$$$      npp = 2*np1
c$$$      if (info .gt. 0) goto 50
c$$$      mtotal = m + npp
c$$$
c$$$c  Set initial values of some variables
c$$$
c$$$      info = 1
c$$$      mact = meq + 1
c$$$      mode = 1
c$$$
c$$$c  Set the initial elements of bdl, bdu, and delta where
c$$$c  bdl are artificial lower bounds,
c$$$c  bdu are artificial upper bounds and
c$$$c  delta is an initial solution estimate
c$$$
c$$$      do 10 i = 1, n
c$$$         bdl(i) = -cd6
c$$$         bdu(i) = cd6
c$$$ 10   continue
c$$$
c$$$c  Bound the artificial variables in qp
c$$$
c$$$      bdl(np1) = zero
c$$$      delta(np1) = one
c$$$      if (meq .le. 0) goto 30
c$$$
c$$$c  Set indices of equality constraints
c$$$c  The bounds are the first npp constraints
c$$$
c$$$      do 20 k = 1, meq
c$$$         iwa(k) = k + npp
c$$$ 20   continue
c$$$
c$$$ 30   continue
c$$$
c$$$c  Set index of upper bound of delta(np1) active
c$$$
c$$$      iwa(mact) = npp
c$$$
c$$$c  Extend gm and b because of the extra variable that is introduced
c$$$c  to allow for feasibility. Set linear term of cost function to
c$$$c  a large value
c$$$
c$$$      gm(np1) = cd6
c$$$      do 40 i = 1, np1
c$$$         b(i,np1) = zero
c$$$         b(np1,i) = zero
c$$$ 40   continue
c$$$
c$$$c  Set the elements of cm and cnorm(np1,*)
c$$$
c$$$ 50   continue
c$$$      do 60 i = 1, n
c$$$         if (ilower(i) .eq. 1) bdl(i) = bndl(i) - x(i)
c$$$         if (iupper(i) .eq. 1) bdu(i) = bndu(i) - x(i)
c$$$         delta(i) = max(zero,bdl(i))
c$$$         delta(i) = min(delta(i),bdu(i))
c$$$ 60   continue
c$$$      do 90 k = 1, m
c$$$         if (k .le. meq) goto 70
c$$$         if (conf(k) .lt. zero) goto 70
c$$$
c$$$c  If an inequality constraint is satisfied set the constant term
c$$$c  in the constraint vector to the violation and put zero in the
c$$$c  constraint matrix for the (n+1)st variable
c$$$
c$$$         cm(k) = -conf(k)
c$$$         cnorm(np1,k) = zero
c$$$         goto 90
c$$$ 70      continue
c$$$
c$$$c  If the constraint is an equality or a violated inequality set
c$$$c  the constant term to zero and put the function value in the
c$$$c  constraint matrix for the (n+1)st variable
c$$$
c$$$         cm(k) = zero
c$$$         cnorm(np1,k) = conf(k)
c$$$ 90   continue
c$$$
c$$$c  Set the upper bound of the (n+1)st variable
c$$$c  Set iflag. iflag will be used in checking active constraints
c$$$c  Call subroutine harwqp to solve quadratic programming problem
c$$$
c$$$      bdu(np1) = one
c$$$      iflag = -1
c$$$ 100  continue
c$$$
c$$$      call harwqp1(np1,mtotal,b,lb,gm,cnorm,lcnorm,cm,bdl,bdu,delta,
c$$$     +     mact,meq,h,lh,iwa,wa,iwa(4*(n+1)+m+1),mode,info)
c$$$
c$$$      if (info .ne. 1) goto 130
c$$$
c$$$c  Check whether the required feasibility conditions hold
c$$$c  If delta(np1) is sufficiently small there is no feasible
c$$$c  solution
c$$$
c$$$      if (delta(np1) .le. cdm6) goto 120
c$$$
c$$$c  Check whether active constraints are bounds
c$$$
c$$$      do 110 j = 1, mact
c$$$         if (iwa(j) .gt. npp) goto 110
c$$$         if (iwa(j) .eq. npp) goto 101
c$$$         if (iwa(j) .gt. np1) goto 105
c$$$         if (iwa(j) .eq. np1) goto 130
c$$$         if (ilower(iwa(j)) .eq. 0) goto 130
c$$$         goto 110
c$$$ 105     continue
c$$$         inx = iwa(j) - np1
c$$$         if (iupper(inx) .eq. 0) goto 130
c$$$         goto 110
c$$$ 101     continue
c$$$
c$$$c  The active constraint is blu(np1)
c$$$
c$$$         iflag = 1
c$$$ 110  continue
c$$$
c$$$c  Normal exit
c$$$
c$$$      if (iflag .ge. 1) goto 140
c$$$
c$$$c  A second call to harwqp found blu(np1) to still be inactive
c$$$c  thus an error exit is made
c$$$
c$$$      if (iflag .ge. 0) goto 120
c$$$
c$$$c  Reduce bdu(np1) and retry harwqp
c$$$
c$$$      bdu(np1) = cp9*delta(np1)
c$$$      iflag = 0
c$$$      goto 100
c$$$
c$$$c  Error return because of infeasibility
c$$$
c$$$ 120  continue
c$$$      info = 5
c$$$      goto 140
c$$$
c$$$c  Error return because of restriction by an artificial bound
c$$$c  or detection of a singular matrix
c$$$
c$$$ 130  continue
c$$$      info = 6
c$$$
c$$$ 140  continue
c$$$
c$$$      return
c$$$      end
c$$$c______________________________________________________________________
c$$$      SUBROUTINE HARWQP1(
c$$$     +     n,m,a,ia,b,c,ic,d,bdl,bdu,x,k,ke,h,ih,lt,wa,iwa,mode,info)
c$$$
c$$$c  This program is a modified version of the Harwell library
c$$$c  subroutine VE02AD dated 11/06/70.  The modifications were made
c$$$c  to substitute the subroutines HINV and DOTPMC for Harwell
c$$$c  subroutines MB01B and MC03AS.  The calling sequence above
c$$$c  includes three entries, WA, IWA, and INFO not present in
c$$$c  the original program.  WA and IWA are real and
c$$$c  integer work arrays, respectively, and must be dimensioned
c$$$c  at least 2*N.  INFO is an output variable set to one for a
c$$$c  normal return and set to two when a singular matrix is detected
c$$$c  in HINV.  All other entries in the calling sequence are as
c$$$c  described in the Harwell documentation.
c$$$c
c$$$c  Modified 5/22/91 to use implicit none (J. Galambos)
c$$$c
c$$$c+**PJK 02/11/92 Throughout this routine, argument 1 of DOTPMC has
c$$$c+**PJK 02/11/92 different dimensions than are declared in the source
c$$$c+**PJK 02/11/92 code of the routine itself. The program runs without
c$$$c+**PJK 02/11/92 error but beware of future modifications.
c$$$
c$$$      IMPLICIT NONE
c$$$
c$$$      INTEGER n,m,ia,ic,k,ke,ih,mode,info
c$$$      INTEGER iwa(*),lt(*)
c$$$      INTEGER i, ial, ib, ii, j, li, ni, nk, nn, n3,n4,n5,n6
c$$$      INTEGER i0,i1,i2,i3
c$$$
c$$$      DOUBLE PRECISION a(ia,*),b(*),c(ic,*),d(*),bdl(*),bdu(*),x(*),
c$$$     +     h(ih,*),wa(*)
c$$$      DOUBLE PRECISION alpha, cac, cc, chc, ghc, y, z, zz
c$$$      DOUBLE PRECISION r0
c$$$
c$$$      LOGICAL retest,passiv,postiv
c$$$
c$$$      i0 = 0
c$$$      i1 = 1
c$$$      i2 = 2
c$$$      i3 = 3
c$$$      r0 = 0.0D0
c$$$
c$$$      info = 1
c$$$      retest = .false.
c$$$      nn = n+n
c$$$      n3 = nn+n
c$$$      n4 = nn+nn
c$$$      n5 = n4+n
c$$$      n6 = n5+n
c$$$
c$$$      if (mode.ge.3) goto 99
c$$$
c$$$c  Call feasible vertex routine
c$$$
c$$$ 8    continue
c$$$      call harwfp1(n,m,c,ic,d,bdl,bdu,x,k,ke,h,ih,lt,wa,iwa,info)
c$$$      if (info .ne. 1) goto 1000
c$$$      if (k.eq.0) goto 1000
c$$$      if ((mode.eq.2).and.(.not.retest)) goto 100
c$$$
c$$$c  Initial operators h=0 and cstar=c(-1) from ve02b
c$$$      do 65 i = 1,n
c$$$         do 60 j = 1,n
c$$$            h(n+i,j) = h(i,j)
c$$$            h(i,j) = 0.0D0
c$$$ 60      continue
c$$$ 65   continue
c$$$      goto 120
c$$$
c$$$ 99   continue
c$$$      do 1 i = 1,m
c$$$         lt(nn+i) = 1
c$$$ 1    continue
c$$$
c$$$c  Constraints indexed as  -1=equality, 0=active, 1=inactive
c$$$      if (k.eq.0) goto 100
c$$$      do 2 i=1,k
c$$$         j=0
c$$$         if (i.le.ke)j=-1
c$$$         lt(nn+lt(i))=j
c$$$ 2    continue
c$$$
c$$$ 100  continue
c$$$      if ((mode.eq.5).and.(.not.retest)) goto 109
c$$$
c$$$c  Set up matrix and rhs of equations governing equality problem
c$$$      do 1011 i = 1,n
c$$$         x(n+i) = b(i)
c$$$         do 101 j = 1,n
c$$$            h(i,j) = a(i,j)
c$$$ 101     continue
c$$$ 1011 continue
c$$$
c$$$      if (((mode.eq.2).or.(mode.eq.3)).and.(.not.retest)) goto 200
c$$$      if (k.eq.0) goto 107
c$$$      do 1021 i = 1,k
c$$$         li = lt(i)
c$$$         if (li.gt.nn) goto 105
c$$$         do 103 j = 1,n
c$$$            h(j,n+i) = 0.0D0
c$$$            h(n+i,j) = 0.0D0
c$$$ 103     continue
c$$$         if (li.gt.n) goto 104
c$$$         h(n+i,li) = 1.0D0
c$$$         h(li,n+i) = 1.0D0
c$$$         x(nn+i) = bdl(li)
c$$$         goto 108
c$$$
c$$$ 104     continue
c$$$         li = li-n
c$$$         h(n+i,li) = -1.0D0
c$$$         h(li,n+i) = -1.0D0
c$$$         x(nn+i) = -bdu(li)
c$$$         goto 108
c$$$
c$$$ 105     continue
c$$$         li = li-nn
c$$$         do 106 j = 1,n
c$$$            h(n+i,j) = c(j,li)
c$$$            h(j,n+i) = c(j,li)
c$$$ 106     continue
c$$$         x(nn+i) = d(li)
c$$$
c$$$ 108     continue
c$$$         do 102 j = 1,k
c$$$            h(n+i,n+j) = 0.0D0
c$$$ 102     continue
c$$$ 1021 continue
c$$$
c$$$ 107  continue
c$$$      nk = n+k
c$$$
c$$$c  Invert matrix giving operators h and cstar
c$$$
c$$$      call hinv1(h,ih,nk,iwa,info)
c$$$      if (info .ne. 1) goto 1000
c$$$      goto 118
c$$$
c$$$c  Set up rhs only
c$$$
c$$$ 109  continue
c$$$      do 113 i = 1,n
c$$$         x(n+i) = b(i)
c$$$ 113  continue
c$$$
c$$$      do 115 i = 1,k
c$$$         li = lt(i)
c$$$         if (li.gt.nn) goto 117
c$$$         if (li.gt.n) goto 116
c$$$         x(nn+i) = bdl(li)
c$$$         goto 115
c$$$
c$$$ 116     continue
c$$$         x(nn+i) = -bdu(li-n)
c$$$         goto 115
c$$$
c$$$ 117     continue
c$$$         x(nn+i)=d(li-nn)
c$$$ 115  continue
c$$$
c$$$c  Solve for solution point x
c$$$
c$$$      nk = n+k
c$$$
c$$$ 118  continue
c$$$      do 119 i=1,n
c$$$         call dotpmc(h(1,i),i1,x(n+1),i1,r0,x(i),nk,i0)
c$$$ 119  continue
c$$$
c$$$c  Check feasibility, if not exit to 8
c$$$
c$$$      do 110 i = 1,m
c$$$         if (lt(nn+i).le.0) goto 110
c$$$         if (i.gt.n) goto 111
c$$$         z = x(i)-bdl(i)
c$$$         goto 114
c$$$
c$$$ 111     continue
c$$$         if (i.gt.nn) goto 112
c$$$         z = bdu(i-n)-x(i-n)
c$$$         goto 114
c$$$
c$$$ 112     continue
c$$$         j = i-nn
c$$$         call dotpmc(c(1,j),i1,x(1),i1,d(j),z,n,i2)
c$$$
c$$$ 114     continue
c$$$         if (z.lt.0.0D0) goto 8
c$$$ 110  continue
c$$$
c$$$ 120  continue
c$$$
c$$$c  Calculate gradient g and Lagrange multipliers -cstar.g,
c$$$c  Find largest multiplier,  exit if not positive
c$$$
c$$$      do 121 i = 1,n
c$$$         call dotpmc(a(i,1),ia,x(1),i1,b(i),x(n6+i),n,i2)
c$$$ 121  continue
c$$$      if (k.eq.0) goto 1000
c$$$
c$$$C+**PJK 17/11/97 D999 reduced to D99
c$$$      z = -1.0D99
c$$$      do 122 i = 1,k
c$$$         if (lt(nn+lt(i)).eq.-1) goto 122
c$$$         call dotpmc(h(n+i,1),ih,x(n6+1),i1,r0,zz,n,i3)
c$$$         if (zz.le.z) goto 122
c$$$         z = zz
c$$$         ii = i
c$$$ 122  continue
c$$$
c$$$      if (z.gt.0.0D0) goto 130
c$$$      if ((retest).or.(mode.ge.4)) goto 137
c$$$      retest = .true.
c$$$      goto 100
c$$$
c$$$ 137  continue
c$$$      if (z.ne.0.0D0) goto 1000
c$$$      goto 1000
c$$$
c$$$c  Set direction of search as corresponding row of cstar
c$$$
c$$$ 130  continue
c$$$      do 131 i = 1,n
c$$$         x(nn+i) = h(n+ii,i)
c$$$ 131  continue
c$$$
c$$$ 136  continue
c$$$      do 132 i = 1,n
c$$$         call dotpmc(a(i,1),ia,x(nn+1),i1,r0,x(n+i),n,i0)
c$$$ 132  continue
c$$$      call dotpmc(x(nn+1),i1,x(n+1),i1,r0,cac,n,i0)
c$$$      if (cac.gt.0.0D0) goto 134
c$$$      postiv = .false.
c$$$      y = 1.0D0
c$$$      goto 135
c$$$
c$$$ 134  continue
c$$$      postiv = .true.
c$$$      y = z/cac
c$$$
c$$$ 135  continue
c$$$      do 133 i = 1,n
c$$$         x(n5+i) = x(nn+i)*y
c$$$ 133  continue
c$$$      passiv = .true.
c$$$
c$$$ 139  continue
c$$$C+**PJK 17/11/97 D999 reduced to D99
c$$$      alpha = 1.0D99
c$$$      nk = n+k
c$$$
c$$$c  Linear search along direction of search,  passiv indicates
c$$$c  a constraint has been removed to get search direction,
c$$$c  postiv indicates positive curvature along the direction
c$$$
c$$$      do 140 i = 1,m
c$$$         if (lt(nn+i).le.0) goto 140
c$$$         if (i.gt.n) goto 141
c$$$         if (x(n5+i).ge.0.0D0) goto 140
c$$$         cc = (bdl(i)-x(i))/x(n5+i)
c$$$         goto 143
c$$$
c$$$ 141     continue
c$$$         if (i.gt.nn) goto 142
c$$$         if (x(n4+i).le.0.0D0) goto 140
c$$$         cc = (bdu(i-n)-x(i-n))/x(n4+i)
c$$$         goto 143
c$$$
c$$$ 142     continue
c$$$         j = i-nn
c$$$         call dotpmc(c(1,j),i1,x(n5+1),i1,r0,zz,n,i0)
c$$$         if (zz.ge.0.0D0) goto 140
c$$$         call dotpmc(c(1,j),i1,x(1),i1,d(j),cc,n,i1)
c$$$         cc = cc/zz
c$$$
c$$$ 143     continue
c$$$         if (cc.ge.alpha) goto 140
c$$$         alpha = cc
c$$$         ial = i
c$$$ 140  continue
c$$$      if (passiv) lt(nn+lt(ii)) = 1
c$$$
c$$$c  If minimum found, goto  170
c$$$
c$$$      if ((postiv).and.(alpha.ge.1.0D0)) goto 170
c$$$
c$$$c  Calculate h.c and cstar.c
c$$$
c$$$      do 144 i=1,n
c$$$         x(i) = x(i)+alpha*x(n5+i)
c$$$ 144  continue
c$$$      alpha = alpha*y
c$$$      j = 1
c$$$      if (k.eq.n) j = n+1
c$$$      if (ial.gt.n) goto 146
c$$$      do 145 i = j,nk
c$$$         x(n3+i) = h(i,ial)
c$$$ 145  continue
c$$$      chc = x(n3+ial)
c$$$      goto 151
c$$$
c$$$ 146  continue
c$$$      ib = ial-n
c$$$      if (ib.gt.n) goto 148
c$$$      do 147 i = j,nk
c$$$         x(n3+i) = -h(i,ib)
c$$$ 147  continue
c$$$      chc = -x(n3+ib)
c$$$      goto 151
c$$$
c$$$ 148  continue
c$$$      ib = ib-n
c$$$      do 149 i = 1,n
c$$$         x(n5+i) = c(i,ib)
c$$$ 149  continue
c$$$      do 150 i = j,nk
c$$$         call dotpmc(h(i,1),ih,x(n5+1),i1,r0,x(n3+i),n,i0)
c$$$ 150  continue
c$$$      if (k.ne.n) call dotpmc(x(n5+1),i1,x(n3+1),i1,r0,chc,n,i0)
c$$$
c$$$ 151  continue
c$$$      lt(nn+ial) = 0
c$$$      if (k.eq.n) goto 180
c$$$      if (passiv) goto 160
c$$$
c$$$c  Apply formula for adding a constraint
c$$$
c$$$ 156  continue
c$$$      if (k.eq.0) goto 157
c$$$      do 1521 i = 1,k
c$$$         alpha = x(n4+i)/chc
c$$$         ni = n+i
c$$$         do 152 j = 1,n
c$$$            h(ni,j) = h(ni,j)-alpha*x(n3+j)
c$$$ 152     continue
c$$$ 1521 continue
c$$$
c$$$ 157  continue
c$$$      k = k+1
c$$$      lt(k) = ial
c$$$      do 158 j = 1,n
c$$$         h(n+k,j) = x(n3+j)/chc
c$$$ 158  continue
c$$$      if (k.lt.n) goto 154
c$$$      do 1531 i = 1,n
c$$$         do 153 j = 1,n
c$$$            h(i,j) = 0.0D0
c$$$ 153     continue
c$$$ 1531 continue
c$$$      goto 159
c$$$
c$$$ 154  continue
c$$$      do 1551 i = 1,n
c$$$         alpha = x(n3+i)/chc
c$$$         do 155 j = 1,i
c$$$            h(i,j) = h(i,j)-alpha*x(n3+j)
c$$$            h(j,i) = h(i,j)
c$$$ 155     continue
c$$$ 1551 continue
c$$$
c$$$ 159  continue
c$$$      if (.not.passiv) goto 167
c$$$
c$$$c  Removal of a constraint has been deferred,  set up as if
c$$$c  the constraint is being removed from augmented basis
c$$$
c$$$      do 164 i=1,n
c$$$         call dotpmc(a(i,1),ia,x(1),i1,b(i),x(n6+i),n,i2)
c$$$         x(nn+i) = h(n+ii,i)
c$$$ 164  continue
c$$$      call dotpmc(x(n6+1),i1,x(nn+1),i1,r0,z,n,i3)
c$$$      if (z.eq.0.0D0) goto 178
c$$$      goto 136
c$$$
c$$$ 160  continue
c$$$      cc = x(n4+ii)
c$$$      y = chc*cac+cc**2
c$$$      call dotpmc(x(n6+1),i1,x(n3+1),i1,r0,ghc,n,i0)
c$$$      if ((alpha*y).lt.(chc*(z-alpha*cac)+ghc*cc)) goto 156
c$$$
c$$$c  Apply formula for exchanging new constraint
c$$$c  with passive constraint
c$$$
c$$$      do 161 i = 1,k
c$$$         ni = n+i
c$$$         call dotpmc(h(ni,1),ih,x(n+1),i1,r0,x(n5+i),n,i0)
c$$$ 161  continue
c$$$      do 162 i = 1,n
c$$$         x(n+i) = (chc*x(nn+i)-cc*x(n3+i))/y
c$$$         x(n6+i) = (cac*x(n3+i)+cc*x(nn+i))/y
c$$$ 162  continue
c$$$      do 1631 i = 1,n
c$$$         do 163 j = 1,i
c$$$            h(i,j) = h(i,j)+x(n+i)*x(nn+j)-x(n6+i)*x(n3+j)
c$$$            h(j,i) = h(i,j)
c$$$ 163     continue
c$$$ 1631 continue
c$$$      x(n4+ii) = x(n4+ii)-1.0D0
c$$$      do 1661 i = 1,k
c$$$         ni = n+i
c$$$         do 166 j = 1,n
c$$$            h(ni,j) = h(ni,j)-x(n4+i)*x(n6+j)-x(n5+i)*x(n+j)
c$$$ 166     continue
c$$$ 1661 continue
c$$$      lt(ii) = ial
c$$$
c$$$ 167  continue
c$$$      if (k.eq.n) goto 120
c$$$
c$$$c  Calculate g,  new search direction is -h.g
c$$$
c$$$      do 168 i = 1,n
c$$$         call dotpmc(a(i,1),ia,x(1),i1,b(i),x(n+i),n,i2)
c$$$ 168  continue
c$$$      z = 0.0D0
c$$$      do 169 i = 1,n
c$$$         call dotpmc(h(i,1),ih,x(n+1),i1,r0,x(n5+i),n,i3)
c$$$         if (x(n5+i).ne.0.0D0) z = 1.0D0
c$$$ 169  continue
c$$$      passiv = .false.
c$$$      if (z.eq.0.0D0) goto 120
c$$$      postiv = .true.
c$$$      goto 139
c$$$
c$$$ 170  continue
c$$$      do 171 i = 1,n
c$$$         x(i) = x(i)+x(n5+i)
c$$$ 171  continue
c$$$
c$$$c  x is now the minimum point in the basis
c$$$c  Update the operators if a constraint had been removed
c$$$
c$$$      if (.not.passiv) goto 120
c$$$
c$$$ 178  continue
c$$$      do 1721 i = 1,n
c$$$         alpha = x(nn+i)/cac
c$$$         do 172 j = 1,i
c$$$            h(i,j) = h(i,j)+alpha*x(nn+j)
c$$$            h(j,i) = h(i,j)
c$$$ 172     continue
c$$$ 1721 continue
c$$$      if (k.gt.1) goto 177
c$$$      k = 0
c$$$      goto 120
c$$$
c$$$ 177  continue
c$$$      if (ii.eq.k) goto 175
c$$$      do 174 i=1,n
c$$$         h(n+ii,i) = h(n+k,i)
c$$$ 174  continue
c$$$      lt(ii) = lt(k)
c$$$
c$$$ 175  continue
c$$$      k = k-1
c$$$      do 173 i = 1,k
c$$$         ni = n+i
c$$$         call dotpmc(h(ni,1),ih,x(n+1),i1,r0,x(n3+i),n,i0)
c$$$ 173  continue
c$$$      do 1761 i = 1,k
c$$$         alpha = x(n3+i)/cac
c$$$         ni = n+i
c$$$         do 176 j = 1,n
c$$$            h(ni,j) = h(ni,j)-alpha*x(nn+j)
c$$$ 176     continue
c$$$ 1761 continue
c$$$      goto 120
c$$$
c$$$ 180  continue
c$$$      z = 1.0D0/x(n4+ii)
c$$$
c$$$c  Apply simplex formula to exchange constraints
c$$$
c$$$      do 181 i = 1,n
c$$$         ni = n+i
c$$$         if (i.ne.ii) goto 182
c$$$         do 183 j = 1,n
c$$$            h(ni,j) = h(ni,j)*z
c$$$ 183     continue
c$$$         goto 181
c$$$
c$$$ 182     continue
c$$$         zz = z*x(n4+i)
c$$$         do 184 j = 1,n
c$$$            h(ni,j) = h(ni,j)-zz*x(nn+j)
c$$$ 184     continue
c$$$ 181  continue
c$$$      lt(ii) = ial
c$$$      goto 120
c$$$
c$$$ 200  continue
c$$$      k = 0
c$$$
c$$$      ke = 0
c$$$      do 202 i = 1,m
c$$$         lt(nn+i) = 1
c$$$ 202  continue
c$$$      call hinv1(h,ih,n,iwa,info)
c$$$      if (info .ne. 1) goto 1000
c$$$
c$$$c  Start with empty basis from feasible point
c$$$c  Search direction is -a(-1).b
c$$$
c$$$      goto 167
c$$$
c$$$ 1000 continue
c$$$
c$$$      return
c$$$      end
c$$$c______________________________________________________________________
c$$$      SUBROUTINE HARWFP1(
c$$$     +     n,m,c,ic,d,bdl,bdu,x,k,ke,h,ih,lt,wa,iwa,info)
c$$$
c$$$c  This program is a modified version of the Harwell Library
c$$$c  subroutine LA02AD.  The modifications were made to substitute
c$$$c  the subroutines HINV and DOTPMC for Harwell subroutines
c$$$c  MB01B and MC03AS.  The calling sequence above includes
c$$$c  three entries, WA, IWA, and INFO not present in the
c$$$c  original program.  WA and IWA are real and
c$$$c  integer work arrays, respectively, and must be dimensioned
c$$$c  at least 2*N.  INFO is an output variable set to one for a
c$$$c  normal return and set to two when a singular matrix is detected
c$$$c  in HINV.  All other entries in the calling sequence are as
c$$$c  described in the Harwell documentation.
c$$$c
c$$$c  Modified  5/22/91 to use implicit none (J. Galambos)
c$$$c
c$$$c+**PJK 02/11/92 Throughout this routine, argument 1 of DOTPMC has
c$$$c+**PJK 02/11/92 different dimensions than are declared in the source
c$$$c+**PJK 02/11/92 code of the routine itself. The program runs without
c$$$c+**PJK 02/11/92 error but beware of future modifications.
c$$$
c$$$      IMPLICIT NONE
c$$$
c$$$      INTEGER n,m,ic,k,ke,ih,info
c$$$      INTEGER i, ial, ib, ii, j, jj, kv, li, ni, nj, nn, n3
c$$$      INTEGER iwa(*), lt(*)
c$$$      INTEGER i0,i1,i2,i3
c$$$
c$$$      DOUBLE PRECISION c(ic,*),d(*),bdl(*),bdu(*),x(*),h(ih,*)
c$$$      DOUBLE PRECISION wa(*)
c$$$      DOUBLE PRECISION alpha, beta, y, z, zz
c$$$      DOUBLE PRECISION r0
c$$$
c$$$      i0 = 0
c$$$      i1 = 1
c$$$      i2 = 2
c$$$      i3 = 3
c$$$      r0 = 0.0D0
c$$$
c$$$      info = 1
c$$$      nn = n+n
c$$$      n3 = nn+n
c$$$      do 1 i = 1,m
c$$$         lt(nn+i) = 1
c$$$ 1    continue
c$$$
c$$$c  Constraints indexed as
c$$$c  -1=equality,  0=active,  1=inactive,  2=violated
c$$$
c$$$      if (k.ne.0) goto 10
c$$$
c$$$c  No designated constraints, vertex chosen from upper and
c$$$c  lower bounds, inverse matrix trivial
c$$$
c$$$      do 4 i = 1,n
c$$$         do 5 j = 1,n
c$$$            h(i,j) = 0.0D0
c$$$ 5       continue
c$$$         if ((x(i)-bdl(i)).gt.(bdu(i)-x(i))) goto 6
c$$$         lt(i) = i
c$$$         h(i,i) = 1.0D0
c$$$         goto 998
c$$$
c$$$ 6       continue
c$$$         lt(i) = n+i
c$$$         h(i,i) = -1.0D0
c$$$ 998     continue
c$$$         lt(nn+lt(i)) = 0
c$$$ 4    continue
c$$$      k = n
c$$$      goto 40
c$$$
c$$$c  Set up normals v of the k designated constraints in basis
c$$$
c$$$ 10   continue
c$$$      do 11 i = 1,k
c$$$         j = 0
c$$$         if (i.le.ke) j = -1
c$$$         lt(nn+lt(i)) = j
c$$$         li = lt(i)
c$$$         ni = n+i
c$$$         if (li.gt.nn) goto 14
c$$$         do 12 j = 1,n
c$$$            h(j,ni) = 0.0D0
c$$$ 12      continue
c$$$         if (li.gt.n) goto 13
c$$$         h(li,ni) = 1.0D0
c$$$         goto 11
c$$$
c$$$ 13      continue
c$$$         h(li-n,ni) = -1.0D0
c$$$         goto 11
c$$$
c$$$ 14      continue
c$$$         li = li-nn
c$$$         do 15 j = 1,n
c$$$            h(j,ni) = c(j,li)
c$$$ 15      continue
c$$$ 11   continue
c$$$
c$$$      if (k.ne.n) goto 19
c$$$      do 161 j = 1,n
c$$$         nj = n+j
c$$$         do 16 i = 1,n
c$$$            h(i,j) = h(i,nj)
c$$$ 16      continue
c$$$ 161  continue
c$$$      call hinv1(h,ih,n,iwa,info)
c$$$      if (info .ne. 1) goto 1000
c$$$      goto 40
c$$$
c$$$ 19   continue
c$$$
c$$$c  Form m = (vtranspose.v)(-1)
c$$$      do 2011 i = 1,k
c$$$         do 20 j = i,k
c$$$            call dotpmc(h(1,n+i),i1,h(1,n+j),i1,r0,h(i,j),n,i0)
c$$$            h(j,i) = h(i,j)
c$$$ 20      continue
c$$$ 2011 continue
c$$$      if (k.ne.1) goto 200
c$$$      h(1,1) = 1.0D0/h(1,1)
c$$$      goto  201
c$$$
c$$$ 200  continue
c$$$      call hinv1(h,ih,k,iwa,info)
c$$$      if (info .ne. 1) goto 1000
c$$$
c$$$ 201  continue
c$$$
c$$$c  Calculate generalized inverse of v,  vplus = m.vtranspose
c$$$
c$$$      do 211 i = 1,k
c$$$         do 22 j = 1,k
c$$$            x(n+j) = h(i,j)
c$$$ 22      continue
c$$$         do 21 j = 1,n
c$$$            call dotpmc(x(n+1),i1,h(j,n+1),ih,r0,h(i,j),k,i0)
c$$$ 21      continue
c$$$ 211  continue
c$$$
c$$$c  Set up diagonal elements of the projection matrix  p = v.vplus
c$$$
c$$$      do 23 i = 1,n
c$$$         call dotpmc(h(1,i),i1,h(i,n+1),ih,r0,x(n+i),k,i0)
c$$$ 23   continue
c$$$      do 24 i = 1,n
c$$$         lt(n+i) = 0
c$$$ 24   continue
c$$$      kv = k
c$$$
c$$$c  Add bound e(i) corresponding to the smallest diag(p)
c$$$
c$$$ 29   continue
c$$$      z = 1.0D0
c$$$      do 25 i = 1,n
c$$$         if (lt(n+i).eq.1) goto 25
c$$$         if (x(n+i).ge.z) goto 25
c$$$         z = x(n+i)
c$$$         ii = i
c$$$ 25   continue
c$$$      y = 1.0D0
c$$$      if ( (x(ii)-bdl(ii)) .gt. (bdu(ii)-x(ii)) ) y = -1.0D0
c$$$
c$$$c  Calculate vectors vplus.e(i) and  u = e(i)-v.vplus.e(i)
c$$$
c$$$      if (y.ne.1.0D0) goto 27
c$$$      do 26 i = 1,k
c$$$         x(nn+i) = h(i,ii)
c$$$ 26   continue
c$$$      goto 30
c$$$
c$$$ 27   continue
c$$$      do 28 i = 1,k
c$$$         x(nn+i) = -h(i,ii)
c$$$ 28   continue
c$$$
c$$$ 30   continue
c$$$      do 31 i = 1,n
c$$$         if (lt(n+i).eq.1) goto 31
c$$$         call dotpmc(h(i,n+1),ih,x(nn+1),i1,r0,x(n3+i),kv,i3)
c$$$ 31   continue
c$$$      do 32 i = 1,n
c$$$         h(i,ii) = 0.0D0
c$$$ 32   continue
c$$$      lt(n+ii) = 1
c$$$      z = 1.0D0+x(n3+ii)*y
c$$$
c$$$c  Update vplus and diag(p)
c$$$
c$$$      do 33 i = 1,n
c$$$         if (lt(n+i).eq.1) goto 33
c$$$         alpha = x(n3+i)/z
c$$$         h(k+1,i) = alpha
c$$$         do 34 j = 1,k
c$$$            h(j,i) = h(j,i)-x(nn+j)*alpha
c$$$ 34      continue
c$$$ 33   continue
c$$$
c$$$      do 35 i = 1,n
c$$$         if (lt(n+i).eq.1) goto 35
c$$$         x(n+i) = x(n+i)+x(n3+i)**2/z
c$$$ 35   continue
c$$$      k = k+1
c$$$      h(k,ii) = y
c$$$      if (y.ne.1.0D0) ii = ii+n
c$$$      lt(nn+ii) = 0
c$$$      lt(k) = ii
c$$$      if (k.ne.n) goto 29
c$$$
c$$$c  Set up rhs of constraints in basis
c$$$
c$$$ 40   continue
c$$$      do 41 i = 1,n
c$$$         li = lt(i)
c$$$         if (li.gt.n) goto 42
c$$$         x(n+i) = bdl(li)
c$$$         goto 41
c$$$
c$$$ 42      continue
c$$$         if (li.gt.nn) goto 43
c$$$         x(n+i) = -bdu(li-n)
c$$$         goto 41
c$$$
c$$$ 43      continue
c$$$         x(n+i) = d(li-nn)
c$$$
c$$$ 41   continue
c$$$
c$$$c  Calculate position of vertex
c$$$
c$$$      do 44 i = 1,n
c$$$         call dotpmc(h(1,i),i1,x(n+1),i1,r0,x(i),n,i0)
c$$$ 44   continue
c$$$
c$$$c  Calculate the constraint residuals, the number of violated
c$$$c  constraints, and the sum of their normals
c$$$
c$$$ 50   continue
c$$$      kv = 0
c$$$      do 51 i = 1,n
c$$$         x(n+i) = 0.0D0
c$$$ 51   continue
c$$$      do 52 i = 1,m
c$$$         if (lt(nn+i).le.0) goto 52
c$$$         if (i.gt.n) goto 53
c$$$         z = x(i)-bdl(i)
c$$$         goto 55
c$$$
c$$$ 53      continue
c$$$         if (i.gt.nn) goto 54
c$$$         z = bdu(i-n)-x(i-n)
c$$$         goto 55
c$$$
c$$$ 54      continue
c$$$         j = i-nn
c$$$         call dotpmc(c(1,j),i1,x(1),i1,d(j),z,n,i2)
c$$$
c$$$ 55      continue
c$$$         x(nn+i) = z
c$$$         if (z.ge.0.0D0) goto 52
c$$$         kv = kv+1
c$$$         lt(nn+i) = 2
c$$$         if (i.gt.n) goto 56
c$$$         x(n+i) = x(n+i)+1.0D0
c$$$         goto 52
c$$$
c$$$ 56      continue
c$$$         if (i.gt.nn) goto 57
c$$$         x(i) = x(i)-1.0D0
c$$$         goto 52
c$$$
c$$$ 57      continue
c$$$         do 58 ii = 1,n
c$$$            x(n+ii) = x(n+ii)+c(ii,j)
c$$$ 58      continue
c$$$ 52   continue
c$$$      if (kv.ne.0) goto 63
c$$$      goto 1000
c$$$
c$$$c  Possible directions of search obtainable by removing a
c$$$c  constraint are rows of h,  calculate the optimum direction
c$$$
c$$$ 63   continue
c$$$      z = 0.0D0
c$$$      do 64 i = 1,n
c$$$         if (lt(nn+lt(i)).eq.-1) goto 64
c$$$         call dotpmc(h(i,1),ih,x(n+1),i1,r0,y,n,i0)
c$$$         if (y.le.z) goto 64
c$$$         z = y
c$$$         ii = i
c$$$ 64   continue
c$$$      if (z.gt.0.0D0) goto 70
c$$$      k = 0
c$$$      goto 1000
c$$$
c$$$c  Search for the nearest of the furthest violated constraint
c$$$c  and the nearest nonviolated nonbasic constraint
c$$$
c$$$ 70   continue
c$$$C+**PJK 17/11/97 D999 reduced to D99
c$$$      alpha = 1.0D99
c$$$      beta = 0.0D0
c$$$      do 71 i = 1,n
c$$$         x(n+i) = h(ii,i)
c$$$ 71   continue
c$$$      do 72 i = 1,m
c$$$         if (lt(nn+i).le.0) goto 72
c$$$         if (i.gt.n) goto 73
c$$$         z = -x(n+i)
c$$$         goto 75
c$$$
c$$$ 73      continue
c$$$         if (i.gt.nn) goto 74
c$$$         z = x(i)
c$$$         goto 75
c$$$
c$$$ 74      continue
c$$$         jj = i-nn
c$$$         call dotpmc(x(n+1),i1,c(1,jj),i1,r0,z,n,i3)
c$$$
c$$$ 75      continue
c$$$         if (lt(nn+i).eq.2) goto 76
c$$$         if (z.le.0.0D0) goto 72
c$$$         z = x(nn+i)/z
c$$$         if (z.ge.alpha) goto 72
c$$$         alpha = z
c$$$         ial = i
c$$$         goto 72
c$$$
c$$$ 76      continue
c$$$         lt(nn+i) = 1
c$$$         if (z.ge.0.0D0) goto 72
c$$$         z = x(nn+i)/z
c$$$         if (z.le.beta) goto 72
c$$$         beta = z
c$$$         ib = i
c$$$ 72   continue
c$$$
c$$$      if (alpha.gt.beta) goto 80
c$$$      ib = ial
c$$$      beta = alpha
c$$$
c$$$c  Exchange with the constraint being removed from the basis,
c$$$c  using simplex formula for new h
c$$$
c$$$ 80   continue
c$$$      lt(nn+lt(ii)) = 1
c$$$      lt(nn+ib) = 0
c$$$      lt(ii) = ib
c$$$      if (ib.gt.n) goto 82
c$$$      do 81 i = 1,n
c$$$         x(nn+i) = h(i,ib)
c$$$ 81   continue
c$$$      goto 90
c$$$
c$$$ 82   continue
c$$$      ib = ib-n
c$$$      if (ib.gt.n) goto 84
c$$$      do 83 i = 1,n
c$$$         x(nn+i) = -h(i,ib)
c$$$ 83   continue
c$$$      goto 90
c$$$
c$$$ 84   continue
c$$$      ib = ib-n
c$$$      do 85 i = 1,n
c$$$         x(n3+i) = c(i,ib)
c$$$ 85   continue
c$$$      do 86 i = 1,n
c$$$         call dotpmc(h(i,1),ih,x(n3+1),i1,r0,x(nn+i),n,i0)
c$$$ 86   continue
c$$$
c$$$ 90   continue
c$$$      z = 1.0D0/x(nn+ii)
c$$$      do 91 i = 1,n
c$$$         x(i) = x(i)+beta*x(n+i)
c$$$         if (i.ne.ii) goto 92
c$$$         do 93 j = 1,n
c$$$            h(i,j) = h(i,j)*z
c$$$ 93      continue
c$$$         goto 91
c$$$
c$$$ 92      continue
c$$$         zz = z*x(nn+i)
c$$$         do 94 j = 1,n
c$$$            h(i,j) = h(i,j)-zz*x(n+j)
c$$$ 94      continue
c$$$ 91   continue
c$$$
c$$$      goto 50
c$$$
c$$$ 1000 continue
c$$$
c$$$      return
c$$$      end
c$$$c______________________________________________________________________
c$$$      SUBROUTINE HINV1(h,ih,n,ipvt,info)
c$$$
c$$$c  This subroutine inverts the matrix H by use of linpack software.
c$$$c
c$$$c  The subroutine statement is
c$$$c
c$$$c  subroutine hinv(h,ih,n,ipvt,info)
c$$$c
c$$$c  where
c$$$c
c$$$c  H is a real IH by IH array which contains the N by N
c$$$c  matrix to be inverted.  On output the N by N inverse
c$$$c  is stored in H.
c$$$c
c$$$c  IH is an input integer variable set to the fortran
c$$$c  declaration of the leading dimension in the H array.
c$$$c
c$$$c  N is the order of H.  N must be less than or equal to IH.
c$$$c
c$$$c  IPVT is an integer work array of length at least N.
c$$$c
c$$$c  INFO is an integer output variable set as follows
c$$$c
c$$$c   INFO = 1  normal return
c$$$c
c$$$c   INFO = 2  H matrix is singular
c$$$c
c$$$c  Algorithm version of June 1979
c$$$c
c$$$c  Roger L. Crane, Kenneth E. Hillstrom, Michael Minkoff
c$$$
c$$$      IMPLICIT NONE
c$$$
c$$$      INTEGER ih,n,info
c$$$      INTEGER ipvt(n)
c$$$      DOUBLE PRECISION h(ih,ih)
c$$$      DOUBLE PRECISION det(2)
c$$$
c$$$c  Do lu decomposition of h
c$$$
c$$$      call sgefa(h,ih,n,ipvt,info)
c$$$
c$$$      if (info .eq. 0) goto 20
c$$$      info = 2
c$$$      goto 1000
c$$$
c$$$c  Form inverse of h
c$$$
c$$$ 20   continue
c$$$      info = 1
c$$$      call sgedi(h,ih,n,ipvt,det,1)
c$$$
c$$$ 1000 continue
c$$$
c$$$      return
c$$$      end
