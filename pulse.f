C----------------------------------------------------------------------
C--SCCS information
C  Module         : $Id: pulse.f,v 1.13 2006/05/25 09:27:02 pknight Exp $
C  Module name    : $RCSfile: pulse.f,v $
C  Version no.    : $Revision: 1.13 $
C  Creation date  : $Date: 2006/05/25 09:27:02 $
C  Creation time  : 
C  SCCS file      :
C  %P%
C----------------------------------------------------------------------
      SUBROUTINE PULSE(nout,iprint)
CCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCC
C--Version number 1.001
C
C--Description
C  Calls the routines relevant to a pulsed reactor scenario
C
C--Author
C  Chris Gardner, c/o
C  Peter Knight D3/G12 Culham Laboratory, ext.3330
C
C--Date
C  10 June 1996
C
C--Reference
C  Work File Notes in F/MPE/MOD/CAG/PROCESS/PULSE
C  
C--History
C  25/11/93 PJK 1.000 Implementation within PROCESS
C  10/06/96 PJK 1.001 Commented out call to STARTUP
C
C--Arguments
C  nout   : (INPUT)  Fortran output unit identifier
C  iprint : (INPUT)  Flag to turn on/off (1/0) output to file
C
CCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCC

      IMPLICIT NONE

C  INCLUDE files
      INCLUDE 'param.h'
      INCLUDE 'pulse.h'
      INCLUDE 'build.h'
      INCLUDE 'phydat.h'
      INCLUDE 'fwblsh.h'
      INCLUDE 'times.h'

C  Arguments
      INTEGER nout,iprint

C  External routines
      EXTERNAL thrmal,tohswg,burn,startup

C--End of preamble--CCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCC

C *** Thermal cycling package

      call thrmal(nout,iprint)

C *** Evaluate minimum OH coil swing time

      call tohswg(nout,iprint)

C *** Burn time calculation

      call burn(nout,iprint)

C *** Start-up model to minimise auxiliary power requirement

C+**PJK 10/06/96 Comment out start-up option as it takes a long time
C+**PJK 10/06/96      if (iprint.eq.1) call startup(iprint)

      return
      end
C----------------------------------------------------------------------
      SUBROUTINE THRMAL(nout,iprint)
CCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCC
C--Version number 1.130
C
C--Description
C  This subroutine calculates the thermal and mechanical stresses
C  induced in the first wall for the case of a pulsed reactor.
C  It is assumed that the first wall is comprised from axisymmetric
C  hollow cylindrical tubes which are packed one against the other in
C  the poloidal direction.
C 
C  The equivalent strains are calculated from the stresses
C  with which a fatigue lifetime is estimated using the fatigue
C  design curves generated by the ASME code.
C 
C  Presently the first wall material is assumed to be stainless
C  steel.
C  
C  The first wall thickness is constrained to lie between a lower
C  limit that ensures that the first wall can withstand the internal
C  coolant pressure, and an upper limit governed by the peak
C  temperature and the neutron fluence.
C
C--Author
C  Chris Gardner, c/o
C  Peter Knight D3/162a Culham, ext.6368
C
C--Date
C  13 February 1997
C
C--Reference
C  Work File Notes in F/MPE/MOD/CAG/PROCESS/PULSE
C  
C--History
C  25/11/93 PJK 1.000 Incorporation into PROCESS.
C  16/06/94 PJK 1.010 Added error warning
C  07/12/95 PJK 1.100 Added D-He3 calculations
C  10/06/96 PJK 1.110 Moved first wall area calculation into RADIALB
C  13/02/97 PJK 1.120 Modified first wall lifetime calculation
C  25/05/06 PJK 1.130 Added SAVE statement
C
C--Arguments
C  nout   : (INPUT)  Fortran output unit identifier
C  iprint : (INPUT)  Flag to turn on/off (1/0) output to file
C
C--Global variables passed via COMMON
C  cc(8) : angular coefficients
C  dd(8) : angular coefficients
C
CCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCC

C  INCLUDE files
      INCLUDE 'param.h'
      INCLUDE 'pulse.h'
      INCLUDE 'build.h'
      INCLUDE 'phydat.h'
      INCLUDE 'fwblsh.h'
      INCLUDE 'ineq.h'
      INCLUDE 'cost.h'

C  Arguments
      INTEGER nout,iprint

C  Global variables
      DOUBLE PRECISION cc(8),dd(8)
      COMMON/tmpcff/cc,dd

C  Local variables
      DOUBLE PRECISION boa,delr(3),delth(3),delz(3),eptbar,eptr(3),
     +     eptrc,eptth(3),eptthc,eptz(3),eptzc,equiv(3),fboa,flnce,
     +     fwlifs,fwndep,fwvol,hcoeff,masflx,mincyc(3),mindif,min01,
     +     min02,min03,poissn,qpp,qppp,rad,sigpm,sigpr,sigpth,sgpthn,
     +     sigpz,sigtr,sigtri,sigtrs,sgtshs,sigtth,sgtthi,sgtths,
     +     sigtz(3),tav,temp,tfwav,tmax,tmpdif,tmprop,tmthet,torlen,
     +     tpeakr,vel

      SAVE flnce,hcoeff,qpp,qppp,tav,tmprop,vel

      INTEGER ncyc(3),k,n

C  External functions
      DOUBLE PRECISION alpha,eyung,smt,tk,yield
      EXTERNAL         alpha,eyung,smt,tk,yield

C  External routines
      EXTERNAL costrm,cycles,oheadr,ocmmnt,oblnkl,ovarrf,ovarre

C--End of preamble--CCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCC

C *** delr(3)  : radial strain range
C *** delth(3) : azimuthal strain range
C *** delz(3)  : axial strain range
C *** eptbar   : average thermal strain
C *** eptr(3)  : radial strain component from total stress
C *** eptrc    : radial strain component from mechanical stress
C *** eptth(3) : azimuthal strain component from total stress
C *** eptthc   : azimuthal strain component from mechanical stress
C *** eptz(3)  : axial strain component from total stress
C *** eptzc    : axial strain component from mechanical stress
C *** equiv(3) : Von Mises equivalent strain
C *** flnce    : neutron fluence
C *** fwndep   : neutron power deposition (W)
C *** fwvol    : first wall volume (m**3)
C *** hcoeff   : heat transfer coefficient (W/m**2/K)
C *** masflx   : coolant max flux (Kg/m**2/s)
C *** ncyc(3)  : number of allowable cycles
C *** poissn   : Poisson's ratio 
C *** mincyc(3): minimum allowable cycle length
C *** fwlifs   : first wall lifetime (s)
C *** qpp      : surface heat flux incident on first wall (W/m**2)
C *** qppp     : volumetric heat flux in first wall material (W/m**3)
C *** sgpthn   : primary stress in thin shell model (Pa)
C *** sgtshs   : shear stress component from surface heat flux (Pa)
C *** sgtthi   : azimuthal stress component from internal heat flux (Pa)
C *** sgtths   : azimuthal stress component from surface heat flux (Pa)
C *** sigpm    : equivalent mechanical stress (Pa)
C *** sigpr    : radial mechanical stress (Pa)
C *** sigpth   : azimuthal mechanical stress (Pa)
C *** sigpz    : axial mechanical stress (Pa)
C *** sigtr    : radial stress component from total heat flux (Pa)
C *** sigtri   : radial stress component from internal heat flux (Pa)
C *** sigtrs   : radial stress component from surface heat flux (Pa)
C *** sigtth   : azimuthal stress component from total heat flux (Pa)
C *** sigtz(3) : axial stress component from total heat flux (Pa)
C *** tav      : average first wall temperature (C)
C *** tmthet   : azimuthal temperature term (C)
C *** torlen   : section of toroidal extent of first wall elements (m)
C *** tpeakr   : peak temperature at a given radius (C)
C *** vel      : coolant velocity (m/s)

C *** Check to see if the pulsed reactor option is selected

      if (lpulse.ne.1) goto 1000

      if (iprint.eq.1) goto 90

C *** Check valid input for pulsed reactor

      if (fhole.eq.0.0D0) then
         write(*,*) 'Error in routine THRMAL:'
         write(*,*) 'fhole should not be zero for a pulsed reactor -'
         write(*,*) 'a fraction fhole of the neutrons leaving the'
         write(*,*) 'plasma are assumed to interact in the first wall.'
         write(*,*) 'PROCESS stopping.'
         STOP
      end if

C *** We will assume that 2*bfw is the average of the inboard and
C *** outboard first wall thicknesses (fwith and fwoth respectively).

      bfw = (fwith+fwoth)/4.0D0
      boa = bfw/afw

C *** Poisson's ratio

      poissn = 0.27d0

C *** Open output file

      open(unit=4,status='unknown',file='thermal.dat')

      n = 0

C *** Start of iteration of bfw - code returns to here...
 10   continue
C *** ...if bfw has been altered to lie within constraints

C *** Check to see if inner radius is greater than outer radius

      if (afw.ge.bfw) then
         write(*,*) 'Error in routine PULSE:'
         write(*,*) 'afw.ge.bfw'
         write(*,*) 'PROCESS stopping.'
         STOP
      end if

C *** Check progress

      n = n+1
      if (n.gt.100) then
C+**PJK 27/04/94 write(4,*) 'Optimisation has failed in routine PULSE'
C+**PJK 16/06/94 Added error warning
         write(*,*) 'Warning in routine THRMAL:'
         write(*,*) 'Optimisation has failed within 100 iterations.'
         write(*,*) 'Possible NaN problems...'
         write(*,*) 'PROCESS continuing.'
         goto 1000
      end if

C *** First wall lifetime in seconds

      fwlifs = 3.1536d+7*fwlife

C *** First wall properties
C *** This assumes that the neutrons lost via fhole actually stop in
C *** the first wall, so are not lost at all...

C+**PJK 07/12/95 fwndep = (14.1d0/17.6d0)*powfmw*fhole*1.0d+6
      fwndep = (pneut*vol)*fhole*1.0d+6

C *** Assume that the first wall volume is equal to its surface area
C *** multiplied by the external diameter of the hollow cylindrical
C *** tubes that make up the first wall.

      fwvol = fwarea*(2.0d0*bfw)

C *** Heat fluxes
C *** -----------
C *** qppp represents the heat generation in the first wall due to
C *** the neutron flux deposited in the material.
C *** qpp represents the heat flux incident on the first wall
C *** surface from the charge particle and electromagnetic radiation
C *** flux.

      qppp = fwndep/fwvol

C+**PJK 07/12/95 qpp = (1.d0-(14.1d0/17.6d0))*powfmw*1.0d6/fwarea
      qpp = (palp+pcharge)*vol*1.0d6/fwarea

C *** Heat transfer coefficient
C *** -------------------------
C *** The coolant is water and the heat transfer coefficient is 
C *** calculated on the inboard side of the first wall.
C *** specific heat capacity: 4190 (J/K/Kg)
C *** mass density: 720 (kg/m**3)
C *** coolant velocity limit: 5 (m/s)
C *** fluid viscosity: 1.61d-4 (Kg/m/s)
C *** viscosity at wall temperature: 1.39d-4 (Kg/m/s)
C *** thermal conductivity: 0.69 (W/m/K)
C *** If the velocity limit is exceeded then the coolant velocity
C *** is set to the velocity limit and the temperature rise is
C *** calculated based upon this fixed velocity.

C+**PJK 23/12/93 Commented out : torlen = 2.0d0*pi*(rmajor-rminor)
c+**PJK 23/12/93 A toroidal length of 3 metres is assumed rather than
C+**PJK 23/12/93 the whole toroidal circumference as we were
C+**PJK 23/12/93 experiencing very high coolant temperature rises.
C+**PJK 23/12/93 This method is okay as it can be envisaged that the
C+**PJK 23/12/93 toroidal parts of the coolant pipes occur in 3 metre
C+**PJK 23/12/93 sections around the torus, instead of one long
C+**PJK 23/12/93 toroidal pipe.

      torlen = 3.0d0
      masflx = torlen*(qppp*(bfw**2-afw**2)+2.0D0*qpp*bfw)
     +     /afw**2/4190.0d0/tmprse
      vel = masflx/720.0d0

      if (vel.ge.5.0d0) then
         vel = 5.0d0
         masflx = vel*720.0d0
         tmprse = torlen*(qppp*(bfw**2-afw**2)+2.0D0*qpp*bfw)
     +        /afw**2/4190.0d0/masflx
      end if

      hcoeff = 0.023d0*(0.69d0/2.0d0/afw)*(masflx*2.0d0*afw
     +     /1.61d-4)**0.8d0*(1.61d-4*4190.0d0/0.69d0)**0.4d0
     +     *(1.61d-4/1.39d-4)**0.14d0

C *** Average temperature
C *** -------------------
C *** There is a problem here because the expression for the
C *** average temperature in the first wall contains a term
C *** which involves the thermal conductivity which is in itself
C *** temperature dependent. How do we resolve this problem?
C *** Firstly we define a temperature range where the lower
C *** bound is defined to be the temperature on the inner
C *** wall (in contact with the coolant) and therefore
C *** equal to the bulk coolant temperature, and the
C *** upper bound is taken to be 800 degrees Celsius.
C *** Next we iterate over this range so that at each 
C *** step the average temperature can be calculated together 
C *** with the difference between the average temperature and 
C *** the iterated temperature. The average temperature
C *** at which this difference is minimised is taken 
C *** as the correct average temperature in the first wall.

      mindif = 1.0d+30

      do 20 k = 1,51

         temp = bctmp+(800.0d0-bctmp)*dble(k-1)/50.0d0
         tfwav = bfw/tk(temp)*(qpp/pi+qppp*bfw/2.d0)*(bfw**2/
     +        (bfw**2-afw**2)*log(bfw/afw)-0.5d0)-
     +        qppp/4.0d0/tk(temp)*((bfw**2-afw**2)/2.0d0)
     +        +(pi*(bfw**2-afw**2)*qppp+2.0d0*bfw*qpp)/
     +        (2.0d0*pi*afw*hcoeff)+ bctmp
         tmpdif = abs(tfwav-temp)
         if (tmpdif.le.mindif) then
            mindif = tmpdif
            tav = tfwav
            tmprop = temp
         end if

 20   continue  

C *** Average thermal strain (integrated from 20 Celsius to `tav').

      eptbar = 10.28d-6/1.093d0*(tav**(1.093d0)-20.0d0**(1.093d0))

C *** Limits on the first wall thickness
C *** ----------------------------------
C *** The upper limit on the first wall thickness is
C *** derived from the swelling limit which for stainless
C *** steel limits the temperature to 500 Celsius. This
C *** temperature limit is equivalent to limiting the neutron
C *** fluence to 5 MW yrs/m**2. The fluence is the product
C *** of the neutron wall loading (qppp*fwvol/fwarea) and
C *** the wall lifetime. This fluence limit is a conservative
C *** one, with the upper bound on the fluence set by the value
C *** 10 MW-yr/m2
C+**PJK 13/02/97 abktflnc should replace the fixed value 10 MW-yr/m2

      flnce = qppp*fwvol/fwarea*fwlife/1.0d6

      tmax = -1.0d+30

      do 40 k = 1,11

         rad = afw+(bfw-afw)*(dble(k-1)/10.0d0)

         call costrm(0.0d0,rad,qpp,hcoeff,tmprop,tmthet)

C *** Peak temperature occurs at (r,theta) = (rad,0)
         tpeak = bfw/tk(tmprop)*(qpp/pi+qppp*bfw/2.d0)*log(rad/afw)-
     +        qppp/4.0d0/tk(tmprop)*(rad**2-afw**2)
     +        +(pi*(bfw**2-afw**2)*qppp+2.0d0*bfw*qpp)/
     +        (2.0d0*pi*afw*hcoeff)+ bctmp + tmthet

         if ((tpeak.gt.500.0d0).or.(flnce.gt.10.0d0)) then
C+**PJK 27/04/94 write(4,*)  'Swelling limit exceeded'
C+**PJK 27/04/94 write(4,30) 'First wall temperature = ',tpeak,' C'
C+**PJK 27/04/94 write(4,30) 'Neutron fluence = ',flnce,' MW/m**2 yrs'

            fwlife = 10.0d0*1.0d6*fwarea/qppp/fwvol
            fwlifs = 3.1536d+7*fwlife

C *** fboa is chosen such that fboa**100 * (bfw/afw) = 1.001,
C *** i.e. after 100 iterations bfw is still just larger than afw.

            fboa = (1.001D0/boa)**0.01D0

            bfw = bfw*fboa
            if ((bfw/afw).le.1.001D0) n = 100
C+**PJK 27/04/94  write(4,30) 'First wall thickness = ',(bfw-afw)*1.0d3,
C+**PJK 27/04/94 +           ' mm'
            goto 10
         end if

 30      format(1x,a,f10.4,a)

C *** Find maximum temperature

         tmax = max(tpeak,tmax)

 40   continue

      tpeak = tmax

C *** The lower limit on the first wall thickness is
C *** derived from the constraint that the first wall
C *** must possess the ability to withstand the internal
C *** coolant pressure. The limit is written as
C *** hmin = p*(afw+bfw)/2/Smt

      sgpthn = (coolp*(afw+bfw)/2.0d0)/(bfw-afw)

      if (sgpthn.gt.smt(tpeak,fwlifs)) then
C+**PJK 27/04/94 write(4,*) 'First wall too thin'
C+**PJK 27/04/94 write(4,50) sgpthn
C+**PJK 27/04/94 write(4,60) smt(tpeak,fwlifs)

 50      format(1x,'Primary stress in first wall = ',e10.4, ' Pa')
 60      format(1x,'Maximum stress intensity = ',e10.4, ' Pa')

C *** Keep `afw' fixed and alter`bfw' so that the lower limit 
C *** is satisfied.

         bfw = (smt(tpeak,fwlifs)+coolp/2.d0)/
     +        (smt(tpeak,fwlifs)-coolp/2.d0)*afw
         goto 10
      end if

C *** Reset inboard and outboard first wall thicknesses

      fwith = 2.0D0*bfw
      fwoth = 2.0D0*bfw

C *** First wall coolant fraction

      fwclfr = (afw/bfw)**2

      min01 = 0.0D0
      min02 = 0.0D0
      min03 = 0.0D0

C *** Iterate from the inner first wall radius to the outer
C *** first wall radius.

      do 70 k = 1,11

C *** Peak temperature at this radius

         rad = afw+(bfw-afw)*(dble(k-1)/10.0d0)

         call costrm(0.0d0,rad,qpp,hcoeff,tmprop,tmthet)

C *** Peak temperature occurs at (r,theta) = (rad,0)

         tpeakr = bfw/tk(tmprop)*(qpp/pi+qppp*bfw/2.d0)*log(rad/afw)-
     +        qppp/4.0d0/tk(tmprop)*(rad**2-afw**2)
     +        +(pi*(bfw**2-afw**2)*qppp+2.0d0*bfw*qpp)/
     +        (2.0d0*pi*afw*hcoeff)+ bctmp + tmthet

C *** Pressure, or mechanical stresses

         sigpr = -coolp*(afw**2/(bfw**2-afw**2))*(bfw**2/rad**2-1.0d0)
         sigpth = coolp*(afw**2/(bfw**2-afw**2))*(bfw**2/rad**2+1.0d0)
         sigpz = coolp*(afw**2/(bfw**2-afw**2))

C *** Equivalent mechanical stress

         sigpm = sqrt(0.5d0*((sigpr-sigpth)**2+(sigpr-sigpz)**2+
     +        (sigpth-sigpz)**2))

C *** Thermal stresses
C *** ----------------

C *** Thermal stress components from surface heat flux (i.e. qpp)

         sigtrs = alpha(tmprop)*eyung(tmprop)/2.0d0/(1.0d0-poissn)*(
     +        rad/(afw**2+bfw**2)*(1.0d0-afw**2/rad**2)*(1.0d0-
     +        bfw**2/rad**2)*cc(1)*cos(0.0d0)+
     +        qpp*bfw/pi/tk(tmprop)/rad**2*(bfw**2*((rad**2-afw**2)/
     +        (bfw**2-afw**2))*log(bfw/afw)-rad**2*log(rad/afw)))
         sgtths = alpha(tmprop)*eyung(tmprop)/2.0d0/(1.0d0-poissn)*(
     +        rad/(afw**2+bfw**2)*(3.0d0-(afw**2+bfw**2)/rad**2-
     +        (afw**2*bfw**2)/rad**4)*cc(1)*cos(0.0d0)+
     +        qpp*bfw/pi/tk(tmprop)/rad**2*(bfw**2*((rad**2+afw**2)/
     +        (bfw**2-afw**2))*log(bfw/afw)-rad**2-
     +        rad**2*log(rad/afw)))
         sgtshs = alpha(tmprop)*eyung(tmprop)/2.0d0/(1.0d0-poissn)*(
     +        rad/(afw**2+bfw**2)*(1.0d0-afw**2/rad**2)*(1.0d0-
     +        bfw**2/rad**2)*cc(1)*sin(0.0d0))

C *** Thermal stress components from internal heat flux (i.e. qppp)

         sigtri = alpha(tmprop)*eyung(tmprop)*qppp/4.0d0/tk(tmprop)/
     +        (1.0d0-poissn)/rad**2*((rad**2-afw**2)/(bfw**2-afw**2)*
     +        bfw**4*log(bfw/afw)-(bfw**2+afw**2)*rad**2/4.0d0
     +        +afw**2*bfw**2/4.0d0-bfw**2*rad**2*log(rad/afw)
     +        +rad**4/4.0d0)
         sgtthi = alpha(tmprop)*eyung(tmprop)*qppp/4.0d0/tk(tmprop)/
     +        (1.0d0-poissn)/rad**2*((rad**2+afw**2)/(bfw**2-afw**2)*
     +        bfw**4*log(bfw/afw)-(5.0d0*bfw**2+afw**2)*rad**2/4.0d0-
     +        afw**2*bfw**2/4.0d0+3.0d0*rad**4/4.0d0
     +        -bfw**2*rad**2*log(rad/afw))

C *** Total thermal stresses

         sigtr = sigtrs+sigtri
         sigtth = sgtths+sgtthi

C *** Axial stresses, three different models are used:
C *** (1) total axial restraint and no bending
C *** (2) no axial restraints and no bending
C *** (3) no axial restraints and bending

C+**PJK 03/11/93 This region commented out by CAG
C ***     aap = alpha(tmprop)*eyung(tmprop)*qppp*bfw**2/
C *** +        4.0d0/tk(tmprop)/(1.0d0-poissn)
C ***     bbp = alpha(tmprop)*eyung(tmprop)*qpp*bfw/
C *** +        2.0d0/pi/tk(tmprop)/(1.0d0-poissn)
C ***     aa = aap*(2.0d0*bfw**2*log(bfw/afw)/(bfw**2-afw**2)-
C *** +        afw**2/2.0d0/bfw**2-3.0d0/2.0d0)
C ***     bb = bbp*(2.0d0*bfw**2*log(bfw/afw)/(bfw**2-afw**2)-1)
C ***     bigi = (aa+bb)*(bfw**2-afw**2)-(aap+bbp)*(2.0d0*bfw**2*
C *** +        log(bfw/afw)-(bfw**2-afw**2))+aap/2.0d0/bfw**2*
C *** +        (bfw**4-afw**4)
C+**PJK

         sigtz(1) = poissn*(sigtr+sigtth)-eyung(tmprop)*
     +        (eptbar+alpha(tav)*(tpeakr-tav))
         sigtz(2) = poissn*(sigtr+sigtth)-eyung(tmprop)*
     +        (alpha(tav)*(tpeakr-tav))
c+**CAG     +        -poissn*bigi/(bfw**2-afw**2)
         sigtz(3) = sigtz(2)+eyung(tmprop)*rad*cos(0.0d0)*alpha(tav)*
     +        (2.0d0*cc(1)/(afw**2+bfw**2)+dd(1))

C *** Strains
C *** -------

         eptr(1) = 1.0d0/eyung(tmprop)*(sigtr+sigpr-poissn*(sigtth+
     +        sigpth+sigtz(1)+sigpz))
         eptth(1) = 1.0d0/eyung(tmprop)*(sigtth+sigpth-poissn*(sigtr+
     +        sigpr+sigtz(1)+sigpz))
         eptz(1) = 1.0d0/eyung(tmprop)*(sigtz(1)+sigpz-poissn*(sigtr+
     +        sigpr+sigtth+sigpth))
         eptr(2) = 1.0d0/eyung(tmprop)*(sigtr+sigpr-poissn*(sigtth+
     +        sigpth+sigtz(2)+sigpz))
         eptth(2) = 1.0d0/eyung(tmprop)*(sigtth+sigpth-poissn*(sigtr+
     +        sigpr+sigtz(2)+sigpz))
         eptz(2) = 1.0d0/eyung(tmprop)*(sigtz(2)+sigpz-poissn*(sigtr+
     +        sigpr+sigtth+sigpth))
         eptr(3) = 1.0d0/eyung(tmprop)*(sigtr+sigpr-poissn*(sigtth+
     +        sigpth+sigtz(3)+sigpz))
         eptth(3) = 1.0d0/eyung(tmprop)*(sigtth+sigpth-poissn*(sigtr+
     +        sigpr+sigtz(3)+sigpz))
         eptz(3) = 1.0d0/eyung(tmprop)*(sigtz(3)+sigpz-poissn*(sigtr+
     +        sigpr+sigtth+sigpth))


C *** For the time being I will take the temperature during rejuvenation
C *** to be T(a,0) during burn and assume the accompanying strains are 
C *** mechanical in origin.

         eptrc = 1.0d0/eyung(tmprop)*(sigpr-poissn*(sigpth+sigpz))
         eptthc = 1.0d0/eyung(tmprop)*(sigpth-poissn*(sigpr+sigpz))
         eptzc = 1.0d0/eyung(tmprop)*(sigpz-poissn*(sigpth+sigpr))

C *** Calculate strain ranges

         delr(1) = eptr(1)-eptrc
         delr(2) = eptr(2)-eptrc
         delr(3) = eptr(3)-eptrc
         delth(1) = eptth(1)-eptthc
         delth(2) = eptth(2)-eptthc
         delth(3) = eptth(3)-eptthc
         delz(1) = eptz(1)-eptzc
         delz(2) = eptz(2)-eptzc
         delz(3) = eptz(3)-eptzc

C *** Calculate Von Mises equivalent strain range

         equiv(1) = 1.0d0/3.0d0*sqrt(2.0d0*((delr(1)-delth(1))**2+
     +        (delth(1)-delz(1))**2+(delz(1)-delr(1))**2))
         equiv(2) = 1.0d0/3.0d0*sqrt(2.0d0*((delr(2)-delth(2))**2+
     +        (delth(2)-delz(2))**2+(delz(2)-delr(2))**2))
         equiv(3) = 1.0d0/3.0d0*sqrt(2.0d0*((delr(3)-delth(3))**2+
     +        (delth(3)-delz(3))**2+(delz(3)-delr(3))**2))

C *** Find allowable cycles

         call cycles(equiv,tpeakr,ncyc)

C *** Calculate minimum allowable cycle lengths

         mincyc(1) = fwlife/dble(ncyc(1))
         mincyc(2) = fwlife/dble(ncyc(2))
         mincyc(3) = fwlife/dble(ncyc(3))

C+**PJK 27/04/94 write(4,80) 'Rest cycle length = ',mincyc(1),' yrs ',
C    +        'at r = ',rad*1.0d3,' mm'
C             write(4,80) 'No bend cycle length = ',mincyc(2),' yrs ',
C    +        'at r = ',rad*1.0d3,' mm'
C             write(4,80) 'With bend cycle length = ',mincyc(3),' yrs ',
C+**PJK 27/04/94+        'at r = ',rad*1.0d3,' mm'

C *** Overall minimum allowable cycle length for each model
C *** (we use the highest value to set correctly the limit on tcycle)

         min01 = max(min01,mincyc(1))
         min02 = max(min02,mincyc(2))
         min03 = max(min03,mincyc(3))

 70   continue
      close(unit=4)

 80   format(1x,a,f10.4,a,a,f10.4,a)

C *** Evaluate minimum cycle time using chosen model

      if (itcycl.eq.1) then
         tcycmn = min01
      else if (itcycl.eq.2) then
         tcycmn = min02
      else
         tcycmn = min03
      end if

C *** Convert from years to seconds

      tcycmn = tcycmn * 3.1536D7

      if (iprint.eq.0) goto 1000

 90   continue

C *** Written output
C *** --------------
      call oheadr(nout,'Pulsed Reactor')

      call ocmmnt(nout,'Thermal cycling considerations for first wall:')
      call oblnkl(nout)

      call ovarrf(nout,'Inner radius of first wall tubes (m)',
     +     '(afw)',afw)
      call ovarrf(nout,'Outer radius of first wall tubes (m)',
     +     '(bfw)',bfw)
      call ovarre(nout,'Bulk coolant temperature (C)','(bctmp)',bctmp)
      call ovarre(nout,'Coolant internal pressure (Pa)','(coolp)',coolp)
      call ovarre(nout,'Neutron fluence (MW-yr/m2)','(flnce)',flnce)
      call ovarre(nout,'Neutron flux deposited in 1st wall (W/m3)',
     +     '(qppp)',qppp)
      call ovarre(nout,'Heat flux incident on first wall (W/m2)',
     +     '(qpp)',qpp)
      call ovarre(nout,'Heat transfer coefficient (W/m2/K)',
     +     '(hcoeff)',hcoeff)

      if (vel.eq.5.0d0) then
         call ocmmnt(nout,
     +        'Calculation based upon fixed coolant velocity')
      else
         call ocmmnt(nout,
     +        'Calculation based upon fixed temperature rise')
      end if
      call ovarre(nout,'Coolant velocity (m/s)','(vel)',vel)
      call ovarre(nout,'Coolant temperature rise (K)','(tmprse)',tmprse)
      call ovarre(nout,'Peak temperature in first wall (C)',
     +     '(tpeak)',tpeak)
      call ovarre(nout,'Average first wall temperature (C)','(tav)',tav)
      call ovarre(nout,'Material property temperature (C)',
     +     '(tmprop)',tmprop)
      call ovarre(nout,'Youngs modulus','(eyung)',eyung(tmprop))
      call ovarre(nout,'Thermal expansion coefficient (/K)',
     +     '(alpha)',alpha(tmprop))
      call ovarre(nout,'Thermal conductivity (W/m/K)','(tk)',tk(tmprop))
      call ovarre(nout,'First wall lifetime (years)','(fwlife)',fwlife)
      call ovarre(nout,'Minimum cycle time (s)','(tcycmn)',tcycmn)

 1000 continue

      return
      end

C----------------------------------------------------------------------
      SUBROUTINE COSTRM(angle,rad,qpp,hcoeff,tmprop,tmthet)
CCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCC
C--Version number 1.000
C
C--Description
C  Calculate cosine terms in temperature distribution
C  These terms are calculated with the material properties
C  measured at the property temperature.
C
C--Author
C  Chris Gardner, c/o
C  Peter Knight D3/G12 Culham Laboratory, ext.3330
C
C--Date
C  25 November 1993
C
C--Reference
C  Work File Notes in F/MPE/MOD/CAG/PROCESS/PULSE
C  
C--History
C  25/11/93 PJK 1.000 Initial version
C
C--Arguments
C  angle  : (INPUT)  azimuthal angle (radians)
C  rad    : (INPUT)  radial position within first wall tube (m)
C  qpp    : (INPUT)  surface heat flux incident on first wall (W/m**2)
C  hcoeff : (INPUT)  heat transfer coefficient (W/m**2/K)
C  tmprop : (INPUT)  property temperature (C)
C  tmthet : (OUTPUT) azimuthal temperature term (C)
C 
C--Global variables passed via COMMON
C  cc(8)  : angular coefficients
C  dd(8)  : angular coefficients
C
CCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCC

      IMPLICIT NONE

C  Parameters

C  INCLUDE files
      INCLUDE 'param.h'
      INCLUDE 'pulse.h'

      INCLUDE 'phydat.h'

C  Arguments
      DOUBLE PRECISION angle,rad,qpp,hcoeff,tmprop,tmthet

C  Global variables
      DOUBLE PRECISION cc(8),dd(8)
      COMMON/tmpcff/cc,dd

C  Local variables
      INTEGER l,k

C  External functions
      DOUBLE PRECISION tk
      EXTERNAL tk

C--End of preamble--CCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCC

C *** Lowest order terms

      cc(1) = qpp*afw**2*bfw**2/2.d0/tk(tmprop)*(tk(tmprop)-hcoeff*afw)/
     +     (tk(tmprop)*(bfw**2-afw**2)+hcoeff*afw*(afw**2+bfw**2))
      dd(1) = qpp*bfw**2/2.d0/tk(tmprop)*(tk(tmprop)+hcoeff*afw)/
     +     (tk(tmprop)*(bfw**2-afw**2)+hcoeff*afw*(afw**2+bfw**2))

      tmthet = (cc(1)/rad+dd(1)*rad)*cos(angle)

C *** Higher order even terms

      do 10 l = 2,8,2
         k = l/2
         cc(l) = qpp/pi/tk(tmprop)/dble(k)*(dble((-1)**(k+1))/
     +        ((2.0d0*dble(k))**2-1.0d0))*(bfw**(2*k+1)*(2.0d0*dble(k)*
     +        tk(tmprop)-hcoeff*afw))/(2.0d0*dble(k)*tk(tmprop)*
     +        ((bfw/afw)**(4*k)-1.0d0)+hcoeff*afw*((bfw/afw)**(4*k)
     +        +1.0d0))
         dd(l) = 1.0d0/((afw*10.0d0)**(4*k))*(10.0d0)**(4*k)*
     +        (2.0d0*dble(k)*tk(tmprop)+hcoeff*afw)/
     +        (2.0d0*dble(k)*tk(tmprop)-hcoeff*afw)*cc(l)

         tmthet = tmthet+(cc(l)/rad**l+dd(l)*rad**l)*cos(dble(l)*angle)

 10   continue   

      return
      end

C----------------------------------------------------------------------
      DOUBLE PRECISION FUNCTION EYUNG(X)
CCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCC
C--Version number 1.000
C
C--Description
C  Calculate the Young's modulus of the first wall material
C  (stainless steel)
C
C--Author
C  Chris Gardner, c/o
C  Peter Knight D3/G12 Culham Laboratory, ext.3330
C
C--Date
C  25 November 1993
C
C--Reference
C  Work File Notes in F/MPE/MOD/CAG/PROCESS/PULSE
C  
C--History
C  25/11/93 PJK 1.000 Initial version
C
C--Arguments
C  X      : (INPUT)  property temperature (C)
C
CCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCC

      IMPLICIT NONE

C  Arguments
      DOUBLE PRECISION X

C--End of preamble--CCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCC

      EYUNG = 465.0D0*(X)**(-0.18D0)*1.0D9

      RETURN
      END

C----------------------------------------------------------------------
      DOUBLE PRECISION FUNCTION ALPHA(X)
CCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCC
C--Version number 1.000
C
C--Description
C  Calculate the thermal expansion coefficient of the first wall
C  (stainless steel)
C
C--Author
C  Chris Gardner, c/o
C  Peter Knight D3/G12 Culham Laboratory, ext.3330
C
C--Date
C  25 November 1993
C
C--Reference
C  Work File Notes in F/MPE/MOD/CAG/PROCESS/PULSE
C  
C--History
C  25/11/93 PJK 1.000 Initial version
C
C--Arguments
C  X      : (INPUT)  property temperature (C)
C
CCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCC

      IMPLICIT NONE

C  Arguments
      DOUBLE PRECISION X

C--End of preamble--CCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCC

      ALPHA = 10.28D0*(X)**(0.093D0)*1.0D-6

      RETURN
      END

C----------------------------------------------------------------------
      DOUBLE PRECISION FUNCTION TK(X)
CCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCC
C--Version number 1.000
C
C--Description
C  Calculate the thermal conductivity of the first wall.
C  This gives a reasonable fit to 316 stainless steel for
C  temperatures X between 300 and 800 degrees Celsius.
C
C--Author
C  Chris Gardner, c/o
C  Peter Knight D3/G12 Culham Laboratory, ext.3330
C
C--Date
C  25 November 1993
C
C--Reference
C  Work File Notes in F/MPE/MOD/CAG/PROCESS/PULSE
C  
C--History
C  25/11/93 PJK 1.000 Initial version
C
C--Arguments
C  X      : (INPUT)  property temperature (C)
C
CCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCC

      IMPLICIT NONE

C  Arguments
      DOUBLE PRECISION X

C--End of preamble--CCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCC

      TK = 3.78D0*(X)**(0.28D0)

      RETURN
      END

C----------------------------------------------------------------------
      DOUBLE PRECISION FUNCTION YIELD(X)
CCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCC
C--Version number 1.000
C
C--Description
C  Calculate the yield strength of the first wall
C  (stainless steel)
C
C--Author
C  Chris Gardner, c/o
C  Peter Knight D3/G12 Culham Laboratory, ext.3330
C
C--Date
C  25 November 1993
C
C--Reference
C  Work File Notes in F/MPE/MOD/CAG/PROCESS/PULSE
C  
C--History
C  25/11/93 PJK 1.000 Initial version
C
C--Arguments
C  X      : (INPUT)  property temperature (C)
C
CCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCC

      IMPLICIT NONE

C  Arguments
      DOUBLE PRECISION X

C--End of preamble--CCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCC

      YIELD = 745.0D0*(X)**(-0.31D0)*1.0D6

      RETURN
      END

C----------------------------------------------------------------------
      DOUBLE PRECISION FUNCTION SMT(X,FWLIFS)
CCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCC
C--Version number 1.000
C
C--Description
C  Calculate the maximum stress intensity from ASME code.
C
C--Author
C  Chris Gardner, c/o
C  Peter Knight D3/G12 Culham Laboratory, ext.3330
C
C--Date
C  25 November 1993
C
C--Reference
C  Work File Notes in F/MPE/MOD/CAG/PROCESS/PULSE
C  
C--History
C  25/11/93 PJK 1.000 Initial version
C
C--Arguments
C  X      : (INPUT)  property temperature (C)
C  FWLIFS : (INPUT)  first wall lifetime (s)
C
CCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCC

      IMPLICIT NONE

C  Arguments
      DOUBLE PRECISION X,FWLIFS

C  Local variables
      DOUBLE PRECISION smt400,smt500,smt600,lnpwr

C--End of preamble--CCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCC

C *** smt400 : smt at 400 degrees Celsius
C *** smt500 : smt at 500 degrees Celsius
C *** smt600 : smt at 600 degrees Celsius
C *** lnpwr  : logarithm of first wall lifetime 

      lnpwr = log(fwlifs)
      smt400 = 109.0d0
      smt500 = 107.0d0
      smt600 = 102.0d0

C *** If x <= 400 smt = 109.
C *** If x <= 500 smt = smt400+(x-400)/100**smt500-smt400 
C *** (simple first order Taylor expansion).

      if (fwlifs.ge.3000) smt600 = -0.8139765d0*lnpwr**2+
     +     6.2849d0*lnpwr+99.147d0

      if (x.le.400) then
         smt = 109.0d0
      else if (x.le.500) then
         smt = smt400+(x-400.0d0)/100.0d0*(smt500-smt400)
      else if (x.le.600) then
         smt = smt500+(x-500.0d0)/100.0d0*(smt600-smt500)
      else
C+**PJK 27/04/94
C      write(4,*) 'No reliable data for SMT stress for temperatures ',
C+**PJK 27/04/94     +        'exceeding 600 degrees Celsius'
         STOP
      end if

      smt = smt*1.0d+6

      return
      end

C----------------------------------------------------------------------
      SUBROUTINE CYCLES(EQUIV,TEMP,NCYC)
CCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCC
C--Version number 1.000
C
C--Description
C  Calculate the number of allowable cycles from a fit of the
C  ASME fatigue design data.
C
C--Author
C  Chris Gardner, c/o
C  Peter Knight D3/G12 Culham Laboratory, ext.3330
C
C--Date
C  25 November 1993
C
C--Reference
C  'Methods of first wall structural analysis .....', R.J. LeClaire,
C     PFC/RR-84-9.
C  Work File Notes in F/MPE/MOD/CAG/PROCESS/PULSE
C  
C--History
C  25/11/93 PJK 1.000 Initial version
C
C--Arguments
C  equiv(3) : (INPUT)  Von Mises equivalent strain
C  temp     : (INPUT)  peak temperature (C)
C  ncyc(3)  : (OUTPUT) number of allowable cycles
C
CCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCC

      IMPLICIT NONE

C  Arguments
      DOUBLE PRECISION equiv(3),temp
      INTEGER ncyc(3)

C  Local variables
      DOUBLE PRECISION logstr,lgn426,lgn454,lgn482
      DOUBLE PRECISION lgn510,lgn649,logn
      DOUBLE PRECISION bsqd(5)
      INTEGER k,l

C--End of preamble--CCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCC

C *** logstr  : logarithm of equivalent strain
C *** lgn426  : logarithm of number of cycles at 426 Celsius
C *** lgn454  : logarithm of number of cycles at 454 Celsius
C *** lgn482  : logarithm of number of cycles at 482 Celsius
C *** lgn510  : logarithm of number of cycles at 510 Celsius
C *** lgn649  : logarithm of number of cycles at 649 Celsius
C *** logn    : logarithm of number of cycles at arbitrary temperature
C *** bsqd(5) : fitting coefficients

      do 20 k = 1,3

         logstr = log(equiv(k))
         lgn426 = (logstr+3.7587178d0)/(-0.198105441d0)
         lgn454 = (logstr+4.2563621d0)/(-0.183711238d0)
         lgn482 = (logstr+4.6637048d0)/(-0.17626645d0)
         lgn510 = (logstr+5.1613625d0)/(-0.16112635d0)
         lgn649 = (logstr+5.691763d0)/(-0.14084195d0)

         bsqd(1) = (8.763d-3)**2-4.0d0*4.548d-4*(0.046d0-equiv(k))
         bsqd(2) = (4.941d-3)**2-4.0d0*2.525d-4*(0.02675d0-equiv(k))
         bsqd(3) = (2.537d-3)**2-4.0d0*1.2564d-4*(0.01459d0-equiv(k))
         bsqd(4) = (1.113d-3)**2-4.0d0*5.199d-5*(7.3355d-3-equiv(k))
         bsqd(5) = (6.558d-4)**2-4.0d0*3.09d-5*(4.3448d-3-equiv(k))

         do 10 l = 1,5
            if (bsqd(l).lt.0.d0) bsqd(l) = 0.d0
 10      continue

C *** This piece seems to be approximating the fatigue design curve by
C *** a quadratic.

         if (equiv(k).gt.0.00376d0)
     +        lgn426 = (8.763d-3-sqrt(bsqd(1)))/(2.0d0*4.548d-4)
         if (equiv(k).gt.0.00261d0)
     +        lgn454 = (4.941d-3-sqrt(bsqd(2)))/(2.0d0*2.525d-4)
         if (equiv(k).gt.0.00186d0)
     +        lgn482 = (2.537d-3-sqrt(bsqd(3)))/(2.0d0*1.2564d-4)
         if (equiv(k).gt.0.0013d0)
     +        lgn510 = (1.133d-3-sqrt(bsqd(4)))/(2.0d0*5.199d-5)
         if (equiv(k).gt.0.000922d0) 
     +        lgn649 = (6.558d-4-sqrt(bsqd(5)))/(2.0d0*3.09d-5)

C *** Taylor expansion in temperature

         if (temp.le.426) then
            logn = lgn426
         else if (temp.le.454) then
            logn = lgn426+(temp-426.0d0)*(lgn454-lgn426)/
     +           (454.0d0-426.0d0)
         else if (temp.le.482) then
            logn = lgn454+(temp-454.0d0)*(lgn482-lgn454)/
     +           (482.0d0-454.0d0)
         else if (temp.le.510) then
            logn = lgn482+(temp-482.0d0)*(lgn510-lgn482)/
     +           (510.0d0-482.0d0)
         else if (temp.le.649) then
            logn = lgn510+(temp-510.0d0)*(lgn649-lgn510)/
     +           (649.0d0-510.0d0)
         else
C+**PJK 27/04/94 write(4,*) 'Fatigue data unreliable for T > 649 (C)'
C+**PJK 27/04/94 write(4,30) temp
            goto 1000
         end if   

         if (logn.gt.15.0D0) logn = 15.0D0
         ncyc(k) = int(exp(logn))

 20   continue

 30   format(1x,'First wall temperature  ',f10.4)

 1000 continue

      return
      end
C----------------------------------------------------------------------
      SUBROUTINE TOHSWG(nout,iprint)
CCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCC
C--Version number 1.100
C
C--Description
C  Routine to calculate the minimum OH coil swing time
C
C--Author
C  Chris Gardner, c/o
C  Peter Knight D3/162a Culham, ext.6368
C
C--Date
C  22 May 2006
C
C--Reference
C  F/MPE/MOD/CAG/PROCESS/PULSE/0013
C  F/PL/PJK/PROCESS/CODE/050
C  
C--History
C  25/11/93 PJK 1.000 Initial version
C  22/05/06 PJK 1.100 Corrected error in tohsmn calculation
C
C--Arguments
C  nout   : (INPUT)  Fortran output unit identifier
C  iprint : (INPUT)  Flag to turn on/off (1/0) output to file
C
CCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCC

      IMPLICIT NONE

C  INCLUDE files
      INCLUDE 'param.h'
      INCLUDE 'pfcoil.h'
      INCLUDE 'pwrcom.h'
      INCLUDE 'vltcom.h'
      INCLUDE 'phydat.h'
      INCLUDE 'ineq.h'
      INCLUDE 'pulse.h'

C  Arguments
      INTEGER nout,iprint

C  Local variables
      DOUBLE PRECISION ioht1,ioht2,r,rho,pfbusl,albusa,v,m,loh,ipdot

C  External routines
      EXTERNAL osubhd,ovarre

C--End of preamble--CCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCC

      if (lpulse.ne.1) goto 1000

      if (iprint.eq.1) goto 10

C *** Current/turn in OH coil at beginning of pulse (A/turn)

      ioht1 = cpt(nohc,2)

C *** Current/turn in OH coil at start of flat-top (A/turn)

      ioht2 = cpt(nohc,3)

C *** OH coil resistance (ohms)

      if (ipfres.eq.0) then
         r = 0.0D0
      else
         r = powohres/( 1.0D6*ric(nohc) )**2
      end if

C *** OH coil bus resistance (ohms) (assumed to include power supply)
C *** Bus parameters taken from routine PWRCONV.

      pfbusl = 8.0D0 * rmajor + 140.0D0
      albusa = abs(cptdin(nohc))/100.0D0

      rho = 1.5D0 * 2.62D-4 * pfbusl/albusa

C *** OH coil power source emf (volts)

      v = vpfskv * 1.0D3

C *** Mutual inductance between OH coil and plasma (H)

      m = sxlg(nohc,ncirt)

C *** Self inductance of OH coil (H)

      loh = sxlg(nohc,nohc)

C *** Maximum rate of change of plasma current (A/s)

      ipdot = 0.5D6

C *** Minimum OH coil swing time (s)

      tohsmn = loh*(ioht2 - ioht1) /
     +     (ioht2*turns(nohc)*(r+rho) - v + m*ipdot)

      if (iprint.eq.0) goto 1000

 10   continue

      call osubhd(nout,'OH coil swing time considerations:')
      call ovarre(nout,'Minimum OH coil swing time (s)',
     +     '(tohsmn)',tohsmn)

 1000 continue

      return
      end
C----------------------------------------------------------------------
      SUBROUTINE BURN(nout,iprint)
CCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCC
C--Version number 1.001
C
C--Description
C  Routine to calculate the burn time for a pulsed reactor.
C
C--Author
C  Chris Gardner, c/o
C  Peter Knight D3/162a Culham, ext.6368
C
C--Date
C  25 May 2006
C
C--Reference
C  F/MPE/MOD/CAG/PROCESS/PULSE/0012
C  
C--History
C  25/11/93 PJK 1.000 Initial version
C  25/05/06 PJK 1.001 Added SAVE statement
C
C--Arguments
C  nout   : (INPUT)  Fortran output unit identifier
C  iprint : (INPUT)  Flag to turn on/off (1/0) output to file
C
CCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCC

      IMPLICIT NONE

C  INCLUDE files
      INCLUDE 'param.h'
      INCLUDE 'pfcoil.h'
      INCLUDE 'pulse.h'
      INCLUDE 'vltcom.h'
      INCLUDE 'phydat.h'
      INCLUDE 'cdriv.h'
      INCLUDE 'times.h'

C  Arguments
      INTEGER nout,iprint

C  Local variables
      DOUBLE PRECISION vburn,vsmax,vssoft
      SAVE vsmax,vssoft

C  External routines
      EXTERNAL osubhd,ovarre

C--End of preamble--CCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCC

      if (lpulse.ne.1) goto 1000

      if (iprint.eq.1) goto 10

C *** Volt-seconds required to produce plasma current during start-up
C *** (i.e. up to start of flat top)

      vssoft = vsres + vsind

C *** Total volt-seconds available during burn (vstot is the total
C *** volt-second capability provided by the PF/OH coils)

      vsmax = abs(vstot) - vssoft

C *** Loop voltage during burn (including MHD sawtooth enhancement)

      vburn = plascur * rplas * facoh * csawth

C *** Burn time (s)

C+**PJK 29/03/94 Removed ... tburn = max(1.0D-3,vsmax/vburn)
      tburn = vsmax/vburn

      if (iprint.eq.0) goto 1000

 10   continue

      call osubhd(nout,'Volt-second considerations:')
      call ovarre(nout,'Total V-s capability of OH/PF coils (Wb)',
     +     '(abs(vstot))',abs(vstot))
      call ovarre(nout,'Required volt-seconds during start-up (Wb)',
     +     '(vssoft)',vssoft)
      call ovarre(nout,'Available volt-seconds during burn (Wb)',
     +     '(vsmax)',vsmax)
      call ovarre(nout,'Burn time (s)','(tburn)',tburn)

 1000 continue

      return
      end
C----------------------------------------------------------------------
      SUBROUTINE STARTUP(iprint)
CCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCC
C--Version number 1.000
C
C--Description
C  Routine to find the minimum auxiliary power required in start-up.
C  This is accomplished by calling the non-linear optimisation routine
C  VMCON, so this subroutine simply sets up the equations to be solved.
C
C  PROCESS assumes that all the ion temperatures and profile
C  parameters are identical and utilises charge neutrality in 
C  order to calculate DENI.
C
C  ZEFF is assumed to remain constant, in other words the
C  ion/electron ratios are invariant.
C
C  The most general form for the energy confinement time is :
C
C                              ptaue   qtaue                   rtaue
C                          ____      __
C  taue =  gtaue + ftaue   dene      te     ( <Paux>  +  alpmw )
C        ____     __
C  where DENE and TE are the electron density (10**20 m**-3) and
C  electron temperature (10 keV) respectively.
C 
C  The equation defining ignition has the form
C                       2   s                2   1/2      -3/2
C   A n   T      =   B n   T    +  P    - C n   T    + D T
C      e20 e10          e20 e10     aux      e20 e10      e10
C  ----------
C     tau
C        E
C                =    P         +  P    -  P         +  P
C                      alpha        aux     rad          ohm
C 
C                      p   q                                  r
C  tau    =  gg  + ff n   T    ( P      + P    + P    + P    )
C     E                e20 e10    alpha    ohm    rad    ohm
C 
C  We solve this equation for (n   , T   ) subject to the constraints,
C                               e20   e10
C 
C            d P
C               aux
C            -----  =  0.
C            d T
C               e10
C 
C  to find the minimum auxiliary power required in start-up.
C
C--Author
C  Chris Gardner, c/o
C  Peter Knight D3/G12 Culham Laboratory, ext.3330
C
C--Date
C  25 November 1993
C
C--Reference
C  Work File Notes in F/MPE/MOD/CAG/PROCESS/PULSE
C  
C--History
C  25/11/93 PJK 1.000 Initial version
C
C--Arguments
C  iprint : (INPUT)  Flag to turn on/off (1/0) output to file
C
CCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCC

      IMPLICIT NONE

C  Parameters
      INTEGER n,m,meq,lcnorm,lb,ldel,lh,lwa,liwa
      PARAMETER(
     +     n = 2,
     +     m = 2,
     +     lcnorm = n+1,
     +     lb = n+1,
     +     ldel = 7*(n+1),
     +     lh = 2*(n+1),
     +     lwa = 2*(n+1),
     +     liwa = 6*(n+1)+m)

C  INCLUDE files
      INCLUDE 'param.h'
      INCLUDE 'numer.h'
      INCLUDE 'start.h'
      INCLUDE 'phydat.h'
      INCLUDE 'cdriv.h'
      INCLUDE 'ineq.h'

C  Arguments
      INTEGER iprint

C  Local variables
      DOUBLE PRECISION x(n),fgrd(n),conf(m),cnorm(lcnorm,m)
      DOUBLE PRECISION b(lb,lb),vlam1(m+2*n+1),glag(n),cm(m)
      DOUBLE PRECISION vmu(m+2*n+1),glaga(n),gamma1(n)
      DOUBLE PRECISION eta(n),xa(n),bdelta(n),delta(ldel)
      DOUBLE PRECISION gm(n+1),bdl(n+1),bdu(n+1),h(lh,lh)
      DOUBLE PRECISION wa(lwa),bndl(n),bndu(n)
      DOUBLE PRECISION objf,tol
      INTEGER maxfev,info,nfev,mode
      INTEGER iwa(liwa),ilower(n),iupper(n)

      DOUBLE PRECISION ne20,te10,ti10
      DOUBLE PRECISION fD,fDT
      DOUBLE PRECISION rrplas

C  External routines
      EXTERNAL start1,start2,vmcon1,oheadr,ovarre

C--End of preamble--CCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCC

      if (iprint.eq.1) goto 10

c *** ne20 : volume averaged electron density (10**20 m**-3)
c *** te10 : volume averaged electron temperature (10 keV)
c *** ti10 : volume averaged D-T temperature (10 keV)

c *** Define normalised temperature and densities.

      ne20 = dene/1.0d20
      te10 = te/10.0d0
      ti10 = ti/10.0d0

      aa = 0.24d0*(1.d0+(deni/dene+ralpne+rncne+rnone+rnfene)*ti/te)

      if ((ti10.gt.0.4d0).and.(ti10.le.1.0d0)) then
         s = 3
      else if ((ti10.gt.1.0d0).and.(ti10.le.2.0d0)) then
         s = 2

C *** Outside the above ranges of ti10, the value of s is not known
C *** (by PJK), so s is set according to whether ti10 is above
C *** or below unity...

      else if (ti10.le.1.0d0) then
         s = 3
      else
         s = 2

      end if   

      fD = (1.d0-ftr)
      fDT = deni/dene

C *** Alpha power multiplier

      bb = 0.155d0*(4.0d0*fD*(1.d0-fD)*fDT**2)*(1.d0+alphan+alphat)**s/
     +     ((1.d0+alphan)**(s-2)*(1.0d0+2.d0*alphan+dble(s)*alphat))

C *** Radiation power multiplier

      cc = 1.68d-2*(sqrt((1.0d0+alphan)**3)*sqrt(1.0d0+alphan+alphat)/
     +     (1.0d0+2.0d0*alphan+0.5d0*alphat))*zeff

C *** Ohmic power multiplier
C *** If the ohmic power density calculated in subroutine POHM is
C *** changed in the future then the constant DD must be changed 
C *** accordingly.

C *** The following lines come directly from the formulae within
C *** routine POHM, but with t10 replaced by pcoef

      rrplas = 2.15D-9*zeff*rmajor/(kappa*rminor**2*pcoef**1.5D0)
      if (ires.eq.1) then
         rrplas = rrplas*rpfac
      end if

      dd = (facoh*plascur)**2 * rrplas * 1.0D-6/vol

C *** Multiply coefficients by plasma volume

      aa = aa*vol
      bb = bb*vol
      cc = cc*vol
      dd = dd*vol

C *** Initial values for the density and temperature.

      x(1) = ne20
      x(2) = te10

C *** Initialise variables for VMCON

      meq = 1
      mode = 0
      tol = 1.0d-3
      maxfev = 100

      ilower(1) = 1
      ilower(2) = 1
      iupper(1) = 1
      iupper(2) = 1
      bndl(1) = 0.1d0
      bndl(2) = 0.5d0
      bndu(1) = 100.0d0
      bndu(2) = 50.0d0

C *** N.B. If the VMCON routine stored in minpac.f is used, then
C *** we have problems with recursive calls. Therefore we must call
C *** an almost identical version, VMCON1, instead.

      call vmcon1(start1,start2,mode,n,m,meq,x,objf,fgrd,conf,
     +     cnorm,lcnorm,b,lb,tol,maxfev,info,nfev,vlam1,glag,vmu,
     +     cm,glaga,gamma1,eta,xa,bdelta,delta,ldel,gm,bdl,bdu,
     +     h,lh,wa,lwa,iwa,liwa,ilower,iupper,bndl,bndu)

      auxmin = objf
      nign = x(1)*1.0D20
      tign = x(2)*10.0D0

      if (iprint.eq.0) goto 1000

 10   continue

      call oheadr(nout,'Start-up')

      call ovarre(nout,'Minimum auxiliary power requirement (MW)',
     +     '(auxmin)',auxmin)
      call ovarre(nout,'Start-up electron density (/m3)',
     +     '(x(1))',x(1)*1.0D20)
      call ovarre(nout,'Start-up electron temperature (keV)',
     +     '(x(2))',x(2)*10.0D0)

 1000 continue

      return
      end
C----------------------------------------------------------------------
      SUBROUTINE START1(n,m,x,objf,conf,info)
CCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCC
C--Version number 1.000
C
C--Description
C  Calculates the auxiliary power and the constraint equations
C  relevant to the minimisation of the auxiliary power.
C
C--Author
C  Chris Gardner, c/o
C  Peter Knight D3/G12 Culham Laboratory, ext.3330
C
C--Date
C  25 November 1993
C
C--Reference
C  Work File Notes in F/MPE/MOD/CAG/PROCESS/PULSE
C  
C--History
C  25/11/93 PJK 1.000 Initial version
C
C--Arguments
C  n       : (INPUT)  number of equations
C  m       : (INPUT)  number of constraints
C  x(n)    : (INPUT)  current values of the density and temperature
C  objf    : (OUTPUT) auxiliary power (MW)
C  conf(m) : (OUTPUT) contraints
C  info    : (IN/OUT) error status flag
C
CCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCC

      IMPLICIT NONE

C  Arguments
      INTEGER n,m,info
      DOUBLE PRECISION x(n),conf(m),objf

C  External routines
      EXTERNAL constr,cudrv1

C--End of preamble--CCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCC

      call cudrv1(n,x,objf)
      call constr(n,m,x,objf,conf)

C+**PJK 27/04/94      write(4,*) x(1),x(2)
C+**PJK 27/04/94      write(4,*) conf(1),conf(2)

      info = info*1

      return
      end
C----------------------------------------------------------------------
      SUBROUTINE START2(n,m,x,fgrd,cnorm,lcnorm,info)
CCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCC
C--Version number 1.000
C
C--Description
C  Calculates the first derivative of the auxiliary power
C  and the constraint equations relevant to the minimisation of
C  the auxiliary power
C
C--Author
C  Chris Gardner, c/o
C  Peter Knight D3/G12 Culham Laboratory, ext.3330
C
C--Date
C  25 November 1993
C
C--Reference
C  Work File Notes in F/MPE/MOD/CAG/PROCESS/PULSE
C  
C--History
C  25/11/93 PJK 1.000 Initial version
C
C--Arguments
C  n       : (INPUT)  number of equations
C  m       : (INPUT)  number of constraints
C  x(n)    : (INPUT)  current values of density and temperature
C  fgrd(n) : (OUTPUT) first derivative of auxiliary power
C  cnorm(m,lcnorm) : (INPUT)  constraints
C  lcnorm  : (INPUT)  array index
C  info    : (IN/OUT) error status flag
C
CCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCC

      IMPLICIT NONE

C  INCLUDE files
      INCLUDE 'param.h'
      INCLUDE 'numer.h'

C  Arguments
      INTEGER n,m,lcnorm,info
      DOUBLE PRECISION x(n),fgrd(n),cnorm(lcnorm,m)

C  Local variables
      DOUBLE PRECISION xfor(2),xbac(2),cfor(2),cbac(2)
      DOUBLE PRECISION ffor,fbac
      INTEGER i,j

C  External routines
      EXTERNAL constr,cudrv1

C--End of preamble--CCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCC

      do 30 i = 1,n
         do 10 j = 1,n
            xfor(j) = x(j)
            xbac(j) = x(j)
            if (i.eq.j) then
               xfor(i) = x(j)*(1.0d0+epsfcn)
               xbac(i) = x(j)*(1.0d0-epsfcn)
            end if
 10      continue

         call cudrv1(n,xfor,ffor)
         call constr(n,m,xfor,ffor,cfor)
         call cudrv1(n,xbac,fbac)
         call constr(n,m,xbac,fbac,cbac)

         fgrd(i) = (ffor-fbac)/(xfor(i)-xbac(i))

         do 20 j = 1,m
            cnorm(i,j) = (cfor(j)-cbac(j))/(xfor(i)-xbac(i))
 20      continue
 30   continue

      info = info*1

      return
      end
C----------------------------------------------------------------------
      SUBROUTINE cudrv1(n,x,paux)
CCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCC
C--Version number 1.000
C
C--Description
C  Routine acting as interface between the start-up routines
C  and CUDRIV.
C
C--Author
C  Chris Gardner, c/o
C  Peter Knight D3/G12 Culham Laboratory, ext.3330
C
C--Date
C  25 November 1993
C
C--Reference
C  Work File Notes in F/MPE/MOD/CAG/PROCESS/PULSE
C  
C--History
C  25/11/93 PJK 1.000 Initial version
C
C--Arguments
C  n      : (INPUT)  number of equations
C  x(n)   : (INPUT)  current values of the density and temperature
C  paux   : (OUTPUT) auxiliary power (MW)
C
CCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCC

      IMPLICIT NONE

C  INCLUDE files
      INCLUDE 'param.h'
      INCLUDE 'numer.h'
      INCLUDE 'phydat.h'
      INCLUDE 'cdriv.h'

C  Arguments
      INTEGER n
      DOUBLE PRECISION x(n),paux

C  Local variables
      DOUBLE PRECISION storen,storet

C  External routines
      EXTERNAL physics

C--End of preamble--CCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCC

C *** Set electron density, temperature for this iteration, but
C *** store original values to allow them to be reset later

      storen = dene
      storet = te

      dene = x(1)*1.0D20
      te = x(2)*10.0D0

C *** Call the physics routines with these values - PHYSICS calls
C *** routine CUDRIV itself.

      call physics

C *** Total injection power (MW)

      paux = (pinje + pinji)*1.0D-6

C *** Reset density and temperature to pre-call values

      dene = storen
      te = storet

C *** Call physics routines again to reset all values

      call physics

      return
      end
C----------------------------------------------------------------------
      SUBROUTINE constr(n,m,x,paux,conf)
CCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCC
C--Version number 1.000
C
C--Description
C  Calculate the constraint equations relevant to the minimisation of
C  the auxiliary power.
C
C--Author
C  Chris Gardner, c/o
C  Peter Knight D3/G12 Culham Laboratory, ext.3330
C
C--Date
C  25 November 1993
C
C--Reference
C  Work File Notes in F/MPE/MOD/CAG/PROCESS/PULSE
C  
C--History
C  25/11/93 PJK 1.000 Initial version
C
C--Arguments
C  n       : (INPUT)  number of equations
C  m       : (INPUT)  number of constraints
C  x(n)    : (INPUT)  current values of the density and temperature
C  paux    : (INPUT)  auxiliary power (MW)
C  conf(m) : (OUTPUT) constraints
C
CCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCC

      IMPLICIT NONE

C  INCLUDE files
      INCLUDE 'start.h'

C  Arguments
      INTEGER n,m
      DOUBLE PRECISION x(n),conf(m),paux

C  Local variables
      DOUBLE PRECISION eta,detadt

C--End of preamble--CCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCC

      eta = bb*x(1)**2*x(2)**s+paux-cc*x(1)**2*sqrt(x(2))+dd/
     +     sqrt(x(2)**3)
      detadt = dble(s)*bb*x(1)**2*x(2)**(s-1)-0.5d0*cc*x(1)**2/
     +     sqrt(x(2))-1.5d0*dd/sqrt(x(2)**5)

      conf(1) = aa*x(1)-(gtaue+ftaue*(1.d0+rtaue)*x(1)**ptaue*
     +     x(2)**qtaue*eta**rtaue)*detadt-qtaue*ftaue*
     +     x(1)**ptaue*x(2)**(qtaue-1.0D0)*eta**(rtaue+1.0D0)
      conf(2) = paux

      return
      end
c______________________________________________________________________
C+**PJK 25/11/93 The following has been added to help STARTUP run.
c______________________________________________________________________
      SUBROUTINE VMCON1(
     +     start1,start2,mode,n,m,meq,x,objf,fgrd,conf,cnorm,lcnorm,
     +     b,lb,tol,maxfev,info,nfev,vlam,glag,vmu,cm,glaga,gamma,eta,
     +     xa,bdelta,delta,ldel,gm,bdl,bdu,h,lh,wa,lwa,iwa,liwa,ilower,
     +     iupper,bndl,bndu)

C+**PJK 25/11/93 This routine is identical to subroutine VMCON
C+**PJK 25/11/93 stored in minpac.f, but calls different routines
C+**PJK 25/11/93 start1,  start2  and qpsub1, instead of
C+**PJK 25/11/93 fcnvmc1, fcnvmc2 and qpsub, respectively.

c  This subroutine calculates the least value of a function of
c  several variables subject to linear and/or nonlinear equality
c  and inequality constraints.  More particularly, it solves the
c  problem
c
c            minimize f(x)
c
c     subject to c (x) =  0.0 ,  i = 1,...,meq
c                 i
c
c            and c (x) >= 0.0 ,  i = meq+1,...,m
c                 i
c
c            and l <= x <= u  ,  i = 1,...n
c                 i    i    i
c
c
c  The subroutine implements a variable metric method for
c  constrained optimization developed by M.J.D. Powell.
c
c  The subroutine statement is
c
c    subroutine vmcon1(start1,start2,mode,n,m,meq,x,objf,fgrd,conf,
c                     cnorm,lcnorm,b,lb,tol,maxfev,info,
c                     nfev,vlam,glag,vmu,cm,glaga,gamma,eta,xa,
c                     bdelta,delta,ldel,gm,bdl,bdu,h,lh,wa,lwa,iwa,
c                     liwa)
c
c  where
c
c  START1 is the name of the user supplied subroutine which
c  calculates the objective and constraint functions. START1
c  should be declared in an external statement in the user
c  calling program, and should be written as follows:
c
c   subroutine start1(n,m,x,objf,conf,info)
c   integer n,m,info
c   real objf
c   real x(n),fgrd(n),conf(m)
c   ---------------
c   statements to calculate the objective and constraint at x.
c   the objective and constraint functions and must be returned in
c   objf, conf. note that the equality
c   constraints must precede the inequality constraints in conf.
c   ---------------
c   return
c   end
c
c  START2 is the name of the user supplied subroutine which
c  calculates the gradients (first derivative vectors)
c  of the objective and constraint functions. START2 should be
c  declared in an external statement in the user calling
c  program, and should be written as follows :
c
c   subroutine start2(n,m,x,fgrd,cnorm,lcnorm,info)
c   integer n,m,lcnorm,info
c   real objf
c   real x(n),cnorm(lcnorm,m)
c   ---------------
c   statements to calculate the gradients of the objective and
c   constraint functions at x. the gradient of the objective
c   function must be returned in fgrd. note that the equality
c   constraints must precede the inequality constraints in conf.
c   the constraint gradients or normals must be returned as the
c   columns of cnorm.
c   ---------------
c   return
c   end
c
c  The value of INFO should not be changed by START2 unless the
c  user wants to terminate execution of VMCON1. In this case
c  set INFO to a negative integer.
c
c  MODE is a non-negative integer input variable set to 1 if the
c  second derivative matrix in b (see below) is provided by the
c  user, and to 0 if it is to be initialized to the identity
c  matrix.
c
c  N is a positive integer input variable set to the number of
c  variables.
c
c  M is a positive integer input variable set to the number of
c  constraints.
c
c  MEQ is a non-negative integer input variable set to the number
c  of equality constraints. MEQ must be less than or equal to N.
c
c  X is a real array of length N. On input it must contain an
c  initial estimate of the solution vector. On output X
c  contains the final estimate of the solution vector.
c
c  OBJF is a real output variable that contains the value of the
c  objective function at the output x.
c
c  FGRD is a real output array of length N which contains the
c  components of the gradient of the objective function at
c  the output X.
c
c  CONF is a real output array of length M which contains the
c  values of the constraint functions at the output X. The
c  equality constraints must precede the inequality constraints.
c
c  CNORM is a real LCNORM by M array whose columns contain the
c  constraint normals at the output X in the first N positions.
c
c  LCNORM is a positive integer input variable set to the row
c  dimension of CNORM which is at least N+1.  The (N+1)st row
c  of CNORM is used for work space.
c
c  B is a real LB by LB array whose first N rows and columns
c  contain the approximation to the second derivative matrix
c  of the Lagrangian function. Often, an adequate initial
c  B matrix can be obtained by approximating the hessian
c  of the objective function.  On input, the approximation is
c  provided by the user if MODE = 1 and is set to the identity
c  matrix if MODE = 0. the (N+1)st row and column are used for
c  work space.
c
c  LB is a positive integer input variable set to the row
c  dimension of B which is at least N+1.
c
c  TOL is a non-negative input variable. A normal return occurs
c  when the objective function plus suitably weighted multiples
c  of the constraint functions are predicted to differ from
c  their optimal values by at most TOL.
c
c  MAXFEV is a positive integer input variable set to the limit
c  on the number of calls to START1.
c
c  INFO is an integer output variable set as follows
c
c   if INFO is negative then user termination. otherwise
c
c   INFO = 0  improper input parameters. Tests are made to ensure
c             that N and M are positive, TOL is non-negative,
c             MEQ is less than or equal to N, and that LCNORM,
c             LB, LDEL, LH, LWA, and LIWA are sufficiently large.
c
c   INFO = 1  a normal return. see description of TOL.
c
c   INFO = 2  number of calls to START1 is at least MAXFEV.
c
c   INFO = 3  line search required ten calls of START1.
c
c   INFO = 4  uphill search direction was calculated.
c
c   INFO = 5  quadratic programming technique was unable to find
c             a feasible point.
c
c   INFO = 6  quadratic programming technique was restricted by
c             an artificial bound or failed due to a singular
c             matrix.
c
c  NFEV is an integer output variable set to the number of calls
c  to START1.
c
c  VLAM is a real output array of length M+2N+1 which contains
c  the Lagrange multipliers at the output X.  The Lagrange
c  multipliers provide the sensitivity of the objective
c  function to changes in the constraint functions.
c  note that VLAM(M+I), I=1,...,N gives the multipliers for
c  the lower bound constraints.  VLAM(M+N+1+I), I=1,...,N
c  gives the multipliers for the upper bound constraints.
c
c  GLAG is a real output array of length N which contains the
c  components of the gradient of the Lagrangian function at
c  the output x.
c
c  CM is a real work array of length M.
c
c  VMU is a real work array of length M+2N+1.
c
c  GLAGA, GAMMA, ETA, XA, BDELTA are real work arrays of
c  length N.
c
c  DELTA is a real work array of length LDEL.
c
c  LDEL is a positive integer input variable set equal to the
c  length of DELTA which is at least MAX(7*(N+1),4*(N+1)+M).
c
c  GM, BDL, BDU are real work arrays of length N+1.
c
c  H is a real LH by LH work array.
c
c  LH is a positive integer input variable set to the dimension
c  of the square array H which is at least 2*(N+1).
c
c  WA is a real work array of length LWA.
c
c  LWA is a positive integer input variable set equal to the
c  dimension of WA which is at least 2*(N+1).
c
c  IWA is an integer work array of length LIWA.
c
c  LIWA is a positive integer input variable set equal to the
c  dimension of IWA which is at least 6*(N+1) + M.
c
c  ILOWER is an integer array of length N.
c  If X(I) has a lower bound, ILOWER(I) is set to 1
c  on input.  If no bound is provided, ILOWER(i) should
c  be 0 (the default value).
c
c  BNDL is a real array of length N.
c  If X(I) has a lower bound, it should be given in BNDL(I).
c
c  IUPPER is an integer array of length N.
c  If X(I) has an upper bound, IUPPER(I) is set to 1
c  on input.  If no bound is provided, IUPPER(I) should
c  be 0 (the default value).
c
c  BNDU is a real array of length N.
c  If X(I) has a upper bound, it should be given in BNDU(I).
c
c  Algorithm version of June 1979.
c
c  Roger L. Crane, Kenneth E. Hillstrom, Michael Minkoff
c  Modified for simple bounds, M. Minkoff (10/26/82)
c  Modified for separate function and gradient evaluation,
c  M. Minkoff (11/18/83)
c  Modified to pass ILOWER, IUPPER,BNDL,BDNU through argument
c  list instead of through common block, and remove write
c  capability J. Galambos (5/21/91)
c  Modified for separate START1 and START2 functions to avoid passing
c  info via a common block. J. Galambos (5/21/91)

      IMPLICIT NONE

      INTEGER mode,n,m,meq,lcnorm,lb,maxfev,info,nfev,ldel,lh,lwa,liwa
      INTEGER iwa(liwa),ilower(n),iupper(n)
      INTEGER i,j,k,mact,nfinit,nls,np1,np1j,npp,nqp,nsix,nsixi
      INTEGER inx,ki,ml,mlp1,mcon,mp1,mpn,mpnpp1,mpnppn

      DOUBLE PRECISION objf,tol
      DOUBLE PRECISION x(n),fgrd(n),conf(m),cnorm(lcnorm,m),b(lb,lb),
     +     vlam(*),glag(n),vmu(*),cm(m),glaga(n),gamma(n),
     +     eta(n),xa(n),bdelta(n),delta(ldel),gm(*),
     +     bdl(*),bdu(*),h(lh,lh),wa(lwa),bndl(n),bndu(n)
      DOUBLE PRECISION alpha,aux,auxa,calpha,cp1,cp2,cp5,dbd,dflsa,dg,
     +     fls,flsa,one,spgdel,sum,temp,thcomp,theta,zero

      EXTERNAL start1,start2

      zero = 0.0D0
      cp1 = 0.1D0
      cp2 = 0.2D0
      cp5 = 0.5D0
      one = 1.0D0

      np1 = n + 1
      npp = 2*np1
      info = 0

c  Check input parameters for errors

      if (
     +     (n.le.0)           .or.
     +     (m.le.0)           .or.
     +     (meq.gt.n)         .or.
     +     (lcnorm.lt.(n+1))  .or.
     +     (lb.lt.(n+1))      .or.
     +     (tol.lt.zero)      .or.
     +     (ldel.lt.max(7*(n+1),4*(n+1)+m)).or.
     +     (lh.lt.(2*(n+1)))  .or.
     +     (lwa.lt.(2*(n+1))) .or.
     +     (liwa.lt.(6*(n+1)+m))
     +     ) goto 450

c  Set the initial elements of b and vmu. vmu is the weighting
c  vector to be used in the line search.
c  Use hessian estimate provided by user if mode = 1 on input

      if (mode .eq. 1) goto 25

c  Use identity matrix for hessian estimate

      do 20 j = 1, n
         do 10 i = 1, n
            b(i,j) = zero
 10      continue
         b(j,j) = one
 20   continue

 25   continue

c  Set m + 1 to mp1
c  Set m + n to mpn (these are limits for lower bound indices)
c  Set m + np1 + 1 to mpnpp1
c  Set m + np1 + n to mpnppn (these are limits for upper bound
c  indices)

      mp1 = m + 1
      mpn = m + n
      mpnpp1 = m + np1 + 1
      mpnppn = m + np1 + n

c  Set mcon to total number of actual constraints

      mcon = m
      do 26 i = 1, n
         if (ilower(i) .eq. 1) mcon = mcon + 1
 26   continue

c  Set ml to m + number of lower bounds

      ml = mcon

c  Set mlp1 to ml + 1

      mlp1 = ml + 1
      do 27 i = 1, n
         if (iupper(i) .eq. 1) mcon = mcon + 1
 27   continue
      do 30 k = 1, mpnppn
         vmu(k) = zero
 30   continue

c  Set initial values of some variables
c  nfev is the number of calls of start1
c  nsix is the length of an array
c  nqp is the number of quadratic subproblems

      nfev = 1
      nsix = 6*np1
      nqp = 0

c  Calculate the initial functions and gradients

      call start1(n,m,x,objf,conf,info)

      if (info .lt. 0) goto 450

      call start2(n,m,x,fgrd,cnorm,lcnorm,info)

      if (info .lt. 0) goto 450

c  Start the iteration by calling the quadratic programming
c  subroutine

 40   continue

c  Increment the quadratic subproblem counter

      nqp = nqp + 1

c  Set the linear term of the quadratic problem objective function
c  to the negative gradient of objf

      do 50 i = 1, n
         gm(i) = -fgrd(i)
 50   continue
      do 55 i = 1, mpnppn
         vlam(i) = zero
 55   continue

      call qpsub1(
     +     n,m,meq,conf,cnorm,lcnorm,b,lb,gm,bdl,bdu,info,x,delta,
     +     ldel,cm,h,lh,mact,wa,lwa,iwa,liwa,ilower,iupper,
     +     bndl,bndu)

c  The following return is made if the quadratic problem solver
c  failed to find a feasible point, if an artificial bound was
c  active, or if a singular matrix was detected

      if ((info .eq. 5) .or. (info .eq. 6)) goto 450

c  Initialize the line search iteration counter

      nls = 0

c  Calculate the Lagrange multipliers

      do 70 j = 1, mact
         k = iwa(j) - npp
         if (k .gt. 0) goto 59
         ki = iwa(j)
         k = ki + m
         if (ki .gt. np1) goto 58
         if (ki .eq. np1) goto 70
         if (ilower(ki) .eq. 1) goto 59
         goto 70
 58      continue
         ki = iwa(j) - np1
         k = ki + m + np1
         if (ki .eq. np1) goto 70
         if (iupper(ki) .eq. 1) goto 59
         goto 70
 59      continue
         do 60 i = 1, n
            np1j = np1 + j
            nsixi = nsix + i
            vlam(k) = vlam(k) + h(np1j,i)*delta(nsixi)
 60      continue
 70   continue

c  Calculate the gradient of the Lagrangian function
c  nfinit is the value of nfev at the start of an iteration

      nfinit = nfev
      do 80 i = 1, n
         glag(i) = fgrd(i)
 80   continue
      do 100 k = 1, m
         if (vlam(k) .eq. zero) goto 100
         do 90 i = 1, n
            glag(i) = glag(i) - cnorm(i,k)*vlam(k)
 90      continue
 100  continue
      do 105 k = mp1, mpn
         if (vlam(k) .eq. zero) goto 105
         inx = k - m
         if (ilower(inx) .eq. 0) goto 105
         glag(inx) = glag(inx) - vlam(k)
 105  continue
      do 106 k = mpnpp1, mpnppn
         if (vlam(k) .eq. zero) goto 106
         inx = k - m - np1
         if (iupper(inx) .eq. 0) goto 106
         glag(inx) = glag(inx) + vlam(k)
 106  continue

c  Set spgdel to the scalar product of fgrd and delta
c  Store the elements of glag and x

      spgdel = zero
      do 110 i = 1, n
         spgdel = spgdel + fgrd(i)*delta(i)
         glaga(i) = glag(i)
         xa(i) = x(i)
 110  continue

c  Revise the vector vmu and test for convergence

      sum = abs(spgdel)
      do 120 k = 1, mpnppn
         aux = abs(vlam(k))
         vmu(k) = max(aux,cp5*(aux + vmu(k)))
         temp = 0.00D0
         if (k .gt. m) goto 111
         temp = conf(k)
         goto 119
 111     continue
         if (k .gt. mpn) goto 112
         inx = k - m
         if (ilower(inx) .eq. 0) goto 120
         temp = x(inx) - bndl(inx)
         goto 119
 112     continue
         inx = k - m - np1
         if ((inx .eq. 0) .or. (inx .gt. n)) goto 120
         if (iupper(inx) .eq. 0) goto 120
         temp = bndu(inx) - x(inx)
 119     continue
         sum = sum + abs(vlam(k)*temp)
 120  continue

c  Exit if convergence criterion is satisfied

      if (sum .le. tol) goto 450

c  Set sum to the weighted sum of infeasibilities
c  Set fls to the line search objective function

 130  continue

c  Increment the line search iteration counter

      nls = nls + 1
      sum = zero
      do 140 k = 1, mpnppn
         aux = 0.0D0
         if (k .le. meq) aux = conf(k)
         temp = 0.0D0
         if (k .gt. m) goto 131
         temp = conf(k)
         goto 139
 131     continue
         if (k .gt. mpn) goto 132
         inx = k - m
         if (ilower(inx) .eq. 0) goto 140
         temp = x(inx) - bndl(inx)
         goto 139
 132     continue
         inx = k - m - np1
         if ((inx .eq. 0) .or. (inx .gt. n)) goto 140
         if (iupper(inx) .eq. 0) goto 140
         temp = bndu(inx) - x(inx)
 139     continue
         sum = sum + vmu(k)*max(aux,-temp)
 140  continue
      fls = objf + sum

      if (nfev .ne. nfinit) goto 150

c  Set the initial conditions for the line search
c  flsa is the initial value of the line search function
c  dflsa is its first derivative (if delta(np1) = 1)
c  alpha is the next reduction in the step-length

      flsa = fls
      dflsa = spgdel - delta(np1)*sum
      if (dflsa .ge. zero) goto 420

c  Set initial multiplying factor for stepsize
c  Set initial value of stepsize for output

      alpha = one
      calpha = one
      goto 210

c  Test whether line search is complete

 150  continue
      aux = fls - flsa

c  Exit line search if function difference is small

      if (aux .le. (cp1*dflsa)) goto 260

c  Exit if the line search requires ten or more function
c  evaluations

      if (nfev .ge. (nfinit + 10)) goto 380

c  Calculate next reduction in the line step assuming a quadratic
c  fit.

      alpha = max(cp1,cp5*dflsa/(dflsa - aux))

c  Multiply delta by alpha and calculate the new x

 210  continue
      calpha = alpha*calpha

      do 220 i = 1, n
         delta(i) = alpha*delta(i)
         x(i) = xa(i) + delta(i)
 220  continue

      dflsa = alpha*dflsa

c  Test nfev against maxfev, call start1 and resume line search

      if (nfev .ge. maxfev) goto 380
      nfev = nfev + 1

      call start1(n,m,x,objf,conf,info)

      if (info .lt. 0) goto 450
      goto 130

c  Line search is complete. Calculate gradient of Lagrangian
c  function for use in updating hessian of Lagrangian

 260  continue

      call start1(n,m,x,objf,conf,info)
      call start2(n,m,x,fgrd,cnorm,lcnorm,info)

      if (info .lt. 0) goto 450
      do 270 i = 1, n
         glag(i) = fgrd(i)
 270  continue
      do 290 k = 1, m
         if (vlam(k) .eq. zero) goto 290
         do 280 i = 1, n
            glag(i) = glag(i) - cnorm(i,k)*vlam(k)
 280     continue
 290  continue
      do 291 k = mp1, mpn
         if (vlam(k) .eq. zero) goto 291
         inx = k - m
         if (ilower(inx) .eq. 0) goto 291
         glag(inx) = glag(inx) - vlam(k)
 291  continue
      do 292 k = mpnpp1, mpnppn
         if (vlam(k) .eq. zero) goto 292
         inx = k - m - np1
         if (iupper(inx) .eq. 0) goto 292
         glag(inx) = glag(inx) + vlam(k)
 292  continue

c  Calculate gamma and bdelta in order to revise b
c  Set dg to the scalar product of delta and gamma
c  Set dbd to the scalar product of delta and bdelta

      dg = zero
      dbd = zero
      do 340 i = 1, n
         gamma(i) = glag(i) - glaga(i)
         bdelta(i) = zero
         do 330 j = 1, n
            bdelta(i) = bdelta(i) + b(i,j)*delta(j)
 330     continue
         dg = dg + delta(i)*gamma(i)
         dbd = dbd + delta(i)*bdelta(i)
 340  continue

c  Calculate the vector eta for the b-f-g-s formula
c  replace dg by the scalar product of delta and eta

      aux = cp2*dbd
      theta = one
      if (dg .lt. aux) theta = (dbd - aux)/(dbd - dg)
      thcomp = one - theta
      do 350 i = 1, n
         eta(i) = theta*gamma(i) + thcomp*bdelta(i)
 350  continue
      if (dg .lt. aux) dg = aux

c  Revise the matrix b and begin new iteration

      do 375 i = 1, n
         aux = bdelta(i)/dbd
         auxa = eta(i)/dg
         do 370 j = i, n
            b(i,j) = b(i,j) - aux*bdelta(j) + auxa*eta(j)
            b(j,i) = b(i,j)
 370     continue
 375  continue
      goto 40

c  Error returns. restore previous solution

 380  continue
      do 390 i = 1, n
         x(i) = xa(i)
 390  continue
      if (nfev .ge. maxfev) goto 400
      nfev = nfev + 1

      call start1(n,m,x,objf,conf,info)

      if (info .lt. 0) goto 450
      goto 410

c  Error return because there have been maxfev calls of start1

 400  continue
      info = 2
      goto 450

c  Error return because line search required 10 calls of start1

 410  continue
      info = 3
      goto 450

c  Error return because uphill search direction was calculated

 420  continue
      info = 4

 450  continue

      return
      end
c______________________________________________________________________
      SUBROUTINE QPSUB1(
     +     n,m,meq,conf,cnorm,lcnorm,b,lb,gm,bdl,bdu,info,
     +     x,delta,ldel,cm,h,lh,mact,wa,lwa,iwa,liwa,
     +     ilower,iupper,bndl,bndu)

c  This subroutine finds the value of the solution vector which
c  minimizes a quadratic function of several variables subject to
c  equality and inequality constraints. This is accomplished
c  by invoking subroutine harwqp, a modified version of subroutine
c  ve02ad, the Harwell Library subroutine for general quadratic
c  programming.
c
c  The subroutine statement is
c
c  subroutine qpsub1(n,m,meq,conf,cnorm,lcnorm,b,lb,gm,bdl,bdu,
c                   info,delta,ldel,cm,h,lh,mact,wa,lwa,iwa,liwa)
c
c  where
c
c  N is a positive integer input variable set to the number of
c  variables.
c
c  M is a positive integer input variable set to the number of
c  constraints.
c
c  MEQ is a non-negative integer input variable set to the number
c  of equality constraints. MEQ must be less than or equal to N.
c
c  CONF is a real input array of length M which contains the
c  constraint functions.
c
c  CNORM is a real LCNORM by M array whose columns contain the
c  constraint normals in the first N positions.  The (N+1)st
c  row of CNORM is used for work space.
c
c  LCNORM is a positive integer input variable set to the row
c  dimension of CNORM which is at least N+1.
c
c  B is a real LB by LB array whose first N rows and columns
c  contain the hessian approximation on input.  The (N+1)st
c  row and column are used for work space.
c
c  LB is a positive integer input variable set to the row
c  dimension of B which is at least N+1.
c
c  GM is a real array of length N+1 which, on input, contains
c  the negative components of the function gradient in the
c  first N elements. The (N+1)st element is used for work space.
c
c  BDL, BDU are real work arrays of length N+1.
c
c  INFO is an integer variable. It must be set to zero before
c  the initial call to qpsub1 and should not otherwise be
c  changed.  On output, INFO is set as follows
c
c   INFO = 1  a normal return.
c
c   INFO = 5  a feasible point was not found.
c
c   INFO = 6  solution is restricted by an artificial bound or
c             failed due to a singular matrix.
c
c  DELTA is a real array of length LDEL.  It need not be set
c  before the first call to QPSUB1, but before each subsequent
c  call, the first N locations should contain an estimate of
c  the solution vector. (Zero is used as the estimate for the
c  first call.)  On output, the value of the solution vector
c  which minimizes the quadratic function is contained in the
c  first N locations.  The remainder of the array is used for
c  work space.
c
c  LDEL is a positive integer input variable set to the length
c  of DELTA which is at least MAX(7*(N+1),4*(N+1)+M).
c
c  CM is a real work array of length M.
c
c  H is a real LH by LH work array.
c
c  LH is a positive integer input variable set to the dimension
c  of the square array H which is at least 2*(N+1).
c
c  MACT is an integer output variable set to the number of
c  constraints in the basis.
c
c  WA is a real work array of length LWA.
c
c  LWA is a positive integer input variable set equal to the
c  dimension of WA which is at least 2*(N+1).
c
c  IWA is an integer work array of length LIWA.
c
c  LIWA is a positive integer input variable set to the length
c  of IWA which is at least 6*(N+1) + M.
c
c  ILOWER is an integer array of length N.
c  If X(I) has a lower bound, ILOWER(I) is set to 1
c  on input.  If no bound is provided, ILOWER(I) should
c  be 0 (the default value).
c
c  BNDL is a real array of length N.
c  If X(I) has a lower bound, it should be given in BNDL(I).
c
c  IUPPER is an integer array of length N.
c  If X(I) has a upper bound, IUPPER(I) is set to 1
c  on input.  If no bound is provided, IUPPER(I) should
c  be 0 (the default value).
c
c  BNDU is a real array of length N.
c  If X(I) has a upper bound, it should be given in BNDU(I).
c
c  Roger L. Crane, Kenneth E. Hillstrom, Michael Minkoff
c  Modified for simple bounds, M. Minkoff (10/26/82)
c
c  Modified to pass ILOWER,IUPPER, BNDL,BNDU in through argument list
c  instead of through COMMON, J. Galambos, (5/21/91)

      IMPLICIT NONE

      INTEGER n,m,meq,lcnorm,lb,info,ldel,lh,mact,lwa,liwa
      INTEGER iwa(liwa),ilower(n),iupper(n)
      INTEGER i,iflag,j,k,mode,mtotal,np1,npp
      INTEGER inx

      DOUBLE PRECISION conf(m),cnorm(lcnorm,m),b(lb,lb),gm(*),bdl(*),
     +     bdu(*),delta(ldel),cm(m),h(lh,lh),wa(lwa)
      DOUBLE PRECISION x(n),bndu(n),bndl(n)
      DOUBLE PRECISION cd6,cdm6,cp9,one,zero

      cd6 = 1.0D6
      cdm6 = 1.0D-6
      cp9 = 0.9D0
      one = 1.0D0
      zero = 0.0D0

      np1 = n + 1
      npp = 2*np1
      if (info .gt. 0) goto 50
      mtotal = m + npp

c  Set initial values of some variables

      info = 1
      mact = meq + 1
      mode = 1

c  Set the initial elements of bdl, bdu, and delta where
c  bdl are artificial lower bounds,
c  bdu are artificial upper bounds and
c  delta is an initial solution estimate

      do 10 i = 1, n
         bdl(i) = -cd6
         bdu(i) = cd6
 10   continue

c  Bound the artificial variables in qp

      bdl(np1) = zero
      delta(np1) = one
      if (meq .le. 0) goto 30

c  Set indices of equality constraints
c  The bounds are the first npp constraints

      do 20 k = 1, meq
         iwa(k) = k + npp
 20   continue

 30   continue

c  Set index of upper bound of delta(np1) active

      iwa(mact) = npp

c  Extend gm and b because of the extra variable that is introduced
c  to allow for feasibility. Set linear term of cost function to
c  a large value

      gm(np1) = cd6
      do 40 i = 1, np1
         b(i,np1) = zero
         b(np1,i) = zero
 40   continue

c  Set the elements of cm and cnorm(np1,*)

 50   continue
      do 60 i = 1, n
         if (ilower(i) .eq. 1) bdl(i) = bndl(i) - x(i)
         if (iupper(i) .eq. 1) bdu(i) = bndu(i) - x(i)
         delta(i) = max(zero,bdl(i))
         delta(i) = min(delta(i),bdu(i))
 60   continue
      do 90 k = 1, m
         if (k .le. meq) goto 70
         if (conf(k) .lt. zero) goto 70

c  If an inequality constraint is satisfied set the constant term
c  in the constraint vector to the violation and put zero in the
c  constraint matrix for the (n+1)st variable

         cm(k) = -conf(k)
         cnorm(np1,k) = zero
         goto 90
 70      continue

c  If the constraint is an equality or a violated inequality set
c  the constant term to zero and put the function value in the
c  constraint matrix for the (n+1)st variable

         cm(k) = zero
         cnorm(np1,k) = conf(k)
 90   continue

c  Set the upper bound of the (n+1)st variable
c  Set iflag. iflag will be used in checking active constraints
c  Call subroutine harwqp to solve quadratic programming problem

      bdu(np1) = one
      iflag = -1
 100  continue

      call harwqp1(np1,mtotal,b,lb,gm,cnorm,lcnorm,cm,bdl,bdu,delta,
     +     mact,meq,h,lh,iwa,wa,iwa(4*(n+1)+m+1),mode,info)

      if (info .ne. 1) goto 130

c  Check whether the required feasibility conditions hold
c  If delta(np1) is sufficiently small there is no feasible
c  solution

      if (delta(np1) .le. cdm6) goto 120

c  Check whether active constraints are bounds

      do 110 j = 1, mact
         if (iwa(j) .gt. npp) goto 110
         if (iwa(j) .eq. npp) goto 101
         if (iwa(j) .gt. np1) goto 105
         if (iwa(j) .eq. np1) goto 130
         if (ilower(iwa(j)) .eq. 0) goto 130
         goto 110
 105     continue
         inx = iwa(j) - np1
         if (iupper(inx) .eq. 0) goto 130
         goto 110
 101     continue

c  The active constraint is blu(np1)

         iflag = 1
 110  continue

c  Normal exit

      if (iflag .ge. 1) goto 140

c  A second call to harwqp found blu(np1) to still be inactive
c  thus an error exit is made

      if (iflag .ge. 0) goto 120

c  Reduce bdu(np1) and retry harwqp

      bdu(np1) = cp9*delta(np1)
      iflag = 0
      goto 100

c  Error return because of infeasibility

 120  continue
      info = 5
      goto 140

c  Error return because of restriction by an artificial bound
c  or detection of a singular matrix

 130  continue
      info = 6

 140  continue

      return
      end
c______________________________________________________________________
      SUBROUTINE HARWQP1(
     +     n,m,a,ia,b,c,ic,d,bdl,bdu,x,k,ke,h,ih,lt,wa,iwa,mode,info)

c  This program is a modified version of the Harwell library
c  subroutine VE02AD dated 11/06/70.  The modifications were made
c  to substitute the subroutines HINV and DOTPMC for Harwell
c  subroutines MB01B and MC03AS.  The calling sequence above
c  includes three entries, WA, IWA, and INFO not present in
c  the original program.  WA and IWA are real and
c  integer work arrays, respectively, and must be dimensioned
c  at least 2*N.  INFO is an output variable set to one for a
c  normal return and set to two when a singular matrix is detected
c  in HINV.  All other entries in the calling sequence are as
c  described in the Harwell documentation.
c
c  Modified 5/22/91 to use implicit none (J. Galambos)
c
c+**PJK 02/11/92 Throughout this routine, argument 1 of DOTPMC has
c+**PJK 02/11/92 different dimensions than are declared in the source
c+**PJK 02/11/92 code of the routine itself. The program runs without
c+**PJK 02/11/92 error but beware of future modifications.

      IMPLICIT NONE

      INTEGER n,m,ia,ic,k,ke,ih,mode,info
      INTEGER iwa(*),lt(*)
      INTEGER i, ial, ib, ii, j, li, ni, nk, nn, n3,n4,n5,n6
      INTEGER i0,i1,i2,i3

      DOUBLE PRECISION a(ia,*),b(*),c(ic,*),d(*),bdl(*),bdu(*),x(*),
     +     h(ih,*),wa(*)
      DOUBLE PRECISION alpha, cac, cc, chc, ghc, y, z, zz
      DOUBLE PRECISION r0

      LOGICAL retest,passiv,postiv

      i0 = 0
      i1 = 1
      i2 = 2
      i3 = 3
      r0 = 0.0D0

      info = 1
      retest = .false.
      nn = n+n
      n3 = nn+n
      n4 = nn+nn
      n5 = n4+n
      n6 = n5+n

      if (mode.ge.3) goto 99

c  Call feasible vertex routine

 8    continue
      call harwfp1(n,m,c,ic,d,bdl,bdu,x,k,ke,h,ih,lt,wa,iwa,info)
      if (info .ne. 1) goto 1000
      if (k.eq.0) goto 1000
      if ((mode.eq.2).and.(.not.retest)) goto 100

c  Initial operators h=0 and cstar=c(-1) from ve02b
      do 65 i = 1,n
         do 60 j = 1,n
            h(n+i,j) = h(i,j)
            h(i,j) = 0.0D0
 60      continue
 65   continue
      goto 120

 99   continue
      do 1 i = 1,m
         lt(nn+i) = 1
 1    continue

c  Constraints indexed as  -1=equality, 0=active, 1=inactive
      if (k.eq.0) goto 100
      do 2 i=1,k
         j=0
         if (i.le.ke)j=-1
         lt(nn+lt(i))=j
 2    continue

 100  continue
      if ((mode.eq.5).and.(.not.retest)) goto 109

c  Set up matrix and rhs of equations governing equality problem
      do 1011 i = 1,n
         x(n+i) = b(i)
         do 101 j = 1,n
            h(i,j) = a(i,j)
 101     continue
 1011 continue

      if (((mode.eq.2).or.(mode.eq.3)).and.(.not.retest)) goto 200
      if (k.eq.0) goto 107
      do 1021 i = 1,k
         li = lt(i)
         if (li.gt.nn) goto 105
         do 103 j = 1,n
            h(j,n+i) = 0.0D0
            h(n+i,j) = 0.0D0
 103     continue
         if (li.gt.n) goto 104
         h(n+i,li) = 1.0D0
         h(li,n+i) = 1.0D0
         x(nn+i) = bdl(li)
         goto 108

 104     continue
         li = li-n
         h(n+i,li) = -1.0D0
         h(li,n+i) = -1.0D0
         x(nn+i) = -bdu(li)
         goto 108

 105     continue
         li = li-nn
         do 106 j = 1,n
            h(n+i,j) = c(j,li)
            h(j,n+i) = c(j,li)
 106     continue
         x(nn+i) = d(li)

 108     continue
         do 102 j = 1,k
            h(n+i,n+j) = 0.0D0
 102     continue
 1021 continue

 107  continue
      nk = n+k

c  Invert matrix giving operators h and cstar

      call hinv1(h,ih,nk,wa,iwa,info)
      if (info .ne. 1) goto 1000
      goto 118

c  Set up rhs only

 109  continue
      do 113 i = 1,n
         x(n+i) = b(i)
 113  continue

      do 115 i = 1,k
         li = lt(i)
         if (li.gt.nn) goto 117
         if (li.gt.n) goto 116
         x(nn+i) = bdl(li)
         goto 115

 116     continue
         x(nn+i) = -bdu(li-n)
         goto 115

 117     continue
         x(nn+i)=d(li-nn)
 115  continue

c  Solve for solution point x

      nk = n+k

 118  continue
      do 119 i=1,n
         call dotpmc(h(1,i),i1,x(n+1),i1,r0,x(i),nk,i0)
 119  continue

c  Check feasibility, if not exit to 8

      do 110 i = 1,m
         if (lt(nn+i).le.0) goto 110
         if (i.gt.n) goto 111
         z = x(i)-bdl(i)
         goto 114

 111     continue
         if (i.gt.nn) goto 112
         z = bdu(i-n)-x(i-n)
         goto 114

 112     continue
         j = i-nn
         call dotpmc(c(1,j),i1,x(1),i1,d(j),z,n,i2)

 114     continue
         if (z.lt.0.0D0) goto 8
 110  continue

 120  continue

c  Calculate gradient g and Lagrange multipliers -cstar.g,
c  Find largest multiplier,  exit if not positive

      do 121 i = 1,n
         call dotpmc(a(i,1),ia,x(1),i1,b(i),x(n6+i),n,i2)
 121  continue
      if (k.eq.0) goto 1000

C+**PJK 17/11/97 D999 reduced to D99
      z = -1.0D99
      do 122 i = 1,k
         if (lt(nn+lt(i)).eq.-1) goto 122
         call dotpmc(h(n+i,1),ih,x(n6+1),i1,r0,zz,n,i3)
         if (zz.le.z) goto 122
         z = zz
         ii = i
 122  continue

      if (z.gt.0.0D0) goto 130
      if ((retest).or.(mode.ge.4)) goto 137
      retest = .true.
      goto 100

 137  continue
      if (z.ne.0.0D0) goto 1000
      goto 1000

c  Set direction of search as corresponding row of cstar

 130  continue
      do 131 i = 1,n
         x(nn+i) = h(n+ii,i)
 131  continue

 136  continue
      do 132 i = 1,n
         call dotpmc(a(i,1),ia,x(nn+1),i1,r0,x(n+i),n,i0)
 132  continue
      call dotpmc(x(nn+1),i1,x(n+1),i1,r0,cac,n,i0)
      if (cac.gt.0.0D0) goto 134
      postiv = .false.
      y = 1.0D0
      goto 135

 134  continue
      postiv = .true.
      y = z/cac

 135  continue
      do 133 i = 1,n
         x(n5+i) = x(nn+i)*y
 133  continue
      passiv = .true.

 139  continue
C+**PJK 17/11/97 D999 reduced to D99
      alpha = 1.0D99
      nk = n+k

c  Linear search along direction of search,  passiv indicates
c  a constraint has been removed to get search direction,
c  postiv indicates positive curvature along the direction

      do 140 i = 1,m
         if (lt(nn+i).le.0) goto 140
         if (i.gt.n) goto 141
         if (x(n5+i).ge.0.0D0) goto 140
         cc = (bdl(i)-x(i))/x(n5+i)
         goto 143

 141     continue
         if (i.gt.nn) goto 142
         if (x(n4+i).le.0.0D0) goto 140
         cc = (bdu(i-n)-x(i-n))/x(n4+i)
         goto 143

 142     continue
         j = i-nn
         call dotpmc(c(1,j),i1,x(n5+1),i1,r0,zz,n,i0)
         if (zz.ge.0.0D0) goto 140
         call dotpmc(c(1,j),i1,x(1),i1,d(j),cc,n,i1)
         cc = cc/zz

 143     continue
         if (cc.ge.alpha) goto 140
         alpha = cc
         ial = i
 140  continue
      if (passiv) lt(nn+lt(ii)) = 1

c  If minimum found, goto  170

      if ((postiv).and.(alpha.ge.1.0D0)) goto 170

c  Calculate h.c and cstar.c

      do 144 i=1,n
         x(i) = x(i)+alpha*x(n5+i)
 144  continue
      alpha = alpha*y
      j = 1
      if (k.eq.n) j = n+1
      if (ial.gt.n) goto 146
      do 145 i = j,nk
         x(n3+i) = h(i,ial)
 145  continue
      chc = x(n3+ial)
      goto 151

 146  continue
      ib = ial-n
      if (ib.gt.n) goto 148
      do 147 i = j,nk
         x(n3+i) = -h(i,ib)
 147  continue
      chc = -x(n3+ib)
      goto 151

 148  continue
      ib = ib-n
      do 149 i = 1,n
         x(n5+i) = c(i,ib)
 149  continue
      do 150 i = j,nk
         call dotpmc(h(i,1),ih,x(n5+1),i1,r0,x(n3+i),n,i0)
 150  continue
      if (k.ne.n) call dotpmc(x(n5+1),i1,x(n3+1),i1,r0,chc,n,i0)

 151  continue
      lt(nn+ial) = 0
      if (k.eq.n) goto 180
      if (passiv) goto 160

c  Apply formula for adding a constraint

 156  continue
      if (k.eq.0) goto 157
      do 1521 i = 1,k
         alpha = x(n4+i)/chc
         ni = n+i
         do 152 j = 1,n
            h(ni,j) = h(ni,j)-alpha*x(n3+j)
 152     continue
 1521 continue

 157  continue
      k = k+1
      lt(k) = ial
      do 158 j = 1,n
         h(n+k,j) = x(n3+j)/chc
 158  continue
      if (k.lt.n) goto 154
      do 1531 i = 1,n
         do 153 j = 1,n
            h(i,j) = 0.0D0
 153     continue
 1531 continue
      goto 159

 154  continue
      do 1551 i = 1,n
         alpha = x(n3+i)/chc
         do 155 j = 1,i
            h(i,j) = h(i,j)-alpha*x(n3+j)
            h(j,i) = h(i,j)
 155     continue
 1551 continue

 159  continue
      if (.not.passiv) goto 167

c  Removal of a constraint has been deferred,  set up as if
c  the constraint is being removed from augmented basis

      do 164 i=1,n
         call dotpmc(a(i,1),ia,x(1),i1,b(i),x(n6+i),n,i2)
         x(nn+i) = h(n+ii,i)
 164  continue
      call dotpmc(x(n6+1),i1,x(nn+1),i1,r0,z,n,i3)
      if (z.eq.0.0D0) goto 178
      goto 136

 160  continue
      cc = x(n4+ii)
      y = chc*cac+cc**2
      call dotpmc(x(n6+1),i1,x(n3+1),i1,r0,ghc,n,i0)
      if ((alpha*y).lt.(chc*(z-alpha*cac)+ghc*cc)) goto 156

c  Apply formula for exchanging new constraint
c  with passive constraint

      do 161 i = 1,k
         ni = n+i
         call dotpmc(h(ni,1),ih,x(n+1),i1,r0,x(n5+i),n,i0)
 161  continue
      do 162 i = 1,n
         x(n+i) = (chc*x(nn+i)-cc*x(n3+i))/y
         x(n6+i) = (cac*x(n3+i)+cc*x(nn+i))/y
 162  continue
      do 1631 i = 1,n
         do 163 j = 1,i
            h(i,j) = h(i,j)+x(n+i)*x(nn+j)-x(n6+i)*x(n3+j)
            h(j,i) = h(i,j)
 163     continue
 1631 continue
      x(n4+ii) = x(n4+ii)-1.0D0
      do 1661 i = 1,k
         ni = n+i
         do 166 j = 1,n
            h(ni,j) = h(ni,j)-x(n4+i)*x(n6+j)-x(n5+i)*x(n+j)
 166     continue
 1661 continue
      lt(ii) = ial

 167  continue
      if (k.eq.n) goto 120

c  Calculate g,  new search direction is -h.g

      do 168 i = 1,n
         call dotpmc(a(i,1),ia,x(1),i1,b(i),x(n+i),n,i2)
 168  continue
      z = 0.0D0
      do 169 i = 1,n
         call dotpmc(h(i,1),ih,x(n+1),i1,r0,x(n5+i),n,i3)
         if (x(n5+i).ne.0.0D0) z = 1.0D0
 169  continue
      passiv = .false.
      if (z.eq.0.0D0) goto 120
      postiv = .true.
      goto 139

 170  continue
      do 171 i = 1,n
         x(i) = x(i)+x(n5+i)
 171  continue

c  x is now the minimum point in the basis
c  Update the operators if a constraint had been removed

      if (.not.passiv) goto 120

 178  continue
      do 1721 i = 1,n
         alpha = x(nn+i)/cac
         do 172 j = 1,i
            h(i,j) = h(i,j)+alpha*x(nn+j)
            h(j,i) = h(i,j)
 172     continue
 1721 continue
      if (k.gt.1) goto 177
      k = 0
      goto 120

 177  continue
      if (ii.eq.k) goto 175
      do 174 i=1,n
         h(n+ii,i) = h(n+k,i)
 174  continue
      lt(ii) = lt(k)

 175  continue
      k = k-1
      do 173 i = 1,k
         ni = n+i
         call dotpmc(h(ni,1),ih,x(n+1),i1,r0,x(n3+i),n,i0)
 173  continue
      do 1761 i = 1,k
         alpha = x(n3+i)/cac
         ni = n+i
         do 176 j = 1,n
            h(ni,j) = h(ni,j)-alpha*x(nn+j)
 176     continue
 1761 continue
      goto 120

 180  continue
      z = 1.0D0/x(n4+ii)

c  Apply simplex formula to exchange constraints

      do 181 i = 1,n
         ni = n+i
         if (i.ne.ii) goto 182
         do 183 j = 1,n
            h(ni,j) = h(ni,j)*z
 183     continue
         goto 181

 182     continue
         zz = z*x(n4+i)
         do 184 j = 1,n
            h(ni,j) = h(ni,j)-zz*x(nn+j)
 184     continue
 181  continue
      lt(ii) = ial
      goto 120

 200  continue
      k = 0

      ke = 0
      do 202 i = 1,m
         lt(nn+i) = 1
 202  continue
      call hinv1(h,ih,n,wa,iwa,info)
      if (info .ne. 1) goto 1000

c  Start with empty basis from feasible point
c  Search direction is -a(-1).b

      goto 167

 1000 continue

      return
      end
c______________________________________________________________________
      SUBROUTINE HARWFP1(
     +     n,m,c,ic,d,bdl,bdu,x,k,ke,h,ih,lt,wa,iwa,info)

c  This program is a modified version of the Harwell Library
c  subroutine LA02AD.  The modifications were made to substitute
c  the subroutines HINV and DOTPMC for Harwell subroutines
c  MB01B and MC03AS.  The calling sequence above includes
c  three entries, WA, IWA, and INFO not present in the
c  original program.  WA and IWA are real and
c  integer work arrays, respectively, and must be dimensioned
c  at least 2*N.  INFO is an output variable set to one for a
c  normal return and set to two when a singular matrix is detected
c  in HINV.  All other entries in the calling sequence are as
c  described in the Harwell documentation.
c
c  Modified  5/22/91 to use implicit none (J. Galambos)
c
c+**PJK 02/11/92 Throughout this routine, argument 1 of DOTPMC has
c+**PJK 02/11/92 different dimensions than are declared in the source
c+**PJK 02/11/92 code of the routine itself. The program runs without
c+**PJK 02/11/92 error but beware of future modifications.

      IMPLICIT NONE

      INTEGER n,m,ic,k,ke,ih,info
      INTEGER i, ial, ib, ii, j, jj, kv, li, ni, nj, nn, n3
      INTEGER iwa(*), lt(*)
      INTEGER i0,i1,i2,i3

      DOUBLE PRECISION c(ic,*),d(*),bdl(*),bdu(*),x(*),h(ih,*)
      DOUBLE PRECISION wa(*)
      DOUBLE PRECISION alpha, beta, y, z, zz
      DOUBLE PRECISION r0

      i0 = 0
      i1 = 1
      i2 = 2
      i3 = 3
      r0 = 0.0D0

      info = 1
      nn = n+n
      n3 = nn+n
      do 1 i = 1,m
         lt(nn+i) = 1
 1    continue

c  Constraints indexed as
c  -1=equality,  0=active,  1=inactive,  2=violated

      if (k.ne.0) goto 10

c  No designated constraints, vertex chosen from upper and
c  lower bounds, inverse matrix trivial

      do 4 i = 1,n
         do 5 j = 1,n
            h(i,j) = 0.0D0
 5       continue
         if ((x(i)-bdl(i)).gt.(bdu(i)-x(i))) goto 6
         lt(i) = i
         h(i,i) = 1.0D0
         goto 998

 6       continue
         lt(i) = n+i
         h(i,i) = -1.0D0
 998     continue
         lt(nn+lt(i)) = 0
 4    continue
      k = n
      goto 40

c  Set up normals v of the k designated constraints in basis

 10   continue
      do 11 i = 1,k
         j = 0
         if (i.le.ke) j = -1
         lt(nn+lt(i)) = j
         li = lt(i)
         ni = n+i
         if (li.gt.nn) goto 14
         do 12 j = 1,n
            h(j,ni) = 0.0D0
 12      continue
         if (li.gt.n) goto 13
         h(li,ni) = 1.0D0
         goto 11

 13      continue
         h(li-n,ni) = -1.0D0
         goto 11

 14      continue
         li = li-nn
         do 15 j = 1,n
            h(j,ni) = c(j,li)
 15      continue
 11   continue

      if (k.ne.n) goto 19
      do 161 j = 1,n
         nj = n+j
         do 16 i = 1,n
            h(i,j) = h(i,nj)
 16      continue
 161  continue
      call hinv1(h,ih,n,wa,iwa,info)
      if (info .ne. 1) goto 1000
      goto 40

 19   continue

c  Form m = (vtranspose.v)(-1)
      do 2011 i = 1,k
         do 20 j = i,k
            call dotpmc(h(1,n+i),i1,h(1,n+j),i1,r0,h(i,j),n,i0)
            h(j,i) = h(i,j)
 20      continue
 2011 continue
      if (k.ne.1) goto 200
      h(1,1) = 1.0D0/h(1,1)
      goto  201

 200  continue
      call hinv1(h,ih,k,wa,iwa,info)
      if (info .ne. 1) goto 1000

 201  continue

c  Calculate generalized inverse of v,  vplus = m.vtranspose

      do 211 i = 1,k
         do 22 j = 1,k
            x(n+j) = h(i,j)
 22      continue
         do 21 j = 1,n
            call dotpmc(x(n+1),i1,h(j,n+1),ih,r0,h(i,j),k,i0)
 21      continue
 211  continue

c  Set up diagonal elements of the projection matrix  p = v.vplus

      do 23 i = 1,n
         call dotpmc(h(1,i),i1,h(i,n+1),ih,r0,x(n+i),k,i0)
 23   continue
      do 24 i = 1,n
         lt(n+i) = 0
 24   continue
      kv = k

c  Add bound e(i) corresponding to the smallest diag(p)

 29   continue
      z = 1.0D0
      do 25 i = 1,n
         if (lt(n+i).eq.1) goto 25
         if (x(n+i).ge.z) goto 25
         z = x(n+i)
         ii = i
 25   continue
      y = 1.0D0
      if ( (x(ii)-bdl(ii)) .gt. (bdu(ii)-x(ii)) ) y = -1.0D0

c  Calculate vectors vplus.e(i) and  u = e(i)-v.vplus.e(i)

      if (y.ne.1.0D0) goto 27
      do 26 i = 1,k
         x(nn+i) = h(i,ii)
 26   continue
      goto 30

 27   continue
      do 28 i = 1,k
         x(nn+i) = -h(i,ii)
 28   continue

 30   continue
      do 31 i = 1,n
         if (lt(n+i).eq.1) goto 31
         call dotpmc(h(i,n+1),ih,x(nn+1),i1,r0,x(n3+i),kv,i3)
 31   continue
      do 32 i = 1,n
         h(i,ii) = 0.0D0
 32   continue
      lt(n+ii) = 1
      z = 1.0D0+x(n3+ii)*y

c  Update vplus and diag(p)

      do 33 i = 1,n
         if (lt(n+i).eq.1) goto 33
         alpha = x(n3+i)/z
         h(k+1,i) = alpha
         do 34 j = 1,k
            h(j,i) = h(j,i)-x(nn+j)*alpha
 34      continue
 33   continue

      do 35 i = 1,n
         if (lt(n+i).eq.1) goto 35
         x(n+i) = x(n+i)+x(n3+i)**2/z
 35   continue
      k = k+1
      h(k,ii) = y
      if (y.ne.1.0D0) ii = ii+n
      lt(nn+ii) = 0
      lt(k) = ii
      if (k.ne.n) goto 29

c  Set up rhs of constraints in basis

 40   continue
      do 41 i = 1,n
         li = lt(i)
         if (li.gt.n) goto 42
         x(n+i) = bdl(li)
         goto 41

 42      continue
         if (li.gt.nn) goto 43
         x(n+i) = -bdu(li-n)
         goto 41

 43      continue
         x(n+i) = d(li-nn)

 41   continue

c  Calculate position of vertex

      do 44 i = 1,n
         call dotpmc(h(1,i),i1,x(n+1),i1,r0,x(i),n,i0)
 44   continue

c  Calculate the constraint residuals, the number of violated
c  constraints, and the sum of their normals

 50   continue
      kv = 0
      do 51 i = 1,n
         x(n+i) = 0.0D0
 51   continue
      do 52 i = 1,m
         if (lt(nn+i).le.0) goto 52
         if (i.gt.n) goto 53
         z = x(i)-bdl(i)
         goto 55

 53      continue
         if (i.gt.nn) goto 54
         z = bdu(i-n)-x(i-n)
         goto 55

 54      continue
         j = i-nn
         call dotpmc(c(1,j),i1,x(1),i1,d(j),z,n,i2)

 55      continue
         x(nn+i) = z
         if (z.ge.0.0D0) goto 52
         kv = kv+1
         lt(nn+i) = 2
         if (i.gt.n) goto 56
         x(n+i) = x(n+i)+1.0D0
         goto 52

 56      continue
         if (i.gt.nn) goto 57
         x(i) = x(i)-1.0D0
         goto 52

 57      continue
         do 58 ii = 1,n
            x(n+ii) = x(n+ii)+c(ii,j)
 58      continue
 52   continue
      if (kv.ne.0) goto 63
      goto 1000

c  Possible directions of search obtainable by removing a
c  constraint are rows of h,  calculate the optimum direction

 63   continue
      z = 0.0D0
      do 64 i = 1,n
         if (lt(nn+lt(i)).eq.-1) goto 64
         call dotpmc(h(i,1),ih,x(n+1),i1,r0,y,n,i0)
         if (y.le.z) goto 64
         z = y
         ii = i
 64   continue
      if (z.gt.0.0D0) goto 70
      k = 0
      goto 1000

c  Search for the nearest of the furthest violated constraint
c  and the nearest nonviolated nonbasic constraint

 70   continue
C+**PJK 17/11/97 D999 reduced to D99
      alpha = 1.0D99
      beta = 0.0D0
      do 71 i = 1,n
         x(n+i) = h(ii,i)
 71   continue
      do 72 i = 1,m
         if (lt(nn+i).le.0) goto 72
         if (i.gt.n) goto 73
         z = -x(n+i)
         goto 75

 73      continue
         if (i.gt.nn) goto 74
         z = x(i)
         goto 75

 74      continue
         jj = i-nn
         call dotpmc(x(n+1),i1,c(1,jj),i1,r0,z,n,i3)

 75      continue
         if (lt(nn+i).eq.2) goto 76
         if (z.le.0.0D0) goto 72
         z = x(nn+i)/z
         if (z.ge.alpha) goto 72
         alpha = z
         ial = i
         goto 72

 76      continue
         lt(nn+i) = 1
         if (z.ge.0.0D0) goto 72
         z = x(nn+i)/z
         if (z.le.beta) goto 72
         beta = z
         ib = i
 72   continue

      if (alpha.gt.beta) goto 80
      ib = ial
      beta = alpha

c  Exchange with the constraint being removed from the basis,
c  using simplex formula for new h

 80   continue
      lt(nn+lt(ii)) = 1
      lt(nn+ib) = 0
      lt(ii) = ib
      if (ib.gt.n) goto 82
      do 81 i = 1,n
         x(nn+i) = h(i,ib)
 81   continue
      goto 90

 82   continue
      ib = ib-n
      if (ib.gt.n) goto 84
      do 83 i = 1,n
         x(nn+i) = -h(i,ib)
 83   continue
      goto 90

 84   continue
      ib = ib-n
      do 85 i = 1,n
         x(n3+i) = c(i,ib)
 85   continue
      do 86 i = 1,n
         call dotpmc(h(i,1),ih,x(n3+1),i1,r0,x(nn+i),n,i0)
 86   continue

 90   continue
      z = 1.0D0/x(nn+ii)
      do 91 i = 1,n
         x(i) = x(i)+beta*x(n+i)
         if (i.ne.ii) goto 92
         do 93 j = 1,n
            h(i,j) = h(i,j)*z
 93      continue
         goto 91

 92      continue
         zz = z*x(nn+i)
         do 94 j = 1,n
            h(i,j) = h(i,j)-zz*x(n+j)
 94      continue
 91   continue

      goto 50

 1000 continue

      return
      end
c______________________________________________________________________
      SUBROUTINE HINV1(h,ih,n,work,ipvt,info)

c  This subroutine inverts the matrix H by use of linpack software.
c
c  The subroutine statement is
c
c  subroutine hinv(h,ih,n,work,ipvt,info)
c
c  where
c
c  H is a real IH by IH array which contains the N by N
c  matrix to be inverted.  On output the N by N inverse
c  is stored in H.
c
c  IH is an input integer variable set to the fortran
c  declaration of the leading dimension in the H array.
c
c  N is the order of H.  N must be less than or equal to IH.
c
c  WORK is a real work array of length at least N.
c
c  IPVT is an integer work array of length at least N.
c
c  INFO is an integer output variable set as follows
c
c   INFO = 1  normal return
c
c   INFO = 2  H matrix is singular
c
c  Algorithm version of June 1979
c
c  Roger L. Crane, Kenneth E. Hillstrom, Michael Minkoff

      IMPLICIT NONE

      INTEGER ih,n,info
      INTEGER ipvt(n)
      DOUBLE PRECISION h(ih,ih),work(n)

c  Do lu decomposition of h

      call sgefa(h,ih,n,ipvt,info)

      if (info .eq. 0) goto 20
      info = 2
      goto 1000

c  Form inverse of h

 20   continue
      info = 1
      call sgedi(h,ih,n,ipvt,work,work,1)

 1000 continue

      return
      end
