!+ad_name  refprop
!+ad_summ  NIST Reference Fluid Thermodynamic and Transport Properties
!+ad_summ  REFPROP Version 9.1
!+ad_type  Subroutines
!+ad_auth  P J Knight, CCFE, Culham Science Centre
!+ad_cont  -
!+ad_args  N/A
!+ad_desc  This file contains the majority of the Fortran files comprising the
!+ad_desc  REFPROP source code.
!+ad_desc  <P>With the exception of this header, it was created simply by
!+ad_desc  concatenating the following files:<P><CODE>
!+ad_desc  core_anc.for  core_bwr.for  core_cpp.for  core_de.for
!+ad_desc  core_ecs.for  core_feq.for  core_mlt.for  core_ph0.for
!+ad_desc  core_pr.for   core_qui.for  core_stn.for  flash2.for
!+ad_desc  flsh_sub.for  idealgas.for  mix_aga8.for  mix_hmx.for
!+ad_desc  prop_sub.for  realgas.for   sat_sub.for   setup2.for
!+ad_desc  setup.for     trns_ecs.for  trnsp.for     trns_tcx.for
!+ad_desc  trns_vis.for  utility.for</CODE>
!+ad_desc  <P>The additional Fortran files <CODE>commons.for</CODE> and
!+ad_desc  <CODE>comtrn.for</CODE> are also required for compilation,
!+ad_desc  and the <CODE>fluids</CODE> subdirectory and its contents
!+ad_desc  are used during run-time.
!+ad_desc  (Note that file <CODE>pass_ftn.for</CODE> is not used.)
!+ad_desc  <P>The code was obtained for CCFE use by M. Kovari through
!+ad_desc  CODAS PC Job Number 16359.
!+ad_prob  None
!+ad_call  -
!+ad_hist  16/12/14 PJK Incorporated for PROCESS use
!+ad_stat  Okay
!+ad_docs  REFPROP Version 9.1 User's Guide,
!+ad_docc  Eric W. Lemmon, Marcia L. Huber, Mark O. McLinden,
!+ad_docc  Applied Chemicals and Materials Division,
!+ad_docc  National Institute of Standards and Technology,
!+ad_docc  Boulder, Colorado 80305,
!+ad_docc  April, 2013
!
! !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!

c  begin file core_ANC.f
c
c  This file contains core routines for the ancillary equations for vapor
c  pressure, saturated liquid density and saturated vapor density.
c
c  contained here are:
c     subroutine SETPS (nread,icomp,ierr,herr)
c     subroutine PSATT (t,x,p,ierr,herr)
c     subroutine PSATK (icomp,t,p,ierr,herr)
c     subroutine DPSATK (icomp,t,dpdt,ierr,herr)
c     subroutine D2PSTK (icomp,t,d2pdt2,ierr,herr)
c     subroutine TSATP (p,x,t,ierr,herr)
c     subroutine SETPL (nread,icomp,ierr,herr)
c     subroutine PLSATT (t,x,p,ierr,herr)
c     subroutine PLSATK (icomp,t,p,ierr,herr)
c     subroutine TSATPL (p,x,t,ierr,herr)
c     subroutine SETDL (nread,icomp,ierr,herr)
c     subroutine DLSATT (t,x,d,ierr,herr)
c     subroutine DLSATK (icomp,t,d,ierr,herr)
c     subroutine SETDV (nread,icomp,ierr,herr)
c     subroutine DVSATT (t,x,d,ierr,herr)
c     subroutine DVSATK (icomp,t,d,ierr,herr)
c     subroutine TSATD (d,x,t,ierr,herr)
c     subroutine SOLVEA (iflag,pd,x,t,ierr,herr)
c
c ======================================================================
c ======================================================================
c
      subroutine SETPS (nread,icomp,ierr,herr)
c
c  set up working arrays for use with the vapor pressure ancillary equation
c
c  inputs:
c    nread--file to read data from (file should have already been
c           opened and pointer set by subroutine SETUP)
c    icomp--component number in mixture (1..nc); 1 for pure fluid
c
c  outputs:
c     ierr--error flag:  0 = successful
c     herr--error string (character*255 variable if ierr<>0)
c     other quantities returned via arrays in commons
c
c  written by E.W. Lemmon, NIST Thermophysics Division, Boulder, Colorado
c  03-13-01 EWL, original version
c
      include 'commons.for'
      character*255 herr
c
c  read data from file
c     write (*,*) ' SETPS--read component',icomp,' from unit',nread
      read (nread,*) pstmin(icomp)        !lower temperature limit
      read (nread,*) pstmax(icomp)        !upper temperature limit
c  the pressure and density limit are not presently used,
c  but are contained in the file for consistency and possible future use;
c  skip over them in reading the file
      read (nread,*) !pjunk               !upper pressure limit (n/a)
      read (nread,*) !rhojnk              !upper density limit (n/a)
      read (nread,*) pstrd(icomp),psprd(icomp)!reducing parameters
      read (nread,*) nps1(icomp),nps2(icomp),nps3(icomp),
     &               nps4(icomp),nps5(icomp),nps6(icomp)
      if (nps1(icomp).gt.0) then
        do k=1,nps1(icomp)
          read (nread,*) pska(icomp,k),psexp(icomp,k)
        enddo
      endif
      ierr=0
      herr=' '
c
      RETURN
      end                                              !subroutine SETPS
c
c ======================================================================
c
      subroutine PSATT (t,x,p,ierr,herr)
c
c  compute mixture or pure fluid vapor pressure with appropriate
c  ancillary equation
c
c  inputs:
c        t--temperature (K)
c        x--composition [array of mol frac]
c   output:
c        p--vapor pressure [kPa]
c     ierr--error flag:  0 = successful
c                        1 = error:  T<Ttrp
c                        121 = error:  T>Tc
c                        100 = error:  unknown vapor pressure equation
c     herr--error string (character*255 variable if ierr<>0)
c
c  written by E.W. Lemmon, NIST Physical & Chemical Properties Division, Boulder, Colorado
c  03-13-01 EWL, original version
c
      include 'commons.for'
      character*255 herr
      dimension x(ncmax)
c
      ierr=0
      herr=' '
      p=0.0d0
      call ISPURE (x,icomp)
      if (icomp.ne.0) then
c  special case--pure component
        call PSATK (icomp,t,p,ierr,herr)
      else
        pp=0.0d0
        do i=1,nc
          call PSATK (i,t,p,ierr,herr)   !Add Raoult's Law here
          pp=pp+x(i)*p
        enddo
        p=pp
      end if
c     write (*,1200) t,p
c1200 format (' PSATT--t,p: ',2f11.6)
c
      RETURN
      end                                              !subroutine PSATT
c
c ======================================================================
c
      subroutine PSATK (icomp,t,p,ierr,herr)
c
c  compute pure fluid vapor pressure with the appropriate ancillary equation
c
c  inputs:
c    icomp--component i
c        t--temperature (K)
c   output:
c        p--vapor pressure [kPa]
c     ierr--error flag:  0 = successful
c                        1 = error:  T<Ttrp
c                        2 = error:  no equation available
c                        121 = error:  T>Tc
c                        100 = error:  unknown vapor pressure equation
c     herr--error string (character*255 variable if ierr<>0)
c
c  written by E.W. Lemmon, NIST Physical & Chemical Properties Division, Boulder, Colorado
c  03-13-01 EWL, original version
c
      include 'commons.for'
      character*255 herr
c
      ierr=0
      herr=' '
      p=0.0d0
      if (t.lt.pstmin(icomp)) then
        p=ptpn(icomp)
        ierr=1
        write (herr,1097) t,pstmin(icomp),hnull
        call ERRMSG (ierr,herr)
 1097   format ('[PSATK error 1] ',
     &          'temperature less than triple point temperature; T =',
     &          g12.5,' K, Ttp =',g12.5,' K.',a1)
        RETURN
      endif
c
      if (t.gt.tcrit(icomp)) then
        p=pcrit(icomp)
        ierr=121
        write (herr,1098) t,tcrit(icomp),hnull
        call ERRMSG (ierr,herr)
 1098   format ('[PSATK error 121] ',
     &          'temperature greater than critical temperature; T =',
     &          g12.5,' K, Tc =',g12.5,' K.',a1)
        RETURN
      endif
c
c  i is the value following 'PS' in the .fld file
      i=0
      i=ICHAR(hpsk(icomp)(3:3))-48
      if (i.lt.0) i=0
      if (i.gt.9) i=0
      if (hpsk(icomp)(1:2).eq.'PS' .and. i.gt.0) then
        tr=ABS(1.d0-t/pstrd(icomp))
        if (MOD(i,2).eq.0) tr=SQRT(tr)  !Even values of i
        pr=0.0d0
        if (nps1(icomp).ne.0) then
          do k=1,nps1(icomp)
            pr=pr+pska(icomp,k)*tr**psexp(icomp,k)
          enddo
        endif
        if (i.eq.1 .or. i.eq.2) pr=1.d0+pr
        if (i.eq.3 .or. i.eq.4) pr=EXP(pr)
        if (i.eq.5 .or. i.eq.6) pr=EXP(pstrd(icomp)/t*pr)
        p=psprd(icomp)*pr
c  do not return error message if fluid contains no vapor pressure line
      elseif (hpsk(icomp).eq.'NBS') then
        p=pcrit(icomp)
        ierr=2
        herr='[PSATK error 2] vapor pressure equation not available'
        call ERRMSG (ierr,herr)
      else
        p=0.0d0
        ierr=100
        write (herr,1099) hpsk(icomp),hnull
        call ERRMSG (ierr,herr)
 1099   format ('[PSATK error 100] ',
     &          'unknown vapor pressure equation:  (',a3,')',a1)
      end if
c     write (*,1200) icomp,t,p
c1200 format (' PSATK--icomp,t,p: ',i4,2f11.6)
c
      RETURN
      end                                              !subroutine PSATK
c
c ======================================================================
c
      subroutine DPSATK (icomp,t,dpdt,ierr,herr)
c
c  compute the first derivative of the vapor pressure with the
c  appropriate equation
c
c  inputs:
c    icomp--component i
c        t--temperature (K)
c   output:
c     dpdt--dp/dt [kPa/K]
c     ierr--error flag:  0 = successful
c                        1 = error:  T<Ttrp
c                        2 = error:  no equation available
c                        121 = error:  T>Tc
c                        100 = error:  unknown vapor pressure equation
c     herr--error string (character*255 variable if ierr<>0)
c
c  written by E.W. Lemmon, NIST Physical & Chemical Properties Division, Boulder, Colorado
c  05-30-01 EWL, original version
c
      include 'commons.for'
      character*255 herr
c
      ierr=0
      herr=' '
      dpdt=0.0d0
      if (t.lt.pstmin(icomp)) then
        dpdt=ptpn(icomp)
        ierr=1
        write (herr,1097) t,pstmin(icomp),hnull
        call ERRMSG (ierr,herr)
 1097   format ('[DPSATK error 1] ',
     &          'temperature less than triple point temperature; T =',
     &          g12.5,' K, Ttp =',g12.5,' K.',a1)
        RETURN
      endif
c
      if (t.gt.tcrit(icomp)) then
        dpdt=pcrit(icomp)
        ierr=121
        write (herr,1098) t,tcrit(icomp),hnull
        call ERRMSG (ierr,herr)
 1098   format ('[DPSATK error 121] ',
     &          'temperature greater than critical temperature; T =',
     &          g12.5,' K, Tc =',g12.5,' K.',a1)
        RETURN
      endif
c
c  i is the value following 'PS' in the .fld file
      i=0
      i=ICHAR(hpsk(icomp)(3:3))-48
      if (i.lt.0) i=0
      if (i.gt.9) i=0
      if (hpsk(icomp)(1:2).eq.'PS' .and. i.gt.0) then
        tr=ABS(1.d0-t/pstrd(icomp))
        if (MOD(i,2).eq.0) tr=SQRT(tr)  !Even values of i
        pr=0.0d0
        dpr=0.0d0
        if (nps1(icomp).ne.0) then
          do k=1,nps1(icomp)
            pe=psexp(icomp,k)
            pr=pr+pska(icomp,k)*tr**pe
            if (MOD(i,2).eq.1) then           !odd values of i
              dpr=dpr-pe*pska(icomp,k)*tr**(pe-1.d0)/pstrd(icomp)
            else                              !even values of i
              dpr=dpr-pe/2.d0*pska(icomp,k)*tr**(pe-2.d0)/pstrd(icomp)
            endif
          enddo
        endif
        tr=pstrd(icomp)/t
        if (i.eq.1 .or. i.eq.2) pr=dpr
        if (i.eq.3 .or. i.eq.4) pr=EXP(pr)*dpr
        if (i.eq.5 .or. i.eq.6) pr=EXP(tr*pr)*tr*(dpr-pr/t)
        dpdt=psprd(icomp)*pr
c  do not return error message if fluid contains no vapor pressure line
      elseif (hpsk(icomp).eq.'NBS') then
        dpdt=pcrit(icomp)
        ierr=2
        herr='[PSATK error 2] vapor pressure equation not available'
        call ERRMSG (ierr,herr)
      else
        dpdt=0.0d0
        ierr=100
        write (herr,1099) hpsk(icomp),hnull
        call ERRMSG (ierr,herr)
 1099   format ('[DPSATK error 100] ',
     &          'unknown vapor pressure equation:  (',a3,')',a1)
      end if
c     write (*,1200) icomp,t,dpdt
c1200 format (' DPSATK--icomp,t,dp/dt: ',i4,2f11.6)
c
      RETURN
      end                                             !subroutine DPSATK
c
c ======================================================================
c
      subroutine D2PSTK (icomp,t,d2pdt2,ierr,herr)
c
c  compute the second derivative of the vapor pressure with the
c  appropriate equation
c
c  inputs:
c    icomp--component i
c        t--temperature (K)
c   output:
c   d2pdt2--d2p/dt2 [kPa/K^2]
c     ierr--error flag:  0 = successful
c                        1 = error:  T<Ttrp
c                        2 = error:  no equation available
c                        121 = error:  T>Tc
c                        100 = error:  unknown vapor pressure equation
c     herr--error string (character*255 variable if ierr<>0)
c
c  written by E.W. Lemmon, NIST Physical & Chemical Properties Division, Boulder, Colorado
c  05-30-01 EWL, original version
c
      include 'commons.for'
      character*255 herr
c
      ierr=0
      herr=' '
      d2pdt2=0.0d0
      if (t.lt.pstmin(icomp)) then
        d2pdt2=ptpn(icomp)
        ierr=1
        write (herr,1097) t,pstmin(icomp),hnull
        call ERRMSG (ierr,herr)
 1097   format ('[D2PSTK error 1] ',
     &          'temperature less than triple point temperature; T =',
     &          g12.5,' K, Ttp =',g12.5,' K.',a1)
        RETURN
      endif
c
      if (t.gt.tcrit(icomp)) then
        d2pdt2=pcrit(icomp)
        ierr=121
        write (herr,1098) t,tcrit(icomp),hnull
        call ERRMSG (ierr,herr)
 1098   format ('[D2PSTK error 121] ',
     &          'temperature greater than critical temperature; T =',
     &          g12.5,' K, Tc =',g12.5,' K.',a1)
        RETURN
      endif
c
c  i is the value following 'PS' in the .fld file
      i=0
      i=ICHAR(hpsk(icomp)(3:3))-48
      if (i.lt.0) i=0
      if (i.gt.9) i=0
      if (hpsk(icomp)(1:2).eq.'PS' .and. i.gt.0) then
        tr=ABS(1.d0-t/pstrd(icomp))
        if (MOD(i,2).eq.0) tr=SQRT(tr)  !Even values of i
        pr=0.0d0
        dpr=0.0d0
        d2pr=0.0d0
        if (nps1(icomp).ne.0) then
          do k=1,nps1(icomp)
            pe=psexp(icomp,k)
            pr=pr+pska(icomp,k)*tr**pe
            if (MOD(i,2).eq.1) then           !odd values of i
              dpr=dpr-pe*pska(icomp,k)*tr**(pe-1.d0)/pstrd(icomp)
              d2pr=d2pr+pe*(pe-1.d0)*pska(icomp,k)*tr**(pe-2.d0)
     &            /pstrd(icomp)**2
            else                              !even values of i
              dpr=dpr-pe/2.d0*pska(icomp,k)*tr**(pe-2.d0)/pstrd(icomp)
              d2pr=d2pr+pe*(pe-2.d0)/4.d0*pska(icomp,k)*tr**(pe-4.d0)
     &            /pstrd(icomp)**2
            endif
          enddo
        endif
        tr=pstrd(icomp)/t
        if (i.eq.1 .or. i.eq.2) pr=d2pr
        if (i.eq.3 .or. i.eq.4) pr=EXP(pr)*(dpr**2+d2pr)
        if (i.eq.5 .or. i.eq.6) pr=EXP(tr*pr)*
     &     ((tr*(dpr-pr/t))**2+2.d0*tr/t**2*pr-2.d0*tr/t*dpr+tr*d2pr)
        d2pdt2=psprd(icomp)*pr
c  do not return error message if fluid contains no vapor pressure line
      elseif (hpsk(icomp).eq.'NBS') then
        d2pdt2=pcrit(icomp)
        ierr=2
        herr='[D2PSTK error 2] vapor pressure equation not available'
        call ERRMSG (ierr,herr)
      else
        d2pdt2=0.0d0
        ierr=100
        write (herr,1099) hpsk(icomp),hnull
        call ERRMSG (ierr,herr)
 1099   format ('[D2PSTK error 100] ',
     &          'unknown vapor pressure equation:  (',a3,')',a1)
      end if
c     write (*,1200) icomp,t,d2pdt2
c1200 format (' D2PSTK--icomp,t,dp/dt: ',i4,2f11.6)
c
      RETURN
      end                                             !subroutine D2PSTK
c
c ======================================================================
c
      subroutine TSATP (p,x,t,ierr,herr)
c
c  compute the vapor temperature as a function of pressure.
c
c  inputs:
c        p--vapor pressure [kPa]
c        x--composition [array of mol frac]
c   output:
c        t--temperature [K]
c        ierr--error flag:  0 = successful
c                           1 = error:  p<ptrp
c                           2 = error:  no equation available
c                           141 = error:  p>pc
c        herr--error string (character*255 variable if ierr<>0)
c
c  written by E.W. Lemmon, NIST Physical & Chem Properties Div, Boulder, CO
c  03-13-01 EWL, original version
c
      include 'commons.for'
      character*255 herr
      dimension x(ncmax)
c
      call ISPURE (x,icomp)
      if (icomp.ne.0) then
        if (hpsk(icomp).eq.'NBS') then  !Return if no vapor pressure eq.
          t=tcrit(icomp)
          ierr=2
          herr='[TSATP error 2] vapor pressure equation not available'
          call ERRMSG (ierr,herr)
          RETURN
        endif
        if (p.lt.ptpn(icomp)) then
          ierr=1
          t=ttpn(icomp)
          write (herr,1148) p/1000.0d0,ptpn(icomp)/1000.0d0,hnull
          call ERRMSG (ierr,herr)
 1148     format ('[TSATP error 1] ',
     &            'pressure less than triple point pressure; P =',
     &          g12.5,' MPa, Ptp =',g12.5,' MPa.',a1)
          RETURN
        endif
        if (p.gt.pcrit(icomp)) then
          ierr=141
          t=tcrit(icomp)
          write (herr,1149) p/1000.0d0,pcrit(icomp)/1000.0d0,hnull
          call ERRMSG (ierr,herr)
 1149     format ('[TSATP error 141] ',
     &            'pressure greater than critical pressure; P =',
     &          g12.5,' MPa, Pc =',g12.5,' MPa.',a1)
          RETURN
        endif
      endif
c
      call SOLVEA (0,p,x,t,ierr,herr)
c
      RETURN
      end                                              !subroutine TSATP
c
c ======================================================================
c
      subroutine SETPL (nread,icomp,ierr,herr)
c
c  set up working arrays for use with the liquid pressure ancillary equation
c
c  inputs:
c    nread--file to read data from (file should have already been
c           opened and pointer set by subroutine SETUP)
c    icomp--component number in mixture (1..nc); 1 for pure fluid
c
c  outputs:
c     ierr--error flag:  0 = successful
c     herr--error string (character*255 variable if ierr<>0)
c     other quantities returned via arrays in commons
c
c  written by E.W. Lemmon, NIST Thermophysics Division, Boulder, Colorado
c  09-18-01 EWL, original version
c
      include 'commons.for'
      character*255 herr
c
c  read data from file
c     write (*,*) ' SETPL--read component',icomp,' from unit',nread
      read (nread,*) pltmin(icomp)        !lower temperature limit
      read (nread,*) pltmax(icomp)        !upper temperature limit
c  the pressure and density limit are not presently used,
c  but are contained in the file for consistency and possible future use;
c  skip over them in reading the file
      read (nread,*) !pjunk               !upper pressure limit (n/a)
      read (nread,*) !rhojnk              !upper density limit (n/a)
      read (nread,*) pltrd(icomp),plprd(icomp)!reducing parameters
      read (nread,*) npl1(icomp),npl2(icomp),npl3(icomp),
     &               npl4(icomp),npl5(icomp),npl6(icomp)
      if (npl1(icomp).gt.0) then
        do k=1,npl1(icomp)
          read (nread,*) plka(icomp,k),plexp(icomp,k)
        enddo
      endif
      ierr=0
      herr=' '
c
      RETURN
      end                                              !subroutine SETPL
c
c ======================================================================
c
      subroutine PLSATT (t,x,p,ierr,herr)
c
c  compute mixture or pure fluid liquid pressure with appropriate
c  ancillary equation
c  (used only for pseudo-pure fluids)
c
c  inputs:
c        t--temperature (K)
c        x--composition [array of mol frac]
c   output:
c        p--liquid pressure [kPa]
c     ierr--error flag:  0 = successful
c                        1 = error:  T<Ttrp
c                        121 = error:  T>Tc
c                        100 = error:  unknown liquid pressure equation
c     herr--error string (character*255 variable if ierr<>0)
c
c  written by E.W. Lemmon, NIST Physical & Chemical Properties Division, Boulder, Colorado
c  09-18-01 EWL, original version
c
      include 'commons.for'
      character*255 herr
      dimension x(ncmax)
c
      ierr=0
      herr=' '
      p=0.0d0
      call ISPURE (x,icomp)
      if (icomp.ne.0) then
c  special case--pure component
        call PLSATK (icomp,t,p,ierr,herr)
      else
        pp=0.0d0
        do i=1,nc
          call PLSATK (i,t,p,ierr,herr)   !Add Raoult's Law here
          pp=pp+x(i)*p
        enddo
        p=pp
      end if
c     write (*,1200) t,p
c1200 format (' PLSATT--t,p: ',2f11.6)
c
      RETURN
      end                                             !subroutine PLSATT
c
c ======================================================================
c
      subroutine PLSATK (icomp,t,p,ierr,herr)
c
c  compute pure fluid liquid pressure with the appropriate ancillary equation
c  (used only for pseudo-pure fluids)
c
c  inputs:
c    icomp--component i
c        t--temperature (K)
c   output:
c        p--liquid pressure [kPa]
c     ierr--error flag:  0 = successful
c                        1 = error:  T<Ttrp
c                        2 = error:  no equation available
c                        121 = error:  T>Tc
c                        100 = error:  unknown liquid pressure equation
c     herr--error string (character*255 variable if ierr<>0)
c
c  written by E.W. Lemmon, NIST Physical & Chemical Properties Division, Boulder, Colorado
c  03-13-01 EWL, original version
c
      include 'commons.for'
      character*255 herr
c
      ierr=0
      herr=' '
      p=0.0d0
      if (t.lt.pltmin(icomp)) then
        p=ptpn(icomp)
        ierr=1
        write (herr,1097) t,pltmin(icomp),hnull
        call ERRMSG (ierr,herr)
 1097   format ('[PLSATK error 1] ',
     &          'temperature less than triple point temperature; T =',
     &          g12.5,' K, Ttp =',g12.5,' K.',a1)
        RETURN
      endif
c
      if (t.gt.tcrit(icomp)) then
        p=pcrit(icomp)
        ierr=121
        write (herr,1098) t,tcrit(icomp),hnull
        call ERRMSG (ierr,herr)
 1098   format ('[PLSATK error 121] ',
     &          'temperature greater than critical temperature; T =',
     &          g12.5,' K, Tc =',g12.5,' K.',a1)
        RETURN
      endif
c
c  i is the value following 'PL' in the .fld file
      i=0
      i=ICHAR(hplk(icomp)(3:3))-48
      if (i.lt.0) i=0
      if (i.gt.9) i=0
      if (hplk(icomp)(1:2).eq.'PL' .and. i.gt.0) then
        tr=ABS(1.d0-t/pltrd(icomp))
        if (MOD(i,2).eq.0) tr=SQRT(tr)  !Even values of i
        pr=0.0d0
        if (npl1(icomp).ne.0) then
          do k=1,npl1(icomp)
            pr=pr+plka(icomp,k)*tr**plexp(icomp,k)
          enddo
        endif
        if (i.eq.1 .or. i.eq.2) pr=1.d0+pr
        if (i.eq.3 .or. i.eq.4) pr=EXP(pr)
        if (i.eq.5 .or. i.eq.6) pr=EXP(pltrd(icomp)/t*pr)
        p=plprd(icomp)*pr
c  do not return error message if fluid contains no liquid pressure line
      elseif (hplk(icomp).eq.'NBS') then
        p=pcrit(icomp)
        ierr=2
        herr='[PLSATK error 2] vapor pressure equation not available'
        call ERRMSG (ierr,herr)
      else
        p=0.0d0
        ierr=100
        write (herr,1099) hplk(icomp),hnull
        call ERRMSG (ierr,herr)
 1099   format ('[PLSATK error 100] ',
     &          'unknown liquid pressure equation:  (',a3,')',a1)
      end if
c     write (*,1200) icomp,t,p
c1200 format (' PLSATK--icomp,t,p: ',i4,2f11.6)
c
      RETURN
      end                                             !subroutine PLSATK
c
c ======================================================================
c
      subroutine TSATPL (p,x,t,ierr,herr)
c
c  compute the liquid temperature as a function of liquid pressure.
c  (used only for pseudo-pure fluids)
c
c  inputs:
c        p--liquid pressure [kPa]
c        x--composition [array of mol frac]
c   output:
c        t--temperature [K]
c        ierr--error flag:  0 = successful
c                           1 = error:  p<ptrp
c                           2 = error:  no equation available
c                           141 = error:  p>pc
c        herr--error string (character*255 variable if ierr<>0)
c
c  written by E.W. Lemmon, NIST Physical & Chem Properties Div, Boulder, CO
c  09-19-02 EWL, original version
c
      include 'commons.for'
      character*255 herr
      dimension x(ncmax)
c
      call ISPURE (x,icomp)
      if (icomp.ne.0) then
        if (hplk(icomp).eq.'NBS') then    !Return if no liquid pressure eq.
          t=tcrit(icomp)
          ierr=2
          herr='[TSATPL error 2] vapor pressure equation not available'
          call ERRMSG (ierr,herr)
          RETURN
        endif
        if (p.lt.ptpn(icomp)) then
          ierr=1
          t=ttpn(icomp)
          write (herr,1148) p/1000.0d0,ptpn(icomp)/1000.0d0,hnull
          call ERRMSG (ierr,herr)
 1148     format ('[TSATPL error 1] ',
     &            'pressure less than triple point pressure; P =',
     &          g12.5,' MPa, Ptp =',g12.5,' MPa.',a1)
          RETURN
        endif
        if (p.gt.pcrit(icomp)) then
          ierr=141
          t=tcrit(icomp)
          write (herr,1149) p/1000.0d0,pcrit(icomp)/1000.0d0,hnull
          call ERRMSG (ierr,herr)
 1149     format ('[TSATPL error 141] ',
     &            'pressure greater than critical pressure; P =',
     &          g12.5,' MPa, Pc =',g12.5,' MPa.',a1)
          RETURN
        endif
      endif
c
      call SOLVEA (4,p,x,t,ierr,herr)
c
      RETURN
      end                                             !subroutine TSATPL
c
c ======================================================================
c
      subroutine SETDL (nread,icomp,ierr,herr)
c
c  set up working arrays for use with the saturated liquid density
c  ancillary equation
c
c  inputs:
c    nread--file to read data from (file should have already been
c           opened and pointer set by subroutine SETUP)
c    icomp--component number in mixture (1..nc); 1 for pure fluid
c
c  outputs:
c     ierr--error flag:  0 = successful
c     herr--error string (character*255 variable if ierr<>0)
c     other quantities returned via arrays in commons
c
c  written by E.W. Lemmon, NIST Thermophysics Division, Boulder, Colorado
c  09-18-01 EWL, original version
c
      include 'commons.for'
      character*255 herr
c
c  read data from file
c     write (*,*) ' SETDL--read component',icomp,' from unit',nread
      read (nread,*) dltmin(icomp)        !lower temperature limit
      read (nread,*) dltmax(icomp)        !upper temperature limit
c  the pressure and density limit are not presently used,
c  but are contained in the file for consistency and possible future use;
c  skip over them in reading the file
      read (nread,*) !pjunk               !upper pressure limit (n/a)
      read (nread,*) !rhojnk              !upper density limit (n/a)
      read (nread,*) dltrd(icomp),dldrd(icomp)!reducing parameters
      read (nread,*) ndl1(icomp),ndl2(icomp),ndl3(icomp),
     &               ndl4(icomp),ndl5(icomp),ndl6(icomp)
      if (ndl1(icomp).gt.0) then
        do k=1,ndl1(icomp)
          read (nread,*) dlka(icomp,k),dlexp(icomp,k)
        enddo
      endif
      ierr=0
      herr=' '
c
      RETURN
      end                                              !subroutine SETDL
c
c ======================================================================
c
      subroutine DLSATT (t,x,d,ierr,herr)
c
c  compute mixture or pure fluid saturated liquid density with appropriate
c  ancillary equation
c
c  inputs:
c        t--temperature (K)
c        x--composition [array of mol frac]
c   output:
c        d--saturated liquid density [mol/L]
c     ierr--error flag:  0 = successful
c                        1 = error:  T<Ttrp
c                        121 = error:  T>Tc
c                        100 = error:  unknown saturated liquid density equation
c     herr--error string (character*255 variable if ierr<>0)
c
c  written by E.W. Lemmon, NIST Physical & Chemical Properties Division, Boulder, Colorado
c  03-13-01 EWL, original version
c
      include 'commons.for'
      character*255 herr
      dimension x(ncmax)
c
      ierr=0
      herr=' '
      d=0.0d0
      call ISPURE (x,icomp)
      if (icomp.ne.0) then
c  special case--pure component
        call DLSATK (icomp,t,d,ierr,herr)
      else
        dd=0.0d0
        do i=1,nc
          call DLSATK (i,t,d,ierr,herr)   !Add Raoult's Law here
          dd=dd+x(i)*d
        enddo
        d=dd
      end if
c     write (*,1200) t,d
c1200 format (' DLSATT--t,d: ',2f11.6)
c
      RETURN
      end                                             !subroutine DLSATT
c
c ======================================================================
c
      subroutine DLSATK (icomp,t,d,ierr,herr)
c
c  compute pure fluid saturated liquid density with appropriate equation
c
c  inputs:
c    icomp--component i
c        t--temperature (K)
c   output:
c        d--saturated liquid density [mol/L]
c     ierr--error flag:  0 = successful
c                        1 = error:  T<Ttrp
c                        2 = error:  no equation available
c                        121 = error:  T>Tc
c                        100 = error:  unknown saturated liquid density equation
c     herr--error string (character*255 variable if ierr<>0)
c
c  written by E.W. Lemmon, NIST Physical & Chemical Properties Division, Boulder, Colorado
c  03-13-01 EWL, original version
c
      include 'commons.for'
      character*255 herr
c
      ierr=0
      herr=' '
      d=0.0d0
      if (t.lt.dltmin(icomp)) then
        d=dtpn(icomp)
        ierr=1
        write (herr,1097) t,dltmin(icomp),hnull
        call ERRMSG (ierr,herr)
 1097   format ('[DLSATK error 1] ',
     &          'temperature less than triple point temperature; T =',
     &          g12.5,' K, Ttp =',g12.5,' K.',a1)
        RETURN
      endif
c
      if (t.gt.tcrit(icomp)) then
        d=dcrit(icomp)
        ierr=121
        write (herr,1098) t,tcrit(icomp),hnull
        call ERRMSG (ierr,herr)
 1098   format ('[DLSATK error 121] ',
     &          'temperature greater than critical temperature; T =',
     &          g12.5,' K, Tc =',g12.5,' K.',a1)
        RETURN
      endif
c
c  i is the value following 'DL' in the .fld file
      i=0
      i=ICHAR(hdlk(icomp)(3:3))-48
      if (i.lt.0) i=0
      if (i.gt.9) i=0
      if (hdlk(icomp)(1:2).eq.'DL' .and. i.gt.0) then
        tr=ABS(1.d0-t/dltrd(icomp))
        if (MOD(i,2).eq.0) tr=tr**(1.d0/3.d0)  !Even values of i
        dr=0.0d0
        if (ndl1(icomp).ne.0) then
          do k=1,ndl1(icomp)
            dr=dr+dlka(icomp,k)*tr**dlexp(icomp,k)
          enddo
        endif
        if (i.eq.1 .or. i.eq.2) dr=1.d0+dr
        if (i.eq.3 .or. i.eq.4) dr=EXP(dr)
        if (i.eq.5 .or. i.eq.6) dr=EXP(dltrd(icomp)/t*dr)
        d=dldrd(icomp)*dr
c  do not return error message if fluid contains no saturated liquid density equation
      elseif (hdlk(icomp).eq.'NBS') then
        d=dcrit(icomp)
        ierr=2
        herr='[DLSATK error 2] liquid density equation not available'
        call ERRMSG (ierr,herr)
      else
        d=0.0d0
        ierr=100
        write (herr,1099) hdlk(icomp),hnull
        call ERRMSG (ierr,herr)
 1099   format ('[DLSATK error 100] ',
     &        'unknown saturated liquid density equation:  (',a3,')',a1)
      end if
c     write (*,1200) icomp,t,d
c1200 format (' DLSATK--icomp,t,d: ',i4,2f11.6)
c
      RETURN
      end                                             !subroutine DLSATK
c
c ======================================================================
c
      subroutine SETDV (nread,icomp,ierr,herr)
c
c  set up working arrays for use with the saturated vapor density
c  ancillary equation
c
c  inputs:
c    nread--file to read data from (file should have already been
c           opened and pointer set by subroutine SETUP)
c    icomp--component number in mixture (1..nc); 1 for pure fluid
c
c  outputs:
c     ierr--error flag:  0 = successful
c     herr--error string (character*255 variable if ierr<>0)
c     other quantities returned via arrays in commons
c
c  written by E.W. Lemmon, NIST Thermophysics Division, Boulder, Colorado
c  03-13-01 EWL, original version
c
      include 'commons.for'
      character*255 herr
c
c  read data from file
c     write (*,*) ' SETDV--read component',icomp,' from unit',nread
      read (nread,*) dvtmin(icomp)        !lower temperature limit
      read (nread,*) dvtmax(icomp)        !upper temperature limit
c  the pressure and density limit are not presently used,
c  but are contained in the file for consistency and possible future use;
c  skip over them in reading the file
      read (nread,*) !pjunk               !upper pressure limit (n/a)
      read (nread,*) !rhojnk              !upper density limit (n/a)
      read (nread,*) dvtrd(icomp),dvdrd(icomp)!reducing parameters
      read (nread,*) ndv1(icomp),ndv2(icomp),ndv3(icomp),
     &               ndv4(icomp),ndv5(icomp),ndv6(icomp)
      if (ndv1(icomp).gt.0) then
        do k=1,ndv1(icomp)
          read (nread,*) dvka(icomp,k),dvexp(icomp,k)
        enddo
      endif
      ierr=0
      herr=' '
c
      RETURN
      end                                              !subroutine SETDV
c
c ======================================================================
c
      subroutine DVSATT (t,x,d,ierr,herr)
c
c  compute mixture or pure fluid saturated vapor density with appropriate
c  ancillary equation
c
c  inputs:
c        t--temperature (K)
c        x--composition [array of mol frac]
c   output:
c        d--saturated vapor density [mol/L]
c     ierr--error flag:  0 = successful
c                        1 = error:  T<Ttrp
c                        121 = error:  T>Tc
c                        100 = error:  unknown saturated vapor density equation
c     herr--error string (character*255 variable if ierr<>0)
c
c  written by E.W. Lemmon, NIST Physical & Chemical Properties Division, Boulder, Colorado
c  03-13-01 EWL, original version
c
      include 'commons.for'
      character*255 herr
      dimension x(ncmax)
c
      ierr=0
      herr=' '
      d=0.0d0
      call ISPURE (x,icomp)
      if (icomp.ne.0) then
c  special case--pure component
        call DVSATK (icomp,t,d,ierr,herr)
      else
        dd=0.0d0
        do i=1,nc
          call DVSATK (i,t,d,ierr,herr)   !Add Raoult's Law here
          dd=dd+x(i)*d
        enddo
        d=dd
      end if
c     write (*,1200) t,d
c1200 format (' DVSATT--t,d: ',2f11.6)
c
      RETURN
      end                                             !subroutine DVSATT
c
c ======================================================================
c
      subroutine DVSATK (icomp,t,d,ierr,herr)
c
c  compute pure fluid saturated vapor density with appropriate equation
c
c  inputs:
c    icomp--component i
c        t--temperature (K)
c   output:
c        d--saturated vapor density [mol/L]
c     ierr--error flag:  0 = successful
c                        1 = error:  T<Ttrp
c                        2 = error:  no equation available
c                        121 = error:  T>Tc
c                        100 = error:  unknown saturated vapor density equation
c     herr--error string (character*255 variable if ierr<>0)
c
c  written by E.W. Lemmon, NIST Physical & Chemical Properties Division, Boulder, Colorado
c  03-13-01 EWL, original version
c
      include 'commons.for'
      character*255 herr
c
      ierr=0
      herr=' '
      d=0.0d0
      if (t.lt.dvtmin(icomp)) then
        d=dtpn(icomp)
        ierr=1
        write (herr,1097) t,dvtmin(icomp),hnull
        call ERRMSG (ierr,herr)
 1097   format ('[DVSATK error 1] ',
     &          'temperature less than triple point temperature; T =',
     &          g12.5,' K, Ttp =',g12.5,' K.',a1)
        RETURN
      endif
c
      if (t.gt.tcrit(icomp)) then
        d=dcrit(icomp)
        ierr=121
        write (herr,1098) t,tcrit(icomp),hnull
        call ERRMSG (ierr,herr)
 1098   format ('[DVSATK error 121] ',
     &          'temperature greater than critical temperature; T =',
     &          g12.5,' K, Tc =',g12.5,' K.',a1)
        RETURN
      endif
c
c  i is the value following 'DV' in the .fld file
      i=0
      i=ICHAR(hdvk(icomp)(3:3))-48
      if (i.lt.0) i=0
      if (i.gt.9) i=0
      if (hdvk(icomp)(1:2).eq.'DV' .and. i.gt.0) then
        tr=ABS(1.d0-t/dvtrd(icomp))
        if (MOD(i,2).eq.0) tr=tr**(1.d0/3.d0)  !Even values of i
        dr=0.0d0
        if (ndv1(icomp).ne.0) then
          do k=1,ndv1(icomp)
            dr=dr+dvka(icomp,k)*tr**dvexp(icomp,k)
          enddo
        endif
        if (i.eq.1 .or. i.eq.2) dr=1.d0+dr
        if (i.eq.3 .or. i.eq.4) dr=EXP(dr)
        if (i.eq.5 .or. i.eq.6) dr=EXP(dvtrd(icomp)/t*dr)
        d=dvdrd(icomp)*dr
c  do not return error message if fluid contains no saturated vapor density equation
      elseif (hdvk(icomp).eq.'NBS') then
        d=dcrit(icomp)
        ierr=2
        herr='[DLSATK error 2] liquid density equation not available'
        call ERRMSG (ierr,herr)
      else
        d=0.0d0
        ierr=100
        write (herr,1099) hdvk(icomp),hnull
        call ERRMSG (ierr,herr)
 1099   format ('[DVSATK error 100] ',
     &         'unknown saturated vapor density equation:  (',a3,')',a1)
      end if
c     write (*,1200) icomp,t,d
c1200 format (' DVSATK--icomp,t,d: ',i4,2f11.6)
c
      RETURN
      end                                             !subroutine DVSATK
c
c ======================================================================
c
      subroutine TSATD (d,x,t,ierr,herr)
c
c  compute the saturated temperature as a function of saturated density.
c
c  inputs:
c        d--saturated density [mol/L]
c        x--composition [array of mol frac]
c   output:
c        t--temperature [K]
c        ierr--error flag:  0 = successful
c                           1 = no ancillary
c                           2 = error:  p<ptrp
c                           141 = error:  p>pc
c        herr--error string (character*255 variable if ierr<>0)
c
c  written by E.W. Lemmon, NIST Physical & Chem Properties Div, Boulder, CO
c  03-13-01 EWL, original version
c  12-14-11 EWL, add error for equation not available
c
      include 'commons.for'
      character*255 herr
      dimension x(ncmax)
c
      i=1
      call ISPURE (x,icomp)
      if (icomp.ne.0) then
c  Return if no saturated ancillary equation
        t=ttpn(icomp)
        if ((hdlk(icomp).eq.'NBS' .and. d.ge.dcrit(icomp)) .or.
     &      (hdvk(icomp).eq.'NBS' .and. d.le.dcrit(icomp))) then
          ierr=1
          herr='[TSATD error 1] Ancillary equation not available'
          call ERRMSG (ierr,herr)
          RETURN
        endif
c       if (d.lt.dtpv(1)) then    !dtpv has not been set yet!
c         ierr=2
c         write (herr,1148) d,dtpv(1),hnull
c         call ERRMSG (ierr,herr)
c1148     format ('[TSATD error 2] ',
c    &            'density less than triple point density; d =',
c    &          g12.5,' mol/L, dtp =',g12.5,' mol/L.',a1)
c         RETURN
c       endif
        if (d.gt.dtpn(icomp)) then
          ierr=141
          write (herr,1149) d,dtpn(icomp),hnull
          call ERRMSG (ierr,herr)
 1149     format ('[TSATD error 141] ',
     &            'density greater than triple point density; d=',
     &          g12.5,' mol/L, dtp =',g12.5,' mol/L.',a1)
c         RETURN
        endif
        if (d.ge.dcrit(icomp)) i=1
        if (d.lt.dcrit(icomp)) i=2
      endif
c
      call SOLVEA (i,d,x,t,ierr,herr)
c
      RETURN
      end                                              !subroutine TSATD
c
c ======================================================================
c
      subroutine SOLVEA (iflag,pd,x,t,ierr,herr)
c
c  solve for temperature given vapor pressure or saturated liquid
c  or vapor density
c
c  inputs:
c     iflag--use:  vapor pressure equation when iflag=0
c                  saturated liquid density equation when iflag=1
c                  saturated vapor density equation when iflag=2
c                  liquid pressure equation when iflag=4
c       pd--pressure [kPa] or density [mol/L]
c        x--composition [array of mol frac]
c   output:
c        t--temperature (K)
c     ierr--error flag:  0 = successful
c                       124 = no convergence
c     herr--error string (character*255 variable if ierr<>0)
c
c  written by E.W. Lemmon, NIST Physical & Chemical Properties Division, Boulder, Colorado
c  03-13-01 EWL, original version
c  07-20-10 EWL, change how t is modified if p1<1.d-15
c  04-04-13 EWL, change initial t to 0.75*tc so that t>ttrp of CO2
c
      include 'commons.for'
      character*255 herr
      dimension x(ncmax)
c
      tol=0.5d-8
      dx=0.001d0
      dt=-10.d0
      call CRITP (x,tc,pc,rhoc,ierr,herr)
c     ttrp=ttpn(icomp)
      t=0.75*tc
c  calculate vapor pressure (or saturated density) and its derivative,
c  then update temperature iteratively
      do i=1,50
        dy=0
        if (t+dx.ge.tc) dy=dx !Prevent numerical deriv. going above Tc
        if (iflag.eq.0) then
          call PSATT (t-dy   ,x,pp,ierr,herr)
          call PSATT (t-dy+dx,x,p1,ierr,herr)
        elseif (iflag.eq.1) then
          call DLSATT (t-dy   ,x,pp,ierr,herr)
          call DLSATT (t-dy+dx,x,p1,ierr,herr)
        elseif (iflag.eq.2) then
          call DVSATT (t-dy   ,x,pp,ierr,herr)
          call DVSATT (t-dy+dx,x,p1,ierr,herr)
        elseif (iflag.eq.4) then
          call PLSATT (t-dy   ,x,pp,ierr,herr)
          call PLSATT (t-dy+dx,x,p1,ierr,herr)
        endif
        if (ierr.ne.0) return
        told=t
        if (ABS(p1).lt.1.d-15) then
          t=t-0.5d0*dt
        else
          if (iflag.eq.1) then
            dpt=(p1-pp)/dx
            dt=-(pp-pd)/dpt        !1st order Newton's method
          else
            dpt=ABS(log(p1)-log(pp))/dx
            dt=-(log(pp)-log(pd))/dpt        !1st order Newton's method
          endif
          t=t+dt
        endif
        if (ABS(dt).lt.tol) RETURN
c       if (t.lt.ttrp) t=(told+ttrp)/2.d0
        if (t.ge.tc) t=(told+tc)/2.d0
      enddo
      ierr=124
      t=-9.99999d6
      write (herr,1100)
      call ERRMSG (ierr,herr)
 1100 format('[SOLVEA error 124] maximum number of iterations exceeded')
      RETURN
      end                                             !subroutine SOLVEA
c
c        1         2         3         4         5         6         7
c23456789012345678901234567890123456789012345678901234567890123456789012
c
c ======================================================================
c                                                    end file core_ANC.f
c ======================================================================
c  begin file core_BWR.f
c
c  This file contains the functions implementing the MBWR equation of
c  state for pure fluids.
c
c  contained here are:
c     function PBWR (icomp,t,rho)
c     function ABWR (icomp,t,rho)
c     function DABWR (icomp,t,rho)
c     function D2ABWR (icomp,t,rho)
c     function DPDBWR (icomp,t,rho)
c     function D2PBWR (icomp,t,rho)
c     function DPTBWR (icomp,t,rho)
c     function PHIBWR (icomp,itau,idel,tau,del)
c     subroutine CRTBWR (icomp,tc,pc,Dc)
c     subroutine SETBWR (nread,icomp,hcasno,ierr,herr)
c     block data BDBWR
c
c  these routines set and/or use values in the following common blocks
c
c  commons associated with the MBWR equations stored in block data
c     common /CASBWR/ hcasb(mxbwr)
c     common /CPMBWR/ icpbwr(mxbwr)
c     common /CFBWR/ ba(mxbwr,32),
c    &               pca(mxbwr),rhoca(mxbwr),tca(mxbwr),
c    &               Rbwra(mxbwr),ptra(mxbwr),rhotra(mxbwr),ttra(mxbwr),
c    &               gammaa(mxbwr),tmaxa(mxbwr),pmaxa(mxbwr)
c     common /MSCBWR/ wmb(mxbwr),ttpb(mxbwr),tnbpb(mxbwr),accenb(mxbwr),
c    &                dipm(mxbwr)
c  commons associated with the nc components of current interest
c  ("working" commons and arrays)
c     common /WCFBWR/ bbwr(n0:nx,32),
c    &              pcbwr(n0:nx),rhocb(n0:nx),tcbwr(n0:nx),Rbwr(n0:nx),
c    &              ptrb(n0:nx),rhotrb(n0:nx),ttrb(n0:nx),gammab(n0:nx),
c    &              tmaxb(n0:nx),pmaxb(n0:nx)
c     common /CCON/ tcrit(n0:nx),pcrit(n0:nx),Dcrit(n0:nx),Zcrit(n0:nx),
c    &              ttpn(n0:nx),ptpn(n0:nx),dtpn(n0:nx),dtpv(n0:nx),
c    &              tnbp(n0:nx),dnbpl(n0:nx),dnbpv(n0:nx),
c    &              wmas(n0:nx),accen(n0:nx),dipole(n0:nx),Reos(n0:nx)
c
c  these routines use the following common blocks from other files
c     common /Gcnst/ R,tz(n0:nx),rhoz(n0:nx)
c     common /EOSMOD/ hpheq,heos,hmxeos(n0:nx),hmodcp(n0:nx)
c
c  various arrays are dimensioned with parameter statements
c
c ======================================================================
c ======================================================================
c
      function PBWR (icomp,t,rho)
c
c  compute pressure as a function of temperature and density
c  for MBWR equation of state, this is the most basic form of MBWR
c
c  based on Younglove & McLinden (1994), JPCRD 23:731-779
c  equations B1 and B2
c
c  inputs:
c    icomp--pointer specifying component (1..nc)
c        t--temperature (K)
c      rho--molar density (mol/L)
c  output: (as function value):
c        p--pressure (kPa)
c
c  written by M. McLinden, NIST Thermophysics Division, Boulder, Colorado
c  10-06-94  MM, original version
c  07-20-95  MM, separate polynomial Cp0 routines from core_BWR
c                and restructure coefficient arrays
c  11-29-95  MM, variable lower limit on coefficient/constant arrays
c                to accommodate ECS reference fluid
c  02-27-96  MM, parameter n0=-ncmax to accommodate ECS-thermo model
c
      include 'commons.for'
      dimension an(15)
c
      j=icomp              !pointer to appropriate fluid
      PBWR=0.d0
      if (t.le.0.d0) RETURN
c
c  calculate a(n) terms in MBWR (Eq B2)
c
      tinv=1.0d0/t
      tinv2=tinv*tinv
      tinv3=tinv2*tinv
      tinv4=tinv3*tinv
c
      an(1)=Rbwr(j)*t
      an(2)= bbwr(j,1)*t+bbwr(j,2)*SQRT(t)+bbwr(j,3)+bbwr(j,4)*tinv
     &      +bbwr(j,5)*tinv2
      an(3)= bbwr(j,6)*t+bbwr(j,7)+bbwr(j,8)*tinv+bbwr(j,9)*tinv2
      an(4)=bbwr(j,10)*t+bbwr(j,11)+bbwr(j,12)*tinv
      an(5)=bbwr(j,13)
      an(6)=bbwr(j,14)*tinv+bbwr(j,15)*tinv2
      an(7)=bbwr(j,16)*tinv
      an(8)=bbwr(j,17)*tinv+bbwr(j,18)*tinv2
      an(9)=bbwr(j,19)*tinv2
      an(10)=bbwr(j,20)*tinv2+bbwr(j,21)*tinv3
      an(11)=bbwr(j,22)*tinv2+bbwr(j,23)*tinv4
      an(12)=bbwr(j,24)*tinv2+bbwr(j,25)*tinv3
      an(13)=bbwr(j,26)*tinv2+bbwr(j,27)*tinv4
      an(14)=bbwr(j,28)*tinv2+bbwr(j,29)*tinv3
      an(15)=bbwr(j,30)*tinv2+bbwr(j,31)*tinv3+bbwr(j,32)*tinv4
c
c  summation of terms 1-9 in Eq B1
      psum=0.0d0
      rhon=1.0d0
      do n=1,9
        rhon=rhon*rho
        psum=psum+an(n)*rhon
      enddo
c  summation of terms 10-15 (exponential terms) in Eq B1
      expsum=0.0d0
      rhon=rho
      rho2=rho*rho
      do n=10,15
        rhon=rhon*rho2
        expsum=expsum+an(n)*rhon
      enddo
c
c  sum terms and convert from bar to kPa
      PBWR=(psum+exp(-(rho/gammab(j))**2)*expsum)*100.0d0
c     PBWR=(psum+exp(-(rho/gammab(j))**2)*expsum)*(R/Rbwr(j))
c
      RETURN
      end                                                 !function PBWR
c
c ======================================================================
c
      function ABWR (icomp,t,rho)
c
c  compute residual Helmholtz free energy for MBWR equation of state
c
c  based on Younglove & McLinden (1994), JPCRD 23:731-779
c  equations A4 and B6
c
c  inputs:
c    icomp--pointer specifying component (1..nc)
c        t--temperature (K)
c      rho--molar density (mol/L)
c  output (as function value):
c       Ar--(A-A0) (J/mol)
c
c  written by M. McLinden, NIST Thermophysics Division, Boulder, Colorado
c  10-06-94  MM, original version
c  07-20-95  MM, separate polynomial Cp0 routines from core_BWR
c                and restructure coefficient arrays
c  11-29-95  MM, variable lower limit on coefficient/constant arrays
c                to accommodate ECS reference fluid
c  02-27-96  MM, parameter n0=-ncmax to accommodate ECS-thermo model
c
      include 'commons.for'
      dimension an(15)
c
      j=icomp              !pointer to appropriate fluid
      ABWR=0.d0
      if (t.le.0.d0) RETURN
c
c  calculate a(n) terms in MBWR (Eq B2)
c
      tinv=1.0d0/t
      tinv2=tinv*tinv
      tinv3=tinv2*tinv
      tinv4=tinv3*tinv
c
      an(1)=Rbwr(j)*t
      an(2)= bbwr(j,1)*t+bbwr(j,2)*SQRT(t)+bbwr(j,3)+bbwr(j,4)*tinv
     &      +bbwr(j,5)*tinv2
      an(3)= bbwr(j,6)*t+bbwr(j,7)+bbwr(j,8)*tinv+bbwr(j,9)*tinv2
      an(4)=bbwr(j,10)*t+bbwr(j,11)+bbwr(j,12)*tinv
      an(5)=bbwr(j,13)
      an(6)=bbwr(j,14)*tinv+bbwr(j,15)*tinv2
      an(7)=bbwr(j,16)*tinv
      an(8)=bbwr(j,17)*tinv+bbwr(j,18)*tinv2
      an(9)=bbwr(j,19)*tinv2
      an(10)=bbwr(j,20)*tinv2+bbwr(j,21)*tinv3
      an(11)=bbwr(j,22)*tinv2+bbwr(j,23)*tinv4
      an(12)=bbwr(j,24)*tinv2+bbwr(j,25)*tinv3
      an(13)=bbwr(j,26)*tinv2+bbwr(j,27)*tinv4
      an(14)=bbwr(j,28)*tinv2+bbwr(j,29)*tinv3
      an(15)=bbwr(j,30)*tinv2+bbwr(j,31)*tinv3+bbwr(j,32)*tinv4
c
c  summation of terms 2-9 in Eq B6
      ar=0.0d0
      rhon=1.0d0
      do n=2,9
        rhon=rhon*rho
        ar=ar+an(n)*rhon/real(n-1)
      enddo
c  summation of term 10 (first exponential term)
      delsq=(rho/gammab(j))**2
      rhoc2=gammab(j)**2
      rhocn=rhoc2
      expdel=exp(-delsq)
      ar=ar-0.5d0*an(10)*rhocn*(expdel-1.0d0)
c  summation of terms 11-15 (remaining exponential terms) in Eq B7
      expmul=1.0d0
      expsub=1.0d0
      delnew=1.0d0
      do n=11,15
        rhocn=rhocn*rhoc2
        delnew=delnew*delsq
        expmul=delnew+expmul*real(n-10)
        expsub=expsub*real(n-10)
        ar=ar-0.5d0*an(n)*rhocn*(expdel*expmul-expsub)
      enddo
c
c  convert from L-bar/mol to J/mol
      ABWR=ar*(100.0d0)
c     ABWR=ar*(R/Rbwr(j))
c
      RETURN
      end                                                 !function ABWR
c
c ======================================================================
c
      function DABWR (icomp,t,rho)
c
c  compute temperature derivative of residual Helmholtz free energy
c  for MBWR equation of state
c
c  based on derivations in Younglove & McLinden (1994), JPCRD 23:731-779
c  equations B4 and B7
c
c  inputs:
c    icomp--pointer specifying fluid to calculate, refers to code numbers
c        t--temperature (K)
c      rho--molar density (mol/L)
c  output (as function value):
c    dardt--dAr/dT (J/(mol-K))
c
c  written by M. McLinden, NIST Thermophysics Division, Boulder, Colorado
c  10-05-94  MM, original version
c  07-20-95  MM, separate polynomial Cp0 routines from core_BWR
c                and restructure coefficient arrays
c  11-29-95  MM, variable lower limit on coefficient/constant arrays
c                to accommodate ECS reference fluid
c  02-27-96  MM, parameter n0=-ncmax to accommodate ECS-thermo model
c
      include 'commons.for'
      dimension dandt(15)
c
      j=icomp              !pointer to appropriate fluid
      DABWR=0.d0
      if (t.le.0.d0) RETURN
c
c  calculate temperature derivatives of a(n) terms in MBWR (Eq B4)
c
      tinv=1.0d0/t
      tinv2=tinv*tinv
      tinv3=tinv2*tinv
      tinv4=tinv3*tinv
      tinv5=tinv4*tinv
c
      dandt(1)=Rbwr(j)
      dandt(2)=bbwr(j,1)+0.5d0*bbwr(j,2)/SQRT(t)-bbwr(j,4)*tinv2
     &         -2.0d0*bbwr(j,5)*tinv3
      dandt(3)=bbwr(j,6)-bbwr(j,8)*tinv2-2.0d0*bbwr(j,9)*tinv3
      dandt(4)=bbwr(j,10)-bbwr(j,12)*tinv2
      dandt(5)=0.0d0
      dandt(6)=-bbwr(j,14)*tinv2-2.0d0*bbwr(j,15)*tinv3
      dandt(7)=-bbwr(j,16)*tinv2
      dandt(8)=-bbwr(j,17)*tinv2-2.0d0*bbwr(j,18)*tinv3
      dandt(9)=-2.0d0*bbwr(j,19)*tinv3
      dandt(10)=-2.0d0*bbwr(j,20)*tinv3-3.0d0*bbwr(j,21)*tinv4
      dandt(11)=-2.0d0*bbwr(j,22)*tinv3-4.0d0*bbwr(j,23)*tinv5
      dandt(12)=-2.0d0*bbwr(j,24)*tinv3-3.0d0*bbwr(j,25)*tinv4
      dandt(13)=-2.0d0*bbwr(j,26)*tinv3-4.0d0*bbwr(j,27)*tinv5
      dandt(14)=-2.0d0*bbwr(j,28)*tinv3-3.0d0*bbwr(j,29)*tinv4
      dandt(15)=-2.0d0*bbwr(j,30)*tinv3-3.0d0*bbwr(j,31)*tinv4
     &          -4.0d0*bbwr(j,32)*tinv5
c
c  summation of terms 2-9 in Eq B7
      dardt=0.0d0
      rhon=1.0d0
      do n=2,9
        rhon=rhon*rho
        dardt=dardt+dandt(n)*rhon/real(n-1)
      enddo
c  summation of term 10 (first exponential term)
      delsq=(rho/gammab(j))**2
      rhoc2=gammab(j)**2
      rhocn=rhoc2
      expdel=exp(-delsq)
      dardt=dardt-0.5d0*dandt(10)*rhocn*(expdel-1.0d0)
c  summation of terms 11-15 (remaining exponential terms) in Eq B7
      expmul=1.0d0
      expsub=1.0d0
      delnew=1.0d0
      do n=11,15
        rhocn=rhocn*rhoc2
        delnew=delnew*delsq
        expmul=delnew+expmul*real(n-10)
        expsub=expsub*real(n-10)
        dardt=dardt-0.5d0*dandt(n)*rhocn*(expdel*expmul-expsub)
      enddo
c
c  convert from L-bar/(mol-K) to J/(mol-K)
      DABWR=dardt*100.0d0
c     DABWR=dardt*(R/Rbwr(j))
c
      RETURN
      end                                                !function DABWR
c
c ======================================================================
c
      function D2ABWR (icomp,t,rho)
c
c  compute second temperature derivative of residual Helmholtz free
c  energy for MBWR equation of state
c
c  based on derivations in Younglove & McLinden (1994), JPCRD 23:731-779
c  equations B8 and B9
c
c  inputs:
c    icomp--pointer specifying component (1..nc)
c        t--temperature (K)
c      rho--molar density (mol/L)
c  output (as function value):
c   d2ardt--d2Ar/dT2 (J/(mol-K**2))
c
c  written by M. McLinden, NIST Thermophysics Division, Boulder, Colorado
c  10-06-94  MM, original version
c  07-20-95  MM, separate polynomial Cp0 routines from core_BWR
c                and restructure coefficient arrays
c  11-29-95  MM, variable lower limit on coefficient/constant arrays
c                to accommodate ECS reference fluid
c  02-27-96  MM, parameter n0=-ncmax to accommodate ECS-thermo model
c
      include 'commons.for'
      dimension d2andt(15)
c
      j=icomp              !pointer to appropriate fluid
c
c  calculate temperature derivatives of a(n) terms in MBWR (Eq B4)
c
      tinv=1.0d0/t
      tinv2=tinv*tinv
      tinv3=tinv2*tinv
      tinv4=tinv3*tinv
      tinv5=tinv4*tinv
      tinv6=tinv5*tinv
c
      d2andt(1)=0.0d0
      d2andt(2)=-0.25d0*bbwr(j,2)/(t**1.5)+2.0d0*bbwr(j,4)*tinv3
     &          +6.0d0*bbwr(j,5)*tinv4
      d2andt(3)=2.0d0*bbwr(j,8)*tinv3+6.0d0*bbwr(j,9)*tinv4
      d2andt(4)=2.0d0*bbwr(j,12)*tinv3
      d2andt(5)=0.0d0
      d2andt(6)=2.0d0*bbwr(j,14)*tinv3+6.0d0*bbwr(j,15)*tinv4
      d2andt(7)=2.0d0*bbwr(j,16)*tinv3
      d2andt(8)=2.0d0*bbwr(j,17)*tinv3+6.0d0*bbwr(j,18)*tinv4
      d2andt(9)=6.0d0*bbwr(j,19)*tinv4
      d2andt(10)=6.0d0*bbwr(j,20)*tinv4+12.0d0*bbwr(j,21)*tinv5
      d2andt(11)=6.0d0*bbwr(j,22)*tinv4+20.0d0*bbwr(j,23)*tinv6
      d2andt(12)=6.0d0*bbwr(j,24)*tinv4+12.0d0*bbwr(j,25)*tinv5
      d2andt(13)=6.0d0*bbwr(j,26)*tinv4+20.0d0*bbwr(j,27)*tinv6
      d2andt(14)=6.0d0*bbwr(j,28)*tinv4+12.0d0*bbwr(j,29)*tinv5
      d2andt(15)=6.0d0*bbwr(j,30)*tinv4+12.0d0*bbwr(j,31)*tinv5
     &           +20.0d0*bbwr(j,32)*tinv6
c
c  summation of terms 2-9 in Eq B8
      d2ardt=0.0d0
      rhon=1.0d0
      do n=2,9
        rhon=rhon*rho
        d2ardt=d2ardt+d2andt(n)*rhon/real(n-1)
      enddo
c  summation of term 10 (first exponential term)
      delsq=(rho/gammab(j))**2
      rhoc2=gammab(j)**2
      rhocn=rhoc2
      expdel=exp(-delsq)
      d2ardt=d2ardt-0.5d0*d2andt(10)*rhocn*(expdel-1.0d0)
c  summation of terms 11-15 (remaining exponential terms) in Eq B7
      expmul=1.0d0
      expsub=1.0d0
      delnew=1.0d0
      do n=11,15
        rhocn=rhocn*rhoc2
        delnew=delnew*delsq
        expmul=delnew+expmul*real(n-10)
        expsub=expsub*real(n-10)
        d2ardt=d2ardt-0.5d0*d2andt(n)*rhocn*(expdel*expmul-expsub)
      enddo
c
c  convert from L-bar/(mol-K**2) to J/(mol-K**2)
      D2ABWR=d2ardt*(100.0d0)
c     D2ABWR=d2ardt*(R/Rbwr(j))
c
      RETURN
      end                                               !function D2ABWR
c
c ======================================================================
c
      function DPDBWR (icomp,t,rho)
c
c  compute partial derivative of pressure with respect to density
c  for MBWR equation of state
c
c  based on derivations in Younglove & McLinden (1994), JPCRD 23:731-779
c  equation B5
c
c  inputs:
c    icomp--pointer specifying component (1..nc)
c        t--temperature (K)
c      rho--molar density (mol/L)
c  output (as function value):
c   DPDBWR--dPdD (kPa-L/mol)
c
c  written by M. McLinden, NIST Thermophysics Division, Boulder, Colorado
c  10-07-94  MM, original version
c  07-20-95  MM, separate polynomial Cp0 routines from core_BWR
c                and restructure coefficient arrays
c  11-29-95  MM, variable lower limit on coefficient/constant arrays
c                to accommodate ECS reference fluid
c  02-27-96  MM, parameter n0=-ncmax to accommodate ECS-thermo model
c  06-06-97 EWL, check if rho < 1.0d-10, avoid divide by zero
c
      include 'commons.for'
      dimension an(15)
c
      DPDBWR=R*t           !ideal-gas
      if (rho.lt.1.0d-10 .or. t.le.0.d0) then
        RETURN             !use ideal-gas solution
      end if
      j=icomp              !pointer to appropriate fluid
c
c  calculate a(n) terms in MBWR (Eq B2)
c
      tinv=1.0d0/t
      tinv2=tinv*tinv
      tinv3=tinv2*tinv
      tinv4=tinv3*tinv
c
      an(1)=Rbwr(j)*t
      an(2)= bbwr(j,1)*t+bbwr(j,2)*SQRT(t)+bbwr(j,3)+bbwr(j,4)*tinv
     &      +bbwr(j,5)*tinv2
      an(3)= bbwr(j,6)*t+bbwr(j,7)+bbwr(j,8)*tinv+bbwr(j,9)*tinv2
      an(4)=bbwr(j,10)*t+bbwr(j,11)+bbwr(j,12)*tinv
      an(5)=bbwr(j,13)
      an(6)=bbwr(j,14)*tinv+bbwr(j,15)*tinv2
      an(7)=bbwr(j,16)*tinv
      an(8)=bbwr(j,17)*tinv+bbwr(j,18)*tinv2
      an(9)=bbwr(j,19)*tinv2
      an(10)=bbwr(j,20)*tinv2+bbwr(j,21)*tinv3
      an(11)=bbwr(j,22)*tinv2+bbwr(j,23)*tinv4
      an(12)=bbwr(j,24)*tinv2+bbwr(j,25)*tinv3
      an(13)=bbwr(j,26)*tinv2+bbwr(j,27)*tinv4
      an(14)=bbwr(j,28)*tinv2+bbwr(j,29)*tinv3
      an(15)=bbwr(j,30)*tinv2+bbwr(j,31)*tinv3+bbwr(j,32)*tinv4
c
c  summation of terms 1-9 in Eq B1
      psum=0.0d0
      rhon=1.0d0/rho
      do n=1,9
        rhon=rhon*rho
        psum=psum+real(n)*an(n)*rhon
      enddo
c  summation of terms 10-15 (exponential terms) in Eq B1
      expsum=0.0d0
      rhon=1.0d0
      rho2=rho*rho
      delsq=(rho/gammab(j))**2
      do n=10,15
        rhon=rhon*rho2
        expsum=expsum+an(n)*rhon*(2.0d0*real(n)-17.0d0-2.0d0*delsq)
      enddo
c
c  collect terms and convert from L-bar/mol to kPa-L/mol
      DPDBWR=(psum+exp(-delsq)*expsum)*(100.0d0)
c     DPDBWR=(psum+exp(-delsq)*expsum)*(R/Rbwr(j))
c
      RETURN
      end                                               !function DPDBWR
c
c ======================================================================
c
      function D2PBWR (icomp,t,rho)
c
c  compute the second partial derivative of pressure with respect to density
c  for the MBWR equation of state
c
c  based on derivations in Younglove & McLinden (1994), JPCRD 23:731-779
c  equation B5
c
c  inputs:
c    icomp--pointer specifying component (1..nc)
c        t--temperature (K)
c      rho--molar density (mol/L)
c  output (as function value):
c   D2PBWR--d^2P/dD^2 (kPa-L^2/mol^2)
c
c  written by E.W. Lemmon, NIST Physical & Chem Properties Div, Boulder, CO
c  06-04-97 EWL, original version
c  04-09-98 EWL, split expression for expsum (Lahey compiler choked on it)
c
      include 'commons.for'
      dimension an(15)
c
      D2PBWR=0.0d0
      if (rho.lt.1d-10 .or. t.le.0.d0) then
        RETURN             !dP2dD2 zero for rho = 0, avoid divide by 0
      end if
      j=icomp              !pointer to appropriate fluid
c
c  calculate a(n) terms in MBWR (Eq B2)
c
      tinv=1.0d0/t
      tinv2=tinv*tinv
      tinv3=tinv2*tinv
      tinv4=tinv3*tinv
c
      an(1)=Rbwr(j)*t
      an(2)=bbwr(j,1)*t+bbwr(j,2)*SQRT(t)+bbwr(j,3)+bbwr(j,4)*tinv
     &     +bbwr(j,5)*tinv2
      an(3)=bbwr(j,6)*t+bbwr(j,7)+bbwr(j,8)*tinv+bbwr(j,9)*tinv2
      an(4)=bbwr(j,10)*t+bbwr(j,11)+bbwr(j,12)*tinv
      an(5)=bbwr(j,13)
      an(6)=bbwr(j,14)*tinv+bbwr(j,15)*tinv2
      an(7)=bbwr(j,16)*tinv
      an(8)=bbwr(j,17)*tinv+bbwr(j,18)*tinv2
      an(9)=bbwr(j,19)*tinv2
      an(10)=bbwr(j,20)*tinv2+bbwr(j,21)*tinv3
      an(11)=bbwr(j,22)*tinv2+bbwr(j,23)*tinv4
      an(12)=bbwr(j,24)*tinv2+bbwr(j,25)*tinv3
      an(13)=bbwr(j,26)*tinv2+bbwr(j,27)*tinv4
      an(14)=bbwr(j,28)*tinv2+bbwr(j,29)*tinv3
      an(15)=bbwr(j,30)*tinv2+bbwr(j,31)*tinv3+bbwr(j,32)*tinv4
c
c  summation of terms 1-9 in Eq B1
      psum=0.0d0
      rhon=1.0d0/rho**2
      do n=1,9
        rhon=rhon*rho
        psum=psum+real(n)*real(n-1)*an(n)*rhon
      enddo
c  summation of terms 10-15 (exponential terms) in Eq B1
      expsum=0.0d0
      rhon=1.0d0/rho
      rho2=rho*rho
      delsq=(rho/gammab(j))**2
      do n=10,15
        rhon=rhon*rho2
        sum=-35.0d0*REAL(n)+2.0d0*REAL(n)**2
        sum=sum+153.0d0+33.0d0*delsq+2.0d0*delsq**2-4.0d0*REAL(n)*delsq
        expsum=expsum+an(n)*rhon*2.0d0*sum
c       expsum=expsum+an(n)*rhon*2.0d0*(-35.0d0*REAL(n)+2.0d0*REAL(n)**2
c    &      +153.0d0+33.0d0*delsq+2.0d0*delsq**2-4.0d0*REAL(n)*delsq)
      enddo
c
c  collect terms and convert from L-bar/mol to kPa-L/mol
      D2PBWR=(psum+exp(-delsq)*expsum)*(100.0d0)
c     D2PBWR=(psum+exp(-delsq)*expsum)*(R/Rbwr(j))
c
      RETURN
      end                                               !function D2PBWR
c
c ======================================================================
c
      function DPTBWR (icomp,t,rho)
c
c  compute partial derivative of pressure with respect to temperature
c  for MBWR equation of state
c
c  based on derivations in Younglove & McLinden (1994), JPCRD 23:731-779
c  equations B3 and B4
c
c  inputs:
c    icomp--pointer specifying component (1..nc)
c        t--temperature (K)
c      rho--molar density (mol/L)
c  output (as function value):
c   DPTBWR--dPdT (kPa/K)
c
c  written by M. McLinden, NIST Thermophysics Division, Boulder, Colorado
c  10-07-94  MM, original version
c  07-20-95  MM, separate polynomial Cp0 routines from core_BWR
c                and restructure coefficient arrays
c  11-29-95  MM, variable lower limit on coefficient/constant arrays
c                to accommodate ECS reference fluid
c  02-27-96  MM, parameter n0=-ncmax to accommodate ECS-thermo model
c
      include 'commons.for'
      dimension dandt(15)
c
      j=icomp              !pointer to appropriate fluid
c
c  calculate temperature derivatives of a(n) terms in MBWR (Eq B4)
c
      tinv=1.0d0/t
      tinv2=tinv*tinv
      tinv3=tinv2*tinv
      tinv4=tinv3*tinv
      tinv5=tinv4*tinv
c
      dandt(1)=Rbwr(j)
      dandt(2)=bbwr(j,1)+0.5d0*bbwr(j,2)/SQRT(t)-bbwr(j,4)*tinv2
     &         -2.0d0*bbwr(j,5)*tinv3
      dandt(3)=bbwr(j,6)-bbwr(j,8)*tinv2-2.0d0*bbwr(j,9)*tinv3
      dandt(4)=bbwr(j,10)-bbwr(j,12)*tinv2
      dandt(5)=0.0d0
      dandt(6)=-bbwr(j,14)*tinv2-2.0d0*bbwr(j,15)*tinv3
      dandt(7)=-bbwr(j,16)*tinv2
      dandt(8)=-bbwr(j,17)*tinv2-2.0d0*bbwr(j,18)*tinv3
      dandt(9)=-2.0d0*bbwr(j,19)*tinv3
      dandt(10)=-2.0d0*bbwr(j,20)*tinv3-3.0d0*bbwr(j,21)*tinv4
      dandt(11)=-2.0d0*bbwr(j,22)*tinv3-4.0d0*bbwr(j,23)*tinv5
      dandt(12)=-2.0d0*bbwr(j,24)*tinv3-3.0d0*bbwr(j,25)*tinv4
      dandt(13)=-2.0d0*bbwr(j,26)*tinv3-4.0d0*bbwr(j,27)*tinv5
      dandt(14)=-2.0d0*bbwr(j,28)*tinv3-3.0d0*bbwr(j,29)*tinv4
      dandt(15)=-2.0d0*bbwr(j,30)*tinv3-3.0d0*bbwr(j,31)*tinv4
     &          -4.0d0*bbwr(j,32)*tinv5
c
c  summation of terms 2-9 in Eq B3
      psum=0.0d0
      rhon=1.0d0
      do n=1,9
        rhon=rhon*rho
        psum=psum+dandt(n)*rhon
      enddo
c  summation of terms 10-15 (exponential terms) in Eq B3
      expsum=0.0d0
      rhon=rho
      rho2=rho*rho
      do n=10,15
        rhon=rhon*rho2
        expsum=expsum+dandt(n)*rhon
      enddo
c
c  collect terms and convert from L-bar/mol to kPa-L/mol
      DPTBWR=(psum+exp(-(rho/gammab(j))**2)*expsum)*(100.0d0)
c     DPTBWR=(psum+exp(-(rho/gammab(j))**2)*expsum)*(R/Rbwr(j))
c
      RETURN
      end                                               !function DPTBWR
c
c ======================================================================
c
      function PHIBWR (icomp,itau,idel,tau,del)
c
c  compute reduced Helmholtz energy or a derivative as functions
c  of dimensionless temperature and density for the MBWR equation of
c  state; uses the dimensioned functions ABWR, PBWR, etc. in this file
c
c  inputs:
c    icomp--pointer specifying component (1..nc)
c     itau--flag specifying order of temperature derivative to calc
c     idel--flag specifying order of density derivative to calculate
c           when itau = 0 and idel = 0, compute A/RT
c           when itau = 0 and idel = 1, compute 1st density derivative
c           when itau = 1 and idel = 1, compute cross derivative
c           etc.
c      tau--dimensionless temperature (To/T)
c      del--dimensionless density (D/Do)
c  output (as function value):
c      phi--residual (real-gas) part of the Helmholtz energy, or one
c           of its derivatives (as specified by itau and idel),
c           in reduced form (A/RT)
c           itau  idel    output (dimensionless for all cases)
c             0    0      A/RT
c             1    0      tau*[d(A/RT)/d(tau)]
c             2    0      tau**2*[d**2(A/RT)/d(tau)**2]
c             0    1      del*[d(A/RT)/d(del)]
c             0    2      del**2*[d**2(A/RT)/d(del)**2]
c             1    1      tau*del*[d**2(A/RT)/d(tau)d(del)]
c                         etc.
c
c  N.B.  The reducing parameters To and Do are often, but not
c        necessarily, equal to the critical temperature and density.
c
c        The Helmholtz energy consists of ideal and residual (real-gas)
c        terms; this routine calculates only the residual part.
c
c        This function computes pure component properties only.
c
c  written by M. McLinden, NIST Thermophysics Division, Boulder, Colorado
c  11-03-95  MM, original version
c  11-29-95  MM, variable lower limit on coefficient/constant arrays
c                to accommodate ECS reference fluid
c  02-27-96  MM, parameter n0=-ncmax to accommodate ECS-thermo model
c  06-04-97 EWL, added third derivative with respect to density
c  09-00-00 EWL, remove del**idel*tau**itau in calculation of phibwr
c
      include 'commons.for'
c
      phibwr=0.0d0
      if (del.le.1.0d-10) then    !trivial solution at zero density
        RETURN                    !for any and all derivatives
      end if
c
      t=tz(icomp)/tau
      rho=rhoz(icomp)*del
c
      if (itau.eq.0 .and. idel.eq.0) then
c  compute reduced Helmholtz energy
        phibwr=ABWR(icomp,t,rho)/(R*t)
      else if (itau.eq.1 .and. idel.eq.1) then
c  compute cross derivative
        phibwr=(PBWR(icomp,t,rho)/t-DPTBWR(icomp,t,rho))/(R*rho)
      else if (itau.eq.1 .and. idel.eq.0) then
c  compute first temperature derivative
        phibwr=(ABWR(icomp,t,rho)/t-DABWR(icomp,t,rho))/R
      else if (itau.eq.2 .and. idel.eq.0) then
c  compute second derivative w.r.t. tau
        phibwr=D2ABWR(icomp,t,rho)*t/R
      else if (idel.eq.1 .and. itau.eq.0) then
c  compute first density derivative
        phibwr=PBWR(icomp,t,rho)/(R*t*rho)-1.0d0
      else if (idel.eq.2 .and. itau.eq.0) then
c  compute second derivative w.r.t. del
        phibwr=(DPDBWR(icomp,t,rho)-2.0d0*PBWR(icomp,t,rho)/rho)/
     &         (R*t)+1.0d0
      else if (idel.eq.3 .and. itau.eq.0) then
c  compute third derivative w.r.t. del
        phibwr=(D2PBWR(icomp,t,rho)*rho-4.0d0*DPDBWR(icomp,t,rho)
     &        +6.0d0*PBWR(icomp,t,rho)/rho)/(R*t)-2.0d0
      else
        phibwr=0
      end if
c
      RETURN
      end                                               !function PHIBWR
c
c ======================================================================
c
      subroutine CRTBWR (icomp,tc,pc,Dc)
c
c  returns critical parameters associated with MBWR EOS
c
c  N.B.  these critical parameters may not necessarily be most
c        accurate values, but they are consistent with MBWR fit
c
c  input:
c    icomp--pointer specifying component (1..nc)
c  outputs:
c    tc--critical temperature (K)
c    pc--critical pressure (kPa)
c    Dc--molar density (mol/L) at critical point
c
c  written by M. McLinden, NIST Thermophysics Division, Boulder, Colorado
c  07-20-95  MM, original version
c  11-29-95  MM, variable lower limit on coefficient/constant arrays
c                to accommodate ECS reference fluid
c  02-27-96  MM, parameter n0=-ncmax to accommodate ECS-thermo model
c
      include 'commons.for'
c
      tc=tcbwr(icomp)
      pc=pcbwr(icomp)*100.0d0    ! convert bar -> kPa
      Dc=rhocb(icomp)
c
      RETURN
      end                                             !subroutine CRTBWR
c
c ======================================================================
c
      subroutine SETBWR (nread,icomp,hcasno,ierr,herr)
c
c  set up working arrays for use with MBWR equation of state
c
c  inputs:
c    nread--file to read data from
c           <= 0 get data from block data
c           >0 read from logical unit nread (file should have already
c              been opened and pointer set by subroutine SETUP)
c    icomp--component number in mixture (1..nc); 1 for pure fluid
c   hcasno--CAS number of component icomp (not req'd if reading from file)
c
c  outputs:
c     ierr--error flag:  0 = successful
c                        1 = error (e.g. fluid not found)
c     herr--error string (character*255 variable if ierr<>0)
c     other quantities returned via arrays in common /WCFBWR/
c
c  written by M. McLinden, NIST Thermophysics Division, Boulder, Colorado
c  07-20-95  MM, original version
c  09-13-95  MM, add ierr, herr to argument list
c  10-03-95  MM, adapt to file input, add nread to argument list
c  11-29-95  MM, variable lower limit on coefficient/constant arrays
c                to accommodate ECS reference fluid
c  02-27-96  MM, parameter n0=-ncmax to accommodate ECS-thermo model
c                add Zcrit to common /CCON/
c  03-19-19  MM, add dipole moment to /CCON/ and /MSCBWR/
c  03-22-96  MM, replace /CPMOD/ with /EOSMOD/
c  06-03-96  MM, add limits to /EOSLIM/, reduce mxbwr from 20 to 2
c  05-27-97  MM, if nc = 1, set R to fluid-specific value
c  02-11-98  MM, store rho at triple point separate from rhomax
c  12-01-98 EWL, add Reos and triple point pressure and density to /CCON/
c  12-22-98 EWL, set Reos to Rbwr
c  02-15-00 EWL, change read statement to aid UNIX machines
c
      include 'commons.for'
      character*3 hcpbwr
      character*12 hcasno,hcasb
      character*255 herr
c  commons associated with the mxbwr fluids with MBWR equations stored
c  in block data BDBWR
      common /CASBWR/ hcasb(mxbwr)
      common /CPMBWR/ hcpbwr(mxbwr)
      common /CFBWR/ ba(mxbwr,32),
     &               pca(mxbwr),rhoca(mxbwr),tca(mxbwr),
     &               Rbwra(mxbwr),ptra(mxbwr),rhotra(mxbwr),ttra(mxbwr),
     &               gammaa(mxbwr),tmaxa(mxbwr),pmaxa(mxbwr)
      common /MSCBWR/ wmb(mxbwr),ttpb(mxbwr),tnbpb(mxbwr),accenb(mxbwr),
     &                dipm(mxbwr)
c
      if (nread.le.0) then
c  get coefficients from block data
c  identify specified fluid with entries in database via match of CAS no
        do i=1,mxbwr
          if (hcasno.eq.hcasb(i)) then
c           write (*,*) ' SETBWR--coeff from block data for CAS#',hcasno
            hmodcp(icomp)=hcpbwr(i)   !pointer to Cp0 model
            do j=1,32
              bbwr(icomp,j)=ba(i,j)        !32 coefficients of MBWR EOS
            enddo
            pcbwr(icomp)=pca(i)          !critical parameters, limits, etc.
            rhocb(icomp)=rhoca(i)
            tcbwr(icomp)=tca(i)
            Rbwr(icomp)=Rbwra(i)
            if (nc.eq.1 .and. icomp.eq.1) then
              R=Rbwr(icomp)*100.0d0   !MBWR uses pressure in bar
            end if
            Reos(icomp)=Rbwr(icomp)*100.0d0
            ptrb(icomp)=ptra(i)       !MBWR uses pressure in bar
            rhotrb(icomp)=rhotra(i)
            Deos(icomp)=rhotra(i)
            ttrb(icomp)=ttra(i)
            gammab(icomp)=gammaa(i)
            tmaxb(icomp)=tmaxa(i)
            pmaxb(icomp)=pmaxa(i)      !MBWR uses bar
c  fill arrays in /CCON/
            wmas(icomp)=wmb(i)
            ttpn(icomp)=ttpb(i)
            tnbp(icomp)=tnbpb(i)
            tcrit(icomp)=tcbwr(icomp)
            pcrit(icomp)=pcbwr(icomp)*100.0d0    !MBWR uses bar
            Dcrit(icomp)=rhocb(icomp)
            Zcrit(icomp)=pcbwr(icomp)/(Rbwr(icomp)*100.0d0  ! MBWR uses bar
     &                  *tcbwr(icomp)*rhocb(icomp))
            accen(icomp)=accenb(i)
            dipole(icomp)=dipm(i)
            ierr=0
            herr=' '
            tz(icomp)=tcrit(icomp)
            rhoz(icomp)=Dcrit(icomp)
            RETURN
          end if
        enddo
        ierr=1
        herr='[SETBWR error] Fluid input to SETBWR not found'//hnull
      else
c  read data from file
c       write (*,*) ' SETBWR--read component',icomp,' from unit',nread
        read (nread,*) ttrb(icomp)   !lower temperature limit
        read (nread,*) tmaxb(icomp)  !upper temperature limit
        read (nread,*) pmaxb(icomp)  !upper pressure limit
        read (nread,*) Deos(icomp)   !upper density limit
        read (nread,2003) hmodcp(icomp)     !pointer to Cp0 model
        read (nread,*) wmas(icomp)   !molecular weight
        read (nread,*) ttpn(icomp)   !triple point temperature
        read (nread,*) ptrb(icomp)   !pressure at triple point
        read (nread,*) rhotrb(icomp) !density at triple point
        read (nread,*) tnbp(icomp)   !normal boiling point temperature
        read (nread,*) accen(icomp)  !acentric factor
        read (nread,*) tcbwr(icomp),pcbwr(icomp),rhocb(icomp) !critical par
        tcrit(icomp)=tcbwr(icomp)
        pcbwr(icomp)=pcbwr(icomp)*0.01d0!MBWR uses pressure in bar
        Dcrit(icomp)=rhocb(icomp)
        tz(icomp)=tcrit(icomp)
        rhoz(icomp)=Dcrit(icomp)
        ptpn(icomp)=ptrb(icomp)
        dtpn(icomp)=rhotrb(icomp)
        dtpv(icomp)=0.0d0
        dnbpl(icomp)=0.0d0
        dnbpv(icomp)=0.0d0
        read (nread,*) tred,Dred     !reducing parameters (same as crit)
        read (nread,*) gammab(icomp) !gamma (usually equal to rhoc)
        read (nread,*) Rbwr(icomp)   !gas constant used in fit
        if (nc.eq.1 .and. icomp.eq.1) then
          R=Rbwr(icomp)*100.0d0      !MBWR uses pressure in bar
c         write (*,*) ' SETBWR--R set to ',R
        end if
        Reos(icomp)=Rbwr(icomp)*100.0d0
        Zcrit(icomp)=pcrit(icomp)/(Rbwr(icomp)*100.0d0  ! MBWR uses bar
     &              *tcbwr(icomp)*rhocb(icomp))
        read (nread,*) nterm,ncoef  !always equal to 32, 1
c  The following format is needed in some cases on Unix machines:
        do j=1,28,3
          read (nread,*) bbwr(icomp,j),bbwr(icomp,j+1),bbwr(icomp,j+2)
        enddo
        read (nread,*) bbwr(icomp,31),bbwr(icomp,32)
c       read (nread,*) (bbwr(icomp,j),j=1,32)  !the 32 coefficients
        if (ABS(tred-tcbwr(icomp)).gt.1.0d-4) then
          ierr=-104
          write (herr,1104) tred,tcbwr(icomp),hnull
          call ERRMSG (ierr,herr)
 1104     format ('[SETUP warning 104] error in specification of BWR ',
     &            'model:  reducing temperature not equal to critical ',
     &            'temperature; T_red = ',f10.3,' K; T_crit = ',f10.3,
     &            ' K.',a1)
        end if
        if (ABS(Dred-rhocb(icomp)).gt.1.0d-6) then
          ierr=-104
          write (herr,1114) Dred,rhocb(icomp),hnull
          call ERRMSG (ierr,herr)
 1114     format ('[SETUP warning 104] error in specification of BWR ',
     &            'model:  reducing density not equal to critical ',
     &            'density; D_red = ',f10.5,' mol/L; D_crit = ',f10.5,
     &            ' mol/L.',a1)
        end if
        if (nterm.ne.32 .or. ncoef.ne.1) then
          ierr=-104
          write (herr,1124) nterm,ncoef,hnull
          call ERRMSG (ierr,herr)
 1124     format ('[SETUP warning 104] error in specification of BWR ',
     &            'model:  Nterm = ',i3,' (must be 32); Ncoef = ',i3,
     &            '(must be 1).',a1)
        end if
c       write (*,*) ' SETBWR--final coefficient: ',bbwr(icomp,32)
        ierr=0
        herr=' '
      end if
c
c  copy limits into /EOSLIM/ arrays
      tmeos(icomp)=ttrb(icomp)
      txeos(icomp)=tmaxb(icomp)
      peos(icomp)=pmaxb(icomp)
c     Deos(icomp)=dmaxecs(icomp)
c
      RETURN
 2003 format (a3)
      end                                             !subroutine SETBWR
cc
cc ======================================================================
cc
c      block data BDBWR
cc
cc  data for MBWR equations of state
cc
c      include 'commons.for'
c      parameter (mxbwr=2)
c      character*3 hcpbwr
c      character*12 hcasb
c      common /CASBWR/ hcasb(mxbwr)
c      common /CFBWR/ ba(mxbwr,32),
c     &               pca(mxbwr),rhoca(mxbwr),tca(mxbwr),
c     &               Rbwra(mxbwr),ptra(mxbwr),rhotra(mxbwr),ttra(mxbwr),
c     &               gammaa(mxbwr),tmaxa(mxbwr),pmaxa(mxbwr)
c      common /MSCBWR/ wmb(mxbwr),ttpb(mxbwr),tnbpb(mxbwr),accenb(mxbwr),
c     &                dipm(mxbwr)
c      common /CPMBWR/ hcpbwr(mxbwr)
cc
cc  explanation of parameter
cc     mxbwr:        maximum number of MBWR fits, used to dimension arrays
cc
cc  explanation of commons and constituent arrays
cc    /CASBWR/    Chem Abstract number; used as unambiguous identifier
cc      hcasb(i):  CAS number for fluid corresponding to equation "i"
cc
cc    /CFBWR/   parameters to MBWR fits for each of mxbwr fluids
cc      ba(i,1..32):  32 coefficients to MBWR equation of state
cc                    units are L, mol, bar, K
cc      pca(i):       critical pressure (bar)
cc      rhoca(i):     critical density (L/mol)
cc      tca(i):       critical temperature (K)
cc      Rbwra(i):     gas constant used in MBWR fit (L-bar/(mol-K))
cc      ptra(i):     pressure at ttrb(i) (bar)
cc      rhotpa(i):    density at ttrb(i), e.g. triple point (L/mol)
cc      ttra(i):     low temperature limit of MBWR--often triple point
cc                    ptrb(i),rhotrb(i) are used for initial guesses, etc.
cc                    and are often approximate values only
cc      gammaa(i):    term in exponential of MBWR--usually same as rhocb(i)
cc      tmaxa(i):     upper temperature limit of MBWR (K)
cc      pmaxa(i):     upper pressure limit of MBWR (bar)
cc
cc    /MSCBWR/  miscellaneous fluid constants
cc      wmb(i):      molecular mass (g/mol)
cc      ttpb(i):     triple point temperature (K)
cc      tnbpb(i):    normal boiling point temperature (K)
cc      accenb(i):   acentric factor for fluid represented by eqn "i"
cc      dipm(i):     dipole moment [debye] (at Tnbp if t-dependent)
cc
cc    /CPMBWR/
cc      hmodcp(i)    pointer to Cp0 model to use with fluid "i"
cc
cc      where "i" is the equation number
cc
cc
cc  written by M. McLinden, NIST Thermophysics Division, Boulder, Colorado
cc  11-20-94  MM, original version
cc  07-21-95  MM, remove Cp0 data and add pointer to Cp0 model
cc  03-19-96  MM, add dipole moment to /MSCBWR/
cc
cc
cc  R134a  1,1,1,2-tetrafluoroethane
c      data hcasb(1) /'811-97-2'/
cc  use polynomial Cp0 model
c      data hcpbwr(1) /'CPP'/
cc  Huber fit 48m (4-11-92)
cc  pub as Huber & McLinden (1992), Int Refrig Conf, Purdue, 453-462
cc
c      data (ba(1,i),i=1,32)/
c     &   0.965209362217d-01,  -0.401824768889d+01,   0.395239532858d+02,
c     &   0.134532868960d+04,  -0.139439741347d+07,  -0.309281355175d-02,
c     &   0.292381512283d+01,  -0.165146613555d+04,   0.150706003118d+07,
c     &   0.534973948313d-04,   0.543933317622d+00,  -0.211326049762d+03,
c     &  -0.268191203847d-01,  -0.541067125950d+00,  -0.851731779398d+03,
c     &   0.205188253646d+00,  -0.733050188093d-02,   0.380655963862d+01,
c     &  -0.105832087589d+00,  -0.679243084424d+06,  -0.126998378601d+09,
c     &  -0.426234431829d+05,   0.101973338234d+10,  -0.186699526782d+03,
c     &  -0.933426323419d+05,  -0.571735208963d+01,  -0.176762738787d+06,
c     &  -0.397282752308d-01,   0.143016844796d+02,   0.803085294260d-04,
c     &  -0.171959073552d+00,   0.226238385661d+01/
cc
c      data pca(1),rhoca(1),tca(1),
c     &     Rbwra(1),ptra(1),rhotra(1),ttra(1),
c     &     gammaa(1),tmaxa(1),pmaxa(1)/
c     &  40.56d0,5.0308d0,374.179d0,
c     &  0.08314471d0,0.003935d0,15.609d0,169.853d0,
c     &  5.0308d0,600.0d0,400.0d0/
cc
c      data wmb(1) /102.031d0/
c      data ttpb(1) /169.853d0/
c      data tnbpb(1) /247.082d0/
c      data accenb(1) /0.32705d0/
c      data dipm(1) /2.058d0/  !dipole moment [Debye]; Meyer, (1991)
cc
cc
cc  R123  2,2-dichloro-1,1,1-trifluoroethane
c      data hcasb(2) /'306-83-2'/
cc  use polynomial Cp0 model
c      data hcpbwr(2) /'CPP'/
cc  fit of Younglove & McLinden (1994), JPCRD 23:731-779
c      data (ba(2,i),i=1,32)/
c     &  -0.657453133659d-02,   0.293479845842d+01,  -0.989140469845d+02,
c     &   0.201029776013d+05,  -0.383566527886d+07,   0.227587641969d-02,
c     &  -0.908726819450d+01,   0.434181417995d+04,   0.354116464954d+07,
c     &  -0.635394849670d-03,   0.320786715274d+01,  -0.131276484299d+04,
c     &  -0.116360713718d+00,  -0.113354409016d+02,  -0.537543457327d+04,
c     &   0.258112416120d+01,  -0.106148632128d+00,   0.500026133667d+02,
c     &  -0.204326706346d+01,  -0.249438345685d+07,  -0.463962781113d+09,
c     &  -0.284903429588d+06,   0.974392239902d+10,  -0.637314379308d+04,
c     &   0.314121189813d+06,  -0.145747968225d+03,  -0.843830261449d+07,
c     &  -0.241138441593d+01,   0.108508031257d+04,  -0.106653193965d-01,
c     &  -0.121343571084d+02,  -0.257510383240d+03/
cc
c      data pca(2),rhoca(2),tca(2),
c     &     Rbwra(2),ptra(2),rhotra(2),ttra(2),
c     &     gammaa(2),tmaxa(2),pmaxa(2)/
c     &  36.618d0, 3.596417d0,456.831d0,
c     &  0.08314510d0,0.00004d0,11.6d0,166.0d0,
c     &  3.596417d0,600.0d0,400.0d0/
cc
c      data wmb(2) /152.931d0/
c      data ttpb(2) /166.0d0/
c      data tnbpb(2) /300.973d0/
c      data accenb(2) /0.28192d0/
c      data dipm(2) /1.356d0/  !dipole moment [Debye]; Meyer, (1991)
cc
c      end                                              !block data BDBWR
c
c
c        1         2         3         4         5         6         7
c23456789012345678901234567890123456789012345678901234567890123456789012
c
c ======================================================================
c                                                    end file core_BWR.f
c ======================================================================
c  begin file core_CPP.f
c
c  This file contains the functions implementing a polynomial fit
c  for the ideal gas heat capacity.
c
c  routines for the polynomial fit of ideal gas heat capacity
c
c  contained here are:
c     subroutine SETCPP (nread,icomp,hcasno,ierr,herr)
c     function CP0CPP (icomp,t)
c     function CPICPP (icomp,t)
c     function CPTCPP (icomp,t)
c     function PH0CPP (icomp,itau,idel,t,rho)
c     block data SAVCPP
c     block data BDCPP
c
c  these routines use the following common blocks from other files
c     common /CREF/ tref(n0:nx),rhoref(n0:nx),href(n0:nx),sref(n0:nx)
c     common /Gcnst/ R,tz(n0:nx),rhoz(n0:nx)
c
c  various arrays are dimensioned with parameter statements
c
c ======================================================================
c ======================================================================
c
      subroutine SETCPP (nread,icomp,hcasno,ierr,herr)
c
c  set up working arrays for polynomial form of ideal heat gas Cp
c  uses cubic polynomial correlation of Cp0 (dimensional form):
c     Cp0 = cpc0(i,0) + cpc0(i,1)*T + cpc0(i,2)*T*T + cpc0(i,3)*T**3
c
c  inputs:
c    nread--file to read data from
c           <= 0 get data from block data
c           >0 read from logical unit nread (file should have already
c              been opened and pointer set by subroutine SETUP)
c    icomp--component number in mixture (1..nc); 1 for pure fluid
c           zero and negative numbers designate ECS reference fluids
c   hcasno--CAS number of component icomp (not req'd if reading from file)
c
c  outputs:
c     ierr--error flag:  0 = successful
c                        1 = error (e.g. fluid not found)
c     herr--error string (character*255 variable if ierr<>0)
c     coefficients, etc. returned via arrays in commons /xxxCPP/
c
c  written by M. McLinden, NIST Thermophysics Division, Boulder, Colorado
c  07-20-95  MM, original version
c  09-13-95  MM, add ierr, herr to argument list
c  10-04-95  MM, adapt to file input, add nread to argument list
c  11-10-95  MM, convert from cubic to general polynomial
c  11-29-95  MM, variable lower limit on coefficient/constant arrays
c                to accommodate ECS reference fluid
c  02-27-96  MM, parameter n0=-ncmax to accommodate ECS-thermo model
c  06-17-96  MM, read in exponential terms (Einstein function)
c  11-13-97  MM, (re)initialize contents of /CPPSAV/ when a new fluid is read in
c  12-05-97  MM, change ncppmx from 15 to 20 (accommodate H2 in NIST14)
c  04-02-98 EWL, read in number of cosh and sinh terms
c  06-29-98 MEV, initialize ncoshc and nsinhc for version previous to 6.1
c  08-13-98  MM, delete obsolete (unused) format statement
c  03-24-10 EWL, set variables in common blocks to 0
c
      include 'commons.for'
      character*12 hcasno,hcasc
      character*255 herr
c  commons associated with the mxcpp fluids with FEQ equations stored
c  in block data BDCPP
      common /NTCPP/ ntrmca(mxcpp),ntrmce(mxcpp)
      common /RDCPP/ treda(mxcpp),Creda(mxcpp)
      common /LMCPP/ tmna(mxcpp),tmxa(mxcpp),pmxa(mxcpp),rhomxa(mxcpp)
      common /CPCPP/ cpca(mxcpp,ncppmx),xka(mxcpp,ncppmx)
      common /CASCPP/ hcasc(mxcpp)
c
c  (re)initialize contents of /CPPSAV/ when a new fluid is read in
      do i=n0,nx
        cp0sav(i)=0.d0
        cpisav(i)=0.d0
        cptsav(i)=0.d0
        tsvcp0(i)=0.d0
      enddo
      do i=1,ncppmx
        cpc0(icomp,i)=0.d0
        xkc0(icomp,i)=0.d0
        cp0h(icomp,i)=0.d0
        x0th(icomp,i)=0.d0
        xh00(icomp,i)=0.d0
      enddo
c
      if (nread.le.0) then
c  get coefficients from block data
c  identify specified fluid with entries in database via match of CAS no
        do k=1,mxcpp
          if (hcasno.eq.hcasc(k)) then
c         write (*,*) ' SETCPP--coeff from block data for CAS # ',hcasno
            tmincp(icomp)=tmna(k)
            tmaxcp(icomp)=tmxa(k)
            pmaxcp(icomp)=pmxa(k)
            dmaxcp(icomp)=rhomxa(k)
            tredcp(icomp)=treda(k)
            Credcp(icomp)=Creda(k)
            ntermc(icomp)=ntrmca(k)
            nterme(icomp)=ntrmce(k)
            ncoshc(icomp)=0
            nsinhc(icomp)=0
            nsp1c(icomp)=0         !spares for future use
            nsp2c(icomp)=0
            nsp3c(icomp)=0
            do j=1,ntrmca(k)
              cpc0(icomp,j)=cpca(k,j)
              xkc0(icomp,j)=xka(k,j)
            enddo
c         write (*,*) ' SETCPP--final coeff: ',cpc0(icomp,ntermc(icomp))
            ierr=0
            herr=' '
            RETURN
          end if
        enddo
        ierr=1
        herr='[SETCPP error] Fluid input not found'//hnull
        RETURN
      else
c  read data from file
c       write (*,*) ' SETCPP--read component',icomp,' from unit',nread
        read (nread,*) tmincp(icomp)              !lower temperature limit
        read (nread,*) tmaxcp(icomp)              !upper temperature limit
        read (nread,*) pmaxcp(icomp)              !upper pressure limit
        read (nread,*) dmaxcp(icomp)            !upper density limit
        read (nread,*) tredcp(icomp),Credcp(icomp)  !reducing parameters
c  read number of polynomial and exponential terms
        if (verfl(icomp).ge.6.099d0) then
c  hyperbolic terms (and spares for future) added for file version 6.100
          read (nread,*) ntermc(icomp),nterme(icomp),
     &                   ncoshc(icomp),nsinhc(icomp),
     &                   nsp1c(icomp),nsp2c(icomp),nsp3c(icomp)  !spares
        else
          read (nread,*) ntermc(icomp),nterme(icomp)
          ncoshc(icomp)=0  !these terms not used in files prior to v6.100
          nsinhc(icomp)=0
          nsp1c(icomp)=0
          nsp2c(icomp)=0
          nsp3c(icomp)=0
        endif
        jterm=0
        if (ntermc(icomp).ge.1) then
          do j=1,ntermc(icomp)        !read polynomial coefficients
            jterm=jterm+1
            read (nread,*) cpc0(icomp,jterm),xkc0(icomp,jterm)
          enddo
        end if
        if (nterme(icomp).ge.1) then
          do j=1,nterme(icomp)        !read exponential coefficients
            jterm=jterm+1
            read (nread,*) cpc0(icomp,jterm),xkc0(icomp,jterm)
          enddo
        end if
        if (ncoshc(icomp).ge.1) then
          do j=1,ncoshc(icomp)     !read cosh coefficients
            jterm=jterm+1
            read (nread,*) cpc0(icomp,jterm),xkc0(icomp,jterm),
     &                     cp0h(icomp,jterm),x0th(icomp,jterm),
     &                                      xh00(icomp,jterm)
          enddo
        end if
        if (nsinhc(icomp).ge.1) then
          do j=1,nsinhc(icomp)     !read sinh coefficients
            jterm=jterm+1
            read (nread,*) cpc0(icomp,jterm),xkc0(icomp,jterm),
     &                     cp0h(icomp,jterm),x0th(icomp,jterm),
     &                                      xh00(icomp,jterm)
          enddo
        end if
c       write (*,*) ' SETCPP--final coeff: ',cpc0(icomp,jterm)
        ierr=0
        herr=' '
      end if
c
      RETURN
      end                                             !subroutine SETCPP
c
c ======================================================================
c
      function CP0CPP (icomp,t)
c
c  compute Cp0
c
c  uses polynomial correlation of Cp0:
c     Cp0/Cred = SUM [cpc0(i,k)*(T/Tred(i))**xkc0(i,k)]
c              + SUM [cpc0(i,k)*u(i,k)**2*exp{u(i,k)}/(1-exp{u(i,k)})**2]
c     where cpc0(i,k), xkc0(i,k) are k-th coefficients for component i
c           u(i,k) = xkc0(i,k)/T
c           Cred is reducing parameter for Cp0 (e.g. gas constant, R)
c           Tred is reducing parameter for t (e.g. critical temperature)
c           (the reducing parameters are specified in the .fld file)
c
c  inputs:
c    icomp--pointer specifying component (1..nc)
c        t--temperature (K)
c  output (as function value):
c   CP0CPP--Cp0 (J/(mol-K))
c
c  written by M. McLinden, NIST Thermophysics Division, Boulder, Colorado
c  10-06-94  MM, original version
c  07-20-95  MM, separate polynomial Cp0 routines from core_BWR
c  11-10-95  MM, convert from cubic to general polynomial
c  11-29-95  MM, variable lower limit on coefficient/constant arrays
c                to accommodate ECS reference fluid
c  02-27-96  MM, parameter n0=-ncmax to accommodate ECS-thermo model
c  06-17-96  MM, add provision for exponential terms
c  06-18-96  MM, actually add the exponential terms
c  04-02-98 EWL, add hyperbolic terms
c  06-29-98 MEV, break up expression for the exponential terms to avoid
c                a possible overflow error.
c  01-24-00 EWL, check for ui>1000 to avoid exp(ui)=overflow
c  05-02-01 EWL, change u1>1000 to ui>200
c
      include 'commons.for'
c
      CP0CPP=0.d0
      if (t.le.0.d0) return
      j=icomp                          !pointer to appropriate fluid
c
      cpsum=0.0d0
      iterm=0
c  polynomial terms
      if (ntermc(j).ge.1) then
        do i=1,ntermc(j)
          iterm=iterm+1
          cpsum=cpsum+cpc0(j,iterm)*(t/tredcp(j))**xkc0(j,iterm)
        enddo
      end if
c  exponential terms
      if (nterme(j).ge.1) then
        do i=1,nterme(j)
          iterm=iterm+1
          ui=xkc0(j,iterm)/t
          if (ui.lt.200.0d0) then
            expui=EXP(ui)
            cp0cp1=expui/(1.0d0-expui)
            cp0cp1=cp0cp1/(1.0d0-expui)
            cpsum=cpsum+cpc0(j,iterm)*ui*ui*cp0cp1
          endif
c       cpsum=cpsum+cpc0(j,iterm)*ui*ui*expui/(1.0d0-expui)**2
        enddo
      end if
c  cosh terms
      if (ncoshc(j).ge.1) then
        do i=1,ncoshc(j)
          iterm=iterm+1
          ttau=cp0h(j,iterm)*(t/tredcp(j))**x0th(j,iterm)
          if (ttau.lt.700.d0) then
            cpsum=cpsum+cpc0(j,iterm)*(t/tredcp(j))**xkc0(j,iterm)*
     &          COSH(ttau)**xh00(j,iterm)
          else
            cpsum=1.d6
          endif
        enddo
      end if
c  sinh terms
      if (nsinhc(j).ge.1) then
        do i=1,nsinhc(j)
          iterm=iterm+1
          ttau=cp0h(j,iterm)*(t/tredcp(j))**x0th(j,iterm)
          if (ttau.lt.700.d0) then
            cpsum=cpsum+cpc0(j,iterm)*(t/tredcp(j))**xkc0(j,iterm)*
     &          SINH(ttau)**xh00(j,iterm)
          else
            cpsum=1.d6
          endif
        enddo
      end if
c
      CP0CPP=cpsum*Credcp(j)
c     write (*,1020) j,t,tredcp(j),Credcp(j),CP0CPP,(cpc0(j,i),i=1,iterm)
c1020 format (1x,' CP0CPP--j,t,tred,Cred,CP0,cpc0(i): ',i3,4f8.2,8d16.6)
c
      RETURN
      end                                               !function CP0CPP
c
c ======================================================================
c
      function CPICPP (icomp,t)
c
c  compute integral of Cp0 over limits of Tref to T
c  for use in enthalpy calculation
c
c  uses polynomial correlation of Cp0:
c     Cp0/Cred = SUM [cpc0(i,k)*(T/Tred(i))**xkc0(i,k)]
c              + SUM [cpc0(i,k)*u(i,k)**2*exp{u(i,k)}/(1-exp{u(i,k)})**2]
c     where cpc0(i,k), xkc0(i,k) are k-th coefficients for component i
c           u(i,k) = xkc0(i,k)/T
c           Cred is reducing parameter for Cp0 (e.g. gas constant, R)
c           Tred is reducing parameter for t (e.g. critical temperature)
c           (the reducing parameters are specified in the .fld file)
c
c  based on derivations in Younglove & McLinden (1994), JPCRD 23:731-779
c  equation C11
c
c  inputs:
c    icomp--pointer specifying component (1..nc);
c        t--temperature (K)
c  output: (as function value):
c   CPICPP--int (Cp0 dT)|T-Tref (J/mol)
c
c  written by M. McLinden, NIST Thermophysics Division, Boulder, Colorado
c  10-06-94  MM, original version
c  07-20-95  MM, separate polynomial Cp0 routines from core_BWR
c  11-10-95  MM, convert from cubic to general polynomial
c  11-29-95  MM, variable lower limit on coefficient/constant arrays
c                to accommodate ECS reference fluid
c  02-27-96  MM, parameter n0=-ncmax to accommodate ECS-thermo model
c  06-17-96  MM, add provision for exponential terms
c  06-18-96  MM, actually add the exponential terms
c  04-02-98 EWL, add hyperbolic terms
c  11-04-02 EWL, include contribution of hyp. terms from the ref. temperature
c
      include 'commons.for'
c
      j=icomp                          !pointer to appropriate fluid
      cpsum=0.0d0
      CPICPP=0.d0
      if (t.le.0) RETURN
      iterm=0
c  polynomial terms
      if (ntermc(j).ge.1) then
        do i=1,ntermc(j)
          iterm=iterm+1
          xki=xkc0(j,iterm)
          xk1=xki+1.0d0
          if (abs(xk1).lt.1.0d-6) then
c  any term with temperature exponent of -1 handled differently
            cpsum=cpsum+cpc0(j,iterm)*tredcp(j)*LOG(t/tref(j))
          else
            cpsum=cpsum+cpc0(j,iterm)*(t**xk1-tref(j)**xk1)
     &           /(xk1*tredcp(j)**xki)
          end if
        enddo
      end if
c  exponential terms
      if (nterme(j).ge.1) then
        do i=1,nterme(j)
          iterm=iterm+1
          ui=xkc0(j,iterm)/t
          if (ui.lt.200.0d0) then
            expui=EXP(ui)
            exptr=EXP(xkc0(j,iterm)/tref(j))
            cpsum=cpsum+cpc0(j,iterm)*(-0.5d0*xkc0(j,iterm))
     &        *((1.0d0+expui)/(1.0d0-expui)-(1.0d0+exptr)/(1.0d0-exptr))
          endif
        enddo
      end if
c  cosh terms, only works for c1/t^2/COSH(c2/t)^2
      if (ncoshc(j).ge.1) then
        do i=1,ncoshc(j)
          iterm=iterm+1
          cpsum=cpsum-cpc0(j,iterm)/cp0h(j,iterm)*TANH(cp0h(j,iterm)/t)
     &         +cpc0(j,iterm)/cp0h(j,iterm)*TANH(cp0h(j,iterm)/tref(j))
        enddo
      end if
c  sinh terms, only works for c1/t^2/SINH(c2/t)^2
      if (nsinhc(j).ge.1) then
        do i=1,nsinhc(j)
          iterm=iterm+1
          cpsum=cpsum+cpc0(j,iterm)/cp0h(j,iterm)/TANH(cp0h(j,iterm)/t)
     &          -cpc0(j,iterm)/cp0h(j,iterm)/TANH(cp0h(j,iterm)/tref(j))
        enddo
      end if
c
      CPICPP=cpsum*Credcp(j)
c     write (*,1020) j,t,tredcp(j),Credcp(j),CPICPP,(cpc0(j,i),i=1,iterm)
c1020 format (1x,' CPICPP--j,t,tred,Cred,CPI,cpc0(i): ',i3,4f8.2,8d16.6)
c
      RETURN
      end                                               !function CPICPP
c
c ======================================================================
c
      function CPTCPP (icomp,t)
c
c  compute integral of Cp0/T over limits of Tref to T
c  for use in entropy calculation
c
c  uses polynomial correlation of Cp0:
c     Cp0/Cred = SUM [cpc0(i,k)*(T/Tred(i))**xkc0(i,k)]
c              + SUM [cpc0(i,k)*u(i,k)**2*exp{u(i,k)}/(1-exp{u(i,k)})**2]
c     where cpc0(i,k), xkc0(i,k) are k-th coefficients for component i
c           u(i,k) = xkc0(i,k)/T
c           Cred is reducing parameter for Cp0 (e.g. gas constant, R)
c           Tred is reducing parameter for t (e.g. critical temperature)
c           (the reducing parameters are specified in the .fld file)
c
c  based on derivations in Younglove & McLinden (1994), JPCRD 23:731-779
c  equation C12
c
c  inputs:
c    icomp--pointer specifying component (1..nc)
c        t--temperature (K)
c  output (as function value):
c   CPTCPP--int (Cp0/T dT)|T-Tref (J/(mol-K))
c
c  written by M. McLinden, NIST Thermophysics Division, Boulder, Colorado
c  10-06-94  MM, original version
c  07-20-95  MM, separate polynomial Cp0 routines from core_BWR
c  11-10-95  MM, convert from cubic to general polynomial
c  11-29-95  MM, variable lower limit on coefficient/constant arrays
c                to accommodate ECS reference fluid
c  02-27-96  MM, parameter n0=-ncmax to accommodate ECS-thermo model
c  06-17-96  MM, add provision for exponential terms
c  06-18-96  MM, actually add the exponential terms
c  04-02-98 EWL, add hyperbolic terms
c  11-04-02 EWL, include contribution of hyp. terms from the ref. temperature
c
      include 'commons.for'
c
      j=icomp                          !pointer to appropriate fluid
      cpsum=0.0d0
      CPTCPP=0.d0
      if (t.le.0.d0) RETURN
c
      iterm=0
c  polynomial terms
      if (ntermc(j).ge.1) then
        do i=1,ntermc(j)
          iterm=iterm+1
          xki=xkc0(j,iterm)
          if (abs(xki).lt.1.0d-6) then
c  any term with temperature exponent of 0 handled differently
            cpsum=cpsum+cpc0(j,iterm)*LOG(t/tref(j))
          else
            cpsum=cpsum+cpc0(j,iterm)*(t**xki-tref(j)**xki)
     &           /(xki*tredcp(j)**xki)
          end if
        enddo
c  exponential terms
      end if
      if (nterme(j).ge.1) then
        do i=1,nterme(j)
          iterm=iterm+1
          ui=xkc0(j,iterm)/t
          if (ui.lt.200.0d0) then
            uiref=xkc0(j,iterm)/tref(j)
            expui=EXP(ui)
            exptr=EXP(uiref)
            cpsum=cpsum+cpc0(j,iterm)*(LOG((1.0d0-exptr)/(1.0d0-expui))
     &           +ui*expui/(expui-1.0d0)-uiref*exptr/(exptr-1.0d0))
          endif
        enddo
      end if
c  cosh terms, only works for c1/t^2/COSH(c2/t)^2
      if (ncoshc(j).ge.1) then
        do i=1,ncoshc(j)
          iterm=iterm+1
          ttau=cp0h(j,iterm)/t
          if (ttau.lt.700.d0) then
           cpsum=cpsum
     &     -cpc0(j,iterm)/cp0h(j,iterm)/t      *TANH(ttau)
     &  +cpc0(j,iterm)/cp0h(j,iterm)/tref(j)*TANH(cp0h(j,iterm)/tref(j))
     &     +cpc0(j,iterm)/cp0h(j,iterm)**2*LOG(COSH(ttau))
     &  -cpc0(j,iterm)/cp0h(j,iterm)**2*LOG(COSH(cp0h(j,iterm)/tref(j)))
          else
            cpsum=1.d6
          endif
        enddo
      end if
c  sinh terms, only works for c1/t^2/SINH(c2/t)^2
      if (nsinhc(j).ge.1) then
        do i=1,nsinhc(j)
          iterm=iterm+1
          ttau=cp0h(j,iterm)/t
          if (ttau.lt.700.d0) then
           cpsum=cpsum
     &     +cpc0(j,iterm)/cp0h(j,iterm)/t      /TANH(ttau)
     &  -cpc0(j,iterm)/cp0h(j,iterm)/tref(j)/TANH(cp0h(j,iterm)/tref(j))
     &     -cpc0(j,iterm)/cp0h(j,iterm)**2*LOG(SINH(ttau))
     &  +cpc0(j,iterm)/cp0h(j,iterm)**2*LOG(SINH(cp0h(j,iterm)/tref(j)))
          else
            cpsum=1.d6
          endif
        enddo
      endif
c
      CPTCPP=cpsum*Credcp(j)
c     write (*,1020) j,t,tredcp(j),Credcp(j),CPTCPP,(cpc0(j,i),i=iterm)
c1020 format (1x,' CPTCPP--j,t,tred,Cred,CPT,cpc0(i): ',i3,4f8.2,8d16.6)
c
      RETURN
      end                                               !function CPTCPP
c
c ======================================================================
c
      function PH0CPP (icomp,itau,idel,t,rho)
c
c  compute the ideal gas part of the reduced Helmholtz energy or a
c  derivative as functions of temperature and density; for
c  use with a Helmholtz-explicit equation of state
c
c  inputs:
c    icomp--pointer specifying component (1..nc)
c     itau--flag specifying order of temperature derivative to calc
c     idel--flag specifying order of density derivative to calculate
c           when itau = 0 and idel = 0, compute A0/RT
c           when itau = 1 and idel = 0, 1st temperature derivative
c           when itau = 2 and idel = 0, 2nd temperature derivative
c           when itau = 0 and idel = 1, 1st density derivative
c           (actually the derivatives are with respect to the dimensionless
c           quantities tau and del)
c        t--temperature (K)
c      rho--density (mol/L)
c  output (as function value):
c   ph0cpp--ideal-gas part of the Helmholtz energy in reduced form (A/RT);
c           the tau derivatives (as specified by itau) are multiplied by
c           the corresponding power of tau; i.e.
c           when itau = 1, the quantity returned is tau*d(ph0cpp)/d(tau)
c                itau = 2, tau**2*d2(ph0cpp)/d(tau)**2 is returned
c                itau = 3, tau**3*d3(ph0cpp)/d(tau)**3 is returned
c           similarly, the del derivatives (as specified by idel) are
c           multiplied by the corresponding power of del (the derivatives
c           usually appear with this factor and this approach neatly
c           avoids a possible divide by zero)
c
c  N.B.  While the real-gas part of the Helmholtz energy is calculated
c        in terms of dimensionless temperature and density, the ideal-
c        gas part is calculated in terms of absolute temperature and
c        density.  (This distinction is necessary for mixtures.)
c
c        The Helmholtz energy consists of ideal-gas and residual
c        (real-gas) terms; this routine calculates only the ideal part.
c
c        This function computes pure component properties only.
c
c  written by M. McLinden, NIST Thermophysics Division, Boulder, Colorado
c  08-04-95  MM, original version
c  08-21-95  MM, put saved variables into common (rather than save stmt)
c  10-03-95  MM, change /MODEL/ + /CPMOD/:  models specified by strings
c  11-06-95  MM, insert HMX model
c  11-29-95  MM, variable lower limit on coefficient/constant arrays
c                to accommodate ECS reference fluid
c  02-27-96  MM, parameter n0=-ncmax to accommodate ECS-thermo model
c  03-13-96  MM, replace calls to REDFEQ, etc with generic REDK
c  03-21-96  MM, delete /MODEL/, not needed because of above change
c  04-18-96  MM, apply tolerance to t-tsvcp0 test
c  04-19-96  MM, fix bug in expression for PHI; change input p -> rho
c  05-10-96  MM, eliminate duplication of href, sref terms with THERM
c  07-05-96  MM, change derivative outputs:  tau*d(phi)/d(tau), etc
c  08-20-97  MM, call ERRMSG if itau out of range; drop idel=idel
c  08-12-98  MM, add third temperature derivative
c                N.B. third derivative not yet implemented for hyperbolic terms
c  08-13-98  MM, add cross derivatives (all zero) and 3rd density deriv
c  08-16-07 NRN, add 3rd derivatives for cosh and sinh (Ryan Nannan, Delft University)
c  03-21-10 EWL, add call to RMIX
c
      include 'commons.for'
      character*255 herr
c
      call INFO (icomp,wmm,ttrp,tnbpt,tc,pc,Dc,Zc,acf,dip,Rgas)
      PH0CPP=0.0d0    !initialize in case of error
      if (t.le.0) RETURN
      if (abs(t-tsvcp0(icomp)).lt.1.0d-8) then
c  use values from previous call (values already in cp0sav, etc.)
c       write (*,*) 'PH0CPP--using stored values for itau,t = ',itau,t
      else
c  otherwise, compute new values and save for possible future use
        cp0sav(icomp)=CP0CPP(icomp,t)
        cpisav(icomp)=CPICPP(icomp,t)
        cptsav(icomp)=CPTCPP(icomp,t)
        tsvcp0(icomp)=t
      end if
c
      Rt=Rgas*t
c
      if (itau*idel.ne.0) then
c  all cross derivates are zero
        PH0CPP=0.0d0
      else if (itau.eq.0 .and. idel.eq.0) then
c  compute reduced Helmholtz
        if (rho.gt.0) PH0CPP=cpisav(icomp)/Rt-cptsav(icomp)/Rgas
     &        +LOG(t*rho/(tref(icomp)*rhoref(icomp)))
     &        -1.0d0
c
      else if (itau.eq.1) then
c  compute derivative w.r.t. tau (dimensionless temperature)
        PH0CPP=cpisav(icomp)/Rt-1.0d0      !return tau*d(ph0cpp)/d(tau)
c
      else if (itau.eq.2) then
c  compute 2nd derivative w.r.t. tau (dimensionless temperature)
c  return tau**2*d2(ph0cpp)/d(tau**2)
        PH0CPP=1.0d0-cp0sav(icomp)/Rgas
c
      else if (itau.eq.3) then
        j=icomp                          !pointer to appropriate fluid
        tau=tz(icomp)/t
c  note that t0 is reducing temperature for EOS (conversion between
c  absolute temperature and tau) while tred is a (possible) separate
c  reducing temperature appearing only in Cp0
        PH0sum=2.0d0*(-1.0d0+cp0sav(icomp)/Rgas)
        iterm=0
c       write (*,*) 'PH0CPP--initial PH0sum:        ',iterm,PH0sum
c  polynomial terms
        if (ntermc(j).ge.1) then
          do i=1,ntermc(j)
            iterm=iterm+1
            if (ABS(xkc0(j,iterm)).gt.1.0d-10) then
c  these terms arise from d(Cp0)/d(tau) and derivative of constant
c  terms is zero
              PH0sum=PH0sum+cpc0(j,iterm)*xkc0(j,iterm)
     &             *(tz(icomp)/tredcp(j))**xkc0(j,iterm)
     &             *tau**(-xkc0(j,iterm))*Credcp(j)/R

            end if
c         write (*,*) 'PH0CPP--i-polynomial,PH0sum:   ',i,PH0sum
          enddo
        end if
c  exponential terms
        if (nterme(j).ge.1) then
          do i=1,nterme(j)
            iterm=iterm+1
            ui=xkc0(j,iterm)/t
            if (ui.lt.200.0d0) then
              expui=EXP(ui)
              PH0sum=PH0sum-tau*cpc0(j,iterm)*xkc0(j,iterm)*expui
     &              /(tz(icomp)*(1.0d0-expui)**2)
     &              *(2.0d0*ui+ui*ui*(1.0d0+2.0d0*expui/(1.0d0-expui)))
c           write (*,*) 'PH0CPP--i-exponential,PH0sum:  ',i,PH0sum
            endif
          enddo
        end if
c  cosh terms
        sum_term = 0.d0
        if (ncoshc(j).ge.1) then
          do i=1,ncoshc(j)
            iterm=iterm+1
            tt   = t/tredcp(j)
            ttau = cp0h(j,iterm) * tt**x0th(j,iterm)
            term = cpc0(j,iterm) * tt**xkc0(j,iterm) *
     &           cosh(ttau)**xh00(j,iterm)*(xkc0(j,iterm)+xh00(j,iterm)*
     &             x0th(j,iterm) * cp0h(j,iterm) * tt**x0th(j,iterm) *
     &             tanh(ttau))
            sum_term = sum_term + term
          enddo
        end if
c  sinh terms
        if (nsinhc(j).ge.1) then
          do i=1,nsinhc(j)
            iterm=iterm+1
            tt   = t/tredcp(j)
            ttau = cp0h(j,iterm) * tt**x0th(j,iterm)
            term = cpc0(j,iterm) * tt**xkc0(j,iterm) *
     &           sinh(ttau)**xh00(j,iterm)*(xkc0(j,iterm)+xh00(j,iterm)*
     &             x0th(j,iterm) * cp0h(j,iterm) * tt**x0th(j,iterm) /
     &             tanh(ttau))
            sum_term = sum_term + term
          enddo
        end if
        PH0CPP=PH0sum+sum_term
c
      else if (idel.eq.1) then
c  the three density derivatives are 1/del, -1/del**2, and 1/del**3
c  the quantity returned is derivative multiplied by corresponding power
c  of del, avoiding a possible divide by zero
        PH0CPP=1.0d0
      else if (idel.eq.2) then
        PH0CPP=-1.0d0
      else if (idel.eq.3) then
        PH0CPP=2.0d0
c
      else
c  invalid value of itau
        ierr=99
        write (herr,1099) itau,idel,hnull
 1099   format ('[PH0CPP warning] invalid input; itau =',i4,'; idel =',
     &          i4,a1)
        call ERRMSG (ierr,herr)
        PH0CPP=0.0d0
      end if
c
c     write (*,*) ' PH0CPP:  output phi: ',ph0cpp
c
      RETURN
      end                                               !function PH0CPP
cc
cc ======================================================================
cc
c      block data BDCPP
cc
cc  data for polynomial form of ideal gas heat capacity
cc     Cp0/Cred = SUM [cpc0(i,k)*(T/Tred(i))**xkc0(i,k)]
cc     where Cred is reducing parameter for Cp0 (e.g. gas constant, R)
cc           Tred is reducing parameter for t (e.g. critical temperature)
cc
c      include 'commons.for'
c      character*12 hcasc
c      common /NTCPP/ ntrmca(mxcpp),ntrmce(mxcpp)
c      common /RDCPP/ treda(mxcpp),Creda(mxcpp)
c      common /LMCPP/ tmna(mxcpp),tmxa(mxcpp),pmxa(mxcpp),rhomxa(mxcpp)
c      common /CPCPP/ cpca(mxcpp,ncppmx),xka(mxcpp,ncppmx)
c      common /CASCPP/ hcasc(mxcpp)
cc
cc  explanation of commons and constituent arrays
cc    /NTCPP/  number of terms in polynomial fit
cc    /RDCPP/  reducing parameters for temperature, Cp0 (often =1)
cc    /LMCPP/  limits of fit: tmin, tmax, pmax (= 0), rhomax (= 0)
cc    /CPCPP/  parameters to polynomial Cp0 fit
cc    /CASCPP/    Chem Abstract number; used as unambiguous identifier
cc      hcasc(i):  CAS number for fluid corresponding to equation "i"
cc
cc
cc  written by M. McLinden, NIST Thermophysics Division, Boulder, Colorado
cc  07-20-95  MM, original version
cc  11-10-95  MM, convert from cubic to general polynomial
cc  06-17-96  MM, add provision for exponential terms
cc
cc      N.B.--the "i" have no particular significance
cc
cc
cc   R134a  1,1,1,2-tetrafluoroethane
c      data hcasc(1) /'811-97-2'/
cc  fit of McLinden et al. (1989), ASHRAE Trans 95(pt 2):263-283
cc  also in Huber & McLinden (1992), Int Refrig Conf, Purdue, 453-462
c      data ntrmca(1),ntrmce(1) /3,0/
c      data treda(1),Creda(1) /1.0d0,1.0d0/
c      data tmna(1),tmxa(1),pmxa(1),rhomxa(1)
c     &  /150.0d0,500.0d0,0.0d0,0.0d0/
c      data (xka(1,i),i=1,3)
c     &  / 0.0d0,   1.0d0,      2.0d0/
c      data (cpca(1,i),i=1,3)
c     &  /19.4006d0,0.258531d0,-1.29665d-4/
cc
cc  R123  2,2-dichloro-1,1,1-trifluoroethane
c      data hcasc(2) /'306-83-2'/
cc  fit of Younglove & McLinden (1994), JPCRD 23:731-779
c      data ntrmca(2),ntrmce(2) /4,0/
c      data treda(2),Creda(2) /456.831d0,8.31451d0/
c      data tmna(2),tmxa(2),pmxa(2),rhomxa(2)
c     &  /150.0d0,500.0d0,0.0d0,0.0d0/
c      data (xka(2,i),i=1,4)
c     &  /0.0d0,      1.0d0,       2.0d0,     3.0d0/
c      data (cpca(2,i),i=1,4)
c     &  /2.046009d0,22.231991d0,-11.658491d0,2.691665/
cc
c      end                                              !block data BDCPP
c
c
c        1         2         3         4         5         6         7
c23456789012345678901234567890123456789012345678901234567890123456789012
c
c ======================================================================
c                                                    end file core_CPP.f
c ======================================================================
c  begin file core_DE.f
c
c  This file contains core routines for the dielectric constant.
c
c  contained here are:
c     subroutine DIELEC (t,rho,x,de)
c     subroutine SETDE (nread,icomp,hcasno,ierr,herr)
c     subroutine DEK (icomp,t,rho,de,ierr,herr)
c
c ======================================================================
c ======================================================================
c
      subroutine DIELEC (t,rho,x,de)
c
c  compute the dielectric constant as a function of temperature, density,
c  and composition.
c
c  inputs:
c        t--temperature [K]
c      rho--molar density [mol/L]
c        x--composition [array of mol frac]
c   output:
c       de--dielectric constant
c
c  written by E.W. Lemmon, NIST Physical & Chem Properties Div, Boulder, CO
c  07-01-98 EWL, original version
c  08-05-04 EWL, add mixture equation
c  03-02-05 EWL, add error checking
c
cx DEC$ ATTRIBUTES DLLEXPORT :: DIELEC
c
      include 'commons.for'
      dimension x(ncmax)
      character*255 herr
c
      call ISPURE (x,icomp)
      if (icomp.ne.0) then
c  special case--pure component
        call DEK (icomp,t,rho,de,ierr,herr)
      else if (hdiel.eq.'DEX' .or. hdiel.eq.'DEM') then
c  mixture calculation (from Harvey and Lemmon, 2005)
        vz=0.d0
        pm=0.d0
        do i=1,nc
          vz=vz+x(i)/rhoz(i)
        enddo
        dr=rho*vz
        do i=1,nc
          call DEK (i,t,dr*rhoz(i),dei,ierr,herr)
          if (ierr.ne.0) then
            de=0.d0
            RETURN
          endif
          p=(dei-1.d0)*(2.d0*dei+1.d0)/9.d0/dei
          pm=pm+x(i)/rhoz(i)/vz*p
        enddo
        de=0.25d0*(1.d0+9.d0*pm+3.d0*SQRT(9.d0*pm**2+2.d0*pm+1.d0))
      else
        ierr=99
        de=-9.999d6
        write (herr,1199) hdiel,hnull
        call ERRMSG (ierr,herr)
 1199   format ('[DE error 99] ',
     &          'unknown dielectric constant model:  (',a3,')',a1)
c       write (*,*) ' DE--output de (ierr = 99):  ',de
      end if
c
      RETURN
      end                                             !subroutine DIELEC
c
c ======================================================================
c
      subroutine SETDE (nread,icomp,hcasno,ierr,herr)
c
c  set up working arrays for use with "DE" dielectric constant model
c
c  inputs:
c    nread--file to read data from (file should have already been
c           opened and pointer set by subroutine SETUP)
c    icomp--component number in mixture (1..nc); 1 for pure fluid
c   hcasno--CAS number of component icomp (not required, it is here
c           to maintain parallel structure with SETBWR and SETFEQ)
c
c  outputs:
c     ierr--error flag:  0 = successful
c                        101 = error (e.g. fluid not found)
c     herr--error string (character*255 variable if ierr<>0)
c     other quantities returned via arrays in commons
c
c  written by E.W. Lemmon, NIST Thermophysics Division, Boulder, Colorado
c  07-01-98 EWL, original version
c
      include 'commons.for'
      character*12 hcasno
      character*255 herr
c
      if (nread.le.0) then
        ierr=101
        write (herr,1101) nread,hcasno,hnull
        call ERRMSG (ierr,herr)
 1101   format ('[SETDE error 101] illegal file specified; nread = ',
     &          i4,'; CAS no. = ',a12,a1)
        RETURN
      else
        herr=' '
        ierr=0
      end if
c
c  read data from file
c     write (*,*) ' SETDE--read component',icomp,' from unit',nread
      read (nread,*) tminde(icomp)          !lower temperature limit
      read (nread,*) tmaxde(icomp)          !upper temperature limit
c  the pressure and density limit are not presently used,
c  but are contained in the file for consistency and possible future use;
c  skip over them in reading the file
      read (nread,*) !pjunk               !upper pressure limit (n/a)
      read (nread,*) !rhojnk              !upper density limit (n/a)
c  read reducing parameters and coefficients
      read (nread,*) tredde(icomp),dredde(icomp),predde(icomp)
      read (nread,*) ntrmd1(icomp),ntrmd2(icomp),ntrmd3(icomp),
     &               ntrmd4(icomp),ntrmd5(icomp),ntrmd6(icomp)
      do k=1,ntrmd1(icomp)
        read (nread,*) decf(icomp,k),deexpt(icomp,k),deexpd(icomp,k),
     &                 deexpp(icomp,k)
      enddo
      do k=1,ntrmd2(icomp)
        j=k+ntrmd1(icomp)
        read (nread,*) decf(icomp,j),deexpt(icomp,j),deexpd(icomp,j),
     &                 deexpp(icomp,j)
      enddo
      do k=1,ntrmd3(icomp)
        j=k+ntrmd1(icomp)+ntrmd2(icomp)
        read (nread,*) decf(icomp,j),deexpt(icomp,j),deexpd(icomp,j),
     &                 deexpp(icomp,j)
      enddo
c
      RETURN
      end                                              !subroutine SETDE
c
c ======================================================================
c
      subroutine DEK (icomp,t,rho,de,ierr,herr)
c
c  compute dielectric constant with appropriate core model
c
c  inputs:
c    icomp--component i
c      tau--dimensionless temperature (1 - T/Tc)
c   output:
c       de--dielectric constant [N/m]
c     ierr--error flag:  0 = successful
c                        1 = successful
c     herr--error string (character*255 variable if ierr<>0)
c
c  written by E.W. Lemmon, NIST Physical & Chemical Properties Division, Boulder, Colorado
c  04-17-97 EWL, original version (based on DE)
c  09-02-99 EWL, return if pi<0
c  08-05-04 EWL, add DE3 and DE4
c  02-22-10 EWL, add check for tau=1
c  03-11-13 EWL, add check for negative values raised to the 0th or 1st power
c
      include 'commons.for'
      character*255 herr
      double precision na,mu,kk
      dimension x(ncmax)
c
      de=0
      ierr=0
      herr=' '
c
      if (rho.lt.1.d-12) then
        de=1.d0
      elseif (hdielk(icomp).eq.'DE1') then
        call press(t,rho,x,p)
        pi=p/1000.0d0/predde(icomp)
        if (pi.lt.0) return
        del=rho/dredde(icomp)
        tau=t/tredde(icomp)
        cm=0.0d0
        do k=1,ntrmd1(icomp)
          cm=cm+decf(icomp,k)*tau**deexpt(icomp,k)*del**deexpd(icomp,k)
     &         *pi**deexpp(icomp,k)
        enddo
        do k=1,ntrmd2(icomp)
          j=k+ntrmd1(icomp)
          cm=cm+decf(icomp,j)*tau**deexpt(icomp,j)*del**deexpd(icomp,j)
     &         *pi**deexpp(icomp,j)*log(1.0d0+1.0d0/tau)
        enddo
        de=(1.0d0+2.0d0*cm)/(1.0d0-cm)
      elseif (hdielk(icomp).eq.'DE2') then
        na=6.0221367d23          !1/mol
        alpha=1.636d-40          !C^2.m^2/J
        mu=6.138d-30             !C.m
        eps=8.854187817d-12      !C^2/J.m
        kk=1.380658d-23           !J/K
        del=rho/dredde(icomp)
        tau=tredde(icomp)/t
        g=1
        do k=1,ntrmd1(icomp)
          g=g+decf(icomp,k)*tau**deexpt(icomp,k)*del**deexpd(icomp,k)
        enddo
        do k=1,ntrmd2(icomp)
         j=k+ntrmd1(icomp)
         t1=t/deexpt(icomp,j)-1.d0
         if (t1.le.0) RETURN
         g=g+decf(icomp,j)*del**deexpd(icomp,j)/t1**deexpp(icomp,j)
        enddo
c
c  Harris-Alder model:
        a = 1000.d0*na*rho*g*mu**2/(eps*kk*t)
        b = 1000.d0*na*rho*alpha/(3.d0*eps)
        c = dsqrt(9.d0 + 2.d0*a + 18.d0*b + a**2 + 10.d0*a*b+9.d0*b**2)
        de = (1.d0 + a + 5.d0*b + c)/(4.d0 - 4.d0*b)
      elseif (hdielk(icomp).eq.'DE3' .or. hdielk(icomp).eq.'DE4') then
        del=rho/dredde(icomp)
        tau=t/tredde(icomp)
        cm=0.0d0
        do k=1,ntrmd1(icomp)
          cm=cm+decf(icomp,k)*tau**deexpt(icomp,k)*del**deexpd(icomp,k)
        enddo
        do k=1,ntrmd2(icomp)
          j=k+ntrmd1(icomp)
          if (abs(deexpt(icomp,j)).lt.1.d-20) then
            cm=cm+decf(icomp,j)*del**deexpd(icomp,j)
          elseif (abs(deexpt(icomp,j)-1.d0).lt.1.d-20) then
            cm=cm+decf(icomp,j)*(tau-1.d0)*del**deexpd(icomp,j)
          else
            cm=cm+decf(icomp,j)*(tau-1.d0)**deexpt(icomp,j)
     &        *del**deexpd(icomp,j)
          endif
        enddo
        do k=1,ntrmd3(icomp)
          j=k+ntrmd1(icomp)+ntrmd2(icomp)
          if (abs(deexpt(icomp,j)).lt.1.d-20) then
            cm=cm+decf(icomp,j)*del**deexpd(icomp,j)
          elseif (abs(deexpt(icomp,j)-1.d0).lt.1.d-20) then
            cm=cm+decf(icomp,j)*(1.d0/tau-1.d0)*del**deexpd(icomp,j)
          else
            cm=cm+decf(icomp,j)*(1.d0/tau-1.d0)**deexpt(icomp,j)
     &        *del**deexpd(icomp,j)
          endif
        enddo
        if (hdielk(icomp).eq.'DE3') then
          de=(1.0d0+2.0d0*cm)/(1.0d0-cm)
        else
          de=0.25d0*(1.d0+9.d0*cm+3.d0*SQRT(9.d0*cm**2+2.d0*cm+1.d0))
        endif
      else
        ierr=1
        de=-9.99999d6
        write (herr,1099) hdielk(icomp),hnull
        call ERRMSG (ierr,herr)
 1099   format ('[DE error 99] ',
     &          'unknown dielectric constant model:  (',a3,')',a1)
      end if
c     write (*,1200) icomp,tau,de
c1200 format (' DEK--icomp,tau,de: ',i4,2f11.6)
c
      RETURN
      end                                                !subroutine DEK
c
c
c        1         2         3         4         5         6         7
c23456789012345678901234567890123456789012345678901234567890123456789012
c
c ======================================================================
c                                                     end file core_DE.f
c ======================================================================
c  begin file core_ECS.f
c
c  This file contains routines implementing an extended corresponding
c  states model with temperature- and density-dependent shape factors.
c
c  contained here are:
c     function PHIECS (icomp,itau,idel,tau,del)
c     subroutine CRTECS (icomp,tc,pc,rhoc)
c     subroutine SETECS (nread,icomp,hcasno,hreff,heqn,ierr,herr)
c     subroutine FJ (icomp,t,d,f,dfdt,d2fdt2,dfdd,d2fdd2,d2fdtd)
c     subroutine HJ (icomp,t,d,h,dhdt,d2hdt2,dhdd,d2hdd2,d2hdtd)
c
c ======================================================================
c ======================================================================
c
      function PHIECS (icomp,itau,idel,tau,del)
c
c  compute reduced Helmholtz energy or a derivative as functions
c  of dimensionless temperature and density for the ECS model
c
c  inputs:
c    icomp--pointer specifying component (1..nc)
c     itau--flag specifying order of temperature derivative to calc
c     idel--flag specifying order of density derivative to calculate
c           when itau = 0 and idel = 0, compute A/RT
c           when itau = 0 and idel = 1, compute 1st density derivative
c           when itau = 1 and idel = 1, compute cross derivative
c           etc.
c      tau--dimensionless temperature (To/T)
c      del--dimensionless density (D/Do)
c  output (as function value):
c      phi--residual (real-gas) part of the Helmholtz energy, or one
c           of its derivatives (as specified by itau and idel),
c           in reduced form (A/RT)
c           itau  idel    output (dimensionless for all cases)
c             0    0      A/RT
c             1    0      tau*[d(A/RT)/d(tau)]
c             2    0      tau**2*[d**2(A/RT)/d(tau)**2]
c             0    1      del*[d(A/RT)/d(del)]
c             0    2      del**2*[d**2(A/RT)/d(del)**2]
c             1    1      tau*del*[d**2(A/RT)/d(tau)d(del)]
c                         etc.
c
c        The Helmholtz energy consists of ideal and residual (real-gas)
c        terms; this routine calculates only the residual part.
c
c        This function computes pure component properties only.
c
c  written by M. McLinden, NIST Thermophysics Division, Boulder, Colorado
c  02-02-96  MM, original version
c  03-19-96  MM, add dipole moment to /CCON/
c  03-22-96  MM, replace /MODEL/ with /EOSMOD/
c  09-23-96 EWL, change calls to FJ, HJ to include density dependence
c  11-13-97 EWL, check for itau.ge.1 before idel.ge.1
c  12-01-98 EWL, add Reos and triple point pressure and density to /CCON/
c  01-26-00 EWL, add check for del>=0 and tau>=0
c  09-05-00 EWL, return 0 for invalid idel or itau
c  01-17-01 EWL, change tau0.ge.0 to tau0.gt.0 and avoid 0**0
c
      include 'commons.for'
c
      phiecs=0.0d0    !initialize outputs and intermediate results
      phi01=0.0d0
      phi02=0.0d0
      phi10=0.0d0
      phi20=0.0d0
      phi11=0.0d0
c
      if (del.le.1.0d-10) then    !trivial solution at zero density
        RETURN                    !for any and all derivatives
      end if
c
c  recover the temperature and density from tau and del (need to compute
c  shape factors at actual temperature rather than reduced temperature)
c
      i=icomp
      t=tcrit(i)/tau
      rho=del*Dcrit(i)
      call FJ (icomp,t,rho,f,dfdt,d2fdt2,dfdd,d2fdd2,d2fdtd)
      call HJ (icomp,t,rho,h,dhdt,d2hdt2,dhdd,d2hdd2,d2hdtd)
c
c  find the reducing temperature to compute tau for the reference fluid
c  and then calculate reduced Helmholtz for the reference fluid at the
c  conformal temperature and density
c
c  note:  cannot use the PHIK function here because it calls this one,
c         and recursive calls are not generally allowed in fortran
c
      iref=-icomp
      tred0=tz(iref)
      Dred0=rhoz(iref)
      if (hmxeos(iref).eq.'BWR') then
        call CRTBWR (iref,tc0,pc0,Dc0)
        tred0=tc0
        Dred0=Dc0
        tau0=tred0/t*f
        del0=rho*h/Dred0
c  compute PHI with same order as input arguments
        phixx=PHIBWR (iref,itau,idel,tau0,del0)
        phixx=phixx/del0**idel/tau0**itau
c  calculate additional PHIs as required
        if (itau.ge.1) then
          phi01=PHIBWR (iref,0,1,tau0,del0)     /del0
          if (idel.eq.1) then
            phi02=PHIBWR (iref,0,2,tau0,del0)   /del0**2
            phi10=PHIBWR (iref,1,0,tau0,del0)   /tau0
            phi20=PHIBWR (iref,2,0,tau0,del0)   /tau0**2
          else if (itau.eq.2) then
            phi10=PHIBWR (iref,1,0,tau0,del0)   /tau0
            phi11=PHIBWR (iref,1,1,tau0,del0)   /del0/tau0
            phi02=PHIBWR (iref,0,2,tau0,del0)   /del0**2
          end if
        end if
        if (idel.ge.1) then
          phi10=PHIBWR (iref,1,0,tau0,del0)     /tau0
          if (idel.eq.2) then
            phi01=PHIBWR (iref,0,1,tau0,del0)   /del0
            phi11=PHIBWR (iref,1,1,tau0,del0)   /del0/tau0
            phi20=PHIBWR (iref,2,0,tau0,del0)   /tau0**2
          end if
        end if
      else if (hmxeos(iref)(1:2).eq.'FE') then
        tau0=tred0/t*f
        del0=rho*h/Dred0
c  compute PHI with same order as input arguments
        phixx=0
        if (del0.ge.0 .and. tau0.gt.0) then
          phixx=PHIFEQ (iref,itau,idel,tau0,del0)
          phixx=phixx/del0**idel/tau0**itau
c  calculate additional PHIs as required
          if (itau.ge.1) then
            phi01=PHIFEQ (iref,0,1,tau0,del0)   /del0
            if (idel.eq.1) then
              phi02=PHIFEQ (iref,0,2,tau0,del0) /del0**2
              phi10=PHIFEQ (iref,1,0,tau0,del0) /tau0
              phi20=PHIFEQ (iref,2,0,tau0,del0) /tau0**2
            else if (itau.eq.2) then
              phi10=PHIFEQ (iref,1,0,tau0,del0) /tau0
              phi11=PHIFEQ (iref,1,1,tau0,del0) /del0/tau0
              phi02=PHIFEQ (iref,0,2,tau0,del0) /del0**2
            end if
          end if
          if (idel.ge.1) then
            phi10=PHIFEQ (iref,1,0,tau0,del0)   /tau0
            if (idel.eq.2) then
              phi01=PHIFEQ (iref,0,1,tau0,del0) /del0
              phi11=PHIFEQ (iref,1,1,tau0,del0) /del0/tau0
              phi20=PHIFEQ (iref,2,0,tau0,del0) /tau0**2
            end if
          end if
        end if
      else
c  reference fluid not found, but no way to return an error from here
        phixx=-9.99d99
      end if
c
c  check if derivatives are requested
c
      if (itau.eq.0) then
        if (idel.eq.0) then
c  compute dimensionless residual Helmholtz of reference fluid
          phiecs=phixx
        else if (idel.eq.1 .and. ABS(f).gt.1.d-20) then
c  compute 1st derivative w.r.t. del (dimensionless density)
          phiecs=Dcrit(i)/Dred0*phixx*(h + rho*dhdd)
     &          +Dcrit(i)*tau0/f*phi10*dfdd
        else if (idel.eq.2) then
c  compute 2nd derivative w.r.t. del
          phiecs=Dcrit(i)**2*(((phixx*(h+rho*dhdd)/dred0
     &    +tred0/t*phi11*dfdd)*(h+rho*dhdd)
     &    +phi01*(2.d0*dhdd+rho*d2hdd2))/dred0
     &    +tred0/t*((phi11/dred0*(h+rho*dhdd)+tred0/t*phi20*dfdd)*dfdd
     &    +d2fdd2*phi10))
        end if
c
      else if (itau.eq.1) then
        dtlogh=dhdt/h  !equal to temperature derivative of log(h)
        if (idel.eq.0) then
c  compute 1st derivative w.r.t. tau (dimensionless temperature)
          phiecs=tred0/tcrit(i)*(f-t*dfdt)*phixx
     &          -t*t*del0/tcrit(i)*dtlogh*phi01
        else if (idel.eq.1) then
c  compute cross derivative
          phiecs=Dcrit(i)/Dred0/tcrit(i)*
     &          (tred0*(f-t*dfdt)*(phixx*(h + rho*dhdd)
     &          +tred0/t*dred0*phi20*dfdd)
     &          +tred0*phi10*Dred0*(dfdd - t*d2fdtd)
     &          -t*t*(phi01*dhdt+rho*dhdt*(phi02/dred0*(h + rho*dhdd)
     &          +tred0/t*phixx*dfdd)
     &          +rho*phi01*d2hdtd))
        end if
c
      else if (itau.eq.2) then
c  compute 2nd derivative w.r.t. tau
        dtlogh=dhdt/h  !equal to temperature derivative of log(h)
        phiecs=(1.0d0/tcrit(i)**2)*
     &        (tred0**2*(f-t*dfdt)**2*phixx
     &        -2.0d0*t*t*tred0*del0*(f-t*dfdt)*dtlogh*phi11
     &        +t**4*del0**2*dtlogh**2*phi02
     &        +tred0*t**3*d2fdt2*phi10
     &        +t**3*del0/h*(t*d2hdt2+2.0d0*dhdt)*phi01)
      else
c  invalid itau and/or idel, but no way to return an error from here
c       phiecs=-9.99d99
      end if
      phiecs=phiecs*del**idel*tau**itau
c
      RETURN
      end                                               !function PHIECS
c
c ======================================================================
c
      subroutine CRTECS (icomp,tc,pc,rhoc)
c
c  returns critical parameters associated with ECS model
c
c  N.B.  these critical parameters may not necessarily be most
c        accurate values, but they are consistent with the ECS fit
c
c  input:
c    icomp--pointer specifying component (1..nc)
c  outputs:
c       tc--critical temperature [K]
c       pc--critical pressure [kPa]
c     rhoc--molar density [mol/L] at critical point
c
c  written by M. McLinden, NIST Thermophysics Division, Boulder, Colorado
c  02-06-96  MM, original version
c  03-19-96  MM, add dipole moment to /CCON/
c  12-01-98 EWL, add Reos and triple point pressure and density to /CCON/
c
      include 'commons.for'
c
      tc=tcrit(icomp)
      pc=pcrit(icomp)
      rhoc=Dcrit(icomp)
c
      RETURN
      end                                             !subroutine CRTECS
c
c ======================================================================
c
      subroutine SETECS (nread,icomp,hcasno,hreff,heqn,ierr,herr)
c
c  set up working arrays for use with ECS model
c
c  inputs:
c    nread--file to read data from (file should have already been
c           opened and pointer set by subroutine SETUP)
c    icomp--component number in mixture (1..nc); 1 for pure fluid
c   hcasno--CAS number of component icomp (not required, it is here
c           to maintain parallel structure with SETBWR and SETFEQ)
c
c  outputs:
c     hreff--file containing reference fluid EOS (character*255)
c     heqn--model ('BWR', etc) for reference fluid EOS (character*3)
c     ierr--error flag:  0 = successful
c                        1 = error (e.g. fluid not found)
c     herr--error string (character*255 variable if ierr<>0)
c     other quantities returned via arrays in commons
c
c  written by M. McLinden, NIST Thermophysics Division, Boulder, Colorado
c  02-06-95  MM, original version
c  03-19-96  MM, add dipole moment to /CCON/
c  03-21-96  MM, delete reference to /MODEL/, not needed
c  03-22-96  MM, replace /CPMOD/ with /EOSMOD/
c  06-03-96  MM, add limits to /EOSLIM/
c  09-23-96 EWL, add density dependent shape factors
c  09-30-96  MM, change order of density factors in .fld files
c  08-19-97  MM, get rid of herr=herr, etc (avoid warning); flag nread<=0
c  07-08-98 EWL, change character strings from *80 to *255
c  12-01-98 EWL, add Reos and triple point pressure and density to /CCON/
c  12-22-98 EWL, set Reos to 8.31451
c  06-22-99 EWL, reset ptp and dtp to zero
c  06-22-99 EWL, change Reos to 8.314472, set R to Reos
c  05-03-04 EWL, change dtp to rhomax
c
      include 'commons.for'
      character*3 heqn
      character*12 hcasno
      character*255 hreff
      character*255 herr
c
      if (nread.le.0) then
        ierr=101
        write (herr,1101) nread,hcasno,hnull
        call ERRMSG (ierr,herr)
 1101   format ('[SETECS error 101] illegal file specified; nread = ',
     &          i4,'; CAS no. = ',a12,a1)
        RETURN
      else
        herr=' '
        ierr=0
      end if
c
c  read data from file
c     write (*,*) ' SETECS--read component',icomp,' from unit',nread
c     iref=-icomp
      Reos(icomp)=8.314472d0
      if (nc.eq.1 .and. icomp.eq.1) R=Reos(icomp)
      ptpn(icomp)=0.0d0
      dtpv(icomp)=0.0d0
      dnbpl(icomp)=0.0d0
      dnbpv(icomp)=0.0d0
      read (nread,*) tminecs(icomp)          !lower temperature limit
      read (nread,*) tmaxecs(icomp)          !upper temperature limit
      read (nread,*) pmaxecs(icomp)          !upper pressure limit
      read (nread,*) dmaxecs(icomp)        !upper density limit
      read (nread,2003) hmodcp(icomp)     !pointer to Cp0 model
      read (nread,2080) hreff              !reference fluid .fld file
      read (nread,2003) heqn              !ref fluid equation of state
      read (nread,*) acfref(icomp)        !acc fac for reference fluid
      read (nread,*) Zcref(icomp)         !Zc for reference fluid
      read (nread,*) acfecs(icomp)        !acentric factor
      read (nread,*) tcrit(icomp)         !critical temperature [K]
      read (nread,*) pcrit(icomp)         !critical pressure [kPa]
      read (nread,*) Dcrit(icomp)         !critical density [mol/L]
      tz(icomp)=tcrit(icomp)
      rhoz(icomp)=Dcrit(icomp)
c     write (*,1020) tcrit(icomp),pcrit(icomp),Dcrit(icomp)
c1020 format (1x,' SETECS--critical T, p, rho: ',f8.3,f8.2,f8.5)
      Zcrit(icomp)=pcrit(icomp)/(Reos(icomp)*tcrit(icomp)*Dcrit(icomp))
c  copy ECS parameters to general fluid constants common block
c     accen(icomp)=acfecs(icomp)
      read (nread,*) nfecs(icomp)    !no. temperature terms for 'f' ESRR
      do j=1,nfecs(icomp)
        read (nread,*) fecs(icomp,j,1),fecs(icomp,j,2)
      enddo
      read (nread,*) nfdecs(icomp)   !no. density terms for 'f' ESRR
      if (nfdecs(icomp).ge.1) then
        do j=1,nfdecs(icomp)
          read (nread,*) fdecs(icomp,j,1),fdecs(icomp,j,2)
        enddo
      end if
      read (nread,*) nhecs(icomp)    !no. temperature terms for 'h' ESRR
      do j=1,nhecs(icomp)
        read (nread,*) hecs(icomp,j,1),hecs(icomp,j,2)
      enddo
      read (nread,*) nhdecs(icomp)   !no. density terms for 'h' ESRR
      if (nhdecs(icomp).ge.1) then
        do j=1,nhdecs(icomp)
          read (nread,*) hdecs(icomp,j,1),hdecs(icomp,j,2)
        enddo
      end if
c
c  copy limits into /EOSLIM/ arrays
      tmeos(icomp)=tminecs(icomp)
      txeos(icomp)=tmaxecs(icomp)
      peos(icomp)=pmaxecs(icomp)
      Deos(icomp)=dmaxecs(icomp)
      dtpn(icomp)=dmaxecs(icomp)
c
      RETURN
 2003 format (a3)
 2080 format (a255)
      end                                             !subroutine SETECS
c
c ======================================================================
c
      subroutine FJ (icomp,t,d,f,dfdt,d2fdt2,dfdd,d2fdd2,d2fdtd)
c
c  compute the equivalent substance reducing ratio (for temperature)
c  and its temperature derivative for use in the ECS model
c
c  This routine implements the function of Huber & Ely, Int. J. Refrig.
c  17:18-31 (1994) modified by additional general terms in (T/Tc) and by
c  density-dependent terms.  The beta1, beta2 of Huber & Ely are
c  hecs(i,1,1) and hecs(i,2,1) here.
c
c  inputs:
c    icomp--pointer specifying component (1..nc)
c        t--temperature [K]
c        d--density [mol/L]
c  outputs:
c        f--equivalent substance reducing ratio (for temperature)
c           this is equal to (Tc,icomp/Tc,ref)*theta(T)
c           where theta is the energy (or temperature) shape factor
c     dfdt--temperature derivative of f
c   d2fdt2--second temperature derivative of f
c     dfdd--density derivative of f
c   d2fdd2--second density derivative of f
c   d2fdtd--temperature-density cross derivative of f
c
c  written by M. McLinden, NIST Thermophysics Division, Boulder, Colorado
c  02-06-96  MM, original version
c  03-19-96  MM, add dipole moment to /CCON/
c  09-23-96 EWL, add density dependent shape factors
c  12-01-98 EWL, add Reos and triple point pressure and density to /CCON/
c  01-17-01 EWL, initialize values and return if t<=0
c  11-15-07 MLH, remove dead code
c
      include 'commons.for'
c
      f=0.d0
      dfdt=0.d0
      d2fdt2=0.d0
      dfdd=0.d0
      d2fdd2=0.d0
      d2fdtd=0.d0
      if (t.le.0.d0) RETURN
      i=icomp
      iref=-icomp
      Tr=t/tcrit(i)
      Dr=d/Dcrit(i)
      domega=acfecs(i)-acfref(i)
c  theta is the density shape factor
      theta=1.0d0+domega*(fecs(i,1,1)+fecs(i,2,1)*log(Tr))
c  first and second (reduced) temperature derivatives of theta
      d1th=domega*fecs(i,2,1)/Tr        !first Tr derivative of theta
      d2th=-domega*fecs(i,2,1)/(Tr*Tr)  !second Tr derivative of theta
c  sum terms beyond those in Huber & Ely function
      if (nfecs(i).ge.3) then
        do j=3,nfecs(i)
          theta=theta+fecs(i,j,1)*Tr**fecs(i,j,2)
          d1th=d1th+fecs(i,j,1)*fecs(i,j,2)*Tr**(fecs(i,j,2)-1.0d0)
          d2th=d2th+fecs(i,j,1)*fecs(i,j,2)*(fecs(i,j,2)-1.0d0)
     &        *Tr**(fecs(i,j,2)-2.0d0)
        enddo
      end if
      d1thd=0.d0
      d2thd=0.d0
      if (nfdecs(i).gt.0) then
        do j=1,nfdecs(i)
          theta=theta+fdecs(i,j,1)*Dr**fdecs(i,j,2)
          d1thd=d1thd+fdecs(i,j,1)*fdecs(i,j,2)*Dr**(fdecs(i,j,2)-1.d0)
          d2thd=d2thd+fdecs(i,j,1)*fdecs(i,j,2)*(fdecs(i,j,2)-1.d0)
     &         *Dr**(fdecs(i,j,2)-2.d0)
        enddo
      end if
c
c  convert theta and its derivatives to 'f' and its derivatives
      Tcrat=tcrit(icomp)/tcrit(iref)
      f=Tcrat*theta
      dfdt=d1th/tcrit(iref)
      d2fdt2=d2th/(tcrit(icomp)*tcrit(iref))
      dfdd=d1thd*Tcrat/Dcrit(icomp)
      d2fdd2=d2thd*Tcrat/Dcrit(icomp)**2
      !d2fdtd=d1thdt*Tcrat/Dcrit(icomp)/tcrit(icomp)
      d2fdtd=0.0d0 !approximation. if needed, calculation of d1thdt is required.
c
      RETURN
      end                                                 !subroutine FJ
c
c ======================================================================
c
      subroutine HJ (icomp,t,d,h,dhdt,d2hdt2,dhdd,d2hdd2,d2hdtd)
c
c  compute the equivalent substance reducing ratio (for density)
c  and its temperature derivative for use in the ECS model
c
c  This routine implements the function of Huber & Ely, Int. J. Refrig.
c  17:18-31 (1994) modified by additional general terms in (T/Tc) and by
c  density-dependent terms.  The beta1, beta2 of Huber & Ely are
c  hecs(i,1,1) and hecs(i,2,1) here.
c
c  inputs:
c    icomp--pointer specifying component (1..nc)
c        t--temperature [K]
c        d--density [mol/L]
c  outputs:
c        h--equivalent substance reducing ratio (for density)
c           this is equal to (rhoc,ref/rhoc,icomp)*phi(T)
c           where phi is the volume (or density) shape factor
c     dhdt--temperature derivative of h
c   d2hdt2--second temperature derivative of h
c     dhdd--density derivative of h
c   d2hdd2--second density derivative of h
c   d2hdtd--temperature-density cross derivative of h
c
c  written by M. McLinden, NIST Thermophysics Division, Boulder, Colorado
c  02-06-96  MM, original version
c  03-19-96  MM, add dipole moment to /CCON/
c  09-23-96 EWL, add density dependent shape factors
c  12-01-98 EWL, add Reos and triple point pressure and density to /CCON/
c  01-17-01 EWL, initialize values and return if t<=0
c  11-15-07 MLH, remove dead code
c
      include 'commons.for'
c
      h=0.d0
      dhdt=0.d0
      d2hdt2=0.d0
      dhdd=0.d0
      d2hdd2=0.d0
      d2hdtd=0.d0
      if (t.le.0.d0) RETURN
      i=icomp
      iref=-icomp
      Tr=t/tcrit(i)
      Dr=d/Dcrit(i)
      domega=acfecs(i)-acfref(i)
      Zrat=Zcref(i)/Zcrit(i)
c  phi is the density shape factor, not to be confused with PHI=A/RT
      phi=Zrat*(1.0d0+domega*(hecs(i,1,1)+hecs(i,2,1)*log(Tr)))
c
c  first and second (reduced) temperature derivatives of phi
      d1phi=Zrat*domega*hecs(i,2,1)/Tr
      d2phi=-Zrat*domega*hecs(i,2,1)/(Tr*Tr)
c
c  sum terms beyond those in Huber & Ely function
      if (nhecs(i).ge.3) then
        do j=3,nhecs(i)
          phi=phi+hecs(i,j,1)*Tr**hecs(i,j,2)
          d1phi=d1phi+hecs(i,j,1)*hecs(i,j,2)*Tr**(hecs(i,j,2)-1.0d0)
          d2phi=d2phi+hecs(i,j,1)*hecs(i,j,2)*(hecs(i,j,2)-1.0d0)
     &         *Tr**(hecs(i,j,2)-2.0d0)
        enddo
      end if
c
      d1phid=0.0d0
      d2phid=0.0d0
      if (nhdecs(i).gt.0) then
        do j=1,nhdecs(i)
         phi=phi+hdecs(i,j,1)*Dr**hdecs(i,j,2)
         d1phid=d1phid+hdecs(i,j,1)*hdecs(i,j,2)*Dr**(hdecs(i,j,2)-1.d0)
         d2phid=d2phid+hdecs(i,j,1)*hdecs(i,j,2)*(hdecs(i,j,2)-1.d0)
     &        *Dr**(hdecs(i,j,2)-2.d0)
        enddo
      end if
c
c  convert phi and its derivatives to 'h' and its derivatives
      Dcrat=Dcrit(iref)/Dcrit(icomp)
      h=Dcrat*phi
      dhdt=d1phi*Dcrat/tcrit(icomp)
      d2hdt2=d2phi*Dcrat/tcrit(icomp)**2
      dhdd=d1phid*Dcrat/Dcrit(icomp)
      d2hdd2=d2phid*Dcrat/Dcrit(icomp)**2
c
      RETURN
      end                                                 !subroutine HJ
c
c
c        1         2         3         4         5         6         7
c23456789012345678901234567890123456789012345678901234567890123456789012
c
c ======================================================================
c                                                    end file core_ECS.f
c ======================================================================
c  begin file core_FEQ.f
c
c  This file contains the routines implementing the Helmholtz form of
c  the pure fluid equation of state (the so-called "Fundamental Eqn").
c
c  contained here are:
c     function PHIFEQ (icomp,itau,idel,tau,del)
c     subroutine CRTFEQ (icomp,tc,pc,Dc)
c     subroutine REDFEQ (icomp,tred,Dred)
c     subroutine SETFEQ (nread,icomp,hcasno,ierr,herr)
c     subroutine SETEXP (icomp)
c     block data BDFEQ
c
c ======================================================================
c ======================================================================
c
      function PHIFEQ (icomp,itau,idel,tau,del)
c
c  compute reduced Helmholtz energy or a derivative as functions
c  of dimensionless temperature and density for the Helmholtz-explicit
c  equation of state
c
c  based on Lemmon et al., J. Chem. Eng. Data, 2009.
c
c  inputs:
c    icomp--pointer specifying component (1..nc)
c     itau--flag specifying order of temperature derivative to calc
c     idel--flag specifying order of density derivative to calculate
c           when itau = 0 and idel = 0, compute A/RT
c           when itau = 0 and idel = 1, compute 1st density derivative
c           when itau = 1 and idel = 1, compute cross derivative
c           etc.
c      tau--dimensionless temperature (To/T)
c      del--dimensionless density (D/Do)
c  output (as function value):
c      phi--residual (real-gas) part of the Helmholtz energy, or one
c           of its derivatives (as specified by itau and idel),
c           in reduced form (A/RT)
c           itau  idel    output (dimensionless for all cases)
c             0    0      A/RT
c             1    0      tau*[d(A/RT)/d(tau)]
c             2    0      tau**2*[d**2(A/RT)/d(tau)**2]
c             0    1      del*[d(A/RT)/d(del)]
c             0    2      del**2*[d**2(A/RT)/d(del)**2]
c             1    1      tau*del*[d**2(A/RT)/d(tau)d(del)]
c                         etc.
c
c  N.B.  The reducing parameters To and Do are often, but not
c        necessarily, equal to the critical temperature and density.
c
c        The Helmholtz energy consists of ideal and residual (real-gas)
c        terms; this routine calculates only the residual part.
c
c        This function computes pure component properties only.
c
c  written by M. McLinden, NIST Thermophysics Division, Boulder, Colorado
c  07-26-95  MM, original version
c  08-14-95  MM, put saved variables into common (rather than save stmt)
c  11-01-95  MM, increase parameter mxtrm to 52 (to accommodate steam)
c  11-29-95  MM, variable lower limit on coefficient/constant arrays
c                to accommodate ECS reference fluid
c  01-16-96  MM, implicit integer (i-n); (include L)
c  02-27-96  MM, parameter n0=-ncmax to accommodate ECS-thermo model
c  04-18-96  MM, apply tolerance to del=delsvf + fix bug (phi not saved)
c  10-09-96  MM, fix potential underflow on exponential term
c  01-03-97  MM, use sorted powers of tau, del, stored in tpower, etc.
c                new arrays added to /WNTFEQ/,/WLFFEQ/,/WCFFEQ/
c  01-22-97 EWL, add critical-region terms of Wagner to Helmholtz equation.
c                increase parameter mxtrm to 56 (to accommodate steam)
c  01-31-97  MM, modify commons associated with critical-region terms
c  06-03-97 EWL, add third derivative of Helmholtz energy with respect to density.
c  07-02-97 EWL, add parameter for g in exp(-g*d^l) for fluids where g<>1
c                modify /WCFFEQ/ to accommodate g parameter
c  04-06-98 EWL, change mxcrt to 8
c  04-06-98 EWL, add term li2 to /WLFFQ2/, use li2 in exponential for tau power
c  04-06-98 EWL, increase parameter mxtrm to 72 (to accommodate krypton)
c  08-11-98  MM, add third temperature derivative and third-order cross derivatives
c                N.B. these not yet implemented for critical-region terms
c  12-28-98 EWL, change arrays in CRTSAV to include icomp dependence
c   8-25-99 EWL, change the calculation of DELB and TAUA at the critical point
c   4-24-00 EWL, change the exponent of del in the EXP term from integer to
c                real*8 and modify the common blocks WCFFEQ and WLFFEQ
c   7-11-00 EWL, remove krypton pieces
c  09-00-00 EWL, add critical region terms for idel=3
c                add additional logic to return if property has already been
c                calculated.  optimize calculations to increase speed.
c                return del*d(alpha)/d(del), etc. (put the del in the calculation)
c  12-00-00 EWL, changed dli2 to tli
c  12-00-00 EWL, make dli and tli integers if delb or taua is less than zero
c  07-16-01 EWL, change check on delsvf from 10^-12 to 10^-16
c  11-04-04 OBD, add check for ex<-200
c  02-02-06 EWL, increase efficiency of code, calculation speed
c  10-19-06 EWL, remove INT in hxpf(icomp,i)=alphaf(icomp,i)*...**INT(dlif(icomp,k)), and in txpf()=...
c                it was causing calculated values for R125 to come out wrong
c  10-29-07 EWL, add 4th derivative of Helmholtz energy with respect to del^2 and tau^2
c  12-12-07 MLH, added general Helmholtz equation of Xiang and Deiters (2007)
c  09-08-09 EWL, optimize equations as given in propane publication
c  09-08-09 EWL, finished da^3/dt^2dd for the critical region terms
c
      include 'commons.for'
c
c     write (*,*) ' PHIFEQ--enter w/ tau,del = ',tau,del
c
      phifeq=0.0d0
      if (del.le.1.0d-10) RETURN  !trivial solution at zero density for
      if (tau.le.0.0d0) RETURN    !  any and all derivatives
c
      ncode=idel*4+itau+1
      if (abs(tau-tausvf(icomp)).lt.1.0d-12 .and.
     &    abs(del-delsvf(icomp)).lt.1.0d-16) then
c  retrieve value from previous call
        if (hdrvflg(icomp)(ncode:ncode).eq.'1') then
          phifeq=drvsav(icomp,ncode)
          RETURN
        endif
c       write (*,*) ' PHIFEQ--using phisvf itau,idel,tau:',itau,idel,tau
      else
c  otherwise, compute new values and save for possible future use
c  first compute needed powers of tau and del (and save for future use)
        hdrvflg(icomp)='0000000000000000'
        if (abs(tau-tausvf(icomp)).gt.1.0d-12) then
          elntau=log(tau)
          tausvf(icomp)=tau
          do j=1,ntpf(icomp)
            taup(icomp,j)=tpower(icomp,j)*elntau
c         write (*,*) ' PHIFEQ--tau,tpower: ',tau,tpower(icomp,j)
          enddo
        end if
        if (abs(del-delsvf(icomp)).gt.1.0d-16) then
          elndel=log(del)
          delsvf(icomp)=del
          do j=1,ndpf(icomp)
            delp(icomp,j)=dpower(icomp,j)*elndel
          enddo
          d2=del*del
          d3=del*d2
          d4=del*d3
          do j=1,nlpf(icomp)
            if (ABS(dlpowr(icomp,j)).lt.1.d-20) then
              delli(icomp,j)=0.0d0
            else
              if (ABS(dlpowr(icomp,j)-1.0d0).lt.1.d-20) then
                delli(icomp,j)=gif2(icomp,j)*del
              elseif (ABS(dlpowr(icomp,j)-2.0d0).lt.1.d-20) then
                delli(icomp,j)=gif2(icomp,j)*d2
              elseif (ABS(dlpowr(icomp,j)-3).lt.1.d-20) then
                delli(icomp,j)=gif2(icomp,j)*d3
              elseif (ABS(dlpowr(icomp,j)-4).lt.1.d-20) then
                delli(icomp,j)=gif2(icomp,j)*d4
              else
                delli(icomp,j)=gif2(icomp,j)*del**dlpowr(icomp,j)
              endif
            end if
          enddo
c         write (*,*) ' PHIFEQ--del,dpower: ',del,dpower(icomp,j)
c         write (*,*) ' PHIFEQ--del,dlpowr: ',del,dlpowr(icomp,j)
        end if
c
c  check for presence of critical-region terms of Wagner (e.g. steam)
c
        if (ncrt(icomp).gt.0) then
          do i=1,ncrt(icomp)
          k=i+ntermf(icomp)
          extf(icomp,i)=1.0d0
          extd(icomp,i)=0.0d0
          extd2(icomp,i)=0.0d0
          extdt(icomp,i)=0.0d0
          extt(icomp,i)=0.0d0
          extt2(icomp,i)=0.0d0
          if (abs(etaf(icomp,i)).lt.1.d-12) then
            delb(icomp,i)=del-deltaf(icomp,i)
            taua(icomp,i)=tau-gammaf(icomp,i)
            if (dlif(icomp,k).eq.2 .and. tlif(icomp,i).eq.2) then
              dxpf(icomp,i)=alphaf(icomp,i)*delb(icomp,i)
     &                   **INT(dlif(icomp,k)-1.d0)
              axpf(icomp,i)= betaf(icomp,i)*taua(icomp,i)
     &                   **INT(tlif(icomp,i)-1.d0)
            else
              dxpf(icomp,i)=alphaf(icomp,i)*delb(icomp,i)
     &                   **(dlif(icomp,k)-1.d0)
              axpf(icomp,i)= betaf(icomp,i)*taua(icomp,i)
     &                   **(tlif(icomp,i)-1.d0)
            endif
            hxpf(icomp,i)=dxpf(icomp,i)*delb(icomp,i)
            txpf(icomp,i)=axpf(icomp,i)*taua(icomp,i)
          else
            del1=del-1.0d0
            tau1=1.0d0-tau
            if (ABS(del1).lt.1.0d-10) del1=SIGN(1.0d-10,del1)
            if (ABS(tau1).lt.1.0d-10) tau1=SIGN(1.0d-10,tau1)
            delb(icomp,i)=del1
            taua(icomp,i)=tau1
            tdg=tau1+gammaf(icomp,i)*ABS(del1)**(1.0d0/betaf(icomp,i))
           extf(icomp,i)=(tdg**2+eidf(icomp,i)*(del1**2)**eitf(icomp,i))
            s=SIGN(1.0d0,del1)
            extd(icomp,i)=2.0d0*tdg*gammaf(icomp,i)/betaf(icomp,i)
     &        *ABS(del1)**(1.0d0/betaf(icomp,i)-1.0d0)*s
     &        +2.0d0*eidf(icomp,i)*eitf(icomp,i)
     &        *ABS(del1)**(2.0d0*eitf(icomp,i)-1.0d0)*s
            extd2(icomp,i)=alphaf(icomp,i)*((alphaf(icomp,i)-1.0d0)
     &        *extf(icomp,i)**(alphaf(icomp,i)-2.0d0)*extd(icomp,i)**2
     &        +extf(icomp,i)**(alphaf(icomp,i)-1.0d0)
     &        *(2.0d0*tdg*gammaf(icomp,i)/betaf(icomp,i)
     &        *(1.0d0/betaf(icomp,i)-1.0d0)
     &        *ABS(del1)**(1.0d0/betaf(icomp,i)-2.0d0)
     &        +2.0d0*(gammaf(icomp,i)/betaf(icomp,i)
     &        *ABS(del1)**(1.0d0/betaf(icomp,i)-1.0d0))**2
     &        +2.0d0*eidf(icomp,i)*eitf(icomp,i)
     &        *(2.0d0*eitf(icomp,i)-1.0d0)
     &        *ABS(del1)**(2.0d0*eitf(icomp,i)-2.0d0)))
            extdt(icomp,i)=-2.0d0*gammaf(icomp,i)/betaf(icomp,i)
     &        * ABS(del1)**(1.0d0/betaf(icomp,i)-1.0d0)*s
            extt(icomp,i)=-2.0d0*tdg
            extt2(icomp,i)=alphaf(icomp,i)*((alphaf(icomp,i)-1.0d0)
     &        *extf(icomp,i)**(alphaf(icomp,i)-2.0d0)*extt(icomp,i)**2
     &        +2.0d0*extf(icomp,i)**(alphaf(icomp,i)-1.0d0))
            extdt(icomp,i)=alphaf(icomp,i)*((alphaf(icomp,i)-1.0d0)
     &        *extf(icomp,i)**(alphaf(icomp,i)-2.0d0)
     &        *extt(icomp,i)*extd(icomp,i)
     &        +extf(icomp,i)**(alphaf(icomp,i)-1.0d0)*extdt(icomp,i))
            extd(icomp,i)=alphaf(icomp,i)
     &        *extf(icomp,i)**(alphaf(icomp,i)-1.0d0)*extd(icomp,i)
            extt(icomp,i)=alphaf(icomp,i)
     &        *extf(icomp,i)**(alphaf(icomp,i)-1.0d0)*extt(icomp,i)
            extf(icomp,i)=extf(icomp,i)**alphaf(icomp,i)
            hxpf(icomp,i)=-deltaf(icomp,i)*del1**(INT(dlif(icomp,k)))
            txpf(icomp,i)=-etaf(icomp,i)*tau1**(INT(dlif(icomp,k)))
            taua(icomp,i)=-taua(icomp,i)
          endif
          enddo
        endif
c
c  end critical-region terms
c
        phisum=0.0d0
        do k=1,ntermf(icomp)
          ex=taup(icomp,itpf(icomp,k))
     &      +delp(icomp,idpf(icomp,k))-delli(icomp,ilpf(icomp,k))
          if (ex.lt.100.d0 .and. ex.gt.-200.d0) then
            phisvf(icomp,k)=afeq(icomp,k)*EXP(ex)
          else
            phisvf(icomp,k)=0.d0
          endif
          phisum=phisum+phisvf(icomp,k)
c
c       write (*,1010) k,phisvf(icomp,k),phisum
c1010   format (1x,i3,2d30.20)   !write out each term for debugging
        enddo
        if (ncrt(icomp).gt.0) then
          do i=1,ncrt(icomp)
            k=i+ntermf(icomp)
            ex=taup(icomp,itpf(icomp,k))
     &        +delp(icomp,idpf(icomp,k))+hxpf(icomp,i)+txpf(icomp,i)
            if (.not.lcrtflg(icomp)) ex=ex+log(extf(icomp,i))
            if (ex.lt.100.d0 .and. ex.gt.-200.d0) then
              phisvf(icomp,k)=afeq(icomp,k)*EXP(ex)
            else
              phisvf(icomp,k)=0.d0
            endif
            phisum=phisum+phisvf(icomp,k)
          enddo
        endif
        phifeq=phisum
        hdrvflg(icomp)(1:1)='1'
        drvsav(icomp,1)=phifeq
      end if
c
c     write (*,1012) tau,del,itau,idel,phifeq
c1012 format (1x,' PHIFEQ--tau,del,itau,idel,phi00: ',2f10.5,2i4,e22.12)
c
c  check if derivatives are requested, calculations make use of fact
c  that terms in derivative summations are very similar to A/RT terms
c
      if (idel.eq.1) then
c  compute derivative w.r.t. del (dimensionless density)
c  save individual terms for possible use in cross derivative
        phisum=0.0d0
        do k=1,ntermf(icomp)
          phir01(k)=phisvf(icomp,k)
     &            *(difeq(icomp,k)
     &            -dlif(icomp,k)*delli(icomp,ilpf(icomp,k)))
          phisum=phisum+phir01(k)
        enddo
c  check for presence of critical-region terms
        if (ncrt(icomp).gt.0) then
          do i=1,ncrt(icomp)
            k=i+ntermf(icomp)
            if (abs(etaf(icomp,i)).lt.1.d-12) then
              phir01(k)=phisvf(icomp,k)
     &                *(difeq(icomp,k)+dlif(icomp,k)*del*dxpf(icomp,i))
            else
              phir01(k)=phisvf(icomp,k)/extf(icomp,i)
     &                *(extf(icomp,i)*(difeq(icomp,k)
     &                +dlif(icomp,k)*del*hxpf(icomp,i)/delb(icomp,i))
     &                +extd(icomp,i)*del)
            endif
            phisum=phisum+phir01(k)
          enddo
        endif
        phifeq=phisum
c
      else if (idel.eq.2) then
c  compute 2nd derivative w.r.t. del (dimensionless density)
c  save individual terms for possible use in cross derivative
        phisum=0.0d0
        do k=1,ntermf(icomp)
          dik=difeq(icomp,k)
          dell=dlif(icomp,k)*delli(icomp,ilpf(icomp,k))
          phir02(k)=phisvf(icomp,k)
     &            *((dik-dell)*(dik-1.d0-dell)-dlif(icomp,k)*dell)
          phisum=phisum+phir02(k)
        enddo
c  check for presence of critical-region terms
        if (ncrt(icomp).gt.0) then
          do i=1,ncrt(icomp)
            k=i+ntermf(icomp)
            dik=difeq(icomp,k)
            if (abs(etaf(icomp,i)).lt.1.d-12) then
              dl=dlif(icomp,k)
              dlb=1.d0
              if (dl.ne.2.d0) dlb=delb(icomp,i)**(dl-2.d0)
              phir02(k)=phisvf(icomp,k)*((dik+dl*del*dxpf(icomp,i))**2
     &                -dik-(dl-dl**2)*del**2*alphaf(icomp,i)*dlb)
            else
              d2=del**2
              dell=dlif(icomp,k)*hxpf(icomp,i)/delb(icomp,i)
              phir02(k)=phisvf(icomp,k)/extf(icomp,i)
     &            *(d2*(extd2(icomp,i)+extd(icomp,i)*(dik/del+dell)
     &            +extf(icomp,i)*(-dik/d2+dell*(dlif(icomp,k)-1.0d0)
     &            /delb(icomp,i)))
     &            +(extd(icomp,i)+extf(icomp,i)*(dik/del+dell))
     &            *(dik*del+d2*dell))
            endif
            phisum=phisum+phir02(k)
          enddo
        endif
        phifeq=phisum
c
      else if (idel.eq.3) then
c  compute 3rd derivative w.r.t. del (dimensionless density)
        phisum=0.0d0
        do k=1,ntermf(icomp)
          dik=difeq(icomp,k)
          dell=dlif(icomp,k)*delli(icomp,ilpf(icomp,k))
          dl=dlif(icomp,k)
          phir03(k)=phisvf(icomp,k)
     &     *(dik*(2.d0-3.d0*dik+dik**2)
     &     +dell*(-2.d0+6.d0*dik-3.d0*dik**2-3.d0*dik*dl+3.d0*dl-dl**2
     &     +dell*(3.d0*(dl+dik-1.d0)-dell)))
          phisum=phisum+phir03(k)
        enddo
c  check for presence of critical-region terms, note that the extended
c  terms (non-Gaussian) in the critical region are not included here.
        if (ncrt(icomp).gt.0) then
          do i=1,ncrt(icomp)
            if (abs(etaf(icomp,i)).lt.1.d-12) then
              k=i+ntermf(icomp)
              dik=difeq(icomp,k)
              dl=dlif(icomp,k)
              dlb=del**2*alphaf(icomp,i)
              dlb2=0.d0
              if (dl.ne.2.d0) then
                dlb2=-dlb*del*(3.d0*dl**2-dl**3-2.d0*dl)
     &                *delb(icomp,i)**(dl-3.d0)
                dlb=dlb*delb(icomp,i)**(dl-2.d0)
              endif
              phir03(k)=phisvf(icomp,k)*((dik+dl*del*dxpf(icomp,i))**3
     &                -3.d0*dik**2+2.d0*dik+dlb2
     &                -3.d0*(dl-dl**2)*dik*dlb
     &                -3.d0*del*dxpf(icomp,i)
     &              *(dik*dl-(dl**3-dl**2)*dlb))
            else
              phir03(k)=0.d0
            endif
            phisum=phisum+phir03(k)
          enddo
        endif
        phifeq=phisum
      end if
c
c
      if (itau.eq.1) then
c  compute derivative w.r.t. tau (dimensionless temperature)
c  save individual terms for possible use in cross derivative
        phisum=0.0d0
        do k=1,ntermf(icomp)
          phir10(k)=phisvf(icomp,k)*tifeq(icomp,k)
          phisum=phisum+phir10(k)
        enddo
c  check for presence of critical-region terms
        if (ncrt(icomp).gt.0) then
          do i=1,ncrt(icomp)
            k=i+ntermf(icomp)
            if (abs(etaf(icomp,i)).lt.1.d-12) then
              phir10(k)=phisvf(icomp,k)
     &                *(tifeq(icomp,k)+tlif(icomp,i)*tau*axpf(icomp,i))
            else
              phir10(k)=phisvf(icomp,k)*(tifeq(icomp,k)
     &              +tau*tlif(icomp,i)*txpf(icomp,i)/taua(icomp,i)
     &              +tau*extt(icomp,i)/extf(icomp,i))
            endif
            phisum=phisum+phir10(k)
          enddo
        endif
        phifeq=phisum
c
      else if (itau.eq.2) then
c  compute 2nd derivative w.r.t. tau (dimensionless temperature)
c  save individual terms for possible use in cross derivative
        phisum=0.0d0
        do k=1,ntermf(icomp)
          tik=tifeq(icomp,k)
          phir20(k)=phisvf(icomp,k)*tik*(tik-1.0d0)
          phisum=phisum+phir20(k)
        enddo
c  check for presence of critical-region terms
        if (ncrt(icomp).gt.0) then
          do i=1,ncrt(icomp)
            k=i+ntermf(icomp)
            tik=tifeq(icomp,k)
            if (abs(etaf(icomp,i)).lt.1.d-12) then
              tl=tlif(icomp,i)
              tlb=1.d0
              if (tl.ne.2.d0) tlb=taua(icomp,i)**(tl-2.d0)
              phir20(k)=phisvf(icomp,k)*((tik+tl*tau*axpf(icomp,i))**2
     &                -tik-(tl-tl**2)*tau**2*betaf(icomp,i)*tlb)
            else
              t2=tau**2
              tauu=tlif(icomp,i)*txpf(icomp,i)/taua(icomp,i)
              phir20(k)=phisvf(icomp,k)*(t2
     &            *(extt2(icomp,i)+extt(icomp,i)*(tik/tau+tauu)
     &            +extf(icomp,i)*(-tik/t2+tauu*(tlif(icomp,i)-1.0d0)
     &            /taua(icomp,i)))
     &            +(extt(icomp,i)+extf(icomp,i)*(tik/tau+tauu))
     &            *(tik*tau+t2*tauu))/extf(icomp,i)
            endif
            phisum=phisum+phir20(k)
          enddo
        endif
        phifeq=phisum
c
      else if (itau.eq.3) then
c  compute 3rd derivative w.r.t. tau (dimensionless temperature)
        phisum=0.0d0
        do k=1,ntermf(icomp)
          tik=tifeq(icomp,k)
          phisum=phisum+phisvf(icomp,k)*tik*(tik-1.d0)*(tik-2.d0)
        enddo
        if (ncrt(icomp).gt.0) then
          do i=1,ncrt(icomp)
            if (abs(etaf(icomp,i)).lt.1.d-12) then
              k=i+ntermf(icomp)
              tik=tifeq(icomp,k)
              tl=tlif(icomp,i)
              tlb=tau**2*betaf(icomp,i)
              tlb2=0.d0
              if (tl.ne.2.d0) then
                tlb2=-tlb*tau*(3.d0*tl**2-tl**3-2.d0*tl)
     &                *taua(icomp,i)**(tl-3.d0)
                tlb=tlb*taua(icomp,i)**(tl-2.d0)
              endif
              phir30(k)=phisvf(icomp,k)*((tik+tl*tau*axpf(icomp,i))**3
     &                -3.d0*tik**2+2.d0*tik+tlb2
     &                -3.d0*(tl-tl**2)*tik*tlb
     &                -3.d0*tau*axpf(icomp,i)
     &              *(tik*tl-(tl**3-tl**2)*tlb))
              phisum=phisum+phir30(k)
            else
              phir30(k)=0.d0
            endif
          enddo
        endif
        phifeq=phisum
      end if
c
c
      if (itau.eq.1 .and. idel.eq.1) then
c  compute cross derivative using terms from 1st derivatives
        phisum=0.0d0
        do k=1,ntermf(icomp)
          if (ABS(phisvf(icomp,k)).gt.1.0d-20)
     &      phisum=phisum+phir10(k)*phir01(k)/phisvf(icomp,k)
        enddo
        if (ncrt(icomp).gt.0) then
          do i=1,ncrt(icomp)
            k=i+ntermf(icomp)
            if (abs(etaf(icomp,i)).lt.1.d-12) then
              if (ABS(phisvf(icomp,k)).gt.1.0d-20)
     &          phisum=phisum+phir10(k)*phir01(k)/phisvf(icomp,k)
            else
              phisum=phisum+(tifeq(icomp,k)+tau*tlif(icomp,i)
     &           *txpf(icomp,i)/taua(icomp,i))*phir01(k)
     &           +phisvf(icomp,k)/extf(icomp,i)*(del*tau*extdt(icomp,i)
     &           +tau*extt(icomp,i)*(difeq(icomp,k)
     &           +del*dlif(icomp,k)*hxpf(icomp,i)/delb(icomp,i)))
            endif
          enddo
        endif
        phifeq=phisum
c
      else if (itau.eq.2 .and. idel.eq.1) then
c  compute cross derivative using term from 1st derivative
        phisum=0.0d0
        do k=1,ntermf(icomp)+ncrt(icomp)
          if (ABS(phisvf(icomp,k)).gt.1.0d-20)
     &      phisum=phisum+phir20(k)*phir01(k)/phisvf(icomp,k)
        enddo
        phifeq=phisum
c
      else if (itau.eq.1 .and. idel.eq.2) then
c  compute cross derivative using term from 2nd derivative
        phisum=0.0d0
        do k=1,ntermf(icomp)+ncrt(icomp)
          if (ABS(phisvf(icomp,k)).gt.1.0d-20)
     &      phisum=phisum+phir10(k)*phir02(k)/phisvf(icomp,k)
        enddo
        phifeq=phisum
c
      else if (itau.eq.2 .and. idel.eq.2) then
c  compute cross derivative using terms from 2nd derivative
        phisum=0.0d0
        do k=1,ntermf(icomp)+ncrt(icomp)
          if (ABS(phisvf(icomp,k)).gt.1.0d-20)
     &      phisum=phisum+phir20(k)*phir02(k)/phisvf(icomp,k)
        enddo
        phifeq=phisum
      end if
c
c     write (*,1021) tau,del,itau,idel,phifeq
c1021 format (1x,' PHIFEQ--tau,del,itau,idel,phixx: ',2f10.5,2i4,e22.12)
c
      drvsav(icomp,ncode)=phifeq
      hdrvflg(icomp)(ncode:ncode)='1'
c
      RETURN
      end                                               !function PHIFEQ
c
c ======================================================================
c
      subroutine CRTFEQ (icomp,tc,pc,Dc)
c
c  returns critical parameters associated with Fundamental EOS
c
c  N.B.  these critical parameters may not necessarily be most
c        accurate values, but they are consistent with the EOS fit;
c        neither are they always equal to the reducing parameters
c
c  input:
c    icomp--pointer specifying component (1..nc)
c  outputs:
c    tc--critical temperature (K)
c    pc--critical pressure (kPa)
c    Dc--molar density (mol/L) at critical point
c
c  written by M. McLinden, NIST Thermophysics Division, Boulder, Colorado
c  08-03-95  MM, original version
c  11-01-95  MM, increase parameter mxtrm to 52 (to accommodate steam)
c  11-29-95  MM, variable lower limit on coefficient/constant arrays
c                to accommodate ECS reference fluid
c  01-16-96  MM, implicit integer (i-n); (include L)
c  02-27-96  MM, parameter n0=-ncmax to accommodate ECS-thermo model
c  01-03-97  MM, new arrays added to /WCFFEQ/ (assoc w/ sorting of powers)
c  07-02-97 EWL, modify /WCFFEQ/ to accommodate g parameter
c
      include 'commons.for'
c
      tc=tcfeq(icomp)
      pc=pcfeq(icomp)
      Dc=rhocfeq(icomp)
c
      RETURN
      end                                             !subroutine CRTFEQ
c
c ======================================================================
c
      subroutine REDFEQ (icomp,tred,Dred)
c
c  returns reducing parameters associated with Fundamental EOS;
c  used to calculate the 'tau' and 'del' which are the independent
c  variables in the EOS
c
c  N.B.  The reducing parameters are often, but not always, equal
c        to the critical temperature and density.
c
c  input:
c    icomp--component number in mixture (1..nc); 1 for pure fluid
c  outputs:
c     tred--reducing temperature (K)
c     Dred--reducing molar density (mol/L)
c
c  written by M. McLinden, NIST Thermophysics Division, Boulder, Colorado
c  08-03-95  MM, original version
c  11-01-95  MM, increase parameter mxtrm to 52 (to accommodate steam)
c  11-29-95  MM, variable lower limit on coefficient/constant arrays
c                to accommodate ECS reference fluid
c  01-16-96  MM, implicit integer (i-n); (include L)
c  02-27-96  MM, parameter n0=-ncmax to accommodate ECS-thermo model
c  01-03-97  MM, new arrays added to /WCFFEQ/ (assoc w/ sorting of powers)
c  07-02-97 EWL, modify /WCFFEQ/ to accommodate g parameter
c
      include 'commons.for'
c
c     write (*,*) ' REDFEQ, i,t0,rho0: ',icomp,t0feq(icomp),rho0feq(icomp)
      tred=t0feq(icomp)
      Dred=rho0feq(icomp)
c
      RETURN
      end                                             !subroutine REDFEQ
c
c ======================================================================
c
      subroutine SETFEQ (nread,icomp,hcasno,ierr,herr)
c
c  set up working arrays for use with Fundamental equation of state
c
c  inputs:
c    nread--file to read data from
c           <= 0 get data from block data
c           >0 read from logical unit nread (file should have already
c              been opened and pointer set by subroutine SETUP)
c    icomp--component number in mixture (1..nc); 1 for pure fluid
c   hcasno--CAS number of component icomp (not req'd if reading from file)
c
c  outputs:
c     ierr--error flag:  0 = successful
c                        1 = error (e.g. fluid not found)
c     herr--error string (character*255 variable if ierr<>0)
c     other quantities returned via arrays in common /WCFFEQ/
c
c  written by M. McLinden, NIST Thermophysics Division, Boulder, Colorado
c  07-20-95  MM, original version
c  09-13-95  MM, add ierr, herr to argument list
c  10-05-95  MM, adapt to file input, add nread to argument list
c  11-01-95  MM, increase parameter mxtrm to 52 (to accommodate steam)
c  11-02-95  MM, add common /CCAS/ to access CAS numbers
c  11-29-95  MM, variable lower limit on coefficient/constant arrays
c                to accommodate ECS reference fluid
c  01-16-96  MM, implicit integer (i-n); (include L)
c  02-27-96  MM, parameter n0=-ncmax to accommodate ECS-thermo model
c                add Zcrit to common /CCON/
c  03-19-96  MM, add dipole moment to /CCON/ and /MSCFEQ/
c  06-03-96  MM, add limits to /EOSLIM/, reduce mxfeq from 20 to 2
c  01-03-97  MM, sort powers of tau, del, store in tpower, etc.
c                new arrays added to /WNTFEQ/,/WLFFEQ/,/WCFFEQ/
c  01-22-97 EWL, add variables for critical region for methane and water.
c  01-31-97  MM, modify commons associated with critical-region terms
c  02-06-97  MM, if steam, reset gas constant to fluid-specific value
c  02-07-97  MM, fix bug in reading of critical terms
c  05-27-97  MM, if nc = 1, set R to fluid-specific value
c  07-02-97 EWL, add parameter for g in exp(-g*d^l) for fluids where g<>1
c                modify /WCFFEQ/ to accommodate g parameter
c  11-13-97  MM, (re)initialize contents of /FEQSAV/ when a new fluid is read in
c  02-11-98  MM, store rho at triple point separate from rhomax
c  04-06-98 EWL, add check for change in exponential coefficient (gi)
c  04-06-98 EWL, change mxcrt to 8
c  04-06-98 EWL, read in powers of del and tau in exponential for critical terms
c  12-01-98 EWL, add Reos and triple point pressure and density to /CCON/
c  12-22-98 EWL, set Reos to Rfeq
c   4-24-00 EWL, change the exponent of del in the EXP term from integer to
c                real*8 and modify the common blocks WCFFEQ and WLFFEQ
c
      include 'commons.for'
      character*3 hcpfeqa
      character*12 hcasa,hcasno
      character*255 herr
c  commons associated with the mxfeq fluids with FEQ equations stored
c  in block data BDFEQ
      common /CASFEQ/ hcasa(mxfeq)
      common /CPMFEQ/ hcpfeqa(mxfeq)
      common /NTFEQ/ ntermfa(mxfeq)
      common /LFFEQ/ dlia(mxfeq,mxtrm)
      common /CFFEQ/ aa(mxfeq,mxtrm),dia(mxfeq,mxtrm),tia(mxfeq,mxtrm),
     &               rho0a(mxfeq),t0a(mxfeq),
     &               pca(mxfeq),rhoca(mxfeq),tca(mxfeq),
     &               wmfa(mxfeq),Rfeqa(mxfeq),
     &               pmina(mxfeq),rhomxa(mxfeq),tmina(mxfeq),
     &               tmaxa(mxfeq),pmaxa(mxfeq)
      common /MSCFEQ/ ttpa(mxfeq),tnbpa(mxfeq),accena(mxfeq),dipa(mxfeq)
c
      ierr=0
      lcrtflg(icomp)=.true.
      herr=' '
c  (re)initialize contents of /FEQSAV/ when a new fluid is read in
      do i=n0,nx
        delsvf(i)=0.0d0
        tausvf(i)=0.0d0
        do j=1,mxtrm
          phisvf(i,j)=0.0d0
          taup(i,j)=0.0d0
          delp(i,j)=0.0d0
          delli(i,j)=0.0d0
        enddo
      enddo
c
      if (nread.le.0) then
c  get coefficients from block data
c  identify specified fluid with entries in database via match of CAS no
        do i=1,mxfeq
        if (hcasno.eq.hcasa(i)) then
C          hmodcp(icomp)=hcpfeqa(i)   ! pointer to ideal gas model
C          ntermf(icomp)=ntermfa(i)   ! number of terms
C          do j=1,ntermf(icomp)
C          dlif(icomp,j)=dlia(i,j)      ! transfer coefficients
C          a(icomp,j)=aa(i,j)        ! into working arrays
C          difeq(icomp,j)=dia(i,j)
C          tifeq(icomp,j)=tia(i,j)
C          enddo
C          rho0feq(icomp)=rho0a(i)      ! reducing parameters
C          t0feq(icomp)=t0a(i)
C          rhoz(icomp)=rho0a(i)      ! reducing parameters
C          tz(icomp)=t0a(i)
C          pcfeq(icomp)=pca(i)          ! critical parameters
C          rhocfeq(icomp)=rhoca(i)
C          tcfeq(icomp)=tca(i)
C          wmfeq(icomp)=wmfa(i)        ! molecular weight
C          Rfeq(icomp)=Rfeqa(i)      ! gas constant
C          if (nc.eq.1 .and. icomp.eq.1) then
C            R=Rfeq(icomp)
C          end if
C          Reos(icomp)=Rfeq(icomp)
C          pminfeq(icomp)=pmina(i)      ! limits
C          Deos(icomp)=rhomxa(i)
C          rhotpfeq(icomp)=rhomxa(i)
C          tminfeq(icomp)=tmina(i)
C          tmaxfeq(icomp)=tmaxa(i)
C          pmaxfeq(icomp)=pmaxa(i)
C          ncoeff(icomp)=4           !# coeff per term
C          ncrt(icomp)=0             !no critical-region terms
C          nsparf(icomp)=0
Cc  fill arrays in /CCON/
C          wmas(icomp)=wmfa(i)
C          ttpn(icomp)=ttpa(i)
C          tnbp(icomp)=tnbpa(i)
C          tcrit(icomp)=tcfeq(icomp)
C          pcrit(icomp)=pcfeq(icomp)
C          Dcrit(icomp)=rhocfeq(icomp)
C          Zcrit(icomp)=pcfeq(icomp)/(Rfeq(icomp)*tcfeq(icomp)*rhocfeq(icomp))
C          accen(icomp)=accena(i)
C          dipole(icomp)=dipa(i)
C          goto 990
        end if
        enddo
        ierr=1
        herr='[SETFEQ error] fluid input to SETFEQ not found'//hnull
      else
c  read data from file
c       write (*,*) ' SETFEQ--read component',icomp,' from unit',nread
        read (nread,*) tminfeq(icomp)   !lower temperature limit
c       write (*,*) ' SETFEQ--first input: tmin: ',tminfeq(icomp)
        read (nread,*) tmaxfeq(icomp)   !upper temperature limit
        read (nread,*) pmaxfeq(icomp)   !upper pressure limit
        read (nread,*) Deos(icomp)      !upper density limit
        read (nread,2003) hmodcp(icomp) !pointer to Cp0 model
        read (nread,*) wmas(icomp)      !molecular weight
        wmfeq(icomp)=wmas(icomp)
        read (nread,*) ttpn(icomp)      !triple point temperature
        read (nread,*) pminfeq(icomp)   !pressure at triple point
        read (nread,*) rhotpfeq(icomp)  !density at triple point
        read (nread,*) tnbp(icomp)      !normal boiling point temperature
        read (nread,*) accen(icomp)     !acentric factor
        read (nread,*) tcfeq(icomp),pcfeq(icomp),rhocfeq(icomp) !critical par
        tcrit(icomp)=tcfeq(icomp)
        pcrit(icomp)=pcfeq(icomp)
        Dcrit(icomp)=rhocfeq(icomp)
        ptpn(icomp)=pminfeq(icomp)
        dtpn(icomp)=rhotpfeq(icomp)
        dtpv(icomp)=0.0d0
        dnbpl(icomp)=0.0d0
        dnbpv(icomp)=0.0d0
        read (nread,*) t0feq(icomp),rho0feq(icomp) !reducing parameters
        tz(icomp)=t0feq(icomp)
        rhoz(icomp)=rho0feq(icomp)
        read (nread,*) Rfeq(icomp)    !gas constant used in fit
        if (nc.eq.1 .and. icomp.eq.1) then
          R=Rfeq(icomp)
c         write (*,*) ' SETFEQ--R set to ',R
        end if
        Reos(icomp)=Rfeq(icomp)
       Zcrit(icomp)=pcrit(icomp)/(Rfeq(icomp)*tcrit(icomp)*dcrit(icomp))
        read (nread,*) nterm,ncoeff(icomp),ncrt(icomp),ncfcrt(icomp),
     &                 nsparf(icomp),ncfsp(icomp)
        ntermf(icomp)=nterm
c       write (*,*) ' SETFEQ--about to read ',nterm,' coefficients'
c  the gi term is a multiplier for the (rho or del) in only the exponential
c  terms; it is needed for e.g. the Bender EOS; set to 1.0 if not present
        do j=1,nterm
          if (ncoeff(icomp).eq.5) then
          read (nread,*) afeq(icomp,j),tifeq(icomp,j),difeq(icomp,j),
     &                   dlif(icomp,j),gif1(icomp,j)
          else
          read (nread,*) afeq(icomp,j),tifeq(icomp,j),difeq(icomp,j),
     &                   dlif(icomp,j)
          gif1(icomp,j)=1.d0
          endif
        enddo
        if (ncrt(icomp).gt.0) then
        do j=1,ncrt(icomp)
          gif1(icomp,j+nterm)=0.d0
          read (nread,*) afeq(icomp,j+nterm),tifeq(icomp,j+nterm),
     &       difeq(icomp,j+nterm),dlif(icomp,j+nterm),tlif(icomp,j),
     &       alphaf(icomp,j),betaf(icomp,j),
     &       gammaf(icomp,j),deltaf(icomp,j),
     &       etaf(icomp,j),eidf(icomp,j),eitf(icomp,j)
          if (abs(etaf(icomp,j)).gt.1.d-20 .and.
     &        abs(eidf(icomp,j)).gt.1.d-20 .and.
     &        abs(eitf(icomp,j)).gt.1.d-20) lcrtflg(icomp)=.false.
        enddo
        end if
c       write (*,*) ' SETFEQ--final coefficient: ',afeq(icomp,nterm)
      end if
c
c 990 continue
c
      call SETEXP(icomp)
c
c  write out all coefficients for debugging
c
c     i=icomp
c     write (*,*) ' SETFEQ--coefficients for comp',i,', CAS # ',hcas(i)
c     write (*,*) ' Cp0 model: ',hmodcp(i)
c     write (*,*) ' Nterms :   ',ntermf(i)
c     write (*,2020)((afeq(i,j),tifeq(i,j),difeq(i,j),dlif(i,j)),j=1,ntermf(i))
c2020 format (1x,d24.14,2f9.3,i4)
c
c     write (*,*) ' SETFEQ--sorted coefs for comp',i,', CAS # ',hcas(i)
c     write (*,2020) ((afeq(i,j),tpower(i,itpf(i,j)),dpower(i,idpf(i,j)),
c    &               dlpowr(i,ilpf(i,j))),j=1,ntermf(i))
c
c  copy limits into /EOSLIM/ arrays
      tmeos(icomp)=tminfeq(icomp)
      txeos(icomp)=tmaxfeq(icomp)
      peos(icomp)=pmaxfeq(icomp)
c     Deos(icomp)=dmaxecs(icomp)
c
      RETURN
 2003 format (a3)
      end                                             !subroutine SETFEQ
c
c ======================================================================
c
      subroutine SETEXP (icomp)
c
c  scan and sort exponents to minimize computations;
c  the array tpower --stores the discrete powers of temperature
c                itp--is a pointer to the appropriate element of tpower
c        dpower, dtp--ditto for density
c        dlpowr, ltp--ditto for the powers of del in the exp terms
c  ntp, ndp, and nlp store the number of entries in the above arrays
c
c  inputs:
c    icomp--component number in mixture (1..nc); 1 for pure fluid
c
c  written by M. McLinden, NIST Thermophysics Division, Boulder, Colorado
c  07-20-95  MM, original version
c   9-18-00 EWL, remove section of code from SETFEQ and place in new
c                subroutine SETEXP so that fitting routines can call it.
c
      include 'commons.for'
c
      tpower(icomp,1)=tifeq(icomp,1)
      dpower(icomp,1)=difeq(icomp,1)
      dlpowr(icomp,1)=dlif(icomp,1)
      gif2(icomp,1)=gif1(icomp,1)
      ntpf(icomp)=1
      ndpf(icomp)=1
      nlpf(icomp)=1
c
      do i=1,ntermf(icomp)+ncrt(icomp)
c  compare the power of temperature for each term with elements
c  already in the tpower array
        do j=1,ntpf(icomp)
          if (abs(tifeq(icomp,i)-tpower(icomp,j)).lt.1.0d-10) then
            itpf(icomp,i)=j
            goto 100
          end if
        enddo
c  power of temperature for term i does not match any previous term
        ntpf(icomp)=ntpf(icomp)+1
        tpower(icomp,ntpf(icomp))=tifeq(icomp,i)
        itpf(icomp,i)=ntpf(icomp)
 100    continue
c  compare the power of density for each term with elements
c  already in the dpower array
        do j=1,ndpf(icomp)
          if (abs(difeq(icomp,i)-dpower(icomp,j)).lt.1.0d-10) then
            idpf(icomp,i)=j
            goto 110
          end if
        enddo
c  power of density for term i does not match any previous term
        ndpf(icomp)=ndpf(icomp)+1
        dpower(icomp,ndpf(icomp))=difeq(icomp,i)
        idpf(icomp,i)=ndpf(icomp)
 110    continue
c  compare the power of density in exponential terms with elements
c  already in the dlpowr array
        do j=1,nlpf(icomp)
          if (ABS(dlif(icomp,i)-dlpowr(icomp,j)).lt.1.0d-10 .and.
     &        abs(gif1(icomp,i)-gif2(icomp,j)).lt.1.0d-10) then
            ilpf(icomp,i)=j
            goto 120
          end if
        enddo
c  exponential of density for term i does not match any previous term
        nlpf(icomp)=nlpf(icomp)+1
        dlpowr(icomp,nlpf(icomp))=dlif(icomp,i)
        ilpf(icomp,i)=nlpf(icomp)
        gif2(icomp,nlpf(icomp))=gif1(icomp,i)
 120    continue
      enddo
      end                                             !subroutine SETEXP
cc
cc ======================================================================
cc
c      block data BDFEQ
cc
cc  data for Helmholtz-explicit equations of state
cc
cc  explanation of parameters
cc     mxfeq:       maximum number of FEQ fits, used to dimension arrays
cc     mxtrm:       max number of terms per fit, used to dimension arrays
cc
cc  explanation of commons and constituent arrays
cc    /CASFEQ/      Chem Abstract number; used as unambiguous identifier
cc        hcas(i):  CAS number for fluid corresponding to equation "i"
cc
cc    /CPMFEQ/
cc      hmodcp(i):  pointer to ideal gas model to use with fluid "i"
cc
cc    /NTFEQ/
cc      ntermf(i):  number of terms in fit corresponding to fluid "i"
cc
cc    /LFFEQ/   parameters to FEQ fits for each of mxfeq fluids
cc      dlif(i,1..N): power of del in the exponential multiplier
cc                  (if dlif(j)=0, then multiplier = 1)
cc
cc    /CFFEQ/   parameters to FEQ fits for each of mxfeq fluids
cc      afeq(i,1..N):  N coefficients to "fundamental" equation of state
cc      difeq(i,1..N): exponents for the N density terms
cc      tifeq(i,1..N): exponents for the N temperature terms
cc      rho0feq(i):    reducing parameter for density (mol/L)
cc      t0feq(i):      reducing parameter for temperature (K)
cc      pcfeq(i):      critical pressure (kPa)
cc      rhocfeq(i):    critical density (L/mol)
cc      tcfeq(i):      critical temperature (K)
cc      wmfeq(i):      molecular weight (g/mol)
cc      Rfeq(i):       gas constant used in fit (J/(mol-K))
cc      pminfeq(i):    pressure at tminfeq(i) (kPa)
cc      rhotpfeq(i):   density at tminfeq(i), e.g. triple point (L/mol)
cc      tminfeq(i):    low temperature limit of fit--often triple point
cc                     pminfeq(i),rhotpfeq(i) are used for initial guesses, etc.
cc                     and are often approximate values only
cc      tmaxfeq(i):    upper temperature limit of fit (K)
cc      pmaxfeq(i):    upper pressure limit of fit (kPa)
cc
cc    /MSCFEQ/  miscellaneous fluid constants
cc      ttpf(i):    triple point temperature (K)
cc      tnbpf(i):   normal boiling point temperature (K)
cc      accenf(i):  acentric factor for fluid represented by eqn "i"
cc      dipm(i):    dipole moment [debye] (at Tnbp if t-dependent)
cc
cc    /FEQSAV/  used to save information between calls to PHIFEQ
cc      phisvf(i,j):individual terms in summation
cc      delsvf(i):  reduced density on last call to PHIFEQ
cc      tausvf(i):  reduced temperature on last call to PHIFEQ
cc      taup(i,j):  reduced temperature raised to power
cc      delp(i,j):  reduced density raised to power
cc
cc    where "i" is the equation number
cc    N.B.--the "i" are, in general, not the same as fluid code numbers
cc
cc
cc  written by M. McLinden, NIST Thermophysics Division, Boulder, Colorado
cc  07-26-95  MM, original version
cc  10-03-95  MM, /CPMFEQ/ changed to character variable
cc  11-01-95  MM, increase parameter mxtrm to 52 (to accommodate steam)
cc  11-29-95  MM, variable lower limit on coefficient/constant arrays
cc                to accommodate ECS reference fluid
cc  01-16-96  MM, implicit integer (i-n); (include L)
cc  02-27-96  MM, parameter n0=-ncmax to accommodate ECS-thermo model
cc  01-03-97  MM, arrays added to /FEQSAV/ (assoc with sorting of powers)
cc
c      include 'commons.for'
c      parameter (mxfeq=2)        !max number of FEQ EOS in block data
c      parameter (nsave=(nx-n0+1)*(mxtrm+1))
c      parameter (nsave1=(nx-n0+1)*mxtrm)
c      parameter (nxsav=nx-n0+1)
c      character*3 hcpfeqa
c      character*12 hcasa
c      common /CASFEQ/ hcasa(mxfeq)
c      common /CPMFEQ/ hcpfeqa(mxfeq)
c      common /NTFEQ/ ntermfa(mxfeq)
c      common /LFFEQ/ dlia(mxfeq,mxtrm)
c      common /CFFEQ/ aa(mxfeq,mxtrm),dia(mxfeq,mxtrm),tia(mxfeq,mxtrm),
c     &               rho0a(mxfeq),t0a(mxfeq),
c     &               pca(mxfeq),rhoca(mxfeq),tca(mxfeq),
c     &               wmfa(mxfeq),Rfeqa(mxfeq),
c     &               pmina(mxfeq),rhomxa(mxfeq),tmina(mxfeq),
c     &               tmaxa(mxfeq),pmaxa(mxfeq)
c      common /MSCFEQ/ ttpa(mxfeq),tnbpa(mxfeq),accena(mxfeq),
c     &                dipa(mxfeq)
cc
c      data phisvf /nsave*0.0d0/
c      data delsvf /nxsav*0.0d0/
c      data tausvf /nxsav*0.0d0/
c      data taup /nsave1*0.0d0/
c      data delp /nsave1*0.0d0/
c      data delli /nsave1*0.0d0/
cc
cc
cc  R134a  1,1,1,2-tetrafluoroethane
c      data hcasa(1) /'811-97-2'/
cc  use polynomial Cp0 model (at least for now)
c      data hcpfeqa(1) /'CPP'/
c      data ntermfa(1) /21/
c      data (aa(1,j),j=1,21)/
c     &  0.5586817d-01,  0.4982230d+00,  0.2458698d-01,  0.8570145d-03,
c     &  0.4788584d-03, -0.1800808d+01,  0.2671641d+00, -0.4781652d-01,
c     &  0.1423987d-01,  0.3324062d+00, -0.7485907d-02,  0.1017263d-03,
c     & -0.5184567d+00, -0.8692288d-01,  0.2057144d+00, -0.5000457d-02,
c     &  0.4603262d-03, -0.3497836d-02,  0.6995038d-02, -0.1452184d-01,
c     & -0.1285458d-03/
cc  exponents for density terms
c      data (dia(1,j),j=1,21)/
c     &       2.00d+00,       1.00d+00,       3.00d+00,       6.00d+00,
c     &       6.00d+00,       1.00d+00,       1.00d+00,       2.00d+00,
c     &       5.00d+00,       2.00d+00,       2.00d+00,       4.00d+00,
c     &       1.00d+00,       4.00d+00,       1.00d+00,       2.00d+00,
c     &       4.00d+00,       1.00d+00,       5.00d+00,       3.00d+00,
c     &      10.00d+00/
cc  exponents for temperature terms
c      data (tia(1,j),j=1,21)/
c     &      -0.50d+00,       0.00d+00,       0.00d+00,       0.00d+00,
c     &       1.50d+00,       1.50d+00,       2.00d+00,       2.00d+00,
c     &       1.00d+00,       3.00d+00,       5.00d+00,       1.00d+00,
c     &       5.00d+00,       5.00d+00,       6.00d+00,      10.00d+00,
c     &      10.00d+00,      10.00d+00,      18.00d+00,      22.00d+00,
c     &      50.00d+00/
cc  power of (-del) in the exponential multiplier
c      data (dlia(1,j),j=1,21)/
c     &       0,              0,              0,              0,
c     &       0,              0,              0,              0,
c     &       1,              1,              1,              2,
c     &       2,              2,              2,              2,
c     &       2,              3,              3,              3,
c     &       4/
cc
c      data rho0a(1),t0a(1)
c     &  /4.978830171d0,374.18d0/          ! reducing parameters
c      data pca(1),rhoca(1),tca(1)
c     &  /4059.28d0,5.017053d0,374.21d0/   ! critical parameters
c      data wmfa(1),Rfeqa(1)
c     &  /102.032d0,8.314471d0/         ! mol weight and gas constant
c      data pmina(1),rhomxaa(1),tmina(1)
c     &  /0.391d0,15.594d0,169.85d0/    ! lower limits (= triple point)
c      data tmaxa(1),pmaxa(1)
c     &  /453.15d0,70000.0d0/           ! upper limits
cc
c      data ttpa(1) /169.85d0/
c      data tnbpa(1) /247.07d0/
c      data accena(1) /0.32684d0/
c      data dipa(1) /2.058d0/  !dipole moment [Debye]; Meyer, (1991)
cc
c      end                                              !block data BDFEQ
c
c
c        1         2         3         4         5         6         7
c23456789012345678901234567890123456789012345678901234567890123456789012
c
c ======================================================================
c                                                    end file core_FEQ.f
c ======================================================================
c  begin file core_MLT.f
c
c  This file contains core routines for melting lines and sublimation lines.
c
c  contained here are:
c     subroutine SETMLT (nread,icomp,ierr,herr)
c     subroutine MELTT (t,x,p,ierr,herr)
c     subroutine MELTP (p,x,t,ierr,herr)
c     subroutine MELTK (icomp,t,p,ierr,herr)
c     subroutine MLTH2O (t,p1,p2)
c     subroutine MLTPH2 (icomp,t,p)
c     subroutine SETSBL (nread,icomp,ierr,herr)
c     subroutine SUBLT (t,x,p,ierr,herr)
c     subroutine SUBLP (p,x,t,ierr,herr)
c     subroutine SUBLK (icomp,t,p,ierr,herr)
c     subroutine SOLVEM (iflag,p,x,t,ierr,herr)
c
c ======================================================================
c ======================================================================
c
      subroutine SETMLT (nread,icomp,ierr,herr)
c
c  set up working arrays for use with melting line equation
c
c  inputs:
c    nread--file to read data from (file should have already been
c           opened and pointer set by subroutine SETUP)
c    icomp--component number in mixture (1..nc); 1 for pure fluid
c
c  outputs:
c     ierr--error flag:  0 = successful
c     herr--error string (character*255 variable if ierr<>0)
c     other quantities returned via arrays in commons
c
c  written by E.W. Lemmon, NIST Thermophysics Division, Boulder, Colorado
c  11-16-98 EWL, original version
c
      include 'commons.for'
      character*255 herr
c
      herr=' '
      ierr=0
c
c  read data from file
c     write (*,*) ' SETMLT--read component',icomp,' from unit',nread
      read (nread,*) tminmt(icomp)          !lower temperature limit
      read (nread,*) tmaxmt(icomp)          !upper temperature limit
c  the pressure and density limit are not presently used,
c  but are contained in the file for consistency and possible future use;
c  skip over them in reading the file
      read (nread,*) !pjunk               !upper pressure limit (n/a)
      read (nread,*) !rhojnk              !upper density limit (n/a)
      read (nread,*) trdmlt(icomp),prdmlt(icomp)!reducing parameters
      read (nread,*) ntrmm1(icomp),ntrmm2(icomp),ntrmm3(icomp),
     &               ntrmm4(icomp),ntrmm5(icomp),ntrmm6(icomp)
      do k=1,ntrmm1(icomp)
        read (nread,*) pmeltk(icomp,k),pmltex(icomp,k)
      enddo
      do k=1,ntrmm2(icomp)
        j=k+ntrmm1(icomp)
        read (nread,*) pmeltk(icomp,j),pmltex(icomp,j)
      enddo
      do k=1,ntrmm3(icomp)
        j=k+ntrmm1(icomp)+ntrmm2(icomp)
        read (nread,*) pmeltk(icomp,j),pmltex(icomp,j)
      enddo
c
      RETURN
      end                                             !subroutine SETMLT
c
c ======================================================================
c
      subroutine MELTT (t,x,p,ierr,herr)
c
c  compute the melting line pressure as a function of temperature
c  and composition.
c
c  inputs:
c        t--temperature [K]
c        x--composition [array of mol frac]
c   output:
c        p--melting line pressure [kPa]
c        ierr--error flag:  0 = successful
c        herr--error string (character*255 variable if ierr<>0)
c
c  written by E.W. Lemmon, NIST Physical & Chem Properties Div, Boulder, CO
c  11-16-98 EWL, original version
c  06-22-99 EWL, return if ptpn(i)=0 for a mixture
c  09-02-99 EWL, add check for p>pmax
c  03-08-07 EWL, remove p=ptpn(i) when t<ttrp and call MELTT anyways, thus making sure the fluid has a melting line.
c  03-08-07 EWL, change p to p2 so that an intermittent value does not get returned when there is no melting line
c
cx DEC$ ATTRIBUTES DLLEXPORT :: MELTT
c
      include 'commons.for'
      dimension x(ncmax)
      character*255 herr
c
      p=0.d0
      p2=0.d0
      call ISPURE (x,icomp)
      if (icomp.ne.0) then
c  special case--pure component
        call MELTK (icomp,t,p,ierr,herr)
        pmax=peos(icomp)
c     else if (hmelt.eq.'MLX' .or. hmelt.eq.'MLM') then
      else
c  mixture melting line--use simple mixing rules
        ttrp=0
        ptrp=0
        do i=1,nc
c  do not return a value if any of the fluids does not have a triple point pressure
          if (ptpn(i).lt.1.d-15) return
          ttrp=ttrp+x(i)*ttpn(i)
          ptrp=ptrp+x(i)*log(ptpn(i))
        enddo
        ptrp=exp(ptrp)
        sum=0.d0
        pmax=0.d0
        do i=1,nc
          if (ttrp.gt.0.d0) then
            t2=t/ttrp*ttpn(i)
            if (t2.lt.ttpn(i)) t2=ttpn(i)
            call MELTK (i,t2,p2,ierr,herr)
c  do not return a value if any of the fluids does not have a melting line
            if (p2.lt.1.d-15) return
            if (ptpn(i).gt.0.d0) sum=sum+x(i)*LOG(p2/ptpn(i))
            pmax=pmax+x(i)*peos(i)
          endif
        enddo
        p=EXP(sum)*ptrp
      end if
c
      RETURN
      end                                              !subroutine MELTT
c
c ======================================================================
c
      subroutine MELTP (p,x,t,ierr,herr)
c
c  compute the melting line temperature as a function of pressure
c  and composition.
c
c  inputs:
c        p--melting line pressure [kPa]
c        x--composition [array of mol frac]
c   output:
c        t--temperature [K]
c        ierr--error flag:  0 = successful
c        herr--error string (character*255 variable if ierr<>0)
c
c  written by E.W. Lemmon, NIST Physical & Chem Properties Div, Boulder, CO
c  02-12-99 EWL, original version
c  01-21-00 EWL, return if fluids does not have a melting line
c
cx DEC$ ATTRIBUTES DLLEXPORT :: MELTP
c
      include 'commons.for'
      character*255 herr
      dimension x(ncmax)
c
      call ISPURE (x,icomp)
      if (icomp.ne.0) then
        if (hmeltk(icomp).eq.'NBS') then  !Return if no melting line
          t=ttpn(icomp)
          RETURN
        endif
        if (p.lt.ptpn(icomp)) then
          ierr=2
          t=ttpn(icomp)
          write (herr,1149) p/1000.0d0,ptpn(icomp)/1000.0d0,hnull
          call ERRMSG (ierr,herr)
 1149     format ('[MELTP error 2] ',
     &            'pressure less than triple point pressure; P =',
     &          g12.5,' MPa, Ptp =',g12.5,' MPa.',a1)
          return
        endif
      endif
c
      call solvem (1,p,x,t,ierr,herr)
c
      RETURN
      end                                              !subroutine MELTP
c
c ======================================================================
c
      subroutine MELTK (icomp,t,p,ierr,herr)
c
c  compute melting line with appropriate core model
c
c  inputs:
c    icomp--component i
c        t--temperature (K)
c   output:
c        p--melting line pressure [kPa]
c     ierr--error flag:  0 = successful
c                        1 = error:  T<Ttrp
c                        105 = error:  unknown melting line
c     herr--error string (character*255 variable if ierr<>0)
c
c  written by E.W. Lemmon, NIST Physical & Chemical Properties Division, Boulder, Colorado
c  11-16-98 EWL, original version
c  10-16-01 EWL, change order, call MLTPH2 instead of MELT2
c  10-16-01 EWL, change ML3 to MLP and ML4 to MLW
c
      include 'commons.for'
      character*255 herr
c
      ierr=0
      herr=' '
      p=0
      tt=ttpn(icomp)
      if (hmeltk(icomp).eq.'MLW') tt=251.165d0
      if (t.lt.tt) then
        p=0.0d0
        ierr=1
        write (herr,1098) t,tt,hnull
        call ERRMSG (ierr,herr)
 1098   format ('[MELTK error 1] ',
     &          'temperature less than lower temperature limit; T =',
     &          g12.5,' K, Tlow =',g12.5,' K.',a1)
        return
      endif
c
      if (hmeltk(icomp).eq.'MLW') then
        call MLTH2O (t,p,p2)     !Water
      elseif (hmeltk(icomp).eq.'MLP') then
        call MLTPH2 (icomp,t,p)  !Parahydrogen
      elseif (hmeltk(icomp)(1:2).eq.'ML') then
        tr=t/trdmlt(icomp)
        pr=0.0d0
        do k=1,ntrmm1(icomp)
          pr=pr+pmeltk(icomp,k)*tr**pmltex(icomp,k)
        enddo
        do k=1,ntrmm2(icomp)
          j=k+ntrmm1(icomp)
          pr=pr+pmeltk(icomp,j)*(tr-1.0d0)**pmltex(icomp,j)
        enddo
        do k=1,ntrmm3(icomp)
          j=k+ntrmm1(icomp)+ntrmm2(icomp)
          pr=pr+pmeltk(icomp,j)*log(tr)**pmltex(icomp,j)
        enddo
        p=pr
        if (hmeltk(icomp).eq.'ML1') p=prdmlt(icomp)*pr
        if (hmeltk(icomp).eq.'ML2') p=prdmlt(icomp)*exp(pr)
c  do not return error message if fluid contains no melting line
      elseif (hmeltk(icomp).eq.'NBS') then
      else
        p=0.0d0
        ierr=105
        write (herr,1099) hmeltk(icomp),hnull
        call ERRMSG (ierr,herr)
 1099   format ('[MELTK error 105] ',
     &          'unknown melting line model:  (',a3,')',a1)
      end if
c     write (*,1200) icomp,t,p
c1200 format (' MELTK--icomp,t,p: ',i4,2f11.6)
c
      RETURN
      end                                              !subroutine MELTK
c
c ======================================================================
c
      subroutine MLTH2O (t,p1,p2)
c
c  compute melting line of water, see fluid file for reference
c
c  inputs:
c    icomp--component i
c        t--temperature (K)
c   output:
c       p1--higher melting line pressure [kPa]
c       p2--lower melting line pressure [kPa]
c       above 273.16 K, only p1 returns a physical answer.
c       between 251.165 and 273.16 K, two pressures are returned.
c
c  written by E.W. Lemmon, NIST Physical & Chemical Properties Division, Boulder, Colorado
c  11-17-98 EWL, original version
c  07-03-01 EWL, add patch to fix water equation above 700 K
c  10-22-10 EWL, update with latest equation of Wagner
c
cx DEC$ ATTRIBUTES DLLEXPORT :: MLTH2O
c
      include 'commons.for'
c
      p1=0.0d0
      p2=0.0d0
c     Ice I
      if (t.gt.251.165d0 .and. t.le.273.1600000001d0) then
        th=t/273.16d0
        p2=0.611657d0*(1.d0
     &    +1195393.37d0*(1.0d0-th**3.0d0)
     &    +80818.3159d0*(1.0d0-th**25.75d0)
     &    +3338.26860d0*(1.0d0-th**103.75d0))
      end if
c
c     Ice III
      if (t.ge.251.165d0 .and. t.lt.256.164d0) then
        th=t/251.165d0
        p1=208566d0*(1.0d0-0.299948d0*(1.d0-th**60.d0))
      end if
c
c     Ice V
      if (t.ge.256.164d0 .and. t.lt.273.31d0) then
        th=t/256.164d0
        p1=350100d0*(1.0d0-1.18721d0*(1.d0-th**8.d0))
      end if
c
c     Ice VI
      if (t.ge.273.31d0 .and. t.lt.355.0d0) then
        th=t/273.31d0
        p1=632400d0*(1.0d0-1.07476d0*(1.d0-th**4.6d0))
      end if
c
c     Ice VII
      if (t.ge.355.d0 .and. t.lt.637.8d0) then
        th=t/355.d0
        p1=2216000.d0*EXP(0.173683d+1*(1.d0-th**(-1.d0))
     &                   -0.544606d-1*(1.d0-th**5.d0)
     &                   +0.806106d-7*(1.d0-th**22.d0))
      end if
c
c  The Wagner melting equation for water above its upper limit of 715 K
c  quickly drops and becomes negative above 840 K.  The following patch
c  corrects this problem.  Although the Wagner equation is valid up to 715 K,
c  the equation is used starting at 637.8 K, where the patch and Wagner's
c  equation cross.  Differences between the two equations within these two
c  temperatures is less than 1% up to 693 K, at which point the Wagner
c  equation starts to turn downward.  The maximum 1% error is well within
c  the uncertainty of the original equation in this region, which is about 5%.
c
      if (t.ge.637.8d0) then
        p1=1000.d0*EXP(0.00805246d0*t + 4.27074d0)
      end if

      RETURN
      end                                             !subroutine MLTH2O
Cc
Cc ======================================================================
Cc
C      subroutine MLTH2O (t,p1,p2)
Cc
Cc  compute melting line of water (these are the old coefficients from the
Cc  1994 publication of Wagner, Saul, and Pruss).
Cc
Cc  inputs:
Cc    icomp--component i
Cc        t--temperature (K)
Cc   output:
Cc       p1--higher melting line pressure [kPa]
Cc       p2--lower melting line pressure [kPa]
Cc       above 273.16 K, only p1 returns a physical answer.
Cc       between 251.165 and 273.16 K, two pressures are returned.
Cc
Cc  written by E.W. Lemmon, NIST Physical & Chemical Properties Division, Boulder, Colorado
Cc  11-17-98 EWL, original version
Cc  07-03-01 EWL, add patch to fix water equation above 700 K.
Cc
C      include 'commons.for'
Cc
Ccx DEC$ ATTRIBUTES DLLEXPORT :: MLTH2O
Cc
C      p1=0.0d0
C      p2=0.0d0
Cc     Ice I
C      if (t.gt.251.165d0 .and. t.le.273.1600000001d0) then
C        th=t/273.16d0
C        p2=0.000611657d0*(1.0d0-626000.d0*(1.0d0-th**(-3.0d0))
C     &   +197135d0*(1.0d0-th**21.2d0))
C      end if
Cc
Cc     Ice III
C      if (t.ge.251.165d0 .and. t.lt.256.164d0) then
C        th=t/251.165d0
C        p1=209.9d0*(1.0d0-.295252d0*(1.0d0-th**60.0d0))
C      end if
Cc
Cc     Ice V
C      if (t.ge.256.164d0 .and. t.lt.273.31d0) then
C        th=t/256.164d0
C        p1=350.1d0*(1.0d0-1.18721d0*(1.0d0-th**8.0d0))
C      end if
Cc
Cc     Ice VI
C      if (t.ge.273.31d0 .and. t.lt.355.0d0) then
C        th=t/273.31d0
C        p1=632.4d0*(1.0d0-1.07476d0*(1.0d0-th**4.6d0))
C      end if
Cc
Cc     Ice VII
C      if (t.ge.355.d0 .and. t.lt.637.8d0) then
C        th=t/355.d0
C        p1=2216.d0*EXP(0.173683d+1*(1.d0-th**(-1.d0))
C     &                -0.544606d-1*(1.d0-th**5.d0)
C     &                +0.806106d-7*(1.d0-th**22.d0))
C      end if
Cc
Cc  The Wagner melting equation for water above its upper limit of 715 K
Cc  quickly drops and becomes negative above 840 K.  The following patch
Cc  corrects this problem.  Although the Wagner equation is valid up to 715 K,
Cc  the equation is used starting at 637.8 K, where the patch and Wagner's
Cc  equation cross.  Differences between the two equations within these two
Cc  temperatures is less than 1% up to 693 K, at which point the Wagner
Cc  equation starts to turn downward.  The maximum 1% error is well within
Cc  the uncertainty of the original equation in this region, which is about 5%.
Cc
C      if (t.ge.637.8d0) then
C        p1=EXP(0.00805246d0*t + 4.27074d0)
C      end if
Cc
C      p1=p1*1000.0d0
C      p2=p2*1000.0d0
Cc
C      RETURN
C      end                                             !subroutine MLTH2O
c
c ======================================================================
c
      subroutine MLTPH2 (icomp,t,p)
c
c  compute melting line of parahydrogen
c
c  inputs:
c    icomp--component i
c        t--temperature (K)
c   output:
c        p--melting line pressure [kPa]
c
c  written by E.W. Lemmon, NIST Physical & Chemical Properties Division, Boulder, Colorado
c  11-17-98 EWL, original version
c
      include 'commons.for'
c
      tr=t/trdmlt(icomp)
      pr=0.0d0
c
c     melting function for parahydrogen
      if (t.gt.22) then
        pr=pmeltk(icomp,1)+pmeltk(icomp,2)*tr**pmltex(icomp,2)
      else
        pr=pmeltk(icomp,3)+pmeltk(icomp,4)*tr**pmltex(icomp,4)
      endif
c
      p=prdmlt(icomp)*pr
c
      RETURN
      end                                             !subroutine MLTPH2
c
c
c ======================================================================
c
      subroutine SETSBL (nread,icomp,ierr,herr)
c
c  set up working arrays for use with sublimation line equation
c
c  inputs:
c    nread--file to read data from (file should have already been
c           opened and pointer set by subroutine SETUP)
c    icomp--component number in mixture (1..nc); 1 for pure fluid
c
c  outputs:
c     ierr--error flag:  0 = successful
c     herr--error string (character*255 variable if ierr<>0)
c     other quantities returned via arrays in commons
c
c  written by E.W. Lemmon, NIST Thermophysics Division, Boulder, Colorado
c  02-12-99 EWL, original version
c
      include 'commons.for'
      character*255 herr
c
      herr=' '
      ierr=0
c
c  read data from file
c     write (*,*) ' SETSBL--read component',icomp,' from unit',nread
      read (nread,*) tminsb(icomp)          !lower temperature limit
      read (nread,*) tmaxsb(icomp)          !upper temperature limit
c  the pressure and density limit are not presently used,
c  but are contained in the file for consistency and possible future use;
c  skip over them in reading the file
      read (nread,*) !pjunk               !upper pressure limit (n/a)
      read (nread,*) !rhojnk              !upper density limit (n/a)
      read (nread,*) trdsbl(icomp),prdsbl(icomp)!reducing parameters
      read (nread,*) ntrmb1(icomp),ntrmb2(icomp),ntrmb3(icomp),
     &               ntrmb4(icomp),ntrmb5(icomp),ntrmb6(icomp)
      do k=1,ntrmb1(icomp)
        read (nread,*) psublk(icomp,k),psblex(icomp,k)
      enddo
      do k=1,ntrmb2(icomp)
        j=k+ntrmb1(icomp)
        read (nread,*) psublk(icomp,j),psblex(icomp,j)
      enddo
      do k=1,ntrmb3(icomp)
        j=k+ntrmb1(icomp)+ntrmb2(icomp)
        read (nread,*) psublk(icomp,j),psblex(icomp,j)
      enddo
c
      RETURN
      end                                             !subroutine SETSBL
c
c ======================================================================
c
      subroutine SUBLT (t,x,p,ierr,herr)
c
c  compute the sublimation line pressure as a function of temperature
c  and composition.
c
c  inputs:
c        t--temperature [K]
c        x--composition [array of mol frac]
c   output:
c        p--sublimation line pressure [kPa]
c        ierr--error flag:  0 = successful
c        herr--error string (character*255 variable if ierr<>0)
c
c  written by E.W. Lemmon, NIST Physical & Chem Properties Div, Boulder, CO
c  02-12-99 EWL, original version
c
cx DEC$ ATTRIBUTES DLLEXPORT :: SUBLT
c
      include 'commons.for'
      dimension x(ncmax)
      character*255 herr
c
      p=0
      call ISPURE (x,icomp)
      if (icomp.ne.0) then
c  special case--pure component
        call SUBLK (icomp,t,p,ierr,herr)
c     else if (hsubl.eq.'SBX' .or. hsubl.eq.'SBM') then
      else
c  mixture sublimation line--use simple mixing rules
        ttrp=0
        ptrp=0
        do i=1,nc
          ttrp=ttrp+x(i)*ttpn(i)
          ptrp=ptrp+x(i)*log(ptpn(i))
        enddo
        ptrp=exp(ptrp)
        sum=0
        do i=1,nc
          call SUBLK (i,t/ttrp*ttpn(i),p,ierr,herr)
          if (p.gt.0 .and. ptpn(i).gt.0) sum=sum+x(i)*LOG(p/ptpn(i))
        enddo
        p=EXP(sum)*ptrp
      end if
c
      RETURN
      end                                              !subroutine SUBLT
c
c ======================================================================
c
      subroutine SUBLP (p,x,t,ierr,herr)
c
c  compute the sublimation line temperature as a function of pressure
c  and composition.
c
c  inputs:
c        p--sublimation line pressure [kPa]
c        x--composition [array of mol frac]
c   output:
c        t--temperature [K]
c        ierr--error flag:  0 = successful
c        herr--error string (character*255 variable if ierr<>0)
c
c  written by E.W. Lemmon, NIST Physical & Chem Properties Div, Boulder, CO
c  02-12-99 EWL, original version
c
cx DEC$ ATTRIBUTES DLLEXPORT :: SUBLP
c
      include 'commons.for'
      character*255 herr
      dimension x(ncmax)
c
      t=300
      call ISPURE (x,icomp)
      if (icomp.ne.0) then
        if (p.gt.ptpn(icomp)) then
          ierr=2
          t=ttpn(icomp)
          write (herr,1149) p/1000.0d0,ptpn(icomp)/1000.0d0,hnull
          call ERRMSG (ierr,herr)
 1149     format ('[MELTP error 2] ',
     &            'pressure greater than triple point pressure; P =',
     &          g12.5,' MPa, Ptp =',g12.5,' MPa.',a1)
          return
        endif
      endif
c
      if (p.gt.0.d0) call solvem (2,p,x,t,ierr,herr)
c
      RETURN
      end                                              !subroutine SUBLP
c
c ======================================================================
c
      subroutine SUBLK (icomp,t,p,ierr,herr)
c
c  compute sublimation line with appropriate core model
c
c  inputs:
c    icomp--component i
c        t--temperature (K)
c   output:
c        p--sublimation line pressure [kPa]
c     ierr--error flag:  0 = successful
c                        15 = T>Ttrp
c                        105 = unknown model
c     herr--error string (character*255 variable if ierr<>0)
c
c  written by E.W. Lemmon, NIST Physical & Chemical Properties Division, Boulder, Colorado
c  02-12-99 EWL, original version
c  10-17-01 EWL, change SB2 to SB3 and add SB2 similar to ML2
c
      include 'commons.for'
      character*255 herr
c
      p=0
      ierr=0
      herr=' '
      if (t.le.0.0d0) then
        p=0.0d0
        ierr=15
        write (herr,1097) t
        call ERRMSG (ierr,herr)
 1097   format ('[SUBLK error 15] ',
     &          'temperature less than zero; T =',g12.5,' K',a1)
        return
      endif
      if (t.gt.ttpn(icomp)) then
        p=0.0d0
        ierr=15
        write (herr,1098) t,ttpn(icomp),hnull
        call ERRMSG (ierr,herr)
 1098   format ('[SUBLK error 15] ',
     &         'temperature greater than triple point temperature; T =',
     &          g12.5,' K, Ttp =',g12.5,' K.',a1)
        return
      endif
c
      if (hsublk(icomp)(1:2).eq.'SB') then
        tr=t/trdsbl(icomp)
        pr=0.0d0
        do k=1,ntrmb1(icomp)
          pr=pr+psublk(icomp,k)*tr**psblex(icomp,k)
        enddo
        do k=1,ntrmb2(icomp)
          j=k+ntrmb1(icomp)
          pr=pr+psublk(icomp,j)*(1.0d0-tr)**psblex(icomp,j)
        enddo
        do k=1,ntrmb3(icomp)
          j=k+ntrmb1(icomp)+ntrmb2(icomp)
          pr=pr+psublk(icomp,j)*log(tr)**psblex(icomp,j)
        enddo
        p=pr
        if (hsublk(icomp).eq.'SB1') p=prdsbl(icomp)*pr
        if (pr.lt.200) then
          if (hsublk(icomp).eq.'SB2') p=prdsbl(icomp)*exp(pr)
          if (hsublk(icomp).eq.'SB3' .and. t.gt.0.d0)     !used for CO2
     &        p=prdsbl(icomp)*exp(trdsbl(icomp)/t*pr)
        else
          pr=0.d0
        endif
c  do not return error message if fluid contains no melting line
      elseif (hsublk(icomp).eq.'NBS') then
      else
        p=0.0d0
        ierr=105
        write (herr,1099) hsublk(icomp),hnull
        call ERRMSG (ierr,herr)
 1099   format ('[SUBLK error 105] ',
     &          'unknown sublimation line model:  (',a3,')',a1)
      end if
c     write (*,1200) icomp,t,p
c1200 format (' SUBLK--icomp,t,p: ',i4,2f11.6)
c
      RETURN
      end                                              !subroutine SUBLK
c
c ======================================================================
c
      subroutine SOLVEM (iflag,p,x,t,ierr,herr)
c
c  solve for the melting or sublimation temperature given p
c
c  inputs:
c     iflag--solve for melting pressure when iflag=1, for sublimation pressure
c           when iflag=2
c        p--pressure [kPa]
c        x--composition [array of mol frac]
c   output:
c        t--temperature (K)
c     ierr--error iflag:  0 = successful
c                       124 = no convergence
c     herr--error string (character*255 variable if ierr<>0)
c
c  written by E.W. Lemmon, NIST Physical & Chemical Properties Division, Boulder, Colorado
c  02-18-99 EWL, original version
c  03-08-00 EWL, add check for t<ttrp
c  10-24-00 EWL, add logic for ICE I (for water)
c  07-20-10 EWL, change how t is modified if pp<0
c
      include 'commons.for'
      character*255 herr
      dimension x(ncmax)
c
      tol=0.5d-8
      dx=0.001d0
      dt=-10.d0
      if (iflag.eq.2) dx=-dx
c  get triple point, use as starting place
      call ISPURE (x,icomp)
      if (icomp.ne.0) then
        ttrp=ttpn(icomp)
      else
        ttrp=0
        do i=1,nc
          ttrp=ttrp+x(i)*ttpn(i)
        enddo
      endif
      iw=0
      if (icomp.ne.0) then
        if (hmeltk(icomp).eq.'MLW' .and. iflag.eq.1) then
          ttrp=251.165d0
          call MELTT (ttrp,x,pw,ierr,herr)
          if (p.lt.pw) iw=1      !Water phase below 209.9 MPa (Ice I)
        endif
      endif
      t=ttrp+1.0d0
      if (iflag.eq.2) t=ttrp-1.0d0
c  calculate melting (sublimation) pressure and its derivative,
c  then update temperature iteratively
      do i=1,100
        if (iflag.eq.1) then
          if (iw.eq.0) then
            call MELTT (t   ,x,pp,ierr,herr)
            call MELTT (t+dx,x,p1,ierr,herr)
          else
            call MLTH2O (t   ,px,pp)
            call MLTH2O (t+dx,px,p1)
          endif
        elseif (iflag.eq.2) then
          call SUBLT (t   ,x,pp,ierr,herr)
          call SUBLT (t+dx,x,p1,ierr,herr)
        endif
        if (ierr.ne.0) return
        told=t
        if (pp.le.0.d0 .or. p1.le.0.d0) then
          t=t-0.5d0*dt
          if (iw.eq.1) t=told-(273.16d0-told)/2.d0
          dx=dx/2.d0
        else
          dpt=(log(p1)-log(pp))/dx
          dt = (log(p)-log(pp))/dpt       !1st order Newton's method
          t=t+dt
        endif
        if (iflag.eq.1 .and. t.lt.ttrp) t=(told+ttrp)/2.d0
        if (iflag.eq.2 .and. t.gt.ttrp) t=(told+ttrp)/2.d0
        if (iw.eq.1 .and. t.gt.273.16d0) t=(273.16d0+told)/2.d0
        if (t.lt.0) t=0.5d0*told          !do not let t become negative
        if (ABS(p-pp).lt.tol) RETURN
      enddo
      ierr=124
      t=-9.99999d6
      write (herr,1100)
      call ERRMSG (ierr,herr)
 1100 format('[SOLVEM error 124] maximum number of iterations exceeded')
      RETURN
      end                                             !subroutine SOLVEM
c
c        1         2         3         4         5         6         7
c23456789012345678901234567890123456789012345678901234567890123456789012
c
c ======================================================================
c                                                    end file core_MLT.f
c ======================================================================
c  begin file core_PH0.f
c
c  This file contains the functions implementing the ideal-gas part of
c  the reduced Helmholtz free energy form of the pure fluid equation of
c  state (the so-called "fundamental equation").
c
c  The Helmholtz energy consists of ideal and residual (real-gas) terms;
c  this routine calculates only the ideal part, and only for pure components.
c
c  contained here are:
c     subroutine SETPH0 (nread,icomp,hcasno,ierr,herr)
c     function PH0PH0 (icomp,itau,idel,t,rho)
c     block data SAVPH0
c
c  these routines use the following common blocks from other files
c     common /CREF/ tref(n0:nx),rhoref(n0:nx),href(n0:nx),sref(n0:nx)
c     common /HCHAR/ htab,hnull
c     common /Gcnst/ R,tz(n0:nx),rhoz(n0:nx)
c
c  various arrays are dimensioned with parameter statements
c     parameter (nph0mx=10)       !max number of terms in Cp0 polynomial
c
c ======================================================================
c ======================================================================
c
      subroutine SETPH0 (nread,icomp,hcasno,ierr,herr)
c
c  set up working arrays for ideal-gas part of the Helmholtz energy
c  implements an expression of the form:
c     phi0 = Sum[ai*log(tau**ti)] + Sum[aj*tau**tj]
c          + Sum[ak*log(1-EXP(bk*tau))]
c
c  inputs:
c    nread--file to read data from
c           <= 0 get data from block data (not currently implemented)
c           >0 read from logical unit nread (file should have already
c              been opened and pointer set by subroutine SETUP)
c    icomp--component number in mixture (1..nc); 1 for pure fluid;
c           zero and negative numbers designate ECS reference fluids
c   hcasno--CAS number of component icomp
c           (not req'd if reading from file--included to maintain
c           parallel structure with other routines)
c
c  outputs:
c     ierr--error flag:  0 = successful
c                        1 = error (e.g. fluid not found)
c     herr--error string (character*255 variable if ierr<>0)
c     coefficients, etc. returned via arrays in common /xxxPH0/
c
c  written by M. McLinden, NIST Thermophysics Division, Boulder, Colorado
c  05-13-96  MM, original version, based (loosely) on SETCPP
c  06-14-96  MM, fix bug in reading/storing coefficients
c  11-13-97  MM, (re)initialize contents of /PH0SAV/ when a new fluid is read in
c  08-31-98 MEV, reverse order of indices in tsvph0(i,j)=0 and rhosvp(i,j)=0
c  08-13-98  MM, delete obsolete (unused) format statement
c  07-25-06 EWL, add cosh and sinh functions
c
      include 'commons.for'
      character*12 hcasno,hcasp
      character*255 herr
      common /CASPH0/ hcasp(mxph0)
c
c  (re)initialize contents of /PH0SAV/ when a new fluid is read in
      do i=n0,nx
        ph0sav(i)=0.0d0
        ph1sav(i)=0.0d0
        ph2sav(i)=0.0d0
        do j=0,2
          tsvph0(j,i)=0.0d0
          rhosvp(j,i)=0.0d0
        enddo
      enddo
c
      if (nread.le.0) then
c  get coefficients from block data
c  identify specified fluid with entries in database via match of CAS no
        do k=1,mxph0
          if (hcasno.eq.hcasp(k)) then
c           write (*,*)' SETPH0--ERROR, block data read not implemented'
            ierr=1
          herr='[SETPH0 error] Block data option not implemented'//hnull
            RETURN
          end if
        enddo
        ierr=1
        herr='[SETPH0 error] Input fluid (block data) not found'//hnull
        RETURN
      else
c  read data from file
c       write (*,*) ' SETPH0--read component',icomp,' from unit',nread
        read (nread,*) tminph(icomp)              !lower temperature limit
        read (nread,*) tmaxph(icomp)              !upper temperature limit
        read (nread,*) pmaxph(icomp)              !upper pressure limit
        read (nread,*) dmaxph(icomp)            !upper density limit
c  read number of terms for each of the various types
        if (verfl(icomp).ge.8.0d0) then
          read (nread,*) nlogp(icomp),ntaup(icomp),nexpp(icomp),
     &                   ncoshp(icomp),nsinhp(icomp),
     &                   nsp1p(icomp),nsp2p(icomp),nsp3p(icomp)  !spares
        else
          read (nread,*) nlogp(icomp),ntaup(icomp),nexpp(icomp)
          ncoshp(icomp)=0  !these terms not used in files prior to v8.0
          nsinhp(icomp)=0
          nsp1p(icomp)=0
          nsp2p(icomp)=0
          nsp3p(icomp)=0
        endif
        jterm=nlogp(icomp)+ntaup(icomp)+nexpp(icomp)+ncoshp(icomp)
     &        +nsinhp(icomp)+nsp1p(icomp)+nsp2p(icomp)+nsp3p(icomp)
        if (jterm.ge.1) then
c  read coefficients for terms of the form [ai*log(tau**ti)],
c  [ai*tau**ti], and [ai*log(1-EXP(bi*tau))]
          do i=1,jterm
            read (nread,*) aiph(icomp,i),tiph(icomp,i)
          enddo
        end if
        ierr=0
        herr=' '
      end if
c
      RETURN
      end                                             !subroutine SETPH0
c
c ======================================================================
c
      function PH0PH0 (icomp,itau,idel,t,rho)
c
c  compute the ideal gas part of the reduced Helmholtz energy or a
c  derivative as functions of temperature and pressure; for
c  use with a Helmholtz-explicit equation of state
c
c  inputs:
c    icomp--pointer specifying component (1..nc)
c     itau--flag specifying order of temperature derivative to calc
c     idel--flag specifying order of density derivative to calculate
c           (the density derivatives are not used in the calculation
c           of any property, and are not implemented)
c           when itau = 0 and idel = 0, compute A0/RT
c           when itau = 1 and idel = 0, 1st temperature derivative
c           when itau = 2 and idel = 0, 2nd temperature derivative
c        t--temperature (K)
c      rho--density (mol/L)
c  output (as function value):
c   ph0ph0--ideal-gas part of the Helmholtz energy in reduced form (A/RT)
c           derivatives (as specified by itau and idel) are multiplied
c           by the corresponding power of tau; i.e. when itau = 1, the
c           quantity returned is tau*d(ph0ph0)/d(tau) and when itau = 2,
c           the quantity returned is tau*tau*d2(ph0ph0)/d(tau)**2
c
c  Note: While the real-gas part of the Helmholtz energy is calculated
c        in terms of dimensionless temperature and density, the ideal-
c        gas part is calculated in terms of absolute temperature and
c        density.  (This distinction is necessary for mixtures.)
c
c        The Helmholtz energy consists of ideal-gas and residual
c        (real-gas) terms; this routine calculates only the ideal part.
c
c        This function computes pure component properties only.
c
c  written by M. McLinden, NIST Thermophysics Division, Boulder, Colorado
c  05-13-96  MM, original version, based (loosely) on PH0CPP
c  06-14-96  MM, add rhosvp to /PH0SAV/
c  07-08-96  MM, change derivative outputs:  tau*d(phi)/d(tau), etc
c  08-20-97  MM, call ERRMSG if itau out of range; drop idel=idel
c  07-11-00 EWL, remove krypton pieces
c  07-25-06 EWL, add cosh and sinh functions
c  08-24-06 EWL, add check for PHG in hmodcp (add EOSMOD common block).
c                If it is used, multiple by R*/R as described in GERG-2004 eos (of Kunz and Wagner)
c
      include 'commons.for'
      character*255 herr
c
c  compute reduced Helmholtz; first check if t same as previous call
c
      PH0PH0=0.0d0         !initialize in case of error
      if (t.le.0) RETURN
      tau=tz(icomp)/t
      del=rho/rhoz(icomp)
      if (itau*idel.ne.0) then
        PH0PH0=0.0d0
      elseif (itau.eq.0 .and. idel.eq.0) then
        if (abs(t-tsvph0(0,icomp)).lt.1.0d-8 .and.
     &      abs(rho-rhosvp(0,icomp)).lt.1.0d-10) then
          PH0PH0=ph0sav(icomp)
c         write (*,*) ' PH0PH0--using saved phi for itau = 0, t =',t
        else
c         write (*,1030) icomp,t,rho,t0,D0,tau,del
c1030     format (1x,'PH0PH0--icomp,t,rho,t0,D0,tau,del: ',i4,6e14.6)
          iterm=0
          phisum=LOG(del)
c    &          +href(icomp)/R/t-sref(icomp)/R !see U. Idaho class notes
          if (nlogp(icomp).ge.1) then
c  sum terms of the form [ai*log(tau**ti)]
            do i=1,nlogp(icomp)
              iterm=iterm+1
             phisum=phisum+aiph(icomp,iterm)*LOG(tau**tiph(icomp,iterm))
c             write (*,1040) iterm,aiph(icomp,iterm),tiph(icomp,iterm),phisum
c1040         format (' PH0PH0--log term iterm,ai,ti,phisum: ',i3,3f12.6)
            enddo
          end if
          if (ntaup(icomp).ge.1) then
c  sum terms of the form [ai*tau**ti]
            do j=1,ntaup(icomp)
              iterm=iterm+1
              phisum=phisum+aiph(icomp,iterm)*tau**tiph(icomp,iterm)
c             write (*,1060) iterm,aiph(icomp,iterm),tiph(icomp,iterm),phisum
c1060         format (' PH0PH0--tau term iterm,ai,ti,phisum: ',i3,3f12.6)
            enddo
          end if
          if (nexpp(icomp).ge.1) then
c  sum terms of the form [ai*log(1-EXP(bi*tau))]
c  (the bi coefficients are stored in the ti array)
            do k=1,nexpp(icomp)
              iterm=iterm+1
              phisum=phisum+aiph(icomp,iterm)
     &              *LOG(1.0d0-EXP(tiph(icomp,iterm)*tau))
c             write (*,1080) iterm,aiph(icomp,iterm),tiph(icomp,iterm),phisum
c1080         format (' PH0PH0--exp term iterm,ai,ti,phisum: ',i3,3f12.6)
            enddo
          end if
          if (ncoshp(icomp).ge.1) then
c  sum terms of the form [ai*log(cosh(bi*tau))]
            do k=1,ncoshp(icomp)
              iterm=iterm+1
              ttau=tiph(icomp,iterm)*tau
              if (ttau.lt.700.d0) then
                phisum=phisum+aiph(icomp,iterm)*LOG(COSH(ttau))
              else
                phisum=phisum+aiph(icomp,iterm)*700.d0
              endif
            enddo
          end if
          if (nsinhp(icomp).ge.1) then
c  sum terms of the form [ai*log(sinh(bi*tau))]
            do k=1,nsinhp(icomp)
              iterm=iterm+1
              ttau=tiph(icomp,iterm)*tau
              if (ttau.lt.700.d0) then
                phisum=phisum+aiph(icomp,iterm)*LOG(SINH(ttau))
              else
                phisum=phisum+aiph(icomp,iterm)*700.d0
              endif
            enddo
          end if
          PH0PH0=phisum
c  save information for possible use on next call to function
          tsvph0(0,icomp)=t
          rhosvp(0,icomp)=rho
          ph0sav(icomp)=PH0PH0
        end if
c
c  compute derivative w.r.t. tau (dimensionless temperature)
c
      else if (itau.eq.1) then
        if (abs(t-tsvph0(1,icomp)).lt.1.0d-8 .and.
     &      abs(rho-rhosvp(1,icomp)).lt.1.0d-10) then
          PH0PH0=ph1sav(icomp)
        else
          iterm=0
          phisum=0.0d0
c         phisum=href(icomp)/(R*tz)          !see U. Idaho class notes
          if (nlogp(icomp).ge.1) then
c  sum terms of the form [ai*log(tau**ti)]
            do i=1,nlogp(icomp)
              iterm=iterm+1
              phisum=phisum+aiph(icomp,iterm)*tiph(icomp,iterm)/tau
            enddo
          end if
          if (ntaup(icomp).ge.1) then
c  sum terms of the form [ai*tau**ti]
            do j=1,ntaup(icomp)
              iterm=iterm+1
              phisum=phisum+aiph(icomp,iterm)*tiph(icomp,iterm)
     &              *tau**(tiph(icomp,iterm)-1.0d0)
            enddo
          end if
          if (nexpp(icomp).ge.1) then
c  sum terms of the form [ai*log(1-EXP(bi*tau))]
c  (the bi coefficients are stored in the ti array)
            do k=1,nexpp(icomp)
              iterm=iterm+1
              exptau=EXP(tiph(icomp,iterm)*tau)
              phisum=phisum-aiph(icomp,iterm)*tiph(icomp,iterm)
     &              *exptau/(1.0d0-exptau)
            enddo
          end if
          if (ncoshp(icomp).ge.1) then
c  sum terms of the form [ai*log(cosh(bi*tau))]
            do k=1,ncoshp(icomp)
              iterm=iterm+1
              phisum=phisum+aiph(icomp,iterm)*tiph(icomp,iterm)
     &              *(TANH(tiph(icomp,iterm)*tau))
            enddo
          end if
          if (nsinhp(icomp).ge.1) then
c  sum terms of the form [ai*log(sinh(bi*tau))]
            do k=1,nsinhp(icomp)
              iterm=iterm+1
              phisum=phisum+aiph(icomp,iterm)*tiph(icomp,iterm)
     &              /(TANH(tiph(icomp,iterm)*tau))
            enddo
          end if
c  save information for possible use on next call to function
          PH0PH0=phisum*tau       !return tau*d(ph0ph0)/d(tau)
          tsvph0(1,icomp)=t
          rhosvp(1,icomp)=rho
          ph1sav(icomp)=PH0PH0
        end if
c
c  compute 2nd derivative w.r.t. tau (dimensionless temperature)
c
      else if (itau.eq.2) then
        if (abs(t-tsvph0(2,icomp)).lt.1.0d-8 .and.
     &      abs(rho-rhosvp(2,icomp)).lt.1.0d-10) then
          PH0PH0=ph2sav(icomp)
        else
          iterm=0
          phisum=0.0d0
          if (nlogp(icomp).ge.1) then
c  sum terms of the form [ai*log(tau**ti)]
            do i=1,nlogp(icomp)
              iterm=iterm+1
              phisum=phisum-aiph(icomp,iterm)*tiph(icomp,iterm)/tau**2
            enddo
          end if
          if (ntaup(icomp).ge.1) then
c  sum terms of the form [ai*tau**ti]
            do j=1,ntaup(icomp)
              iterm=iterm+1
              phisum=phisum+aiph(icomp,iterm)*tiph(icomp,iterm)
     &              *(tiph(icomp,iterm)-1.0d0)
     &              *tau**(tiph(icomp,iterm)-2.0d0)
            enddo
          end if
          if (nexpp(icomp).ge.1) then
c  sum terms of the form [ai*log(1-EXP(bi*tau))]
c  (the bi coefficients are stored in the ti array)
            do k=1,nexpp(icomp)
              iterm=iterm+1
              exptau=EXP(tiph(icomp,iterm)*tau)
              phisum=phisum-aiph(icomp,iterm)*tiph(icomp,iterm)**2
     &              *exptau/(1.0d0-exptau)**2
            enddo
          end if
          if (ncoshp(icomp).ge.1) then
c  sum terms of the form [ai*log(cosh(bi*tau))]
            do k=1,ncoshp(icomp)
              iterm=iterm+1
              if (tiph(icomp,iterm)*tau.lt.500.d0) then
                phisum=phisum+aiph(icomp,iterm)*tiph(icomp,iterm)**2
     &                /(COSH(tiph(icomp,iterm)*tau))**2
              endif
            enddo
          end if
          if (nsinhp(icomp).ge.1) then
c  sum terms of the form [ai*log(sinh(bi*tau))]
            do k=1,nsinhp(icomp)
              iterm=iterm+1
              if (tiph(icomp,iterm)*tau.lt.500.d0) then
                phisum=phisum-aiph(icomp,iterm)*tiph(icomp,iterm)**2
     &                /(SINH(tiph(icomp,iterm)*tau))**2
              endif
            enddo
          end if
c  save information for possible use on next call to function
          PH0PH0=phisum*tau*tau
          tsvph0(2,icomp)=t
          rhosvp(2,icomp)=rho
c  return tau**2*d2(ph0ph0)/d(tau**2)
          ph2sav(icomp)=PH0PH0
        end if
      else if (itau.eq.3) then
          iterm=0
          phisum=0.0d0
          if (nlogp(icomp).ge.1) then
            do i=1,nlogp(icomp)
              iterm=iterm+1
              phisum=phisum+2.d0*aiph(icomp,iterm)
     &              *tiph(icomp,iterm)/tau**3
            enddo
          end if
          if (ntaup(icomp).ge.1) then
            do j=1,ntaup(icomp)
              iterm=iterm+1
              phisum=phisum+aiph(icomp,iterm)*tiph(icomp,iterm)
     &             *(tiph(icomp,iterm)-1.0d0)
     &             *(tiph(icomp,iterm)-2.0d0)
     &             *tau**(tiph(icomp,iterm)-3.0d0)
            enddo
          end if
          if (nexpp(icomp).ge.1) then
            do k=1,nexpp(icomp)
              iterm=iterm+1
              exptau=EXP(tiph(icomp,iterm)*tau)
              phisum=phisum-aiph(icomp,iterm)*tiph(icomp,iterm)**3*
     &              (exptau/(1.0d0-exptau)**2+
     &               2.d0*exptau**2/(1.0d0-exptau)**3)
            enddo
          end if
          if (ncoshp(icomp).ge.1) then
            do k=1,ncoshp(icomp)
              iterm=iterm+1
              phisum=phisum-2.d0*aiph(icomp,iterm)*tiph(icomp,iterm)**3
     &              /(COSH(tiph(icomp,iterm)*tau))**3
     &              *(SINH(tiph(icomp,iterm)*tau))
            enddo
          end if
          if (nsinhp(icomp).ge.1) then
            do k=1,nsinhp(icomp)
              iterm=iterm+1
              phisum=phisum+2.d0*aiph(icomp,iterm)*tiph(icomp,iterm)**3
     &              /(SINH(tiph(icomp,iterm)*tau))**3
     &              *(COSH(tiph(icomp,iterm)*tau))
            enddo
          end if
          PH0PH0=phisum*tau**3
      elseif (idel.eq.1) then
        PH0PH0=1.0d0
      elseif (idel.eq.2) then
        PH0PH0=-1.0d0
      elseif (idel.eq.3) then
        PH0PH0=2.0d0
      else
c
c  invalid value of itau
c
        ierr=99
        write (herr,1099) itau,idel,hnull
 1099   format ('[PH0PH0 warning] invalid input; itau =',i4,'; idel =',
     &          i4,a1)
        call ERRMSG (ierr,herr)
        PH0PH0=0.0d0
      end if
      if (hmodcp(icomp).eq.'PHG') then
        PH0PH0=8.31451D0/8.314472D0*PH0PH0
      endif
c
c     write (*,*) ' PH0PH0:  output phi: ',ph0ph0
c
      RETURN
      end                                               !function PH0PH0
c
c        1         2         3         4         5         6         7
c23456789012345678901234567890123456789012345678901234567890123456789012
c
c ======================================================================
c                                                    end file core_PH0.f
c ======================================================================
c  begin file core_PR.f
c
c  This file contains the routines implementing the Peng-Robinson and other
c  similar cubic equations of state.
c
c  contained here are:
c     function PHIPR (icomp,itau,idel,tau,del)
c     function PHIPRX (itau,idel,tau,del,x)
c     subroutine CRTPR (icomp,tc,pc,rhoc)
c     subroutine CRTPRX (x,tc,pc,rhoc)
c     subroutine REDPR (x,tred,Dred)
c     subroutine SETPR (nread,icomp,hcasno,ierr,herr)
c     subroutine SETPRCO (i)
c     subroutine PREOS (i)
c     subroutine TPRHOPR (t,p,x,rho1,rho2)
c     subroutine ESTPR (i,j,ibin,ierr,herr)
c
c ======================================================================
c ======================================================================
c
      function PHIPR (icomp,itau,idel,tau,del)
c
c  compute reduced Helmholtz energy or a derivative as functions
c  of dimensionless temperature and density for the Peng-Robinson or SRK
c  equations of state
c
c  inputs:
c    icomp--pointer specifying component (1..nc)
c     itau--flag specifying order of temperature derivative to calc
c     idel--flag specifying order of density derivative to calculate
c           when itau = 0 and idel = 0, compute A/RT
c           when itau = 0 and idel = 1, compute 1st density derivative
c           when itau = 1 and idel = 1, compute cross derivative
c           etc.
c      tau--dimensionless temperature (Tc/T)
c      del--dimensionless density (D/Dc)
c  output (as function value):
c      phi--residual (real-gas) part of the Helmholtz energy, or one
c           of its derivatives (as specified by itau and idel),
c           in reduced form (A/RT)
c           itau  idel    output (dimensionless for all cases)
c             0    0      A/RT
c             1    0      tau*[d(A/RT)/d(tau)]
c             2    0      tau**2*[d**2(A/RT)/d(tau)**2]
c             0    1      del*[d(A/RT)/d(del)]
c             0    2      del**2*[d**2(A/RT)/d(del)**2]
c             1    1      tau*del*[d**2(A/RT)/d(tau)d(del)]
c                         etc.
c
c  written by E.W. Lemmon, NIST Thermophysics Division, Boulder, Colorado
c  07-21-03 EWL, original version
c
      include 'commons.for'
      dimension x(ncmax)
c
      do i=1,nc
        x(i)=0.d0
      enddo
      x(icomp)=1.d0
      phipr=PHIPRX (itau,idel,tau,del,x)
      return
      end                                                !function PHIPR
c
c ======================================================================
c
      function PHIPRX (itau,idel,tau,del,x)
c
c  compute reduced Helmholtz energy or a derivative as functions
c  of dimensionless temperature and density for a volume-translated
c  modification of the Peng-Robinson equations of state
c  EOS: P=RT/(v+t+b)-a/((v+t)*(v+t+b)+b(v+t+b))
c  original translation concept given in Peneloux, A. and Rauzy, E.,
c  FPE 8 (1982) 7-23  (although it was applied to SRK)
c  Translation is considered as a constant (see Pfohl, FPE 163 (1999) 157-159)
c  to avoid crossing of isotherms at high density, near critical conditions
c  If translation is set to zero, original Peng Robinson is recovered.
c
c  inputs:
c    icomp--pointer specifying component (1..nc)
c     itau--flag specifying order of temperature derivative to calc
c     idel--flag specifying order of density derivative to calculate
c           when itau = 0 and idel = 0, compute A/RT
c           when itau = 0 and idel = 1, compute 1st density derivative
c           when itau = 1 and idel = 1, compute cross derivative
c           etc.
c      tau--dimensionless temperature (Tc/T)
c      del--dimensionless density (D/Dc)
c  output (as function value):
c      phi--residual (real-gas) part of the Helmholtz energy, or one
c           of its derivatives (as specified by itau and idel),
c           in reduced form (A/RT)
c           itau  idel    output (dimensionless for all cases)
c             0    0      A/RT
c             1    0      tau*[d(A/RT)/d(tau)]
c             2    0      tau**2*[d**2(A/RT)/d(tau)**2]
c             0    1      del*[d(A/RT)/d(del)]
c             0    2      del**2*[d**2(A/RT)/d(del)**2]
c             0    3      del**3*[d**3(A/RT)/d(del)**3]
c             1    1      tau*del*[d**2(A/RT)/d(tau)d(del)]
c                         etc.
c
c  written by NIST Thermophysics Division, Boulder, Colorado
c  10-11-04 original version
c  09-11-09 EWL, remove x dependence for pure fluids
c  06-08-10 EWL, increase fprkij array size
c
c
      include 'commons.for'
      double precision x(ncmax),ai(ncmax),bi(ncmax),ki(ncmax)
      dimension atci(ncmax),daidt(ncmax),d2aidt2(ncmax),aij(ncmax,ncmax)
c
      call ISPURE (x,icomp)
      phiprx=0.d0
      if (del.le.1.d-10) RETURN  !trivial solution at zero density
      if (tau.le.0.d0) RETURN    !for any and all derivatives
c
c     ncode=idel*4+itau+1
c     if (abs(tau-tausvp(icomp)).lt.1.0d-12 .and.
c    &    abs(del-delsvp(icomp)).lt.1.0d-16) then
c  retrieve value from previous call
c       if (drvflp(icomp)(ncode:ncode).eq.'1') then
c         phiprx=drvsvp(icomp,ncode)
c         RETURN
c       endif
c     else
c  otherwise, compute new values and save for possible future use
c  first compute needed powers of tau and del (and save for future use)
c       drvflp(icomp)='0000000000000000'
c
      call REDX (x,tred,Dred)
      if (icomp.ne.0 .and. hcas(icomp).eq.'811-97-2') then     !R-134a
        tred=374.18d0
        Dred=4.978830171d0
      endif
      t=tred/tau
      d=Dred*del
      v=1.d0/d
c
c  set up volume translation factor
      tshift=0.d0
      if (icomp.ne.0) then
        tshift=prcoef(icomp,1)
      else
        do i=1,nc
          tshift=tshift+x(i)*prcoef(i,1)
        enddo
      endif
c     tshift=0.d0      !For testing purposes only
c
      rt=r*t
c  parameters for the SRK equation
      u=1.d0
      w=0.d0
c  parameters for the Peng-Robinson equation
      u=2.d0
      w=-1.d0
c
      do i=1,nc
        bi(i)=0.0778d0*r*tcpr(i)/pcpr(i)
        ki(i)=0.37464d0+1.54226d0*acnpr(i)-0.26992d0*acnpr(i)**2
        atci(i)=0.45724d0*r**2*tcpr(i)**2/pcpr(i)
        ai(i)=atci(i)*(1.d0+ki(i)*(1.d0-SQRT(t/tcpr(i))))**2
      enddo
c
c     ai(1)=1
c     ai(2)=1
c     atci(1)=0
c     atci(2)=0
c     fprkij(1,2,1)=1
c     fprkij(2,1,1)=1
c     fprkij(1,1,1)=1
c     fprkij(2,2,1)=1
      if (icomp.ne.0) then
        a=ai(icomp)
        b=bi(icomp)
      else
        a=0.d0
        b=0.d0
        do i=1,nc
          do j=1,nc
            aij(i,j)=SQRT(ai(i)*ai(j))*(1.d0-fprkij(i,j,1))
            a=a+x(i)*x(j)*aij(i,j)
          enddo
          b=b+x(i)*bi(i)
        enddo
      endif
c
      vb=v-b
      q=b*SQRT(u**2-4.d0*w)
      v1=2.d0*v+u*b+q
      v2=2.d0*v+u*b-q
      v1n=v1+2.d0*tshift
      v2n=v2+2.d0*tshift
      dts=d*tshift
      b2=b**2
      bu=b*u
      b2dw=b2*d*w
      arg1=vb+tshift
      arg2=v2n/v1n
      if (arg1.lt.1.d-9) arg1=1.d-9 !prevent neg log arguments
      if (arg2.lt.1.d-9) arg2=1.d-9
      if (   v.lt.1.d-9)    v=1.d-9
      if (   q.lt.1.d-9)    q=1.d-9
      t1=d*(b-tshift)/(1.d0-b*d+dts)
      t2=((1.d0+dts)*(1.d0+d*(tshift+bu))+b2dw*d)/d
c
c  check if derivatives are requested
c
      if (itau.eq.0 .and. idel.eq.0) then
        phiprx=LOG(v)-LOG(arg1)+a/rt*LOG(arg2)/q
c
      elseif (itau.eq.-2) then
        do i=1,nc
          daidt(i)=-atci(i)*ki(i)/SQRT(t*tcpr(i))
     &            *(1.d0+ki(i)*(1.d0-SQRT(t/tcpr(i))))
        enddo
        dadt=0.d0
        do i=1,nc
          do j=1,nc
            da=SQRT(ai(i)/ai(j))*daidt(j)/2.d0+
     &         SQRT(ai(j)/ai(i))*daidt(i)/2.d0
            dadt=dadt+x(i)*x(j)*(1.d0-fprkij(i,j,1))*da
          enddo
        enddo

        vb=v-b
        vpb=v+b
        vbb=v*vpb+b*vb
        vb2=vbb**2
        sq2=SQRT(2.d0)
        sq2p=1.d0+sq2
        sq2m=1.d0-sq2
        bsq2=2.d0*b*sq2*R*T
        v2bp=v+sq2p*b
        v2bm=v+sq2m*b
        vx=sq2m/v2bm
        vy=sq2p/v2bp
        arg=v2bm/v2bp
        argl=log(arg)
        dpdv=-rt/vb**2+2.d0*a*vpb/vb2
        dpt=r/vb-dadt/vbb
        p=d*rt*(1.d0+t1-a/rt/t2)

        do i=1,nc
          bip=bi(i)+b
          bim=bi(i)-b
          suma=0.d0
          saa=0.d0
          do j=1,nc
            da=0
            if (ai(i).ne.0 .and. ai(j).ne.0)
     &      da=SQRT(ai(i)/ai(j))*daidt(j)/2.d0+
     &         SQRT(ai(j)/ai(i))*daidt(i)/2.d0
            saa=saa+x(j)*(1.d0-fprkij(i,j,1))*da
            suma=suma+x(j)*aij(i,j)
          enddo
          daddn(i)=log(v/vb)+bi(i)/vb     !store dnadn temporarily in daddn d(nar)/d(ni) eq. 13
     &            +((a-a*bip/b+2.d0*suma)*argl+a*bi(i)*(vx-vy))/bsq2
          d2adbn(i)=1.d0/bsq2*(dadt-a/t)*argl
     &          +argl/bsq2/b*(a*bip/t-2.d0*b/t*suma+2.d0*b*saa-dadt*bip)
     &          +bi(i)/bsq2*(dadt-a/t)*(vx-vy)
          dpdn(i)=rt*(v+bim)/vb**2+2.d0*a*bi(i)*vb/vb2-2.d0*suma/vbb
          vrt=-dpdn(i)/dpdv/rt
          dphidT(i)=d2adbn(i)+1.d0/t-vrt*dpt
          dphidP(i)=vrt-1.d0/p
        enddo
        do i=1,nc
          do j=1,nc
            vs=0.d0
            do k=1,nc
              vs=vs+x(k)*(bi(j)*aij(i,k)+bi(i)*aij(j,k))
            enddo
            bij=bi(i)*bi(j)
            d2adnn(i,j)=(bi(i)+bi(j))/vb+bij/vb**2
     &        +2.d0/bsq2*(argl*(a*bij/b**2+aij(i,j)-vs/b)
     &        -(vx-vy)*(a*bij/b-vs)+(vy**2-vx**2)*a*bij/2.d0)
            dphidnj(i,j)=d2adnn(i,j)+1.d0+dpdn(j)*dpdn(i)/dpdv/rt
          enddo
        enddo

        phiprx=-1.d0

      elseif (itau.eq.1 .and. idel.eq.1) then
c  compute cross derivative using terms from 1st derivatives
        do i=1,nc
          daidt(i)=-atci(i)*ki(i)/SQRT(t*tcpr(i))
     &            *(1.d0+ki(i)*(1.d0-SQRT(t/tcpr(i))))
        enddo
        if (icomp.ne.0) then
          dadt=daidt(icomp)
        else
          dadt=0.d0
          do i=1,nc
          do j=1,nc
            da=SQRT(ai(i)/ai(j))*daidt(j)/2.d0+
     &         SQRT(ai(j)/ai(i))*daidt(i)/2.d0
            dadt=dadt+x(i)*x(j)*(1.d0-fprkij(i,j,1))*da
          enddo
          enddo
        endif
        trm=2.d0*(1.d0+b*d+d*tshift)
        phiprx=4.d0*d/r*(dadt-a/t)/(trm-d*q)/(trm+d*q)
c
      elseif (itau.eq.2 .and. idel.eq.1) then
c  compute cross derivative using term from 1st derivative
        phiprx=0.d0      !not yet implemented
c
      elseif (itau.eq.1 .and. idel.eq.2) then
c  compute cross derivative using term from 2nd derivative
        phiprx=0.d0      !not yet implemented
c
      elseif (itau.eq.2 .and. idel.eq.2) then
        phiprx=0.d0      !not yet implemented
c
      elseif (idel.eq.1) then
c  compute derivative w.r.t. del (dimensionless density)
        phiprx=t1-a/rt/t2
c-------alternative method:
c       phiprx=-1.d0+1.d0/(1.d0-b*d+d*tshift)
c    &         +a/rt/q*(2.d0/v1n-2.d0/v2n)/d
c
      elseif (idel.eq.2) then
c  compute 2nd derivative w.r.t. del (dimensionless density)
        phiprx=t1**2+a/rt/t2**2
     &          *(bu+2.d0*(tshift+dts*tshift+b*dts*u+b2dw))
c-------alternative method:
c       bdt=1.d0-b*d+d*tshift
c       phiprx=1.d0-1.d0/bdt-(tshift*dred-b*dred)*del/bdt**2
c    &        +4.d0*a/rt/q/d*((1.d0/v2n-1.d0/v1n)
c    &        +(1.d0/v1n**2-1.d0/v2n**2)/d)
c
      elseif (idel.eq.3) then
c  compute 3rd derivative w.r.t. del (dimensionless density)
        phiprx=2.d0*t1**3+2.d0*a/rt*d/t2**2
     &        *(tshift**2+b*tshift*u+b2*w)-2.d0*a/rt/t2**3
     &        *(bu+2.d0*(tshift+dts*tshift+b*dts*u+b2dw))**2
c-------alternative method:
c       dts=d*tshift
c       db=d*b
c       bt2=2.d0*(b+tshift)
c       bqtp=bt2+q
c       bqtm=bt2-q
c       term2n=-2.d0+(2.d0+6.d0*db**2+6.d0*dts+6.d0*dts**2
c    &                    -6.d0*db-12.d0*db*dts)/(1.d0-db+dts)**3
c       terma=2.d0+d*bqtm
c       termb=2.d0+d*bqtp
c       termc=4.d0*(db*b+b+tshift*(1.d0+dts+2.d0*db))-d*q**2
c       term3n=-8.d0*a/rt*(q**2
c    &        -4.d0*b**2-8.d0*b*tshift-4.d0*tshift**2
c    &        +2.d0*bqtp*termc/termb
c    &        +2.d0*bqtm*termc/terma)/terma**2/termb**2
c       phiprx=term2n+term3n*d**3
c
      elseif (itau.eq.1) then
c  compute derivative w.r.t. tau (dimensionless temperature)
        do i=1,nc
          daidt(i)=-atci(i)*ki(i)/SQRT(t*tcpr(i))
     &            *(1.d0+ki(i)*(1.d0-SQRT(t/tcpr(i))))
        enddo
        if (icomp.ne.0) then
          dadt=daidt(icomp)
        else
          dadt=0.d0
          do i=1,nc
          do j=1,nc
            da=SQRT(ai(i)/ai(j))*daidt(j)/2.d0+
     &         SQRT(ai(j)/ai(i))*daidt(i)/2.d0
            dadt=dadt+x(i)*x(j)*(1.d0-fprkij(i,j,1))*da
          enddo
          enddo
        endif
        phiprx=(a/t-dadt)*LOG(arg2)/r/q
c
      elseif (itau.eq.2) then
c  compute 2nd derivative w.r.t. tau (dimensionless temperature)
        do i=1,nc
          daidt(i)=-atci(i)*ki(i)/SQRT(t*tcpr(i))*
     &     (1.d0+ki(i)*(1.d0-SQRT(t/tcpr(i))))
          d2aidt2(i)=0.5d0*atci(i)*ki(i)/SQRT(tcpr(i))
     &              *(1.d0+ki(i))/t**1.5d0
        enddo
        if (icomp.ne.0) then
          dadt=daidt(icomp)
          d2adt2=d2aidt2(icomp)
        else
          dadt=0.d0
          d2adt2=0.d0
          do i=1,nc
          do j=1,nc
            da=SQRT(ai(i)/ai(j))*daidt(j)/2.d0+
     &         SQRT(ai(j)/ai(i))*daidt(i)/2.d0
            daij=0.5d0*(daidt(i)/SQRT(ai(i)*ai(j))-
     &                  daidt(j)*SQRT(ai(i))/(ai(j)**1.5d0))
            daji=0.5d0*(daidt(j)/SQRT(ai(j)*ai(i))-
     &                  daidt(i)*SQRT(ai(j))/(ai(i)**1.5d0))
            aaij=SQRT(ai(i)/ai(j))
            aaji=SQRT(ai(j)/ai(i))
            d2a=(aaij*d2aidt2(j)+daidt(j)*daij
     &         + aaji*d2aidt2(i)+daidt(i)*daji)*0.5d0
            dadt=dadt+x(i)*x(j)*(1.d0-fprkij(i,j,1))*da
            d2adt2=d2adt2+x(i)*x(j)*(1.d0-fprkij(i,j,1))*d2a
          enddo
          enddo
        endif
        phiprx=d2adt2*t*LOG(arg2)/r/q
c
      elseif (itau.eq.3) then
c  compute 3rd derivative w.r.t. tau (dimensionless temperature)
        phiprx=0.d0      !not yet implemented
      end if
c
c     drvsvp(icomp,ncode)=phiprx
c     drvflp(icomp)(ncode:ncode)='1'
c
      RETURN
      end                                               !function PHIPRX
c ======================================================================
c
      subroutine CRTPR (icomp,tc,pc,rhoc)
c
c  returns critical parameters associated with PR model
c
c  input:
c    icomp--pointer specifying component (1..nc)
c  outputs:
c       tc--critical temperature [K]
c       pc--critical pressure [kPa]
c     rhoc--molar density [mol/L] at critical point
c
c  written by NIST Thermophysics Division, Boulder, Colorado
c  09-24-04 original version
c
      include 'commons.for'
c
      tc=tcrit(icomp)
      pc=pcrit(icomp)
      rhoc=Dcrit(icomp)
c
      RETURN
      end                                              !subroutine CRTPR
c
c ======================================================================
c
      subroutine CRTPRX (x,tc,pc,rhoc)
c
c  returns critical parameters associated with PR model
c
c  input:
c        x--composition array [mol frac]
c  outputs:
c       tc--critical temperature [K]
c       pc--critical pressure [kPa]
c     rhoc--molar density [mol/L] at critical point
c
c  written by NIST Thermophysics Division, Boulder, Colorado
c  10-21-04 original version
c
      include 'commons.for'
      dimension x(ncmax)
c
      call ISPURE (x,icomp)
      if (icomp.ne.0) then
        tc=tcrit(icomp)
        pc=pcrit(icomp)
        rhoc=Dcrit(icomp)
      else
        tc=0.d0
        pc=0.d0
        rhoc=0.d0
        do k=1,nc
          tc=tc+x(k)*tcrit(k)
          pc=pc+x(k)*pcrit(k)
          rhoc=rhoc+x(k)*Dcrit(k)
        enddo
      endif
c
      RETURN
      end                                             !subroutine CRTPRX
c
c ======================================================================
c
      subroutine REDPR (x,tred,Dred)
c
c  returns reducing parameters associated with PR model
c
c  input:
c        x--composition array [mol frac]
c  outputs:
c     tred--reducing temperature [K]
c     Dred--reducing molar density [mol/L]
c
c  written by NIST Thermophysics Division, Boulder, Colorado
c  09-24-04 original version
c
      include 'commons.for'
      dimension x(ncmax)
c
      call ISPURE (x,icomp)
      if (icomp.ne.0) then
        tred=tz(icomp)
        Dred=rhoz(icomp)
      else
        tsum=0.d0
        Vsum=0.d0
        do i=1,nc
          tsum=tsum+x(i)*tz(i)
          Vsum=Vsum+x(i)/rhoz(i)
        enddo
        if (ABS(tsum).gt.0.5d-12 .and. ABS(Vsum).gt.0.5d-12) then
          tred=tsum
          Dred=1.d0/Vsum
        else
          tred=100
          Dred=10
        endif
c
        RETURN
      endif
      end                                              !subroutine REDPR
c
c ======================================================================
c
      subroutine SETPR (nread,icomp,hcasno,ierr,herr)
c
c  set up working arrays for use with cubic equations of state
c
c  inputs:
c    nread--file to read data from
c    icomp--component number in mixture (1..nc); 1 for pure fluid
c   hcasno--CAS number of component icomp (not req'd if reading from file)
c
c  outputs:
c     ierr--error flag:  0 = successful
c                        1 = error (e.g. fluid not found)
c     herr--error string (character*255 variable if ierr<>0)
c
c  written by E.W. Lemmon, NIST Thermophysics Division, Boulder, Colorado
c  11-10-04 EWL, original version
c  09-11-09 EWL, initialize prcoef
c
      include 'commons.for'
      character*3 hmodcp2
      character*12 hcasno
      character*255 herr
c
      ierr=0
      herr=' '
c
      if (nread.eq.999) then
        acnpr(icomp)=accen(icomp)
        wmfpr(icomp)=wmas(icomp)
        tcpr(icomp)=tcrit(icomp)
        pcpr(icomp)=pcrit(icomp)
        rhocpr(icomp)=Dcrit(icomp)
        Rprq(icomp)=Reos(icomp)
        RETURN
      endif

c
c  read data from file
      read (abs(nread),*) tmin                 !lower temperature limit
      read (abs(nread),*) tmax                 !upper temperature limit
      read (abs(nread),*) pmax                 !upper pressure limit
      read (abs(nread),*) rhomx2               !upper density limit
      read (abs(nread),2003) hmodcp2           !pointer to Cp0 model
      read (abs(nread),*) wmfpr(icomp)           !molecular weight
      read (abs(nread),*) acnpr(icomp)           !acentric factor
      read (abs(nread),*) tcpr(icomp)
      read (abs(nread),*) pcpr(icomp)
      read (abs(nread),*) rhocpr(icomp)
      read (abs(nread),*) Rprq(icomp)           !gas constant
      if (nread.gt.0) then
        Deos(icomp)=rhomx2
        hmodcp(icomp)=hmodcp2
        accen(icomp)=acnpr(icomp)
        wmas(icomp)=wmfpr(icomp)
        tcrit(icomp)=tcpr(icomp)
        pcrit(icomp)=pcpr(icomp)
        Dcrit(icomp)=rhocpr(icomp)
        tz(icomp)=tcpr(icomp)
        rhoz(icomp)=rhocpr(icomp)
        ptpn(icomp)=0.d0
        dtpn(icomp)=0.d0
        dtpv(icomp)=0.d0
        dnbpl(icomp)=0.d0
        dnbpv(icomp)=0.d0
        if (nc.eq.1 .and. icomp.eq.1) R=Rprq(icomp)
        Reos(icomp)=Rprq(icomp)
        Zcrit(icomp)=pcpr(icomp)/(Rprq(icomp)*tcpr(icomp)*rhocpr(icomp))
        tmeos(icomp)=tmin
        txeos(icomp)=tmax
        peos(icomp)=pmax
      endif
      read (abs(nread),*) nj
      if (icomp.ge.0) then
        prcoef(icomp,1)=0.d0
        if (nj.gt.0) then
          iprflag(icomp)=1  !values read in
          do j=1,nj
            read (abs(nread),*) prcoef(icomp,j)
          enddo
        endif
      endif
c
      RETURN
 2003 format (a3)
      end                                              !subroutine SETPR
c
c ======================================================================
c
      subroutine SETPRCO (i)
c
c     compute a value for the translation factor in translated Peng Robinson EOS
c     for component i
c
c  written by NIST Thermophysics Division, Boulder, Colorado
c
      include 'commons.for'
c
c     compute translation factor if not pre-loaded
c     default prescription is constant portion of translation in
c     Magoulas, K and Tassios, D. FPE 56 (1990) 119-140
c     do not use a t-dependent translation- see Pfohl, O. FPE 163 (1999) 157-159.
      if (iprflag(i).lt.1 .and. pcpr(i).gt.0.d0) then
         tr0=-0.014471d0+0.067498d0*acnpr(i)-0.084852d0*acnpr(i)**2
     &      +0.067298d0*acnpr(i)**3-0.017366d0*acnpr(i)**4
         prcoef(i,1)=(R*tcpr(i)/pcpr(i))*tr0
      endif
      RETURN
      end                                            !subroutine SETPRCO
c
c ======================================================================
c
      subroutine PREOS (i)
c
c  Turn on or off the use of the PR cubic equation.  Should be called after
c  calling SETUP.
c
c  inputs:
c        i--flag specifying use of PR:
c           0 - Use full equation of state (Peng-Robinson off)
c           1 - Use full equation of state with Peng-Robinson for sat. conditions
c               (not currently working)
c           2 - Use Peng-Robinson equation for all calculations
c           if i=-1, then i is returned with current usage of PR:  0, 1, or 2.
c
c  written by E.W. Lemmon, NIST Thermophysics Division, Boulder, Colorado
c  07-21-03 EWL, original version
c  08-11-06 MLH, use variable hrf instead of 'DEF'
c
cx DEC$ ATTRIBUTES DLLEXPORT :: PREOS
c
      include 'commons.for'
      character*255 herr
      character hrf*3
      dimension x0(ncmax)
c
      lsatt=.false.
      lsatp=.false.
      k=1
      hrf='DEF'
      if (i.eq.-1) then
        i=0
        if (heos.eq.'PR') i=1
      elseif (i.eq.1) then
        if (heos.ne.'PR') hprsav=heos
        do j=1,nx
          if (hmxeos(j).ne.'PR') hmxsv(j)=hmxeos(j)
          hmxeos(j)='PR'
        enddo
        heos='PR'
        hsvrfs=' '
        call SETREF (hrf,k,x0,h0,s0,t0,p0,ierr,herr)
      elseif (i.eq.2) then       ! this should be for full prs
        if (heos.ne.'PR') hprsav=heos
        do j=1,nx
          if (hmxeos(j).ne.'PR') hmxsv(j)=hmxeos(j)
          hmxeos(j)='PR'
        enddo
        heos='PR'
        hsvrfs=' '
        call SETREF (hrf,k,x0,h0,s0,t0,p0,ierr,herr)
      elseif (hprsav.ne.' ') then
        do j=1,nx
          if (hmxsv(j).ne.' ') hmxeos(j)=hmxsv(j)
        enddo
        heos=hprsav
        hsvrfs=' '
        hprsav=' '
        call SETREF (hrf,k,x0,h0,s0,t0,p0,ierr,herr)
      endif
c
      RETURN
      end                                              !subroutine PREOS
c
c ======================================================================
c
      subroutine TPRHOPR (t,p,x,rho1,rho2)
c  compute density using a volume-translated modification of the Peng-Robinson equation of state
c  EOS: P=RT/(v+t+b)-a/((v+t)*(v+t+b)+b(v+t+b)), t is a translation constant
c  Translation concept given in Peneloux, A. and Rauzy, E., FPE 8 (1982) 7-23
c
c  written by NIST Thermophysics Division, Boulder, Colorado
c  10-11-04 original version
c
      include 'commons.for'
      double precision x(ncmax),ai(ncmax),bi(ncmax),ki(ncmax)
      dimension atci(ncmax),az(3),zz(3)
c
      icomp=0
      call ISPURE (x,icomp)
c     ierr=0
c     herr=' '
c
      call REDX (x,tred,Dred)
      if (icomp.ne.0 .and. hcas(icomp).eq.'811-97-2') then     !R-134a
        tred=374.18d0
        Dred=4.978830171d0
      endif
      rt=r*t
c     set volume translation factor
      tshift=0.d0
      if (icomp.ne.0) then
        tshift=prcoef(icomp,1)
      else
        do i=1,nc
          tshift=tshift+x(i)*prcoef(i,1)
        enddo
      endif
c     tshift=0.d0      !For testing purposes only

      do i=1,nc
        bi(i)=0.0778d0*r*tcpr(i)/pcpr(i)
        ki(i)=0.37464d0+1.54226d0*acnpr(i)-0.26992d0*acnpr(i)**2
        atci(i)=0.45724d0*r**2*tcpr(i)**2/pcpr(i)
        ai(i)=atci(i)*(1.d0+ki(i)*(1.d0-SQRT(t/tcpr(i))))**2
      enddo
      if (icomp.ne.0) then
        a=ai(icomp)
        b=bi(icomp)
      else
        a=0.d0
        b=0.d0
        do i=1,nc
          do j=1,nc
            a=a+x(i)*x(j)*SQRT(ai(i)*ai(j))*(1.d0-fprkij(i,j,1))
          enddo
          b=b+x(i)*bi(i)
        enddo
      endif
c
c
c
      aa=a*p/r**2/T**2
      bb=b*p/r/T
      az(1)=(-aa+bb+bb**2)*bb
      az(2)=aa-bb*(3.d0*bb+2.d0)
      az(3)=bb-1.d0
c     revised translated eos
c     solve the cubic equation
c     only use largest and smallest roots; middle one does not have a physical meaning
      call CUBIC(az,zz)
c     compute the translation term
      rho1=p/(zz(1)*rt) !largest density root
      rho2=p/(zz(2)*rt) !smallest density root
      v1=1.d0/rho1
      v2=1.d0/rho2
      rho1=1.d0/(v1-tshift)
      rho2=1.d0/(v2-tshift)
c
c     the following lines can be uncommented to demonstrate that the shifted equation
c     is equivalent to the non-shifted version
c     if the shift is zero, it is identical to the PR EOS
c
c      CC=tshift*p/r/T
c      az(1)=(-AA*BB +BB*BB +BB*BB*BB) +
c     :      (-3.*BB*BB*CC + AA*CC + BB*CC*CC + CC*CC*CC -2.*BB*CC-CC*CC)
c      az(2) = (AA-3.*BB*BB-2.*BB) +
c     :      (2.*BB*CC + 3.*CC*CC - 2.*CC)
c      az(3) = (BB-1.d0) +3.*CC
c      call CUBIC(az,zz)
c       compute the translation term
c      rho1 = p / (zz(1) * rt) !largest density root
c      rho2 = p / (zz(2) * rt) !smallest density root
c
      RETURN
      end                                            !subroutine TPRHOPR
c
c ======================================================================
c
      subroutine ESTPR (i,j,ibin,ierr,herr)
c
c  estimate binary parameters for the Peng Robinson mixture model
c  estimates based on the following references
c     Nishiumi, H., Arai, T. and Takeuchi, K., FPE 42 (1988) 43-62
c     Valderrama and Reyes, FPE 13 (1983) 195-202
c
c
c  inputs:
c        i--component i
c        j--component j
c     ibin--counter for binary pair (1,2 = 1; 1,3 = 2; 2,3 = 3; etc.)
c  outputs:
c     ierr--error flag:  0 = successful
c                     -117 = no binary parameters found (warning)
c                      117 = no binary parameters found (critical error)
c
c     Binary interaction parameters fprkij are written to common block CFXPR
c
c     original version 10.14.04
c  10-04-07  HH, change MXINF2 to MXINF1 as is the case in other code
c  05-21-10 EWL, do not set hbin in this routine, overwrites HMX file
c
      include 'commons.for'
      character*255 herr
      dimension ifam(n0:nx),IJ(2)
c
c     legend
c     igroup    type
c
c     0         not covered in the correlation
c     1         c1-c16 alkane, branched alkanes
c     2         cycloalkane
c     3         alkene
c     4         aromatic
c     5         c18-c20 alkanes
c     6         CO2
c     7         N2
c     8         H2S
c     9         acetylene
c
c               mixtures with hydrogen are covered separately using Valderram correlation
c
      dimension igroup(0:11,0:11),binco(5,14)

      parameter (igroup = reshape((/
     & 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
     & 0, 1, 1, 2, 3, 4, 5, 7, 8,10, 0, 0,
     & 0, 1, 1, 0, 3, 0, 5, 0, 0, 0, 0, 0,
     & 0, 2, 0, 2, 3, 4, 6, 7, 8, 9, 0, 0,
     & 0, 3, 3, 3, 3, 0, 6, 7,12,11, 0, 0,
     & 0, 4, 0, 4, 0, 0, 4, 0, 0, 0, 0, 0,
     & 0, 5, 5, 6, 6, 4, 0,12,13, 0, 0, 0,
     & 0, 7, 0, 7, 7, 0,12, 0,14, 0, 0, 0,
     & 0, 8, 0, 8,12, 0,13,14, 0, 0, 0, 0,
     & 0,10, 0, 9,11, 0, 0, 0, 0, 0, 0, 0,
     & 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
     & 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0/), (/12,12/)))

      parameter (binco = reshape((/
     & 1.041, 0.110,-0.0403, 0.0367, 0.0000,
     & 1.017,-0.417,-0.0124, 0.0852, 0.0000,
     & 1.025, 0.317,-0.0385,-0.0258, 0.0000,
     & 0.823, 0.000, 0.0673, 0.0000,-0.0051,
     & 0.883, 0.000, 0.0023, 0.0000, 0.0000,
     & 0.948, 0.000,-0.0084, 0.0000, 0.0000,
     & 0.982, 0.000,-0.0241, 0.0000, 0.0000,
     & 0.907, 0.000, 0.0109, 0.0000, 0.0000,
     & 1.090, 0.000,-0.1435, 0.0000, 0.0000,
     & 0.855, 0.000, 0.0000, 0.0000, 0.0000,
     & 0.965, 0.000, 0.0000, 0.0000, 0.0000,
     & 1.016, 0.000, 0.0000, 0.0000, 0.0000,
     & 0.894, 0.000, 0.0000, 0.0000, 0.0000,
     & 0.848, 0.000, 0.0000, 0.0000, 0.0000/), (/5,14/)))

c     DATA (igroup(k, 0),k=0,11)/0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0/
c     DATA (igroup(k, 1),k=0,11)/0, 1, 1, 2, 3, 4, 5, 7, 8,10, 0, 0/
c     DATA (igroup(k, 2),k=0,11)/0, 1, 1, 0, 3, 0, 5, 0, 0, 0, 0, 0/
c     DATA (igroup(k, 3),k=0,11)/0, 2, 0, 2, 3, 4, 6, 7 ,8, 9, 0, 0/
c     DATA (igroup(k, 4),k=0,11)/0, 3, 3, 3, 3, 0, 6, 7,12,11, 0, 0/
c     DATA (igroup(k, 5),k=0,11)/0, 4, 0, 4, 0, 0, 4, 0, 0, 0, 0, 0/
c     DATA (igroup(k, 6),k=0,11)/0, 5, 5, 6, 6, 4, 0,12,13, 0, 0, 0/
c     DATA (igroup(k, 7),k=0,11)/0, 7, 0, 7, 7, 0,12, 0,14, 0, 0, 0/
c     DATA (igroup(k, 8),k=0,11)/0, 8, 0, 8,12, 0,13,14, 0, 0, 0, 0/
c     DATA (igroup(k, 9),k=0,11)/0, 10,0, 9,11, 0, 0, 0, 0, 0, 0, 0/
c     DATA (igroup(k,10),k=0,11)/0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0/
c     DATA (igroup(k,11),k=0,11)/0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0/
c     DATA (binco(k,1), k=1,5)/1.041, 0.110,-0.0403, 0.0367, 0.0000/
c     DATA (binco(k,2), k=1,5)/1.017,-0.417,-0.0124, 0.0852, 0.0000/
c     DATA (binco(k,3), k=1,5)/1.025, 0.317,-0.0385,-0.0258, 0.0000/
c     DATA (binco(k,4), k=1,5)/0.823, 0.000, 0.0673, 0.0000,-0.0051/
c     DATA (binco(k,5), k=1,5)/0.883, 0.000, 0.0023, 0.0000, 0.0000/
c     DATA (binco(k,6), k=1,5)/0.948, 0.000,-0.0084, 0.0000, 0.0000/
c     DATA (binco(k,7), k=1,5)/0.982, 0.000,-0.0241, 0.0000, 0.0000/
c     DATA (binco(k,8), k=1,5)/0.907, 0.000, 0.0109, 0.0000, 0.0000/
c     DATA (binco(k,9), k=1,5)/1.090, 0.000,-0.1435, 0.0000, 0.0000/
c     DATA (binco(k,10),k=1,5)/0.855, 0.000, 0.0000, 0.0000, 0.0000/
c     DATA (binco(k,11),k=1,5)/0.965, 0.000, 0.0000, 0.0000, 0.0000/
c     DATA (binco(k,12),k=1,5)/1.016, 0.000, 0.0000, 0.0000, 0.0000/
c     DATA (binco(k,13),k=1,5)/0.894, 0.000, 0.0000, 0.0000, 0.0000/
c     DATA (binco(k,14),k=1,5)/0.848, 0.000, 0.0000, 0.0000, 0.0000/
c
c     assign family code to components i and j
c     initialize to zero
      do k=1,nmxprb
        fprkij(i,j,k)=0.0d0
        fprkij(j,i,k)=0.0d0
      enddo
      ierr=0
      ij(1)=i
      ij(2)=j
      if (i.ne.j) then
        do k=1,2
          iL=ij(k)
          if ((family(iL).eq.'br-alkane').or.
     &        (family(iL).eq.'n-alkane')) then
            if (wmas(iL).lt.227) then                           !c1 to c16
              ifam(iL)=1
            elseif (wmas(iL).gt.227 .and. wmas(iL).lt.283) then !c17 to c20
              ifam(iL)=5
            else
              ifam(iL)=5                                   !treat like c17-c20 :untested
            endif
          elseif (family(iL).eq.'napthene') then
            ifam(iL)=2
          elseif (family(iL).eq.'br-alkene') then
            ifam(iL)=3
          elseif (family(iL).eq.'n-alkene') then
            ifam(iL)=3
          elseif (family(iL).eq.'aromatic') then
            ifam(iL)=4
          elseif (hcas(iL).eq.'124-38-9')   then            !co2
            ifam(iL)=6
          elseif (hcas(iL).eq.'7727-37-9')  then            !n2
            ifam(iL)=7
          elseif (hcas(iL).eq.'7783-06-4')  then            !h2s
            ifam(iL)=8
          elseif (hcas(iL).eq.'74-86-2')    then            !acetylene
            ifam(iL)=9
          elseif (family(iL).eq.'other')    then            !other fluids
            ifam(iL)=10
          else
            ifam(iL)=0                                     !not covered
          endif
        enddo
c
c    The following is the correlation of Nishiumi and Arai
        if (igroup(ifam(i),ifam(j)).eq.0) then
          fprkij(i,j,1)=0.d0
          ierr=-117
        else
          wdif=ABS(acnpr(i)-acnpr(j))
          kk=igroup(ifam(i),ifam(j))
          bigc=binco(1,kk)+binco(2,kk)*wdif
          bigd=binco(3,kk)+binco(4,kk)*wdif
          bige=binco(5,kk)
          vcrat=dcrit(i)/dcrit(j)
          if (vcrat.lt.1.d0) vcrat=1.d0/vcrat
          fprkij(i,j,1)=1.d0-(bigc+bigd*vcrat+bige*vcrat**2)
          fprkij(j,i,1)=fprkij(i,j,1)
          ierr=0
        endif
c
c     The following is the correlation of Valderrama, J.O. and Reyes, L.R.
c     FPE 13, 195-202.  for mixtures with hydrogen,
c     but evaluated at the normal boiling point of the
c     non-hydrogen component instead of using full temperature dependence.
        if (hcas(i).eq.'1333-74-0' .or. hcas(j).eq.'1333-74-0') then
          if (hcas(i).eq.'1333-74-0') then
            wi2=acnpr(j)
            tr2=tnbp(j)/tcrit(j)
          else
            wi2=acnpr(i)
            tr2=tnbp(i)/tcrit(i)
          endif
          alpha2=0.1805d0+3.21d0*wi2+2.437d0*wi2**2
          beta2=0.1323d0+0.5507d0*wi2+3.5994d0*wi2**2
          fprkij(i,j,1)=alpha2-beta2/tr2
          fprkij(j,i,1)=fprkij(i,j,1)
          ierr=0
        endif
      else
        fprkij(i,j,1)=0.d0
        ierr=0
      endif
c
c     The following is based loosely upon correlation of water+alkane given in
c     Daridon, J.L., Lagourette, B., Saint-Guirons, H. and Xans, P., FPE 91(1993),31-54
c     does not implement temp or composition dependent contribution; thus just a rough estimate
      if (hcas(i).eq.'7732-18-5') then
         if (family(j).eq.'n-alkane') then
           nmet=(INT(wmas(j))-2)/14 -2  !number of -ch2- groups
           fprkij(i,j,1)=0.5d0 -0.00834d0*float(nmet)
           fprkij(j,i,1)=fprkij(i,j,1)
           ierr=0
         endif
      elseif (hcas(j).eq.'7732-18-5') then
         if (family(i).eq.'n-alkane') then
           nmet=(INT(wmas(i))-2)/14 -2  !number of -ch2- groups
           fprkij(j,i,1)=0.5d0 -0.00834d0*float(nmet)
           fprkij(i,j,1)=fprkij(j,i,1)
           ierr=0
         endif
      endif
c
      fprkij(j,i,1)=fprkij(i,j,1)
c
c     set warning messages for GUI
      if (ierr.eq.-117) then
        herr='[SETUP error -117] Binary interaction parameters are not '
     &     //'presently available for this mixture; calculations '
     &     //'will be made assuming ideal solution behavior. '//hnull
c       hbin(ibin)='Estimation of mixing parameters is not available '
c    &     //'for this mixture.'//hnull
c  do not call this yet until this routine is fully functional
c       call ERRMSG (ierr,herr)
      endif
c
      RETURN
      end                                              !subroutine ESTPR
c
c        1         2         3         4         5         6         7
c23456789012345678901234567890123456789012345678901234567890123456789012
c
c ======================================================================
c                                                     end file core_PR.f
c ======================================================================
c  begin file core_QUI.f
c
c  This file contains the routines implementing the Helmholtz form of
c  the pure fluid equation of state in the Quintic form.
c
c  contained here are:
c     function PHIQUI (icomp,itau,idel,tau,del)
c     subroutine CRTQUI (icomp,tc,pc,Dc)
c     subroutine REDQUI (icomp,tred,Dred)
c     subroutine SETQUI (nread,icomp,hcasno,ierr,herr)
c
c ======================================================================
c ======================================================================
c
      function PHIQUI (icomp,itau,idel,tau,del)
c
c  compute reduced Helmholtz energy or a derivative as functions
c  of dimensionless temperature and density for the Helmholtz-explicit
c  equation of state
c
c  inputs:
c    icomp--pointer specifying component (1..nc)
c     itau--flag specifying order of temperature derivative to calc
c     idel--flag specifying order of density derivative to calculate
c           when itau = 0 and idel = 0, compute A/RT
c           when itau = 0 and idel = 1, compute 1st density derivative
c           when itau = 1 and idel = 1, compute cross derivative
c           etc.
c      tau--dimensionless temperature (To/T)
c      del--dimensionless density (D/Do)
c  output (as function value):
c      phi--residual (real-gas) part of the Helmholtz energy, or one
c           of its derivatives (as specified by itau and idel),
c           in reduced form (A/RT)
c           itau  idel    output (dimensionless for all cases)
c             0    0      A/RT
c             1    0      tau*[d(A/RT)/d(tau)]
c             2    0      tau**2*[d**2(A/RT)/d(tau)**2]
c             0    1      del*[d(A/RT)/d(del)]
c             0    2      del**2*[d**2(A/RT)/d(del)**2]
c             1    1      tau*del*[d**2(A/RT)/d(tau)d(del)]
c                         etc.
c
c  written by D.E. Cristancho, NIST Thermophysics Division, Boulder, Colorado
c  06-18-09 DEC, original version
c
      include 'commons.for'
c
      phiqui=0.d0
      if (del.le.1.0d-10) RETURN  !trivial solution at zero density for
      if (tau.le.0.d0) RETURN    !  any and all derivatives
c
      ncode=idel*4+itau+1
      nterm=netaq(icomp)+nepsq(icomp)+nbbq(icomp)+ngamq(icomp)
     &     +nbetq(icomp)
      if (abs(tau-tausvq(icomp)).lt.1.0d-12 .and.
     &    abs(del-delsvq(icomp)).lt.1.0d-16) then
c  retrieve value from previous call
        if (drvflq(icomp)(ncode:ncode).eq.'1') then
          phiqui=drvsvq(icomp,ncode)
          RETURN
        endif
      else
c  otherwise, compute new values and save for possible future use
c  first compute needed powers of tau and del (and save for future use)
        drvflq(icomp)='0000000000000000'
        if (abs(tau-tausvq(icomp)).gt.1.0d-12) then
          elntau=log(tau)
          tausvq(icomp)=tau
          do j=1,nterm
            taupq(icomp,j)=tiqui(icomp,j)*elntau
          enddo
        end if
        if (abs(del-delsvq(icomp)).gt.1.0d-16) then
          elndel=log(del)
          delsvq(icomp)=del
          do j=1,nterm
            delpq(icomp,j)=diqui(icomp,j)*elndel
          enddo
        end if
c
        phisum=0.d0
        etaq=0.d0
        etaq10=0.d0
        etaq20=0.d0
        epsq=0.d0
        epsq10=0.d0
        epsq20=0.d0
        bbq00=0.d0
        bbq10=0.d0
        bbq20=0.d0
        gamq=0.d0
        gamq10=0.d0
        gamq20=0.d0
        betq=0.d0
        betq10=0.d0
        betq20=0.d0
        j=0
        do k=1,netaq(icomp)
          j=j+1
          etaqui=etaqui+aqui(icomp,j)*tau**tiqui(icomp,j)
          etaqui10=etaqui10
     &          +tiqui(icomp,j)*aqui(icomp,j)*tau**(tiqui(icomp,j)-1.d0)
          etaq20=etaq20+tiqui(icomp,j)*(tiqui(icomp,j)-1.d0)*
     &           aqui(icomp,j)*tau**(tiqui(icomp,j)-2.d0)
        enddo
        do k=1,nepsq(icomp)
          j=j+1
          epsq=epsq+aqui(icomp,j)*tau**tiqui(icomp,j)
          epsq10=epsq10
     &          +tiqui(icomp,j)*aqui(icomp,j)*tau**(tiqui(icomp,j)-1.d0)
          epsq20=epsq20+tiqui(icomp,j)*(tiqui(icomp,j)-1.d0)*
     &           aqui(icomp,j)*tau**(tiqui(icomp,j)-2.d0)
        enddo
        do k=1,nbbq(icomp)
          j=j+1
          bbq00=bbq00+aqui(icomp,j)*tau**tiqui(icomp,j)
          bbq10=bbq10
     &         +tiqui(icomp,j)*aqui(icomp,j)*tau**(tiqui(icomp,j)-1.d0)
          bbq20=bbq20+tiqui(icomp,j)*(tiqui(icomp,j)-1.d0)*
     &           aqui(icomp,j)*tau**(tiqui(icomp,j)-2.d0)
        enddo
        do k=1,ngamq(icomp)
          j=j+1
          gamq=gamq+aqui(icomp,j)*tau**tiqui(icomp,j)
          gamq10=gamq10
     &          +tiqui(icomp,j)*aqui(icomp,j)*tau**(tiqui(icomp,j)-1.d0)
          gamq20=gamq20+tiqui(icomp,j)*(tiqui(icomp,j)-1.d0)*
     &           aqui(icomp,j)*tau**(tiqui(icomp,j)-2.d0)
        enddo
        do k=1,nbetq(icomp)
          j=j+1
          betq=betq+aqui(icomp,j)*tau**tiqui(icomp,j)
         betq10=betq10
     &         +tiqui(icomp,j)*aqui(icomp,j)*tau**(tiqui(icomp,j)-1.d0)
          betq20=betq20+tiqui(icomp,j)*(tiqui(icomp,j)-1.d0)*
     &           aqui(icomp,j)*tau**(tiqui(icomp,j)-2.d0)
        enddo
        phisum=etaq*(del-log(1.d0-bbq00*del)/bbq00)
     &        -epsq*log((1.d0+gamq*del)/(1.d0-betq*del))
c         ex=taupq(icomp,k)+delpq(icomp,k)
c         if (ex.lt.100.d0 .and. ex.gt.-200.d0) then
c           phisvq(icomp,k)=aqui(icomp,k)*EXP(ex)
c         else
c           phisvq(icomp,k)=0.d0
c         endif
c         phisum=phisum+phisvq(icomp,k)
        phiqui=phisum
        drvflq(icomp)(1:1)='1'
        drvsvq(icomp,1)=phiqui
      end if
c
c  check if derivatives are requested, calculations make use of fact
c  that terms in derivative summations are very similar to A/RT terms
c
      if (idel.eq.1) then
c  compute derivative w.r.t. del (dimensionless density)
c  save individual terms for possible use in cross derivative
        phisum=0.d0
        phisum=etaq*(1.d0+1.d0/(1.d0-bbq00*del))
     &        -epsq*(gamq/(1.d0+gamq*del)+betq/(1.d0-betq*del))
        phiqui=phisum*del
c
      elseif (idel.eq.2) then
c  compute 2nd derivative w.r.t. del (dimensionless density)
c  save individual terms for possible use in cross derivative
        phisum=0.d0
c        do k=1,nterm
c          dik=diqui(icomp,k)
c          phiq02(k)=phisvq(icomp,k)*(dik**2-dik)
c           phisum+phiq02(k)
c          phisum=etaq*(1.d0+1.d0/(1.d0-bbq00*del))
c              epsq*(gamq/(1.d0+gamq*del)+betq/(1.d0-betq*del))
c         enddo
        phisum=etaq*bbq00/(1.d0-bbq00*del)**2
     &        -epsq*(-gamq**2/(1.d0+gamq*del)**2
     &        +betq**2/(1.d0-betq*del)**2)
        phiqui=phisum*del**2
c
      elseif (idel.eq.3) then
c  compute 3rd derivative w.r.t. del (dimensionless density)
        phisum=0.d0
c        do k=1,nterm
c          dik=diqui(icomp,k)
c          phiq03(k)=phisvq(icomp,k)
c    &     +6.0d0*dik-3.0d0*dik-3.0d0*dik**2
c          phisum=phisum+phiq03(k)
c        enddo
        phisum=2.d0*etaq*bbq00**2/(1.d0-bbq00*del)**3
     &        -2.d0*epsq*(gamq**3/(1.d0+gamq*del)**3
     &        +betq**3/(1.d0-betq*del)**3)
        phiqui=phisum*del**3
      end if
c
c
c   epsqi0,bbqio,gamqi0,betqi0,etaqi0 are the i tau derivatives of fitting
c   parameters
c
      if (itau.eq.1) then
c  compute derivative w.r.t. tau (dimensionless temperature)
c  save individual terms for possible use in cross derivative
        phisum=0.d0
          phisum=etaq10*(del-log(1.d0-bbq00*del)/bbq00)
     &        +etaq*bbq10/bbq00*(log(1.d0-bbq00*del)/bbq00
     &        +del/(1.d0-bbq00*del))
     &        -epsq10*log((1.d0+gamq*del)/(1.d0-betq*del))
     &        -epsq*del*(gamq10/(1.d0+gamq*del)
     &        +betq10/(1.d0-betq*del))
        phiqui=phisum*tau
c
      elseif (itau.eq.2) then
c  compute 2nd derivative w.r.t. tau (dimensionless temperature)
c  save individual terms for possible use in cross derivative
        phisum=0.d0
c        do k=1,nterm
c          tik=tiqui(icomp,k)
c          phiq20(k)=phisvq(icomp,k)*tik*(tik-1.0d0)
c          phisum=phisum+phiq20(k)
c        enddo
          phisum=etaq20*(del-log(1.d0-bbq00*del)/bbq00)
     &        +1.d0/bbq00*(2.d0*etaq10*bbq10+etaq*bbq20
     &        -etaq*bbq10**2/bbq00)
     &        *(log(1.d0-bbq00*del)/bbq00+del/(1.d0-bbq00*del))
     &        +etaq*bbq10**2/bbq00**2*(del*(2.d0*bbq00*del-1)/
     &        (1.d0-bbq00*del)**2-log(1.d0-bbq00*del)/bbq00)
     &        -epsq20*log((1.d0+gamq*del)/(1.d0-betq*del))
     &        -2.d0*epsq10*del*(gamq10/(1.d0+gamq*del)
     &        +betq10/(1.d0-betq*del))
     &        -epsq*del*(gamq20/(1.d0+gamq*del)
     &        +betq20/(1.d0-betq*del)-del*(gamq10**2/
     &        (1.d0+gamq*del)**2-betq10**2/(1.d0-betq*del)**2))

        phiqui=phisum*tau**2
c
C    not third derivative!!!!!
      elseif (itau.eq.3) then
c  compute 3rd derivative w.r.t. tau (dimensionless temperature)
        phisum=0.d0
        do k=1,nterm
          tik=tiqui(icomp,k)
          phisum=phisum+phisvq(icomp,k)*tik*(tik-1.d0)*(tik-2.d0)
        enddo
        phiqui=phisum
      end if
c
c
      if (itau.eq.1 .and. idel.eq.1) then
c  compute cross derivative using terms from 1st derivatives
        phisum=0.d0
          phisum=etaq10*(1.d0+1.d0/(1.d0-bbq00*del))
     &        +etaq*bbq10*del/(1.d0-bbq00*del)**2
     &        -epsq10*(gamq/(1.d0+gamq*del)+betq/(1.d0-betq*del))
     &        -epsq*(gamq10/(1.d0+gamq*del)
     &        +betq10/(1.d0-betq*del)-del*(gamq*gamq10/
     &        (1.d0+gamq*del)**2-betq*betq10/(1.d0-betq*del)**2))
        phiqui=phisum*del*tau
c
      elseif (itau.eq.2 .and. idel.eq.1) then
c  compute cross derivative using term from 1st derivative
        phisum=0.d0
C       do k=1,nterm
C         tik=tiqui(icomp,k)
C         phisum=phisum+(tik*tik-tik)*phiq01(k)
C       enddo
        phiqui=phisum
c
      elseif (itau.eq.1 .and. idel.eq.2) then
c  compute cross derivative using term from 2nd derivative
        phisum=0.d0
C       do k=1,nterm
C         phisum=phisum+tiqui(icomp,k)*phiq02(k)
C       enddo
        phiqui=phisum
c
      elseif (itau.eq.2 .and. idel.eq.2) then
c  compute cross derivative using terms from 2nd derivative
        phisum=0.d0
C       do k=1,nterm
C         tik=tiqui(icomp,k)
C         phisum=phisum+(tik*tik-tik)*phiq02(k)
C       enddo
        phiqui=phisum
c
      end if
c
      drvsvq(icomp,ncode)=phiqui
      drvflq(icomp)(ncode:ncode)='1'
c
      RETURN
      end                                               !function PHIQUI
c
c ======================================================================
c
      subroutine CRTQUI (icomp,tc,pc,Dc)
c
c  returns critical parameters associated with Fundamental EOS
c
c  input:
c    icomp--pointer specifying component (1..nc)
c  outputs:
c    tc--critical temperature (K)
c    pc--critical pressure (kPa)
c    Dc--molar density (mol/L) at critical point
c
c  written by D.E. Cristancho, NIST Thermophysics Division, Boulder, Colorado
c  06-18-09 DEC, original version
c
      include 'commons.for'
c
      tc=tcqui(icomp)
      pc=pcqui(icomp)
      Dc=rhocq(icomp)
c
      RETURN
      end                                             !subroutine CRTQUI
c
c ======================================================================
c
      subroutine REDQUI (icomp,tred,Dred)
c
c  returns reducing parameters associated with Fundamental EOS;
c  used to calculate the 'tau' and 'del' which are the independent
c  variables in the EOS
c
c  input:
c    icomp--component number in mixture (1..nc); 1 for pure fluid
c  outputs:
c     tred--reducing temperature (K)
c     Dred--reducing molar density (mol/L)
c
c  written by D.E. Cristancho, NIST Thermophysics Division, Boulder, Colorado
c  06-18-09 DEC, original version
c
      include 'commons.for'
c
      tred=t0qui(icomp)
      Dred=rho0q(icomp)
c
      RETURN
      end                                             !subroutine REDQUI
c
c ======================================================================
c
      subroutine SETQUI (nread,icomp,hcasno,ierr,herr)
c
c  set up working arrays for use with Fundamental equation of state
c
c  inputs:
c    nread--file to read data from
c           <= 0 get data from block data
c           >0 read from logical unit nread (file should have already
c              been opened and pointer set by subroutine SETUP)
c    icomp--component number in mixture (1..nc); 1 for pure fluid
c   hcasno--CAS number of component icomp (not req'd if reading from file)
c
c  outputs:
c     ierr--error flag:  0 = successful
c                        1 = error (e.g. fluid not found)
c     herr--error string (character*255 variable if ierr<>0)
c     other quantities returned via arrays in common /WCFQUI/
c
c  written by D.E. Cristancho, NIST Thermophysics Division, Boulder, Colorado
c  06-18-09 DEC, original version
c
      include 'commons.for'
      character*12 hcasno
      character*255 herr
c
      ierr=0
      herr=' '
c  (re)initialize contents of /QUISAV/ when a new fluid is read in
      do i=n0,nx
        delsvq(i)=0.d0
        tausvq(i)=0.d0
        do j=1,mxtrm
          phisvq(i,j)=0.d0
          taupq(i,j)=0.d0
          delpq(i,j)=0.d0
        enddo
      enddo
c
      if (nread.le.0 .or. hcasno.eq.' ') then
c  get coefficients from block data
c  identify specified fluid with entries in database via match of CAS no
        ierr=1
        herr='[SETQUI error] fluid input to SETQUI not found'//hnull
      else
c  read data from file
        read (nread,*) tminq(icomp)     !lower temperature limit
        read (nread,*) tmaxq(icomp)     !upper temperature limit
        read (nread,*) pmaxq(icomp)     !upper pressure limit
        read (nread,*) Deos(icomp)      !upper density limit
        read (nread,2003) hmodcp(icomp) !pointer to Cp0 model
        read (nread,*) wmas(icomp)      !molecular weight
        wmfq(icomp)=wmas(icomp)
        read (nread,*) ttpn(icomp)      !triple point temperature
        read (nread,*) pminq(icomp)     !pressure at triple point
        read (nread,*) rhotpq(icomp)    !density at triple point
        read (nread,*) tnbp(icomp)      !normal boiling point temperature
        read (nread,*) accen(icomp)     !acentric factor
        read (nread,*) tcqui(icomp),pcqui(icomp),rhocq(icomp) !critical par
        tcrit(icomp)=tcqui(icomp)
        pcrit(icomp)=pcqui(icomp)
        Dcrit(icomp)=rhocq(icomp)
        ptpn(icomp)=pminq(icomp)
        dtpn(icomp)=rhotpq(icomp)
        dtpv(icomp)=0.d0
        dnbpl(icomp)=0.d0
        dnbpv(icomp)=0.d0
        read (nread,*) t0qui(icomp),rho0q(icomp) !reducing parameters
        tz(icomp)=t0qui(icomp)
        rhoz(icomp)=rho0q(icomp)
        read (nread,*) Rqui(icomp)    !gas constant used in fit
        if (nc.eq.1 .and. icomp.eq.1) R=Rqui(icomp)
        Reos(icomp)=Rqui(icomp)
        Zcrit(icomp)=pcqui(icomp)/(Rqui(icomp)
     &              *tcqui(icomp)*rhocq(icomp))
        read(nread,*)netaq(icomp),nepsq(icomp),nbbq(icomp),ngamq(icomp),
     &                 nbetq(icomp)
        nterm=netaq(icomp)+nepsq(icomp)+nbbq(icomp)+ngamq(icomp)
     &       +nbetq(icomp)
        do j=1,nterm
          read (nread,*) aqui(icomp,j),tiqui(icomp,j),diqui(icomp,j)
        enddo
      end if
c
c  copy limits into /EOSLIM/ arrays
      tmeos(icomp)=tminq(icomp)
      txeos(icomp)=tmaxq(icomp)
      peos(icomp)=pmaxq(icomp)
c     Deos(icomp)=rhomaxq(icomp)
c
      RETURN
 2003 format (a3)
      end                                             !subroutine SETQUI
c
c ======================================================================
c
c ======================================================================
c                                                    end file core_QUI.f
c ======================================================================
c  begin file core_STN.f
c
c  This file contains core routines for the surface tension.
c
c  contained here are:
c     subroutine SURFT (t,rhol,xl,sigma,ierr,herr)
c     subroutine SURTEN (t,rhol,rhov,xl,xv,sigma,ierr,herr)
c     subroutine SETST1 (nread,icomp,hcasno,ierr,herr)
c     subroutine STN (t,rhol,rhov,xl,xv,sigma,ierr,herr)
c     subroutine STNK (icomp,tau,sigma,ierr,herr)
c     subroutine CRITF (zeta,x,tc,pc,Dc,ierr,herr)
c
c ======================================================================
c ======================================================================
c
      subroutine SURFT (t,rhol,xl,sigma,ierr,herr)
c
c  compute surface tension
c
c  inputs:
c        t--temperature [K]
c       xl--composition of liquid phase [array of mol frac]
c  outputs:
c     rhol--molar density of liquid phase [mol/L]
c           if rho > 0 use as input value
c                  < 0 call SATT to find density
c    sigma--surface tension [N/m]
c     ierr--error flag:   0 = successful
c                         1 = T < Tmin
c                         8 = x out of range
c                         9 = T and x out of range
c                       120 = CRITP did not converge
c                       121 = T > Tcrit
c                       122 = TPRHO-liquid did not converge in SATT
c                       123 = TPRHO-vapor did not converge in SATT
c                       124 = SATT pure fluid iteration did not converge
c                       128 = SATT mixture iteration did not converge
c     herr--error string if ierr<>0 (character*255)
c
c  written by M. McLinden, NIST Thermophysics Division, Boulder, Colorado
c  03-24-96  MM, original version
c  03-27-96  MM, add error checks; move calculations to STN (in core_STN)
c  04-05-96  MM, test for supercritical '.ge. tc' rather than '.gt. tc'
c  05-31-96  MM, if error on call to SATT modify herr and return
c  06-03-96  MM, check input temperature against limits
c  06-07-96  MM, fix loss of LIMITX warnings on calls to SATT, STN
c  04-21-97  MM, delete tcrit from call to STN (t > tcrit check moved to STN)
c  10-01-97  MM, add compiler switch to allow access by DLL
c  12-15-97  MM, pass any ierr,herr from STN as outputs
c  06-02-99  MM, always call SATT (need rhov, xv for STH model)
c                [should now call SURTEN; this retained for compatibility]
c
cx DEC$ ATTRIBUTES DLLEXPORT :: SURFT
c
      include 'commons.for'
      character*255 herr,herr2
      dimension xl(ncmax),xliq(ncmax),xvap(ncmax)
c
      ierr=0
      herr=' '
c
c  check that input conditions (in this case t and x) are within limits
c  (check that t < tcrit done in STN)
c
      Ddum=0.d0
      pdum=0.d0
      sigma=0.d0
      call LIMITX ('STN',t,Ddum,pdum,xl,tmin,tmax,Dmx,pmx,ierr,herr2)
      if (t.lt.tmin .and. ierr.le.0) then
        ierr=1
        herr='[SURFT error 1] t<tmin'
        call ERRMSG (ierr,herr)
        RETURN
      elseif (ierr.lt.0) then
c  temperature is outside limits, but in region where extrapolation is
c  usually reliable, set warning flag
        ierr=ierr-20
        write (herr,1002) ierr,herr2(1:234),hnull
 1002   format ('[SURFT warning',i4,'] ',a234,a1)
        call ERRMSG (ierr,herr)
      elseif (ierr.gt.0) then
c  temperature and/or x are outside limits, set error flag
        write (herr,1003) ierr,herr2(1:237),hnull
 1003   format ('[SURFT error',i3,'] ',a237,a1)
        call ERRMSG (ierr,herr)
        RETURN
      end if
c
c  calculate density of saturated liquid, if required
c     if (rhol.le.0.0d0) then
c       kph=1
c       call SATT (t,xl,kph,p,rhol,rhov,xliq,xvap,ierr2,herr2)
c       if (ierr2.ne.0) then
c         write (herr,1005) ierr2,herr2(1:237),hnull
c1005     format ('[SURFT error',i3,'] ',a237,a1)
c         call ERRMSG (ierr,herr)
c         if (ierr2.gt.0) RETURN
c       end if
c     end if
c     call STN (t,rhol,xl,sigma,ierr,herr)
c
c  because of model 'STH' in STN, it is necessary to provide rhov, xv
      kph=1
      call SATT (t,xl,kph,p,rhol,rhov,xliq,xvap,ierr2,herr2)
      if (ierr2.ne.0) then
        ierr=ierr2
        write (herr,1005) ierr2,herr2(1:237),hnull
 1005   format ('[SURFT error',i3,'] ',a237,a1)
        call ERRMSG (ierr,herr)
        if (ierr2.gt.0) RETURN
      end if
      call STN (t,rhol,rhov,xl,xvap,sigma,ierr,herr)
c
      RETURN
      end                                              !subroutine SURFT
c
c ======================================================================
c
      subroutine SURTEN (t,rhol,rhov,xl,xv,sigma,ierr,herr)
c
c  compute surface tension
c
c  inputs:
c        t--temperature [K]
c     rhol--molar density of liquid phase [mol/L]
c     rhov--molar density of vapor phase [mol/L]
c           if either rhol or rhov < 0 call SATT to find densities
c       xl--composition of liquid phase [array of mol frac]
c       xv--composition of vapor phase [array of mol frac]
c           (xv is optional input if rhol < 0 or rhov < 0)
c  outputs:
c    sigma--surface tension [N/m]
c     ierr--error flag:   0 = successful
c                         1 = T < Tmin
c                         8 = x out of range
c                         9 = T and x out of range
c                       120 = CRITP did not converge
c                       121 = T > Tcrit
c                       122 = TPRHO-liquid did not converge in SATT
c                       123 = TPRHO-vapor did not converge in SATT
c                       124 = SATT pure fluid iteration did not converge
c                       128 = SATT mixture iteration did not converge
c     herr--error string if ierr<>0 (character*255)
c
c  written by M. McLinden, NIST Phys & Chem Properties Div, Boulder, CO
c  06-02-99  MM, original version; based on and replaces SURFT
c
cx DEC$ ATTRIBUTES DLLEXPORT :: SURTEN
c
      include 'commons.for'
      character*255 herr,herr1,herr2
      dimension xl(ncmax),xv(ncmax),xliq(ncmax)
c
      ierr=0
      herr=' '
c
c  check that input conditions (in this case t and x) are within limits
c  (check that t < tcrit done in STN)
c
      Ddum=0.0d0
      pdum=0.0d0
      call LIMITX ('STN',t,Ddum,pdum,xl,tmin,tmax,Dmx,pmx,ierr1,herr1)
      if (rhov.gt.0.0d0) then
c  check input vapor composition only if vapor density is specified
c  (otherwise, vapor comp is computed by a call to SATT, and input value
c  is irrelevant)
        call LIMITX ('STN',t,Ddum,pdum,xv,tmin,tmax,Dmx,pmx,ierr2,herr2)
      else
        ierr2=0
        herr2=hnull
      end if
      if (ierr1.gt.0 .or. ierr2.gt.0) then
c  temperature and/or x are outside limits, set error flag
        if (ierr1.gt.ierr2) then
          ierr=ierr1
          herr2=herr1
        else
          ierr=ierr2
        end if
        write (herr,1002) ierr,herr2(1:236),hnull
 1002   format ('[SURTEN error',i3,'] ',a236,a1)
        call ERRMSG (ierr,herr)
        sigma=xnotc
        RETURN
      else if (ierr1.lt.0) then
c  temperature is outside limits, but in region where extrapolation is
c  usually reliable, set warning flag
        ierr=ierr1-20
        write (herr,1004) ierr,herr1(1:233),hnull
 1004   format ('[SURTEN warning',i4,'] ',a233,a1)
        call ERRMSG (ierr,herr)
      end if
c
c  calculate density of saturated liquid, if required
      if (rhol.le.0.0d0 .or. rhov.le.0.0d0) then
        kph=1
        call SATT (t,xl,kph,p,rhol,rhov,xliq,xv,ierr2,herr2)
        if (ierr2.ne.0) then
          write (herr,1005) ierr2,herr2(1:236),hnull
 1005     format ('[SURTEN error',i3,'] ',a236,a1)
          call ERRMSG (ierr,herr)
          if (ierr2.gt.0) then
            sigma=0.0d0
            RETURN
          end if
        end if
      end if
      call STN (t,rhol,rhov,xl,xv,sigma,ierr,herr)
c
      RETURN
      end                                             !subroutine SURTEN
c
c ======================================================================
c
      subroutine SETST1 (nread,icomp,hcasno,ierr,herr)
c
c  set up working arrays for use with "ST1" surface tension model:
c
c    sigma = sum[sigma_k*tau**sigexp_k]
c      tau = 1 - t/tc
c
c    Note:  The critical temperature used is that of the current
c           equation of state. This may differ slightly from that used
c           in the original correlation of surface tension; this change
c           is necessary to give proper behavior of surface tension near
c           the critical point and to avoid possible numerical crashes.
c
c  inputs:
c    nread--file to read data from (file should have already been
c           opened and pointer set by subroutine SETUP)
c    icomp--component number in mixture (1..nc); 1 for pure fluid
c   hcasno--CAS number of component icomp (not required, it is here
c           to maintain parallel structure with SETBWR and SETFEQ)
c
c  outputs:
c     ierr--error flag:  0 = successful
c                        1 = error (e.g. fluid not found)
c     herr--error string (character*255 variable if ierr<>0)
c     other quantities returned via arrays in commons
c
c  written by M. McLinden, NIST Thermophysics Division, Boulder, Colorado
c  03-24-96  MM, original version (skeleton only)
c  08-16-96  MM, add actual ST1 model
c  08-19-97  MM, get rid of herr=herr (avoid warning); flag nread<=0
c  12-02-97  MM, skip over pressure and density limit and Tc on file read
c
      include 'commons.for'
      character*12 hcasno
      character*255 herr
c
      if (nread.le.0) then
        ierr=101
        write (herr,1101) nread,hcasno,hnull
        call ERRMSG (ierr,herr)
 1101   format ('[SETST1 error 101] illegal file specified; nread = ',
     &          i4,'; CAS no. = ',a12,a1)
        RETURN
      else
        herr=' '
        ierr=0
      end if
c
c  read data from file
c     write (*,*) ' SETSTN--read component',icomp,' from unit',nread
      read (nread,*) tminst(icomp)          !lower temperature limit
      read (nread,*) tmaxst(icomp)          !upper temperature limit
c  the pressure and density limit and the Tc are not presently used,
c  but are contained in the file for consistency and possible future use;
c  skip over them in reading the file
      read (nread,*) !pjunk               !upper pressure limit (n/a)
      read (nread,*) !rhojnk              !upper density limit (n/a)
      read (nread,*) ntermu(icomp)
      read (nread,*) !Tcjunk              !Tc in original fit (not used)
      do k=1,ntermu(icomp)
        read (nread,*) sigmak(icomp,k),sigexp(icomp,k)
      enddo
c
      RETURN
      end                                             !subroutine SETST1
c
c ======================================================================
c
      subroutine STN (t,rhol,rhov,xl,xv,sigma,ierr,herr)
c
c  compute surface tension with appropriate core model
c
c  inputs:
c        t--temperature [K]
c     rhol--molar density of liquid phase [mol/L]
c     rhov--molar density of vapor phase [mol/L]
c       xl--composition of liquid phase [array of mol frac]
c       xv--composition of vapor phase [array of mol frac]
c   output:
c    sigma--surface tension [N/m]
c     ierr--error flag:  0 = successful
c                        1 = error (e.g. fluid not found)
c     herr--error string (character*255 variable if ierr<>0)
c
c  written by M. McLinden, NIST Thermophysics Division, Boulder, Colorado
c  03-27-96  MM, original version (skeleton only)
c  08-16-96  MM, add actual ST1 model
c  04-17-97  MM, add pcrit to argument, break pures to separate STNK
c                add mixture model (Holcomb's mod of Moldover & Rainwater)
c  04-21-97  MM, delete critical par from arguments, add call to CRITF
c  12-15-97  MM, return if error from CRITF, set sigma = "not calculated"
c  12-01-98 EWL, add Reos and triple point pressure and density to /CCON/
c  06-02-99  MM, add vapor density and composition to argument list to
c                accommodate new mixture model of Holcomb & Higashi
c
      include 'commons.for'
      character*255 herr,herr2
      dimension xl(ncmax),zeta(ncmax),f(ncmax),cx(ncmax),xcritf(ncmax),
     &          xv(ncmax),zmole(ncmax)
c
      ierr=0
      herr=' '
c
      i=ierrcrt
      ierrcrt=1
      call CRITP (xl,tc,pc,dc,ierr,herr2)
      ierrcrt=i
      if (ierr.gt.0) then
c  error condition--set outputs, issue warning, and return
        ierr=160
        sigma=0.0d0
        write (herr,1016) herr2(1:236),hnull
 1016   format ('[STN error 160] ',a236,a1)
        call ERRMSG (ierr,herr)
        RETURN
      end if
      if (t.gt.tc) then
        ierr=121
        write (herr,1121) t,tc,hnull
        call ERRMSG (ierr,herr)
 1121   format ('[STN error 121] ',
     &          'temperature input to surface tension routine is ',
     &          'greater than critical temperature; T =',g12.5,
     &          ' K, Tcrit =',g12.5,' K.',a1)
        sigma=0.0d0
c       write (*,*) ' STN--output sigma (ierr = 121):  ',sigma
        RETURN
      end if
      call ISPURE (xl,icomp)
      if (icomp.ne.0) then
c  special case--pure component
        tau=1.0d0-t/tc
        call STNK (icomp,tau,sigma,ierr,herr)
        RETURN
      end if
c  base surface tensions on critical parameters at same composition,
      tau=1.0d0-t/tc
      tau126=tau**1.26d0
      alpha=0.10d0
      const=3.74d0**1.5d0*SQRT(R)*alpha*(1.0d0-alpha)*(2.0d0-alpha)
      do i=1,nc
c  define effective parameter in function sigma = sigma0*tau**1.26
        call STNK (i,tau,sigk,ierr,herr)
        if (sigk.lt.0) RETURN
        sig0=0.d0
        if (tau126.gt.0.d0) sig0=sigk/tau126
c     write (*,*) ' STN--icomp, effective sigma_0: ',icomp,sig0
        cx(i)=sig0**1.50d0/(const*SQRT(Tcrit(i))*Pcrit(i))
      enddo
      if (hsten.eq.'STX' .or. hsten.eq.'STM') then
c  mixture case--apply mixing rules to the cx(i)
c  compute fugacities and fugacity fraction
        call FGCTY2 (t,rhol,xl,f,ierr,herr)
        fsum=0.0d0
        do i=1,nc
          fsum=fsum+f(i)
        enddo
        do i=1,nc
          zeta(i)=f(i)/fsum
          xcritf(i)=xl(i)   !initial guess for crit comp at same zeta
        enddo
c       write (*,1244) (zeta(i),i=1,nc)
c1244   format (1x,' STN--zeta(i):  ',5f14.7)
c       write (*,1245) (cx(i),i=1,nc)
c1245   format (1x,' STN--cx(i):    ',5e14.4)
c  find critical parameters at same fugacity fraction
        call CRITF (zeta,xcritf,tcritf,pcritf,Dcritf,ierr,herr)
        if (ierr.gt.0) then
c  error in CRITF--solution not possible
          sigma=xnotc
          RETURN
        end if
      else if (hsten.eq.'STH') then
c  mixture case--apply Holcomb & Higashi modification of Moldover & Rainwater
c  (i.e. apply mixing rules at overall mass composition corresponding to a
c  liquid volume fraction of 0.5)
c  (M.R. Moldover and J.C. Rainwater, J. Chem. Phys., 88:7772-7780, 1988.)
        do i=1,nc
          zmole(i)=(xl(i)*rhol+xv(i)*rhov)/(rhol+rhov)
        enddo
        call XMASS (zmole,zeta,xmw)
        call CRITP (zmole,tcritf,pcritf,Dcritf,ierr,herr)
      else
        ierr=99
        sigma=-9.999d6
        write (herr,1199) hsten,hnull
 1199   format ('[STN error 99] ',
     &          'unknown surface tension model:  (',a3,')',a1)
c       write (*,*) ' STN--output sigma (ierr = 99):  ',sigma
      end if
c
      cmix=0.0d0
      if (hsten.eq.'STM' .or. hsten.eq.'STH') then
c  use Moldover & Rainwater or Holcomb & Higashi mod of M & R method
c  difference is in the zeta defined above
        do i=1,nc
          cmix=cmix+zeta(i)*cx(i)
        enddo
c       write (*,*) ' STN--cmix by M-R:  ',cmix
      else if (hsten.eq.'STX') then
c  use Holcomb's modification of Moldover & Rainwater method
        pcsum=0.0d0
        do i=1,nc
          pcsum=pcsum+zeta(i)**2*Pcrit(i)
        enddo
        do i=1,nc
c  sum i = j terms
          cmix=cmix+zeta(i)**2*cx(i)
          if (i.lt.nc) then
            do j=i+1,nc
c  sum cross terms
c         cij=0.5d0*(pcritf-pcsum)*SQRT(cx(i)*cx(j)/(pcrit(i)*pcrit(j)))
c    &       /(zeta(i)*zeta(j))
c         cmix=cmix+2.0d0*zeta(i)*zeta(j)*cij !factor 2 from ij = ji
c  above lines reduce to
              cmix=cmix+
     &             (pcritf-pcsum)*SQRT(cx(i)*cx(j)/(Pcrit(i)*Pcrit(j)))
            enddo
          end if
        enddo
c       write (*,*) ' STN--cmix by Holcomb''s mod to M-R:  ',cmix
      end if
c
c  recover mixture sigma_0 parameter from cmix
c  this expression is based on critical parameters at same zeta
      sig0=(const*SQRT(tcritf)*pcritf*cmix)**(2.0d0/3.0d0)
      sigma=sig0*tau**1.26d0
c     write (*,*) ' STN--hsten,sigma: ',hsten,' ',sigma
c
      RETURN
      end                                                !subroutine STN
c
c ======================================================================
c
      subroutine STNK (icomp,tau,sigma,ierr,herr)
c
c  compute surface tension with appropriate core model
c
c  inputs:
c    icomp--component i
c      tau--dimensionless temperature (1 - T/Tc)
c   output:
c    sigma--surface tension [N/m]
c     ierr--error flag:  0 = successful
c                        1 = error (e.g. fluid not found)
c     herr--error string (character*255 variable if ierr<>0)
c
c  written by M. McLinden, NIST Physical & Chemical Properties Division, Boulder, Colorado
c  04-17-97  MM, original version (based on STN)
c
      include 'commons.for'
      character*255 herr
c
      ierr=0
      herr=' '
c
      if (hstenk(icomp).eq.'ST1') then
        sigma=0.0d0
        do k=1,ntermu(icomp)
          sigma=sigma+sigmak(icomp,k)*tau**sigexp(icomp,k)
        enddo
      else
        sigma=-999.0d0
        write (herr,1099) hstenk(icomp),hnull
        call ERRMSG (ierr,herr)
 1099   format ('[STN error 99] ',
     &          'unknown surface tension model:  (',a3,')',a1)
      end if
c     write (*,1200) icomp,tau,sigma
c1200 format (' STNK--icomp,tau,sigma: ',i4,2f11.6)
c
      RETURN
      end                                               !subroutine STNK
c
c ======================================================================
c
      subroutine CRITF (zeta,x,tc,pc,Dc,ierr,herr)
c
c  critical parameters as a function of fugacity fraction
c
c  inputs:
c     zeta--fugacity fraction [array of f/f]
c        x--initial guess for composition [array of mol frac]
c  outputs:
c        x--composition [array of mol frac]
c    tc--critical temperature [K]
c    pc--critical pressure [kPa]
c    Dc--critical density [mol/L]
c     ierr--error flag:  0 = successful
c                      160 = did not converge
c     herr--error string (character*255 variable if ierr<>0)
c
c  written by M. McLinden, NIST Physical and Chemical Properties Division, Boulder, Colorado
c  04-21-97  MM, original version
c  12-15-97  MM, change value of ierr for non-convergence
c
      include 'commons.for'
      character*255 herr,herr1
      dimension zeta(ncmax),zetaj(ncmax),x(ncmax),f(ncmax),xnew(ncmax)
c
      parameter (itmax=20)
      tolx=1.0d-5
      ierr=0
      herr=' '
c
c     do i=1,nc
c       x(i)=zeta(i)    !initial guess for composition
c     enddo
      do it=1,itmax
        call CRITP (x,tc,pc,Dc,ierr1,herr1)
        call FGCTY2 (tc,Dc,x,f,ierr,herr)
        fsum=0.0d0
        do i=1,nc
          fsum=fsum+f(i)
        enddo
        do i=1,nc
          zetaj(i)=f(i)/fsum
        enddo
        delx=0.0d0
        xsum=0.0d0
        do i=1,nc
c  simple successive substitution
          xnew(i)=x(i)-(zetaj(i)-zeta(i))
          if (xnew(i).lt.0.0d0) xnew(i)=0.0d0
          xsum=xsum+xnew(i)
          delx=delx+abs(xnew(i)-x(i))
        enddo
c       write (*,1160) it,tc,pc,delx,x(1),zetaj(1),zeta(1)
c1160   format (1x,' CRITF--it,tc,pc,delx,x,zetaj,zeta:  ',i4,6f14.6)
        if (delx.lt.tolx) then
          RETURN    !iteration converged
        end if
        do i=1,nc
          xnew(i)=xnew(i)/xsum
          x(i)=xnew(i)
        enddo
      enddo
      ierr=160
      herr='[SURFT error 160] CRITF (find critical parameters at '//
     &     'a specified fugacity fraction) did not converge in the '//
     &     'surface tension calculation'//hnull
      call ERRMSG (ierr,herr)
c
      RETURN
      end                                              !subroutine CRITF
c
c
c        1         2         3         4         5         6         7
c23456789012345678901234567890123456789012345678901234567890123456789012
c
c ======================================================================
c                                                    end file core_STN.f
c ======================================================================
c  begin file flash2.f
c
c  This file contains additional iterative routines which call the
c  intermediate level routines
c
c  contained here are:
c     subroutine THFLSH (t,h,z,kr,p,D,Dl,Dv,x,y,q,e,s,cv,cp,w,ierr,herr)
c     subroutine THFL1 (t,h,x,Dmin,Dmax,D,ierr,herr)
c     subroutine THFL2 (t,h,z,ksat,pbub,pdew,Dlbub,Dvdew,ybub,xdew,
c    &                  p,Dl,Dv,x,y,q,ierr,herr)
c     subroutine TSFLSH (t,s,z,kr,p,D,Dl,Dv,x,y,q,e,h,cv,cp,w,ierr,herr)
c     subroutine TSFL1 (t,s,x,Dmin,Dmax,D,ierr,herr)
c     subroutine TSFL2 (t,s,z,ksat,pbub,pdew,Dlbub,Dvdew,ybub,xdew,
c    &                  p,Dl,Dv,x,y,q,ierr,herr)
c     subroutine TEFLSH (t,e,z,kr,p,D,Dl,Dv,x,y,q,h,s,cv,cp,w,ierr,herr)
c     subroutine TEFL1 (t,e,x,Dmin,Dmax,D,ierr,herr)
c     subroutine TEFL2 (t,e,z,ksat,pbub,pdew,Dlbub,Dvdew,ybub,xdew,
c    &                  p,Dl,Dv,x,y,q,ierr,herr)
c     subroutine DHFLSH (D,h,z,t,p,Dl,Dv,x,y,q,e,s,cv,cp,w,ierr,herr)
c     subroutine DHFL1 (rho,h,x,t,ierr,herr)
c     subroutine DHFL2 (d,h,z,t,p,Dl,Dv,x,y,q,ierr,herr)
c     subroutine DSFLSH (D,s,z,t,p,Dl,Dv,x,y,q,e,h,cv,cp,w,ierr,herr)
c     subroutine DSFL1 (rho,s,x,t,ierr,herr)
c     subroutine DSFL2 (d,s,z,t,p,Dl,Dv,x,y,q,ierr,herr)
c     subroutine DEFLSH (D,e,z,t,p,Dl,Dv,x,y,q,h,s,cv,cp,w,ierr,herr)
c     subroutine DEFL1 (rho,e,x,t,ierr,herr)
c     subroutine DEFL2 (d,e,z,t,p,Dl,Dv,x,y,q,ierr,herr)
c     subroutine HSFLSH (h,s,z,t,p,D,Dl,Dv,x,y,q,e,cv,cp,w,ierr,herr)
c     subroutine HSFL1 (h,s,x,Dmin,Dmax,t,D,ierr,herr)
c     subroutine ESFLSH (e,s,z,t,p,D,Dl,Dv,x,y,q,h,cv,cp,w,ierr,herr)
c
c     subroutine TQFLSH (t,q,z,kq,p,D,Dl,Dv,x,y,e,h,s,cv,cp,w,ierr,herr)
c     subroutine TQFL2 (t,q,z,kq,ksat,pbub,pdew,Dlbub,Dvdew,ybub,xdew,
c    &                  p,Dl,Dv,x,y,ierr,herr)
c     subroutine PQFLSH (p,q,z,kq,t,D,Dl,Dv,x,y,e,h,s,cv,cp,w,ierr,herr)
c     subroutine PQFL2 (p,q,z,kq,ksat,tbub,tdew,Dlbub,Dvdew,ybub,xdew,
c    &                  t,Dl,Dv,x,y,ierr,herr)
c     subroutine DQFL2 (d,q,z,kq,t,p,Dl,Dv,x,y,ierr,herr)
c
c     subroutine TBFLSH (t,b,z,kr,ab,p,D,Dl,Dv,x,y,q,e,h,s,cv,cp,w,
c    &                   ierr,herr)
c     subroutine DBFLSH (D,b,z,ab,t,p,Dl,Dv,x,y,q,e,h,s,cv,cp,w,
c    &                   ierr,herr)
c     subroutine ABFL1 (a,b,x,kph,ab,dmin,dmax,t,p,D,ierr,herr)
c     subroutine DBFL1 (d,b,x,ab,t,p,ierr,herr)
c     subroutine ABFL2 (a,b,z,kq,ksat,ab,
c    &                  tbub,tdew,pbub,pdew,Dlbub,Dvdew,ybub,xdew,
c    &                  t,p,Dl,Dv,x,y,q,ierr,herr)
c     subroutine DBFL2 (d,b,z,kq,ab,t,p,Dl,Dv,x,y,q,ierr,herr)
c     subroutine PTANC (t,p,q,b,bt,Dl,Dv)
c     subroutine CSTAR (t,p,v,x,cs,ts,Ds,ps,ws,ierr,herr)
c
c  these routines use the following common blocks from other files
c     common /Gcnst/ R,tz(n0:nx),rhoz(n0:nx)
c     common /HCHAR/ htab,hnull
c     common /FLAGS/ xnota,x2ph,xsubc,xsuph,xsupc,xinf,xerr,xnotd,xnotc
c
c  various arrays are dimensioned with parameter statements
c
c ======================================================================
c ======================================================================
c
      subroutine THFLSH (t,h,z,kr,p,D,Dl,Dv,x,y,q,e,s,cv,cp,w,ierr,herr)
c
c  flash calculation given temperature, bulk enthalpy, and bulk composition.
c  Often in the liquid, two solutions exist, one of them in the two phase.
c  If this is the case, call THFLSH with kr=2 to get the single-phase state.
c
c  inputs:
c        t--temperature [K]
c        h--overall (bulk) enthalpy [J/mol]
c        z--composition [array of mol frac]
c       kr--flag specifying desired root for multi-valued inputs:
c           1 = return lower density root
c           2 = return higher density root
c
c  outputs:
c        p--pressure [kPa]
c        D--overall (bulk) molar density [mol/L]
c       Dl--molar density [mol/L] of the liquid phase
c       Dv--molar density [mol/L] of the vapor phase
c           if only one phase is present, Dl = Dv = D
c        x--composition [array of mol frac] for liquid phase
c        y--composition [array of mol frac] for vapor phase
c           if only one phase is present, x = y = z
c        q--vapor quality on a MOLAR basis [moles vapor/total moles]
c           q < 0 indicates subcooled (compressed) liquid
c           q = 0 indicates saturated liquid
c           q = 1 indicates saturated vapor
c           q > 1 indicates superheated vapor
c           q = -998 subcooled liquid, but quality not defined (p > Pc)
c           q = 999 indicates supercritical state (t > Tc) and (p > Pc)
c        e--overall (bulk) internal energy [J/mol]
c        s--overall (bulk) entropy [J/mol-K]
c       Cv--isochoric (constant V) heat capacity [J/mol-K]
c       Cp--isobaric (constant p) heat capacity [J/mol-K]
c        w--speed of sound [m/s]
c           Cp, w are not defined for 2-phase states
c           in such cases, a flag = -9.99998d6 is returned
c     ierr--error flag:  0 = successful (see TBFLSH for others)
c     herr--error string (character*255 variable if ierr<>0)
c
c  written by M. McLinden, NIST Phys & Chem Properties Div, Boulder, CO
c  03-26-98  MM, original version
c  09-25-98  MM, move kguess=0 outside if,then,else
c  01-11-00 EWL, remove ierr from line 1002 and several other places in flash2.for
c  07-07-00 EWL, check for other locations of hmax
c  01-18-01 EWL, remove code and call generic TBFLSH
c
cx DEC$ ATTRIBUTES DLLEXPORT :: THFLSH
c
      include 'commons.for'
      character*255 herr
      dimension x(ncmax),y(ncmax),z(ncmax)
c
      call TBFLSH (t,h,z,kr,'TH',p,D,Dl,Dv,x,y,q,e,hh,s,cv,cp,w,
     &             ierr,herr)
      RETURN
      end                                             !subroutine THFLSH
c
c ======================================================================
c
      subroutine THFL1 (t,h,x,Dmin,Dmax,D,ierr,herr)
c
c  flash calculation given temperature, enthalpy, and composition.  This
c  routine accepts only single-phase inputs, it is intended primarily for
c  use with the more general flash routine THFLSH.
c
c  inputs:
c        t--temperature [K]
c        h--enthalpy [J/mol]
c        x--composition [array of mol frac]
c     Dmin--lower bound on density [mol/L]
c     Dmax--upper bound on density [mol/L]
c
c  outputs:
c        D--molar density [mol/L]
c     ierr--error flag:  0 = successful
c     herr--error string (character*255 variable if ierr<>0)
c
cx DEC$ ATTRIBUTES DLLEXPORT :: THFL1
c
      include 'commons.for'
      character*255 herr
      dimension x(ncmax)
c
      call ABFL1 (t,h,x,0,'TH',dmin,dmax,tt,p,D,ierr,herr)
      RETURN
      end                                              !subroutine THFL1
c
c ======================================================================
c
      subroutine THFL2 (t,h,z,ksat,pbub,pdew,Dlbub,Dvdew,ybub,xdew,
     &                  p,Dl,Dv,x,y,q,ierr,herr)
c
c  flash calculation given temperature, bulk enthalpy, and composition
c
c  This routine accepts only two-phase states as input; it is intended
c  primarily for use by the general temperature-enthalpy flash routine
c  THFLSH.  It may be called independently if the state is known to be
c  two-phase.  But beware--this routine does not check limits, and it
c  will be significantly faster than THFLSH only if the bubble and dew
c  point limits can be provided (ksat = 1 option).
c
c  inputs:
c        t--temperature [K]
c        h--overall (bulk) molar enthalpy [J/mol]
c        z--overall (bulk) composition [array of mol frac]
c     ksat--flag for bubble and dew point limits
c           0 = dew and bubble point limits computed here
c           1 = must provide values for the following:
c     pbub--bubble point pressure [kPa] at (t,x=z)
c     pdew--dew point pressure [kPa] at (t,y=z)
c    Dlbub--liquid density [mol/L] at bubble point
c    Dvdew--vapor density [mol/L] at dew point
c     ybub--vapor composition [array of mol frac] at bubble point
c     xdew--liquid composition [array of mol frac] at dew point
c
c  outputs:
c        p--pressure [kPa]
c       Dl--molar density [mol/L] of the liquid phase
c       Dv--molar density [mol/L] of the vapor phase
c        x--composition of liquid phase [array of mol frac]
c        y--composition of vapor phase [array of mol frac]
c        q--vapor quality on a MOLAR basis [moles vapor/total moles]
c     ierr--error flag:  0 = successful
c     herr--error string (character*255 variable if ierr<>0)
c
cx DEC$ ATTRIBUTES DLLEXPORT :: THFL2
c
      include 'commons.for'
      character*255 herr
      dimension z(ncmax),x(ncmax),y(ncmax),xdew(ncmax),ybub(ncmax)
c
      call ABFL2 (t,h,z,1,ksat,'TH',
     &                 tbub,tdew,pbub,pdew,Dlbub,Dvdew,ybub,xdew,
     &                 tt,p,Dl,Dv,x,y,q,ierr,herr)
c
      RETURN
      end                                              !subroutine THFL2
c
c ======================================================================
c
      subroutine TSFLSH (t,s,z,kr,p,D,Dl,Dv,x,y,q,e,h,cv,cp,w,ierr,herr)
c
c  flash calculation given temperature, bulk entropy, and bulk composition
c
c  inputs:
c        t--temperature [K]
c        s--overall (bulk) entropy [J/mol-K]
c        z--composition [array of mol frac]
c       kr--flag specifying desired root for multi-valued inputs:
c           1 = return lower density root
c           2 = return higher density root
c
c  outputs:
c        p--pressure [kPa]
c        D--overall (bulk) molar density [mol/L]
c       Dl--molar density [mol/L] of the liquid phase
c       Dv--molar density [mol/L] of the vapor phase
c           if only one phase is present, Dl = Dv = D
c        x--composition [array of mol frac] for liquid phase
c        y--composition [array of mol frac] for vapor phase
c           if only one phase is present, x = y = z
c        q--vapor quality on a MOLAR basis [moles vapor/total moles]
c           q < 0 indicates subcooled (compressed) liquid
c           q = 0 indicates saturated liquid
c           q = 1 indicates saturated vapor
c           q > 1 indicates superheated vapor
c           q = -998 subcooled liquid, but quality not defined (p > Pc)
c           q = 999 indicates supercritical state (t > Tc) and (p > Pc)
c        e--overall (bulk) internal energy [J/mol]
c        h--overall (bulk) enthalpy [J/mol]
c       Cv--isochoric (constant V) heat capacity [J/mol-K]
c       Cp--isobaric (constant p) heat capacity [J/mol-K]
c        w--speed of sound [m/s]
c           Cp, w are not defined for 2-phase states
c           in such cases, a flag = -9.99998d6 is returned
c     ierr--error flag:  0 = successful (see TBFLSH for others)
c     herr--error string (character*255 variable if ierr<>0)
c
c  written by E.W. Lemmon, NIST Phys & Chem Properties Div, Boulder, CO
c  01-18-01 EWL, original version
c
cx DEC$ ATTRIBUTES DLLEXPORT :: TSFLSH
c
      include 'commons.for'
      character*255 herr
      dimension x(ncmax),y(ncmax),z(ncmax)
c
      call TBFLSH (t,s,z,kr,'TS',p,D,Dl,Dv,x,y,q,e,h,ss,cv,cp,w,
     &             ierr,herr)
      RETURN
      end                                             !subroutine TSFLSH
c
c ======================================================================
c
      subroutine TSFL1 (t,s,x,Dmin,Dmax,D,ierr,herr)
c
c  flash calculation given temperature, entropy, and composition.  This
c  routine accepts only single-phase inputs, it is intended primarily for
c  use with the more general flash routine TSFLSH.
c
c  inputs:
c        t--temperature [K]
c        s--entropy [J/mol-K]
c        x--composition [array of mol frac]
c     Dmin--lower bound on density [mol/L]
c     Dmax--upper bound on density [mol/L]
c
c  outputs:
c        D--molar density [mol/L]
c     ierr--error flag:  0 = successful
c     herr--error string (character*255 variable if ierr<>0)
c
cx DEC$ ATTRIBUTES DLLEXPORT :: TSFL1
c
      include 'commons.for'
      character*255 herr
      dimension x(ncmax)
c
      call ABFL1 (t,s,x,0,'TS',dmin,dmax,tt,p,D,ierr,herr)
      RETURN
      end                                              !subroutine TSFL1
c
c ======================================================================
c
      subroutine TSFL2 (t,s,z,ksat,pbub,pdew,Dlbub,Dvdew,ybub,xdew,
     &                  p,Dl,Dv,x,y,q,ierr,herr)
c
c  flash calculation given temperature, bulk entropy, and composition
c
c  This routine accepts only two-phase states as input; it is intended
c  primarily for use by the general temperature-entropy flash routine
c  TSFLSH.  It may be called independently if the state is known to be
c  two-phase.  But beware--this routine does not check limits, and it
c  will be significantly faster than TSFLSH only if the bubble and dew
c  point limits can be provided (ksat = 1 option).
c
c  inputs:
c        t--temperature [K]
c        h--overall (bulk) molar enthalpy [J/mol]
c        z--overall (bulk) composition [array of mol frac]
c     ksat--flag for bubble and dew point limits
c           0 = dew and bubble point limits computed here
c           1 = must provide values for the following:
c     pbub--bubble point pressure [kPa] at (t,x=z)
c     pdew--dew point pressure [kPa] at (t,y=z)
c    Dlbub--liquid density [mol/L] at bubble point
c    Dvdew--vapor density [mol/L] at dew point
c     ybub--vapor composition [array of mol frac] at bubble point
c     xdew--liquid composition [array of mol frac] at dew point
c
c  outputs:
c        p--pressure [kPa]
c       Dl--molar density [mol/L] of the liquid phase
c       Dv--molar density [mol/L] of the vapor phase
c        x--composition of liquid phase [array of mol frac]
c        y--composition of vapor phase [array of mol frac]
c        q--vapor quality on a MOLAR basis [moles vapor/total moles]
c     ierr--error flag:  0 = successful
c     herr--error string (character*255 variable if ierr<>0)
c
cx DEC$ ATTRIBUTES DLLEXPORT :: TSFL2
c
      include 'commons.for'
      character*255 herr
      dimension z(ncmax),x(ncmax),y(ncmax),xdew(ncmax),ybub(ncmax)
c
      call ABFL2 (t,s,z,1,ksat,'TS',
     &                 tbub,tdew,pbub,pdew,Dlbub,Dvdew,ybub,xdew,
     &                 tt,p,Dl,Dv,x,y,q,ierr,herr)
c
      RETURN
      end                                              !subroutine TSFL2
c
c ======================================================================
c
      subroutine TEFLSH (t,e,z,kr,p,D,Dl,Dv,x,y,q,h,s,cv,cp,w,ierr,herr)
c
c  flash calculation given temperature, bulk energy, and bulk composition
c
c  inputs:
c        t--temperature [K]
c        e--overall (bulk) internal energy [J/mol]
c        z--composition [array of mol frac]
c       kr--flag specifying desired root for multi-valued inputs:
c           1 = return lower density root
c           2 = return higher density root
c
c  outputs:
c        p--pressure [kPa]
c        D--overall (bulk) molar density [mol/L]
c       Dl--molar density [mol/L] of the liquid phase
c       Dv--molar density [mol/L] of the vapor phase
c           if only one phase is present, Dl = Dv = D
c        x--composition [array of mol frac] for liquid phase
c        y--composition [array of mol frac] for vapor phase
c           if only one phase is present, x = y = z
c        q--vapor quality on a MOLAR basis [moles vapor/total moles]
c           q < 0 indicates subcooled (compressed) liquid
c           q = 0 indicates saturated liquid
c           q = 1 indicates saturated vapor
c           q > 1 indicates superheated vapor
c           q = -998 subcooled liquid, but quality not defined (p > Pc)
c           q = 999 indicates supercritical state (t > Tc) and (p > Pc)
c        h--overall (bulk) enthalpy [J/mol]
c        s--overall (bulk) entropy [J/mol-K]
c       Cv--isochoric (constant V) heat capacity [J/mol-K]
c       Cp--isobaric (constant p) heat capacity [J/mol-K]
c        w--speed of sound [m/s]
c           Cp, w are not defined for 2-phase states
c           in such cases, a flag = -9.99998d6 is returned
c     ierr--error flag:  0 = successful (see TBFLSH for others)
c     herr--error string (character*255 variable if ierr<>0)
c
c  written by E.W. Lemmon, NIST Phys & Chem Properties Div, Boulder, CO
c  01-18-01 EWL, original version
c
cx DEC$ ATTRIBUTES DLLEXPORT :: TEFLSH
c
      include 'commons.for'
      character*255 herr
      dimension x(ncmax),y(ncmax),z(ncmax)
c
      call TBFLSH (t,e,z,kr,'TE',p,D,Dl,Dv,x,y,q,ee,h,s,cv,cp,w,
     &             ierr,herr)
      RETURN
      end                                             !subroutine TEFLSH
c
c ======================================================================
c
      subroutine TEFL1 (t,e,x,Dmin,Dmax,D,ierr,herr)
c
c  flash calculation given temperature, energy, and composition.  This
c  routine accepts only single-phase inputs, it is intended primarily for
c  use with the more general flash routine TEFLSH.
c
c  inputs:
c        t--temperature [K]
c        e--energy [J/mol]
c        x--composition [array of mol frac]
c     Dmin--lower bound on density [mol/L]
c     Dmax--upper bound on density [mol/L]
c
c  outputs:
c        D--molar density [mol/L]
c     ierr--error flag:  0 = successful
c     herr--error string (character*255 variable if ierr<>0)
c
cx DEC$ ATTRIBUTES DLLEXPORT :: TEFL1
c
      include 'commons.for'
      character*255 herr
      dimension x(ncmax)
c
      call ABFL1 (t,e,x,0,'TE',dmin,dmax,tt,p,D,ierr,herr)
      RETURN
      end                                              !subroutine TEFL1
c
c ======================================================================
c
      subroutine TEFL2 (t,e,z,ksat,pbub,pdew,Dlbub,Dvdew,ybub,xdew,
     &                  p,Dl,Dv,x,y,q,ierr,herr)
c
c  flash calculation given temperature, bulk energy, and composition
c
c  This routine accepts only two-phase states as input; it is intended
c  primarily for use by the general temperature-energy flash routine
c  TEFLSH.  It may be called independently if the state is known to be
c  two-phase.  But beware--this routine does not check limits, and it
c  will be significantly faster than TEFLSH only if the bubble and dew
c  point limits can be provided (ksat = 1 option).
c
c  inputs:
c        t--temperature [K]
c        e--overall (bulk) molar energy [J/mol]
c        z--overall (bulk) composition [array of mol frac]
c     ksat--flag for bubble and dew point limits
c           0 = dew and bubble point limits computed here
c           1 = must provide values for the following:
c     pbub--bubble point pressure [kPa] at (t,x=z)
c     pdew--dew point pressure [kPa] at (t,y=z)
c    Dlbub--liquid density [mol/L] at bubble point
c    Dvdew--vapor density [mol/L] at dew point
c     ybub--vapor composition [array of mol frac] at bubble point
c     xdew--liquid composition [array of mol frac] at dew point
c
c  outputs:
c        p--pressure [kPa]
c       Dl--molar density [mol/L] of the liquid phase
c       Dv--molar density [mol/L] of the vapor phase
c        x--composition of liquid phase [array of mol frac]
c        y--composition of vapor phase [array of mol frac]
c        q--vapor quality on a MOLAR basis [moles vapor/total moles]
c     ierr--error flag:  0 = successful
c     herr--error string (character*255 variable if ierr<>0)
c
cx DEC$ ATTRIBUTES DLLEXPORT :: TEFL2
c
      include 'commons.for'
      character*255 herr
      dimension z(ncmax),x(ncmax),y(ncmax),xdew(ncmax),ybub(ncmax)
c
      call ABFL2 (t,e,z,1,ksat,'TE',
     &                 tbub,tdew,pbub,pdew,Dlbub,Dvdew,ybub,xdew,
     &                 tt,p,Dl,Dv,x,y,q,ierr,herr)
c
      RETURN
      end                                              !subroutine TEFL2
c
c ======================================================================
c
      subroutine DHFLSH (D,h,z,t,p,Dl,Dv,x,y,q,e,s,cv,cp,w,ierr,herr)
c
c  flash calculation given density, enthalpy, and bulk composition
c
c  This routine accepts both single-phase and two-phase states as the
c  input; for single-phase calculations, the subroutine DHFL1 is faster.
c
c  inputs:
c        D--overall (bulk) molar density [mol/L]
c        h--overall (bulk) enthalpy [J/mol]
c        z--overall (bulk) composition [array of mol frac]
c
c  outputs:
c        t--temperature [K]
c        p--pressure [kPa]
c       Dl--molar density [mol/L] of the liquid phase
c       Dv--molar density [mol/L] of the vapor phase
c           if only one phase is present, Dl = Dv = D
c        x--composition of liquid phase [array of mol frac]
c        y--composition of vapor phase [array of mol frac]
c           if only one phase is present, x = y = z
c        q--vapor quality on a MOLAR basis [moles vapor/total moles]
c           q < 0 indicates subcooled (compressed) liquid
c           q = 0 indicates saturated liquid
c           q = 1 indicates saturated vapor
c           q > 1 indicates superheated vapor
c           q = 998 superheated vapor, but quality not defined (in most situations, t > Tc)
c           q = 999 indicates supercritical state (t > Tc) and (p > Pc)
c        e--overall (bulk) internal energy [J/mol]
c        s--overall (bulk) entropy [J/mol-K]
c       Cv--isochoric (constant V) heat capacity [J/mol-K]
c       Cp--isobaric (constant p) heat capacity [J/mol-K]
c        w--speed of sound [m/s]
c           Cp, w are not defined for 2-phase states
c           in such cases, a flag = -9.99998d6 is returned
c     ierr--error flag:  0 = successful
c                      210 = CRITP did not converge
c                      248 = iteration did not converge
c                      249 = H out of range
c     herr--error string (character*255 variable if ierr<>0)
c
c  written by E.W. Lemmon, NIST Thermophysics Division, Boulder, Colorado
c  05-13-99 EWL, original version
c
cx DEC$ ATTRIBUTES DLLEXPORT :: DHFLSH
c
      include 'commons.for'
      character*255 herr
      dimension z(ncmax),x(ncmax),y(ncmax)
c
      call DBFLSH (D,h,z,'DH',t,p,Dl,Dv,x,y,q,e,hh,s,cv,cp,w,ierr,herr)
      RETURN
      end                                             !subroutine DHFLSH
c
c ======================================================================
c
      subroutine DHFL1 (rho,h,x,t,ierr,herr)
c
c  iterate for single-phase temperature as a function of density, enthalpy,
c  and composition
c
c  inputs:
c      rho--molar density [mol/L]
c        h--enthalpy [J/mol]
c        x--composition [array of mol frac]
c
c  outputs:
c        t--temperature [K]
c     ierr--error flag:  0 = successful
c     herr--error string (character*255 variable if ierr<>0)
c
cx DEC$ ATTRIBUTES DLLEXPORT :: DHFL1
c
      include 'commons.for'
      character*255 herr
      dimension x(ncmax)
c
      call ABFL1 (rho,h,x,0,'DH',0.d0,0.d0,t,pp,dd,ierr,herr)
      RETURN
      end                                              !subroutine DHFL1
c
c ======================================================================
c
      subroutine DHFL2 (d,h,z,t,p,Dl,Dv,x,y,q,ierr,herr)
c
c  flash calculation given bulk density, enthalpy, and composition
c
c  This routine accepts only two-phase states as input; it is intended
c  primarily for use by the general density-enthalpy flash routine
c  DHFLSH.  It may be called independently if the state is known to be
c  two-phase.  But beware--this routine does not check limits, and it
c  will be significantly faster than DHFLSH only if the bubble and dew
c  point limits can be provided (ksat = 1 option).
c
c  inputs:
c        d--overall (bulk) molar density [mol/L]
c        h--overall (bulk) molar enthalpy [J/mol]
c        z--overall (bulk) composition [array of mol frac]
c
c  outputs:
c        t--temperature [K]
c        p--pressure [kPa]
c       Dl--molar density [mol/L] of the liquid phase
c       Dv--molar density [mol/L] of the vapor phase
c        x--composition of liquid phase [array of mol frac]
c        y--composition of vapor phase [array of mol frac]
c        q--vapor quality on a MOLAR basis [moles vapor/total moles]
c     ierr--error flag:  0 = successful
c     herr--error string (character*255 variable if ierr<>0)
c
cx DEC$ ATTRIBUTES DLLEXPORT :: DHFL2
c
      include 'commons.for'
      character*255 herr
      dimension z(ncmax),x(ncmax),y(ncmax)
c
      call DBFL2 (d,h,z,0,'DH',
     &                 t,p,Dl,Dv,x,y,q,ierr,herr)
c
      RETURN
      end                                              !subroutine DHFL2
c
c ======================================================================
c
      subroutine DSFLSH (D,s,z,t,p,Dl,Dv,x,y,q,e,h,cv,cp,w,ierr,herr)
c
c  flash calculation given density, entropy, and bulk composition
c
c  This routine accepts both single-phase and two-phase states as the
c  input; for single-phase calculations, the subroutine DSFL1 is faster.
c
c  inputs:
c        D--overall (bulk) molar density [mol/L]
c        s--overall (bulk) entropy [J/mol-K]
c        z--overall (bulk) composition [array of mol frac]
c
c  outputs:
c        t--temperature [K]
c        p--pressure [kPa]
c       Dl--molar density [mol/L] of the liquid phase
c       Dv--molar density [mol/L] of the vapor phase
c           if only one phase is present, Dl = Dv = D
c        x--composition of liquid phase [array of mol frac]
c        y--composition of vapor phase [array of mol frac]
c           if only one phase is present, x = y = z
c        q--vapor quality on a MOLAR basis [moles vapor/total moles]
c           q < 0 indicates subcooled (compressed) liquid
c           q = 0 indicates saturated liquid
c           q = 1 indicates saturated vapor
c           q > 1 indicates superheated vapor
c           q = 998 superheated vapor, but quality not defined (in most situations, t > Tc)
c           q = 999 indicates supercritical state (t > Tc) and (p > Pc)
c        e--overall (bulk) internal energy [J/mol]
c        h--overall (bulk) enthalpy [J/mol]
c       Cv--isochoric (constant V) heat capacity [J/mol-K]
c       Cp--isobaric (constant p) heat capacity [J/mol-K]
c        w--speed of sound [m/s]
c           Cp, w are not defined for 2-phase states
c           in such cases, a flag = -9.99998d6 is returned
c     ierr--error flag:  0 = successful
c                      210 = CRITP did not converge
c                      248 = iteration did not converge
c                      249 = H out of range
c     herr--error string (character*255 variable if ierr<>0)
c
c  written by E.W. Lemmon, NIST Thermophysics Division, Boulder, Colorado
c  01-19-01 EWL, original version
c
cx DEC$ ATTRIBUTES DLLEXPORT :: DSFLSH
c
      include 'commons.for'
      character*255 herr
      dimension z(ncmax),x(ncmax),y(ncmax)
c
      call DBFLSH (D,s,z,'DS',t,p,Dl,Dv,x,y,q,e,h,ss,cv,cp,w,ierr,herr)
      RETURN
      end                                             !subroutine DSFLSH
c
c ======================================================================
c
      subroutine DSFL1 (rho,s,x,t,ierr,herr)
c
c  iterate for single-phase temperature as a function of density, entropy,
c  and composition
c
c  inputs:
c      rho--molar density [mol/L]
c        s--entropy [J/mol-K]
c        x--composition [array of mol frac]
c
c  outputs:
c        t--temperature [K]
c     ierr--error flag:  0 = successful
c     herr--error string (character*255 variable if ierr<>0)
c
      include 'commons.for'
      character*255 herr
      dimension x(ncmax)
c
      call ABFL1 (rho,s,x,0,'DS',0.d0,0.d0,t,pp,dd,ierr,herr)
      RETURN
      end                                              !subroutine DSFL1
c
c ======================================================================
c
      subroutine DSFL2 (d,s,z,t,p,Dl,Dv,x,y,q,ierr,herr)
c
c  flash calculation given bulk density, entropy, and composition
c
c  This routine accepts only two-phase states as input; it is intended
c  primarily for use by the general density-entropy flash routine
c  DSFLSH.  It may be called independently if the state is known to be
c  two-phase.  But beware--this routine does not check limits, and it
c  will be significantly faster than DSFLSH only if the bubble and dew
c  point limits can be provided (ksat = 1 option).
c
c  inputs:
c        d--overall (bulk) molar density [mol/L]
c        s--overall (bulk) molar entropy [J/mol]
c        z--overall (bulk) composition [array of mol frac]
c
c  outputs:
c        t--temperature [K]
c        p--pressure [kPa]
c       Dl--molar density [mol/L] of the liquid phase
c       Dv--molar density [mol/L] of the vapor phase
c        x--composition of liquid phase [array of mol frac]
c        y--composition of vapor phase [array of mol frac]
c        q--vapor quality on a MOLAR basis [moles vapor/total moles]
c     ierr--error flag:  0 = successful
c     herr--error string (character*255 variable if ierr<>0)
c
cx DEC$ ATTRIBUTES DLLEXPORT :: DSFL2
c
      include 'commons.for'
      character*255 herr
      dimension z(ncmax),x(ncmax),y(ncmax)
c
      call DBFL2 (d,s,z,0,'DS',
     &                 t,p,Dl,Dv,x,y,q,ierr,herr)
c
      RETURN
      end                                              !subroutine DSFL2
c
c ======================================================================
c
      subroutine DEFLSH (D,e,z,t,p,Dl,Dv,x,y,q,h,s,cv,cp,w,ierr,herr)
c
c  flash calculation given density, energy, and bulk composition
c
c  This routine accepts both single-phase and two-phase states as the
c  input; for single-phase calculations, the subroutine DHFL1 is faster.
c
c  inputs:
c        D--overall (bulk) molar density [mol/L]
c        e--overall (bulk) internal energy [J/mol]
c        z--overall (bulk) composition [array of mol frac]
c
c  outputs:
c        t--temperature [K]
c        p--pressure [kPa]
c       Dl--molar density [mol/L] of the liquid phase
c       Dv--molar density [mol/L] of the vapor phase
c           if only one phase is present, Dl = Dv = D
c        x--composition of liquid phase [array of mol frac]
c        y--composition of vapor phase [array of mol frac]
c           if only one phase is present, x = y = z
c        q--vapor quality on a MOLAR basis [moles vapor/total moles]
c           q < 0 indicates subcooled (compressed) liquid
c           q = 0 indicates saturated liquid
c           q = 1 indicates saturated vapor
c           q > 1 indicates superheated vapor
c           q = 998 superheated vapor, but quality not defined (in most situations, t > Tc)
c           q = 999 indicates supercritical state (t > Tc) and (p > Pc)
c        h--overall (bulk) enthalpy [J/mol]
c        s--overall (bulk) entropy [J/mol-K]
c       Cv--isochoric (constant V) heat capacity [J/mol-K]
c       Cp--isobaric (constant p) heat capacity [J/mol-K]
c        w--speed of sound [m/s]
c           Cp, w are not defined for 2-phase states
c           in such cases, a flag = -9.99998d6 is returned
c     ierr--error flag:  0 = successful
c                      210 = CRITP did not converge
c                      248 = iteration did not converge
c                      249 = H out of range
c     herr--error string (character*255 variable if ierr<>0)
c
c  written by E.W. Lemmon, NIST Thermophysics Division, Boulder, Colorado
c  01-19-01 EWL, original version
c
cx DEC$ ATTRIBUTES DLLEXPORT :: DEFLSH
c
      include 'commons.for'
      character*255 herr
      dimension z(ncmax),x(ncmax),y(ncmax)
c
      call DBFLSH (D,e,z,'DE',t,p,Dl,Dv,x,y,q,ee,h,s,cv,cp,w,ierr,herr)
      RETURN
      end                                             !subroutine DEFLSH
c
c ======================================================================
c
      subroutine DEFL1 (rho,e,x,t,ierr,herr)
c
c  iterate for single-phase temperature as a function of density, energy,
c  and composition
c
c  inputs:
c      rho--molar density [mol/L]
c        e--energy [J/mol]
c        x--composition [array of mol frac]
c
c  outputs:
c        t--temperature [K]
c     ierr--error flag:  0 = successful
c     herr--error string (character*255 variable if ierr<>0)
c
cx DEC$ ATTRIBUTES DLLEXPORT :: DEFL1
c
      include 'commons.for'
      character*255 herr
      dimension x(ncmax)
c
      call ABFL1 (rho,e,x,0,'DE',0.d0,0.d0,t,pp,dd,ierr,herr)
      RETURN
      end                                              !subroutine DEFL1
c
c ======================================================================
c
      subroutine DEFL2 (d,e,z,t,p,Dl,Dv,x,y,q,ierr,herr)
c
c  flash calculation given bulk density, energy, and composition
c
c  This routine accepts only two-phase states as input; it is intended
c  primarily for use by the general density-energy flash routine
c  DEFLSH.  It may be called independently if the state is known to be
c  two-phase.  But beware--this routine does not check limits, and it
c  will be significantly faster than DEFLSH only if the bubble and dew
c  point limits can be provided (ksat = 1 option).
c
c  inputs:
c        d--overall (bulk) molar density [mol/L]
c        e--overall (bulk) molar energy [J/mol]
c        z--overall (bulk) composition [array of mol frac]
c
c  outputs:
c        t--temperature [K]
c        p--pressure [kPa]
c       Dl--molar density [mol/L] of the liquid phase
c       Dv--molar density [mol/L] of the vapor phase
c        x--composition of liquid phase [array of mol frac]
c        y--composition of vapor phase [array of mol frac]
c        q--vapor quality on a MOLAR basis [moles vapor/total moles]
c     ierr--error flag:  0 = successful
c     herr--error string (character*255 variable if ierr<>0)
c
cx DEC$ ATTRIBUTES DLLEXPORT :: DEFL2
c
      include 'commons.for'
      character*255 herr
      dimension z(ncmax),x(ncmax),y(ncmax)
c
      call DBFL2 (d,e,z,0,'DE',
     &                 t,p,Dl,Dv,x,y,q,ierr,herr)
c
      RETURN
      end                                              !subroutine DEFL2
c
c ======================================================================
c
      subroutine HSFLSH (h,s,z,t,p,D,Dl,Dv,x,y,q,e,cv,cp,w,ierr,herr)
c
c  flash calculation given bulk enthalpy, entropy, and composition
c
c  inputs:
c        h--overall (bulk) enthalpy [J/mol]
c        s--overall (bulk) entropy [J/mol-K]
c        z--composition [array of mol frac]
c
c  outputs:
c        t--temperature [K]
c        p--pressure [kPa]
c        D--overall (bulk) molar density [mol/L]
c       Dl--molar density [mol/L] of the liquid phase
c       Dv--molar density [mol/L] of the vapor phase
c           if only one phase is present, Dl = Dv = D
c        x--composition [array of mol frac] for liquid phase
c        y--composition [array of mol frac] for vapor phase
c           if only one phase is present, x = y = z
c        q--vapor quality on a MOLAR basis [moles vapor/total moles]
c           q < 0 indicates subcooled (compressed) liquid
c           q = 0 indicates saturated liquid
c           q = 1 indicates saturated vapor
c           q > 1 indicates superheated vapor
c           q = -998 subcooled liquid, but quality not defined (p > Pc)
c           q = 999 indicates supercritical state (t > Tc) and (p > Pc)
c        e--overall (bulk) internal energy [J/mol]
c       Cv--isochoric (constant V) heat capacity [J/mol-K]
c       Cp--isobaric (constant p) heat capacity [J/mol-K]
c        w--speed of sound [m/s]
c           Cp, w are not defined for 2-phase states
c           in such cases, a flag = -9.99998d6 is returned
c     ierr--error flag:  0 = successful (see TBFLSH for others)
c     herr--error string (character*255 variable if ierr<>0)
c
c  written by E.W. Lemmon, NIST Phys & Chem Properties Div, Boulder, CO
c  12-17-01 EWL, original version
c  05-08-04 OBD, (Conecpts NREC) add routine to determine 2-phase states
c  10-20-04 EWL, check for t1=0 before call to ENTRO
c  03-12-06 EWL, fix bug with e not being returned
c  03-07-11 EWL, initialize s1 and s2
c  05-16-11 EWL, add check for ierr>0 for liquid phase when T>Tsat and T<Tsat*1.01
c  03-01-12 EWL, after the call to SATH, change dmin from 0 to 1.d-4 so that the calculated entropy at dmin won't be so large
c  11-21-12 EWL, specify better values of q after call to HSFL1
c
cx DEC$ ATTRIBUTES DLLEXPORT :: HSFLSH
c
      include 'commons.for'
      character*255 herr
      dimension x(ncmax),y(ncmax),z(ncmax)
c
      call ISPURE (z,icomp)
      if (icomp.eq.0) then
        do i=1,nc
          x(i)=z(i)
          y(i)=z(i)
        enddo
      else
        do i=1,nc
          x(i)=0.d0
          y(i)=0.d0
        enddo
        x(icomp)=1.d0
        y(icomp)=1.d0
      endif
      call SATH (h,z,0,nroot,k1,t1,p1,d1,k2,t2,p2,d2,ierr,herr)
      dmin=1.d-4
      call LIMITS ('EOS',z,tmin,tmax,Dmax,pmax)
      call CRITP (z,tc,pc,rhoc,ierr,herr)
      if (nroot.eq.0) then
        q=999
        t=tc*1.1d0
        d=rhoc
      else
        s1=0
        s2=0
        if (t1.gt.0.d0) call ENTRO (t1,d1,z,s1)
        if (d2.gt.0.d0) call ENTRO (t2,d2,z,s2)
        if (s.lt.s1) then
          dmin=d1
          t=t1*1.01d0
          d=d1*1.01d0
          q=-998
        elseif (s.gt.s2 .and. nroot.eq.2) then
          dmax=d2
          t=t2
          d=d2/1.1d0
          q=998
        else
          p=p1
          do i=1,25
            call PSFLSH (p,s,z,t,D,Dl,Dv,x,y,q,ee,hh,cv,cp,w,ierr,herr)
            dh=hh-h
            if (abs(dh).le.1.d-5) goto 100
            p=max(0.2d0*(p+1d-3),p-dh*D)
          enddo
 100      continue
          if (ieflg.eq.0) e=ee
          if (ieflg.eq.1) e=hh
          if (ierr.eq.0 .and. i.lt.25) RETURN
          t=tc
          d=rhoc
          Dl=d
          Dv=d
          call THERM (t,D,z,p,e,hh,ss,cv,cp,w,hjt)
          ierr=200
          write (herr,1200) hnull
 1200     format ('[HSFLSH error 200] ',
     &          'h-s inputs are two-phase or out of bounds, iterative',
     &          ' routine is not available to find a solution.',a1)
          call ERRMSG (ierr,herr)
          RETURN
        endif
      endif
      call HSFL1 (h,s,z,Dmin,Dmax,t,D,ierr,herr)
      if (ierr.gt.0 .and. nroot.ne.0) then
        if (s.lt.s1) then
          dmin=d1
          t=t1
          d=d1
          q=-998
          call HSFL1 (h,s,z,Dmin,Dmax,t,D,ierr,herr)
        endif
      endif
      call THERM (t,D,z,p,e,hh,ss,cv,cp,w,hjt)
      if (ieflg.eq.1) e=hh
      Dl=d
      Dv=d
      if (p.gt.pc .and. t.gt.tc) then
        q=999.d0     !quality undefined
      elseif (p.gt.pc) then
        q=-998.d0    !subcooled
      elseif (t.gt.tc) then
        q=998.d0     !superheated
      elseif (d.gt.rhoc) then
        q=-998.d0    !subcooled
      elseif (d.lt.rhoc) then
        q=998.d0     !superheated
      end if
      if (ierr.eq.0)
     &   call LIMITX ('EOS',t,D,p,z,tmin,tmax,rhomax,pmax,ierr,herr)
      RETURN
      end                                             !subroutine HSFLSH
c
c ======================================================================
c
      subroutine HSFL1 (h,s,x,Dmin,Dmax,t,D,ierr,herr)
c
c  flash calculation given enthalpy, entropy, and composition.  This
c  routine accepts only single-phase inputs, it is intended primarily for
c  use with the more general flash routine HSFLSH.
c
c  inputs:
c        h--enthalpy [J/mol-K]
c        s--entropy [J/mol-K]
c        x--composition [array of mol frac]
c     Dmin--lower bound on density [mol/L]
c     Dmax--upper bound on density [mol/L]
c
c  outputs:
c        t--temperature [K]
c        D--molar density [mol/L]
c     ierr--error flag:  0 = successful
c     herr--error string (character*255 variable if ierr<>0)
c
cx DEC$ ATTRIBUTES DLLEXPORT :: HSFL1
c
      include 'commons.for'
      character*255 herr
      dimension x(ncmax)
c
      if (ieflg.ne.1) then
        call ABFL1 (s,h,x,0,'SH',dmin,dmax,t,p,D,ierr,herr)
      else
        call ABFL1 (s,h,x,0,'SE',dmin,dmax,t,p,D,ierr,herr)
      endif
      RETURN
      end                                              !subroutine HSFL1
c
c ======================================================================
c
      subroutine ESFLSH (e,s,z,t,p,D,Dl,Dv,x,y,q,h,cv,cp,w,ierr,herr)
c
c  flash calculation given bulk energy, entropy, and composition
c
c  inputs:
c        e--overall (bulk) energy [J/mol]
c        s--overall (bulk) entropy [J/mol-K]
c        z--composition [array of mol frac]
c
c  outputs:
c        see HSFLSH for list of outputs
c
c  written by E.W. Lemmon, NIST Phys & Chem Properties Div, Boulder, CO
c  05-16-05 EWL, original version
c
cx DEC$ ATTRIBUTES DLLEXPORT :: ESFLSH
c
      include 'commons.for'
      character*255 herr
      dimension x(ncmax),y(ncmax),z(ncmax)
c
      ieflg=1
      call HSFLSH (e,s,z,t,p,D,Dl,Dv,x,y,q,h,cv,cp,w,ierr,herr)
      ieflg=0
      RETURN
      end                                             !subroutine ESFLSH
c
c ======================================================================
c
      subroutine TQFLSH (t,q,z,kq,p,D,Dl,Dv,x,y,e,h,s,cv,cp,w,ierr,herr)
c
c  flash calculation given temperature, quality, and bulk composition
c
c  This routine accepts saturation or two-phase states as inputs.
c
c  inputs:
c        t--temperature [K]
c        q--vapor quality [basis specified by kq]
c           q = 0 indicates saturated liquid
c           q = 1 indicates saturated vapor
c           q < 0 or q > 1 are not allowed and will result in warning
c        z--overall (bulk) composition [array of mol frac]
c       kq--flag specifying units for input quality
c           kq = 1 quality on MOLAR basis [moles vapor/total moles]
c           kq = 2 quality on MASS basis [mass vapor/total mass]
c
c  outputs:
c        p--pressure [kPa]
c        D--overall (bulk) molar density [mol/L]
c       Dl--molar density [mol/L] of the liquid phase
c       Dv--molar density [mol/L] of the vapor phase
c        x--composition of liquid phase [array of mol frac]
c        y--composition of vapor phase [array of mol frac]
c        e--overall (bulk) internal energy [J/mol]
c        h--overall (bulk) enthalpy [J/mol]
c        s--overall (bulk) entropy [J/mol-K]
c       Cv--isochoric (constant V) heat capacity [J/mol-K]
c       Cp--isobaric (constant p) heat capacity [J/mol-K]
c        w--speed of sound [m/s]
c           Cp, w are not defined for 2-phase states
c           in such cases, -9.992d6 is returned
c     ierr--error flag:   0 = successful
c                         1 = T < Tmin
c                         8 = x out of range
c                         9 = T and x out of range
c                       270 = CRITP did not converge
c                       271 = T > Tcrit
c                       275 = q out of range
c                       278 = TQFLSH did not converge
c     herr--error string (character*255 variable if ierr<>0)
c
c  written by M. McLinden, NIST Thermophysics Division, Boulder, Colorado
c  04-08-96  MM, original version, based on TPFLSH
c  05-16-97  MM, get special-case flags from /FLAGS/
c  07-14-97  MM, add check for q out of range; add call to LIMITS
c  10-01-97  MM, add compiler switch to allow access by DLL
c  12-05-97  MM, change warning -279 to error 279
c  09-25-98  MM, define kguess prior to call to TPRHO
c  09-02-99  MM, add check for x(i) = 1
c  05-08-00  MM, set alpha=1-qmole in mass conversion
c  12-16-02 EWL, add checks for pseudo-pure fluid, calculate p using q
c  01-20-10 EWL, initialize x and y
c  05-06-10 EWL, allow T>Tc for mixtures
c
cx DEC$ ATTRIBUTES DLLEXPORT :: TQFLSH
c
      include 'commons.for'
      character*255 herr,herr2
      dimension z(ncmax),x(ncmax),y(ncmax)
      dimension xdew(ncmax),ybub(ncmax)
c
      ierr=0
      herr=' '
      p=0.d0
      D=0.d0
      Dl=0.d0
      Dv=0.d0
      e=0.d0
      h=0.d0
      s=0.d0
      cv=0.d0
      cp=0.d0
      w=0.d0
      call ISPURE (z,icomp)
      if (icomp.eq.0) then
        do i=1,nc
          x(i)=z(i)
          y(i)=z(i)
        enddo
      else
        do i=1,nc
          x(i)=0.d0
          y(i)=0.d0
        enddo
        x(icomp)=1.d0
        y(icomp)=1.d0
      endif
c
c  initialize x and y for nc=1
c
c  check that input conditions (in this case t and z) are within limits
c
      Ddum=0.0d0
      pdum=0.0d0
      call LIMITX ('EOS',t,Ddum,pdum,z,tmin,tmax,rhomax,pmax,ierr,herr2)
      if (ierr.gt.0) then
c  T and/or z are out of bounds, set error flag and return
        write (herr,1110) ierr,herr2(1:236),hnull
 1110   format ('[TQFLSH error',i3,'] ',a236,a1)
        call ERRMSG (ierr,herr)
        RETURN
      end if
c
      call CRITP (z,tc,pc,rhoc,ierr,herr2)
      if (ierr.gt.0) then
        ierr=270
        write (herr,1111) herr2(1:235),hnull
 1111   format ('[TQFLSH error 270] ',a235,a1)
        call ERRMSG (ierr,herr)
        RETURN
      end if
c
      if ((t.ge.tc .and. nc.eq.1) .or. t.gt.tc*1.5d0) then
c  supercritical state
        ierr=271
        write (herr,1271) t,tc,hnull
 1271   format ('[TQFLSH error 271] ',
     &          'temperature input to temperature-quality flash is ',
     &          'greater than critical temperature; T =',g12.5,
     &          ' K, Tcrit =',g12.5,' K.',a1)
        call ERRMSG (ierr,herr)
        RETURN
      else if (ABS(q).le.1.0d-8) then
c  saturated liquid
        call SATT (t,z,1,p,Dl,Dv,x,y,ierr,herr2)
        if (ianc(icomp).eq.1) call SATT (t,z,2,p,D,Dv,x,y,ierr,herr2)
        if (ierr.ne.0) then
          herr='[TQFLSH error] (sat liquid):  '//herr2
          call ERRMSG (ierr,herr)
          RETURN
        end if
        D=Dl
        call THERM (t,Dl,x,p,e,h,s,cv,cp,w,hjt)
      else if (ABS(1.0d0-q).le.1.0d-8) then
c  saturated vapor
        call SATT (t,z,2,p,Dl,Dv,x,y,ierr,herr2)
        if (ianc(icomp).eq.1) call SATT (t,z,1,p,Dl,D,x,y,ierr,herr2)
        if (ierr.ne.0) then
          herr='[TQFLSH error] (sat vapor):  '//herr2
          call ERRMSG (ierr,herr)
          RETURN
        end if
        D=Dv
        call THERM (t,Dv,y,p,e,h,s,cv,cp,w,hjt)
      else if (q.lt.0.0d0 .or. q.gt.1.0d0) then
c  quality out of range
        ierr=275
        write (herr,1275) q,hnull
 1275   format ('[TQFLSH error 275] ',
     &          'input quality is out of range; q =',g12.5,
     &          '; quality must be between 0 and 1 ',a1)
        call ERRMSG (ierr,herr)
        RETURN
      else
c  two-phase state
c  check if any component has mole fraction 1--if so it is pure
c  component (even if nc <> 1); [mixture 2-phase iteration will
c  not converge if x(i) = 1]
        lpure=.false.
        do i=1,nc
          if (ABS(z(i)-1.0d0).lt.1.0d-8) lpure=.true.
        enddo
        if (icomp.ne.0) lpure=.true.
        if (lpure .or. ianc(icomp).eq.1) then
c  special case--two-phase state for a pure fluid
          call SATT (t,z,1,p,Dl,Dv,x,ybub,ierr,herr2)
          pl=p
          pv=p
          if (ierr.ne.0) then
            herr='[TQFLSH error] (2-phase):  '//herr2
            call ERRMSG (ierr,herr)
            RETURN
          end if
        if (ianc(icomp).eq.1)call SATT (t,z,2,pv,D,Dv,xdew,y,ierr,herr2)
          call THERM (t,Dl,x,ptherm,el,hl,sl,cvl,cp,w,hjt)
          call THERM (t,Dv,y,ptherm,ev,hv,sv,cvv,cp,w,hjt)
          cp=x2ph                 !Cp, w not defined for 2-phase
          w=x2ph
          cv=x2ph
c  bulk properties are weighted average of liquid and vapor phases
c  note that for a pure fluid quality on mass and molar basis is same
          alpha=1.0d0-q               !alpha is liq fraction,
          D=1.0d0/(alpha/Dl+q/Dv)     !q is vapor frac
          p=alpha*pl+q*pv
          e=alpha*el+q*ev
          h=alpha*hl+q*hv
          s=alpha*sl+q*sv
        else
c
c  general 2-phase mixture state
c  generate initial guesses for t, x, y by interpolating sat liq & vap
c
          call SATT (t,z,1,pbub,Dlbub,Dvbub,x,ybub,ierr,herr2)
          call SATT (t,z,2,pdew,Dldew,Dvdew,xdew,y,ierr,herr)
          if (ierr.ne.0) then
            herr='[TQFLSH error] (2-phase):  '//herr2
            call ERRMSG (ierr,herr)
            RETURN
          end if
          xsum=0.0d0
          ysum=0.0d0        !sums for normalization of compositions
          do i=1,nc
            x(i)=(1.0d0-q)*z(i)+q*xdew(i)
            y(i)=q*z(i)+(1.0d0-q)*ybub(i)
            xsum=xsum+x(i)
            ysum=ysum+y(i)
          enddo
          do i=1,nc
            x(i)=x(i)/xsum
            y(i)=y(i)/ysum
          enddo
          p=(1.0d0-q)*pbub+q*pdew  !initial guess for pressure
          Dl=Dlbub                 !initial guess for liquid density
          Dv=Dvdew                 !initial guess for vapor density
          ksat=0
          call TQFL2 (t,q,z,kq,ksat,pbub,pdew,Dlbub,Dvdew,ybub,xdew,
     &                p,Dl,Dv,x,y,ierr,herr)
c         write (*,*) 'TQFLSH--return from TQFL2'
c  compute 2-phase properties and load output variables
c  call TPRHO to ensure consistency of t, p, rho
          kguess=1   !use above as initial guess
          call TPRHO (t,p,x,1,kguess,Dl,ierr,herr)
          call THERM (t,Dl,x,ptherm,el,hl,sl,cvl,cp,w,hjt)
          call TPRHO (t,p,y,2,kguess,Dv,ierr,herr)
          call THERM (t,Dv,y,ptherm,ev,hv,sv,cvv,cp,w,hjt)
c         ierr=279
c         herr='[TQFLSH error 279] temperature-quality flash '//
c    &         'calculations are not implemented for mixtures'//hnull
          cp=x2ph              !Cp, w not defined for 2-phase
          w=x2ph
          cv=x2ph
c  bulk properties are weighted average of liquid and vapor phases
          if (kq.eq.1) then
            qmole=q                 !qmole is vapor frac [molar basis]
            alpha=1.0d0-q           !alpha is liq fraction
          else
c  convert mass quality to molar quality
            wmliq=WMOL(x)
            wmvap=WMOL(y)
            qmole=q/wmvap/(q/wmvap+(1.0d0-q)/wmliq)
            alpha=1.0d0-qmole
          end if
          D=1.0d0/(alpha/Dl+qmole/Dv)
          e=alpha*el+qmole*ev
          h=alpha*hl+qmole*hv
          s=alpha*sl+qmole*sv
        end if
      end if
c
      RETURN
      end                                             !subroutine TQFLSH
c
c ======================================================================
c
      subroutine TQFL2 (t,q,z,kq,ksat,pbub,pdew,Dlbub,Dvdew,ybub,xdew,
     &                  p,Dl,Dv,x,y,ierr,herr)
c
c  flash calculation given temperature, quality, and composition
c
c  This routine accepts only two-phase states as input; it is intended
c  primarily for use by the general temperature-quality flash routine
c  TQFLSH.  It may be called independently if the state is known to be
c  two-phase.  But beware--this routine does not check limits, and it
c  will be significantly faster than TQFLSH only if the bubble and dew
c  point limits can be provided (ksat = 1 option).
c
c  inputs:
c        t--temperature [K]
c        q--vapor quality [basis specified by kq]
c        z--overall (bulk) composition [array of mol frac]
c       kq--flag specifying units for input quality
c           kq = 1 quality on MOLAR basis [moles vapor/total moles]
c           kq = 2 quality on MASS basis [mass vapor/total mass]
c     ksat--flag for bubble and dew point limits
c           0 = dew and bubble point limits computed here
c           1 = must provide values for the following:
c     pbub--bubble point pressure [kPa] at (t,x=z)
c     pdew--dew point pressure [kPa] at (t,y=z)
c    Dlbub--liquid density [mol/L] at bubble point
c    Dvdew--vapor density [mol/L] at dew point
c     ybub--vapor composition [array of mol frac] at bubble point
c     xdew--liquid composition [array of mol frac] at dew point
c
c  outputs:
c        p--pressure [kPa]
c       Dl--molar density [mol/L] of the liquid phase
c       Dv--molar density [mol/L] of the vapor phase
c        x--composition of liquid phase [array of mol frac]
c        y--composition of vapor phase [array of mol frac]
c     ierr--error flag:  0 = successful
c     herr--error string (character*255 variable if ierr<>0)
c
cx DEC$ ATTRIBUTES DLLEXPORT :: TQFL2
c
      include 'commons.for'
      character*255 herr
      dimension z(ncmax),x(ncmax),y(ncmax),xdew(ncmax),ybub(ncmax)
c
      call ABFL2 (t,q,z,kq,ksat,'TQ',
     &                 tbub,tdew,pbub,pdew,Dlbub,Dvdew,ybub,xdew,
     &                 tt,p,Dl,Dv,x,y,qq,ierr,herr)
c
      RETURN
      end                                              !subroutine TQFL2
c
c ======================================================================
c
      subroutine PQFLSH (p,q,z,kq,t,D,Dl,Dv,x,y,e,h,s,cv,cp,w,ierr,herr)
c
c  flash calculation given pressure, quality, and bulk composition
c
c  This routine accepts saturation or two-phase states as inputs.
c
c  inputs:
c        p--pressure [kPa]
c        q--vapor quality [basis specified by kq]
c           q = 0 indicates saturated liquid
c           q = 1 indicates saturated vapor
c           q < 0 or q > 1 are not allowed and will result in warning
c        z--overall (bulk) composition [array of mol frac]
c       kq--flag specifying units for input quality
c           kq = 1 quality on MOLAR basis [moles vapor/total moles]
c           kq = 2 quality on MASS basis [mass vapor/total mass]
c
c  outputs:
c        t--temperature [K]
c        D--overall (bulk) molar density [mol/L]
c       Dl--molar density [mol/L] of the liquid phase
c       Dv--molar density [mol/L] of the vapor phase
c        x--composition of liquid phase [array of mol frac]
c        y--composition of vapor phase [array of mol frac]
c        e--overall (bulk) internal energy [J/mol]
c        h--overall (bulk) enthalpy [J/mol]
c        s--overall (bulk) entropy [J/mol-K]
c       Cv--isochoric (constant V) heat capacity [J/mol-K]
c       Cp--isobaric (constant p) heat capacity [J/mol-K]
c        w--speed of sound [m/s]
c           Cp, w are not defined for 2-phase states
c           in such cases, -9.992d6 is returned
c     ierr--error flag:   0 = successful
c                         4 = P < 0
c                         8 = x out of range
c                         9 = P and x out of range
c                       290 = CRITP did not converge
c                       291 = P > Pcrit
c                       295 = q out of range
c                       298 = PQFLSH did not converge
c                      -299 = 2-phase for mix not implemented yet
c     herr--error string (character*255 variable if ierr<>0)
c
c  written by M. McLinden, NIST Thermophysics Division, Boulder, Colorado
c  04-08-96  MM, original version, based on TQFLSH
c  04-23-96  MM, alpha = 1 - qmole, not 1 - q when q input as mass
c  05-16-97  MM, get special-case flags from /FLAGS/
c  07-14-97  MM, add check for q out of range; add call to LIMITS
c  10-01-97  MM, add compiler switch to allow access by DLL
c  12-05-97  MM, change warning -299 to error 299
c  09-25-98  MM, define kguess prior to call to TPRHO
c  09-02-99  MM, add check for x(i) = 1
c  12-16-02 EWL, add checks for pseudo-pure fluid, calculate p using q
c  01-20-10 EWL, initialize x and y
c  05-06-10 EWL, allow p>pc*1.5 for mixtures
c
cx DEC$ ATTRIBUTES DLLEXPORT :: PQFLSH
c
      include 'commons.for'
      character*255 herr,herr2
      dimension z(ncmax),x(ncmax),y(ncmax)
      dimension xdew(ncmax),ybub(ncmax)
c
      ierr=0
      herr=' '
      D=0.d0
      Dl=0.d0
      Dv=0.d0
      e=0.d0
      h=0.d0
      s=0.d0
      cv=0.d0
      cp=0.d0
      w=0.d0
      call ISPURE (z,icomp)
      if (icomp.eq.0) then
        do i=1,nc
          x(i)=z(i)
          y(i)=z(i)
        enddo
      else
        do i=1,nc
          x(i)=0.d0
          y(i)=0.d0
        enddo
        x(icomp)=1.d0
        y(icomp)=1.d0
      endif
c
c  initialize x and y for nc=1
c
      call CRITP (z,tc,pc,rhoc,ierr,herr2)
      if (ierr.gt.0) then
        ierr=290
        t=300.0d0
        write (herr,1108) herr2(1:235),hnull
 1108   format ('[PQFLSH error 290] ',a235,a1)
        call ERRMSG (ierr,herr)
        RETURN
      end if
c
c  check that input conditions (in this case p and z) are within limits
c
      Ddum=0.0d0
      tdum=0.8d0*tc
      call LIMITX ('EOS',tdum,Ddum,p,z,tmin,tmax,rhomax,pmax,ierr,herr2)
      if (ierr.gt.0) then
c  p and/or x are out of bounds, set error flag and return
c  set output temperature to "reasonable" value to avoid GUI crash
        t=0.8d0*tc
        write (herr,1110) ierr,herr2(1:236),hnull
 1110   format ('[PQFLSH error',i3,'] ',a236,a1)
        call ERRMSG (ierr,herr)
        RETURN
      end if
c
      if ((p.ge.pc .and. nc.eq.1) .or. p.gt.pc*1.5d0) then
c  supercritical state
c  set output temperature to critical value to avoid GUI crash
        t=tc
        ierr=291
        write (herr,1291) p/1000.0d0,pc/1000.0d0,hnull
 1291   format ('[PQFLSH error 291] ',
     &          'pressure input to pressure-quality flash is ',
     &          'greater than critical pressure; P =',g12.5,
     &          ' MPa, Pcrit =',g12.5,' MPa.',a1)
        call ERRMSG (ierr,herr)
        RETURN
      else if (ABS(q).le.1.0d-8 .and. ianc(icomp).eq.0) then
c  saturated liquid
        call SATP (p,z,1,t,Dl,Dv,x,y,ierr,herr2)
        if (ierr.ne.0) then
          herr='[PQFLSH error] (sat liquid):  '//herr2
          call ERRMSG (ierr,herr)
          RETURN
        end if
        D=Dl
        call THERM (t,Dl,x,ptherm,e,h,s,cv,cp,w,hjt)
      else if (ABS(1.0d0-q).le.1.0d-8 .and. ianc(icomp).eq.0) then
c  saturated vapor
        call SATP (p,z,2,t,Dl,Dv,x,y,ierr,herr2)
        if (ierr.ne.0) then
          herr='[PQFLSH error] (sat vapor):  '//herr2
          call ERRMSG (ierr,herr)
          RETURN
        end if
        D=Dv
        call THERM (t,Dv,y,ptherm,e,h,s,cv,cp,w,hjt)
      else if (q.lt.0.0d0 .or. q.gt.1.0d0) then
c  quality out of range
        ierr=295
        write (herr,1295) q,hnull
 1295   format ('[PQFLSH error 295] ',
     &          'input quality is out of range; q =',g12.5,
     &          '; quality must be between 0 and 1 ',a1)
        call ERRMSG (ierr,herr)
        RETURN
      else
c  two-phase state
c  check if any component has mole fraction 1--if so it is pure
c  component (even if nc <> 1); [mixture 2-phase iteration will
c  not converge if x(i) = 1]
        lpure=.false.
        do i=1,nc
          if (ABS(z(i)-1.0d0).lt.1.0d-8) lpure=.true.
        enddo
        if (icomp.ne.0) lpure=.true.
        if (lpure .or. ianc(icomp).eq.1) then
c  special case--two-phase state for a pure fluid
          call SATP (p,z,1,t,Dl,Dv,x,y,ierr,herr2)
          if (ierr.ne.0) then
            herr='[PQFLSH error] (2-phase):  '//herr2
            call ERRMSG (ierr,herr)
            RETURN
          end if
          if (ianc(icomp).eq.1) then
            tl=t
            call SATP (p,z,2,tv,D,Dv,x,y,ierr,herr2)
            t=(1.d0-q)*tl+q*tv
            if (ianc(icomp).eq.1) call PTANC (t,p,q,d,'Q',Dl,Dv)
          endif
          call THERM (t,Dl,x,ptherm,el,hl,sl,cvl,cp,w,hjt)
          call THERM (t,Dv,y,ptherm,ev,hv,sv,cvv,cp,w,hjt)
          cp=x2ph                 !Cp, w not defined for 2-phase
          w=x2ph
          cv=x2ph
c  bulk properties are weighted average of liquid and vapor phases
c  note that for a pure fluid quality on mass and molar basis is same
          alpha=1.0d0-q               !alpha is liq fraction,
          D=1.0d0/(alpha/Dl+q/Dv)     !q is vapor frac
          e=alpha*el+q*ev
          h=alpha*hl+q*hv
          s=alpha*sl+q*sv
        else
c
          call SATP (p,z,1,tbub,Dlbub,Dvbub,x,ybub,ierr,herr2)
          call SATP (p,z,2,tdew,Dldew,Dvdew,xdew,y,ierr,herr2)
          if (ierr.ne.0) then
            herr='[PQFLSH error] (2-phase):  '//herr2
            call ERRMSG (ierr,herr)
            RETURN
          end if
          ksat=1   !dew & bubble point limits are provided
          call PQFL2 (p,q,z,kq,ksat,tbub,tdew,Dlbub,Dvdew,ybub,xdew,
     &                t,Dl,Dv,x,y,ierr,herr)
          call THERM (t,Dl,x,ptherm,el,hl,sl,cvl,cp,w,hjt)
          call THERM (t,Dv,y,ptherm,ev,hv,sv,cvv,cp,w,hjt)
          cp=x2ph                   !Cp, w not defined for 2-phase
          w=x2ph
          cv=x2ph
c  bulk properties are weighted average of liquid and vapor phases
          if (kq.eq.2) then
c  convert mass quality to molar quality
            wmliq=WMOL(x)
            wmvap=WMOL(y)
            qmole=q/wmvap/(q/wmvap+(1.0d0-q)/wmliq)
          else
            qmole=q                 !qmole is vapor frac [molar basis]
          end if
          alpha=1.0d0-qmole         !alpha is liq fraction
          D=1.0d0/(alpha/Dl+qmole/Dv)
          e=alpha*el+qmole*ev
          h=alpha*hl+qmole*hv
          s=alpha*sl+qmole*sv
        end if
      end if
c
      RETURN
      end                                             !subroutine PQFLSH
c
c ======================================================================
c
      subroutine PQFL2 (p,q,z,kq,ksat,tbub,tdew,Dlbub,Dvdew,ybub,xdew,
     &                  t,Dl,Dv,x,y,ierr,herr)
c
c  flash calculation given pressure, quality, and composition
c
c  This routine accepts only two-phase states as input; it is intended
c  primarily for use by the general pressure-quality flash routine
c  PQFLSH.  It may be called independently if the state is known to be
c  two-phase.  But beware--this routine does not check limits, and it
c  will be significantly faster than PQFLSH only if the bubble and dew
c  point limits can be provided (ksat = 1 option).
c
c  This routine calls TPFL2 within a secant-method iteration for
c  pressure to find a solution.  Initial guesses are based on liquid
c  density at the bubble point and vapor density at the dew point.
c
c  inputs:
c        p--pressure [kPa]
c        q--vapor quality [basis specified by kq]
c        z--overall (bulk) composition [array of mol frac]
c       kq--flag specifying units for input quality
c           kq = 1 quality on MOLAR basis [moles vapor/total moles]
c           kq = 2 quality on MASS basis [mass vapor/total mass]
c     ksat--flag for bubble and dew point limits
c           0 = dew and bubble point limits computed here
c           1 = must provide values for the following:
c     tbub--bubble point temperature [K] at (p,x=z)
c     tdew--dew point temperature [K] at (p,y=z)
c    Dlbub--liquid density [mol/L] at bubble point
c    Dvdew--vapor density [mol/L] at dew point
c     ybub--vapor composition [array of mol frac] at bubble point
c     xdew--liquid composition [array of mol frac] at dew point
c
c  outputs:
c        t--temperature [K]
c       Dl--molar density [mol/L] of the liquid phase
c       Dv--molar density [mol/L] of the vapor phase
c        x--composition of liquid phase [array of mol frac]
c        y--composition of vapor phase [array of mol frac]
c     ierr--error flag:  0 = successful
c     herr--error string (character*255 variable if ierr<>0)
c
cx DEC$ ATTRIBUTES DLLEXPORT :: PQFL2
c
      include 'commons.for'
      character*255 herr
      dimension z(ncmax),x(ncmax),y(ncmax),xdew(ncmax),ybub(ncmax)
c
      call ABFL2 (p,q,z,kq,ksat,'PQ',
     &                 tbub,tdew,pbub,pdew,Dlbub,Dvdew,ybub,xdew,
     &                 t,pp,Dl,Dv,x,y,qq,ierr,herr)
c
      RETURN
      end                                              !subroutine PQFL2
c
c ======================================================================
c
      subroutine DQFL2 (d,q,z,kq,t,p,Dl,Dv,x,y,ierr,herr)
c
c  flash calculation given bulk density, quality, and composition
c
c  This routine accepts only two-phase states as input; it is intended
c  primarily for use by the general density-quality flash routine
c  DQFLSH.  It may be called independently if the state is known to be
c  two-phase.  But beware--this routine does not check limits.
c
c  inputs:
c        d--overall (bulk) molar density [mol/L]
c        q--vapor quality on a MOLAR basis [moles vapor/total moles]
c        z--overall (bulk) composition [array of mol frac]
c       kq--flag specifying units for input quality
c           kq = 1 quality on MOLAR basis [moles vapor/total moles]
c           kq = 2 quality on MASS basis [mass vapor/total mass]
c
c  outputs:
c        t--temperature [K]
c        p--pressure [kPa]
c       Dl--molar density [mol/L] of the liquid phase
c       Dv--molar density [mol/L] of the vapor phase
c        x--composition of liquid phase [array of mol frac]
c        y--composition of vapor phase [array of mol frac]
c     ierr--error flag:  0 = successful
c     herr--error string (character*255 variable if ierr<>0)
c
cx DEC$ ATTRIBUTES DLLEXPORT :: DQFL2
c
      include 'commons.for'
      character*255 herr
      dimension z(ncmax),x(ncmax),y(ncmax)
c
      call DBFL2 (d,q,z,kq,'DQ',
     &                 t,p,Dl,Dv,x,y,q,ierr,herr)
c
      RETURN
      end                                              !subroutine DQFL2
c
c ======================================================================
c
      subroutine TBFLSH (t,b,z,kr,ab,p,D,Dl,Dv,x,y,q,e,h,s,cv,cp,w,
     &                   ierr,herr)
c
c  flash calculation given temperature, bulk composition, and either
c  enthalpy, entropy, or energy
c
c  inputs:
c        t--temperature [K]
c        b--second property (energy, enthalpy, or entropy)
c        z--composition [array of mol frac]
c       kr--flag specifying desired root for multi-valued inputs:
c           1 = return lower density root
c           2 = return higher density root
c       ab--character*2 string defining the inputs: 'TH', 'TS', or 'TE'
c
c  outputs:
c        p--pressure [kPa]
c        D--overall (bulk) molar density [mol/L]
c       Dl--molar density [mol/L] of the liquid phase
c       Dv--molar density [mol/L] of the vapor phase
c           if only one phase is present, Dl = Dv = D
c        x--composition [array of mol frac] for liquid phase
c        y--composition [array of mol frac] for vapor phase
c           if only one phase is present, x = y = z
c        q--vapor quality on a MOLAR basis [moles vapor/total moles]
c           q < 0 indicates subcooled (compressed) liquid
c           q = 0 indicates saturated liquid
c           q = 1 indicates saturated vapor
c           q > 1 indicates superheated vapor
c           q = -998 subcooled liquid, but quality not defined (p > Pc)
c           q = 998 superheated vapor, but quality not defined (in most situations, t > Tc)
c           q = 999 indicates supercritical state (t > Tc) and (p > Pc)
c        e--overall (bulk) internal energy [J/mol]
c        h--overall (bulk) enthalpy [J/mol]
c        s--overall (bulk) entropy [J/mol-K]
c       Cv--isochoric (constant V) heat capacity [J/mol-K]
c       Cp--isobaric (constant p) heat capacity [J/mol-K]
c        w--speed of sound [m/s]
c           Cp, w are not defined for 2-phase states
c           in such cases, a flag = -9.99998d6 is returned
c     ierr--error flag:  0 = successful
c                        4 = Pin < 0
c                        8 = x out of range (< 0 or > 1)
c                       12 = x out of range and P < 0
c     errors are in 230 range
c                      240 = CRITP did not converge
c                      241 = SATP did not converge at bubble point
c                      242 = SATP did not converge at dew point
c                      243 = SATP (bubble pt) did not converge for 2-ph
c                      244 = SATP (dew pt) did not converge  for 2-phase
c                      245 = TQFL2 did not converge
c                      246 = 2-phase iteration did not converge
c                      247 = TPRHO did not converge for single-phase
c                      248 = single-phase iteration did not converge
c                      249 = H out of range
c     herr--error string (character*255 variable if ierr<>0)
c
c  rewritten by E.W. Lemmon, NIST Physical & Chemical Properties Div, Boulder, CO
c  01-18-01 EWL, original version, rewritten by combining code of McLinden
c                from the THFLSH routine to make one unified routine
c  12-16-02 EWL, calculate p using q for a pure or pseudo-pure fluid
c  03-23-05 EWL, add check for Dpmax>Dmax
c  03-15-12 EWL, change rho0 from 10^-10 to 10^-4 so that the inital entropy will not be so high (causing root failure)
c
cx DEC$ ATTRIBUTES DLLEXPORT :: TBFLSH
c
      include 'commons.for'
      character*1 bt
      character*2 ab
      character*255 herr,herr1
      dimension x(ncmax),y(ncmax),z(ncmax),xdew(ncmax),xbub(ncmax),
     &          ydew(ncmax),ybub(ncmax)
c
      bt=ab(2:2)
      ierr=0
      herr=' '
      p=0.d0
      D=0.d0
      Dl=0.d0
      Dv=0.d0
      e=0.d0
      h=0.d0
      s=0.d0
      cv=0.d0
      cp=0.d0
      w=0.d0
      q=998
      call ISPURE (z,icomp)
      if (icomp.eq.0) then
        do i=1,nc
          x(i)=z(i)
          y(i)=z(i)
        enddo
      else
        do i=1,nc
          x(i)=0.d0
          y(i)=0.d0
        enddo
        x(icomp)=1.d0
        y(icomp)=1.d0
      endif
c
c  set output liquid and vapor compositions to input values
c  zero output values for undefined components
c     if (nc.lt.ncmax) then
c       do i=nc+1,ncmax
c         x(i)=0.0d0
c         y(i)=0.0d0
c       enddo
c     end if
c
      call CRITP (z,tc,pc,Dc,ierr,herr1)
      if (ierr.gt.0) then
        ierr=230
        write (herr,1002) ab,herr1(1:234),hnull
 1002   format ('[',a2,'FLSH error 230] ',a234,a1)
        call ERRMSG (ierr,herr)
        q=999.d0     !quality undefined
        RETURN
      end if
c
c  check that input conditions are within limits, get max D,p
c
      pdum=0.0d0
      Ddum=0.0d0
      call LIMITX ('EOS',t,Ddum,pdum,z,tmin,tmax,Dmax,pmax,ierr,herr1)
c  maximum value may be in several locations
      rho0=1.0d-4
      if (bt.eq.'H') then
        call ENTHAL (t,rho0,z,bmax)
        call ENTHAL (t,Dmax,z,bmax1)
      elseif (bt.eq.'E') then
        call ENERGY (t,rho0,z,bmax)
        call ENERGY (t,Dmax,z,bmax1)
      elseif (bt.eq.'S') then
        call ENTRO (t,rho0,z,bmax)
        call ENTRO (t,Dmax,z,bmax1)
      endif
      if (bmax1.gt.bmax) bmax=bmax1
      if (ierr.lt.0) then
c  one or inputs are outside limits--if just a warning proceed w/ calc
        write (herr,1006) ab,ierr,herr1(1:233),hnull
 1006   format ('[',a2,'FLSH warning',i4,'] ',a233,a1)
        call ERRMSG (ierr,herr)
      else
c  if inputs are outside limits set outputs and return (x = y = z)
        if (ierr.ge.1) then
          write (herr,1007) ab,ierr,herr1(1:235),hnull
 1007     format ('[',a2,'FLSH error',i4,'] ',a235,a1)
        else if (b.gt.bmax) then
          ierr=239
          write (herr,1008) ab,ierr,bt,b,bt,bmax,hnull
 1008     format ('[',a2,'FLSH error',i4,'] Input value is ',
     &            'outside limits; ',a1,' =',g12.5,', ',a1,'max =',
     &            g12.5,a1)
        end if
        if (ierr.ge.1) then
          call ERRMSG (ierr,herr)
          D=rho0
          Dl=rho0
          Dv=rho0
          p=R*t*rho0
          q=xerr
          e=xerr
          h=xerr
          s=xerr
          cv=xerr
          cp=xerr
          w=xerr
          RETURN
        end if
      end if
c
      kguess=0    !no initial guess provided
      if (t.ge.tc) then
c
c  super-critical state (must be single-phase)
c
c  find density and second input at t, p = pmax
        kph=1       !find liquid solution
        call TPRHO (t,pmax,z,kph,kguess,Dpmax,ierr,herr)
c  bpmax is b at pmax; it is close to minimum density
        if (bt.eq.'H') call ENTHAL (t,Dpmax,z,bpmax)
        if (bt.eq.'E') call ENERGY (t,Dpmax,z,bpmax)
        if (bt.eq.'S') call ENTRO (t,Dpmax,z,bpmax)
c       write (*,*) ' TBFLSH--b at rhomax:  ',bpmax,Dpmax
        if (b.lt.bpmax) then
c  two roots exist--find actual minimum b to bound solution
c  use general golden-section search routine (in utility.f file)
          neval=29   !reduce interval to 10**-6 of original
          call GOLD (rho0,Dpmax,neval,.false.,z,t,z3,z4,bt,
     &               Dbmin,bmin,ijunk)
c         write (*,*) ' TBFLSH--bmin at rho: ',bmin,Dbmin
c  check that input h is within bounds; if out of bounds, set outputs
c  and return
          if (b.lt.bmin) then
            ierr=239
            write (herr,1010) ab,ierr,bt,b,bt,bmin,hnull
 1010       format ('[',a2,'FLSH error',i4,'] Input value is ',
     &              'outside limits; ',a1,' =',g12.5,', ',a1,'min =',
     &              g12.5,a1)
            call ERRMSG (ierr,herr)
            D=rho0
            Dl=rho0
            Dv=rho0
            p=R*t*rho0
            q=xerr
            e=xerr
            h=xerr
            s=xerr
            cv=xerr
            cp=xerr
            w=xerr
            RETURN
          end if
c  issue warning that two roots exist
          ierr=-238
          if (kr.eq.2) then
c  set bounds to find higher-density root
            write (herr,1238) ab,hnull
 1238       format ('[',a2,'FLSH warning 238] two solutions exist for ',
     &           'the input values; the higher density root has been ',
     &           'calculated',a1)
            Dmin=Dbmin
            Dmax=Dpmax
          else
c  find lower-density root
            write (herr,1239) ab,hnull
 1239       format ('[',a2,'FLSH warning 238] two solutions exist for ',
     &           'the input values; the lower density root has been ',
     &           'calculated',a1)
            Dmin=rho0
            Dmax=Dbmin
          end if
        else
c  only a single root exists
          Dmin=rho0
          Dmax=Dpmax
        end if
        call ABFL1 (t,b,z,0,ab,Dmin,Dmax,tt,pp,D,ierr,herr)
c  set remaining outputs (x = y = z as initialized above)
        Dl=D
        Dv=D
        call THERM (t,D,z,p,e,h,s,cv,cp,w,hjt)
        q=998.d0                  !superheated
        if (p.gt.pc) q=999.d0     !quality undefined
c
      else
c
c  sub-critical state (possibility of solution in two-phase state)
c
c  first check if input h > h at dew point
        kph=2
        call SATT (t,z,kph,pdew,Dldew,Dvdew,xdew,ydew,ierr1,herr1)
        if (bt.eq.'H') call ENTHAL (t,Dvdew,z,bdew)
        if (bt.eq.'E') call ENERGY (t,Dvdew,z,bdew)
        if (bt.eq.'S') call ENTRO (t,Dvdew,z,bdew)
        if (b.ge.bdew) then
c  solution is single-phase vapor
          Dmin=rho0
          Dmax=Dvdew
          call ABFL1 (t,b,z,0,ab,Dmin,Dmax,tt,pp,D,ierr1,herr1)
          if (ierr1.ne.0) then
            ierr=ierr1
            herr=herr1
          end if
c  set remaining outputs (x = y = z as initialized above)
          Dl=D
          Dv=D
          q=998.0d0
          call THERM (t,D,z,p,e,h,s,cv,cp,w,hjt)
c
        else
c  solution is either compressed liquid or two-phase
          call TPRHO (t,pmax,z,kph,kguess,Dpmax,ierr,herr)
          if (ierr.eq.202 .and. Dpmax.gt.Dmax) Dpmax=Dmax
c  bpmax is b at pmax; it is close to minimum density
          if (bt.eq.'H') call ENTHAL (t,Dpmax,z,bpmax)
          if (bt.eq.'E') call ENERGY (t,Dpmax,z,bpmax)
          if (bt.eq.'S') call ENTRO (t,Dpmax,z,bpmax)
c         write (*,*) ' TBFLSH--b at rhomax:  ',bpmax,Dpmax
c  check for possible minimum in h in compressed liquid region
          if (icomp.ne.0 .and. ianc(icomp).eq.0) then
c  for pure component Dlbub = Dldew
            Dlbub=Dldew
            pbub=pdew
          else
c  find bubble point density, etc.
            kph=1
            call SATT (t,z,kph,pbub,Dlbub,Dvbub,xbub,ybub,ierr,herr)
          end if
          if (bt.eq.'H') call ENTHAL (t,Dlbub,z,bbub)
          if (bt.eq.'E') call ENERGY (t,Dlbub,z,bbub)
          if (bt.eq.'S') call ENTRO (t,Dlbub,z,bbub)
c         write (*,*) ' TBFLSH--bbub,bdew:  ',bbub,bdew
c  check slope of b vs. rho
          Dlbub1=Dlbub+1.0d-6
          if (bt.eq.'H') call ENTHAL (t,Dlbub1,z,bbub1)
          if (bt.eq.'E') call ENERGY (t,Dlbub1,z,bbub1)
          if (bt.eq.'S') call ENTRO (t,Dlbub1,z,bbub1)
          if (bbub1.lt.bbub) then
c  minimum exists in compressed liquid region, otherwise bmin is at bbub
c  use general golden-section search routine (in utility.f file)
c           write (*,*) ' TBFLSH--minimum in compressed liquid'
            neval=29   !reduce interval to 10**-6 of original
            call GOLD (Dlbub,Dpmax,neval,.false.,z,t,z3,z4,bt,
     &                 Dbmin,bmin,ijunk)
c           write (*,*) ' TBFLSH--bmin at rho: ',bmin,Dbmin
          else
            bmin=bbub
            Dbmin=Dlbub
          end if
c  check that input b is within bounds; if out of bounds, set outputs
c  and return
          if (b.lt.bmin) then
            ierr=239
            write (herr,1010) ab,ierr,bt,b,bt,bmin,hnull
            call ERRMSG (ierr,herr)
            D=rho0
            Dl=rho0
            Dv=rho0
            p=R*t*rho0
            q=xerr
            e=xerr
            s=xerr
            cv=xerr
            cp=xerr
            w=xerr
            RETURN
          else if (b.lt.bpmax) then
c  issue warning that two roots exist
            ierr=-238
            if (kr.eq.2) then
              write (herr,1238) ab,hnull
            else
              write (herr,1239) ab,hnull
            end if
          end if
c  determine if desired solution is liquid or two-phase
          if (b.lt.bbub .or. kr.eq.2) then
c  find liquid-phase solution
            if (kr.eq.2) then
              Dmin=Dbmin
              Dmax=Dpmax
            else
              Dmin=Dlbub
              Dmax=Dbmin
            end if
            call ABFL1 (t,b,z,0,ab,Dmin,Dmax,tt,pp,D,ierr1,herr1)
            if (ierr1.ne.0) then
              ierr=ierr1
              herr=herr1
            end if
c  set remaining outputs (x = y = z as initialized above)
            Dl=D
            Dv=D
            q=-998.0d0
            call THERM (t,D,z,p,e,h,s,cv,cp,w,hjt)
          else
c  find two-phase solution
c           write (*,*) ' TBFLSH--solution is 2-phase'
            if (icomp.ne.0) then
c  special case:  pure-fluid two-phase (x = y = z as set above)
              q=(b-bbub)/(bdew-bbub)
              Dl=Dlbub
              Dv=Dvdew
            else
c  general case:  mixture 2-phase
              q=0.5
              Dl=Dlbub
              Dv=Dvdew
              ksat=0
              call ABFL2 (t,b,z,1,ksat,ab,
     &                    tbub,tdew,pbub,pdew,Dlbub,Dvdew,ybub,xdew,
     &                    tt,p,Dl,Dv,x,y,q,ierr,herr)
              if (ierr1.ne.0) then
c  two-phase iteration did not converge--error message written by TBFL2
                ierr=ierr1
                herr=herr1
                call ERRMSG (ierr,herr)
                q=999.d0     !quality undefined
                RETURN
              end if
c             write (*,1225) t,q,(x(i),i=1,3),(y(i),i=1,3)
c1225         format (1x,' TBFLSH--TBFL2 return   t,q,x,y = ',8f12.7)
            end if
c  compute remaining properties for 2-phase states
            call THERM (t,Dl,x,p,el,hl,sl,cvl,cp,w,hjt)
            call THERM (t,Dv,y,ptherm,ev,hv,sv,cvv,cp,w,hjt)
            alpha=1.0d0-q
            D=1.0d0/(alpha/Dl+q/Dv)
            if (ianc(icomp).eq.1) p=alpha*pbub+q*pdew
            e=alpha*el+q*ev
            h=alpha*hl+q*hv
            s=alpha*sl+q*sv
            w=xnotd       !Cp,w not defined for 2-phase states
            cp=xnotd
            cv=xnotd
          end if
        end if
      end if
c
      RETURN
      end                                             !subroutine TBFLSH
c
c ======================================================================
c
      subroutine DBFLSH (D,b,z,ab,t,p,Dl,Dv,x,y,q,e,h,s,cv,cp,w,
     &                   ierr,herr)
c
c  flash calculation given density, bulk composition, and either
c  enthalpy, entropy, or energy
c
c  inputs:
c        D--overall (bulk) molar density [mol/L]
c        b--second property (energy, enthalpy, or entropy)
c        z--overall (bulk) composition [array of mol frac]
c       ab--character*2 string defining the inputs: 'DH', 'DS', or 'DE'
c
c  outputs:
c        t--temperature [K]
c        p--pressure [kPa]
c       Dl--molar density [mol/L] of the liquid phase
c       Dv--molar density [mol/L] of the vapor phase
c           if only one phase is present, Dl = Dv = D
c        x--composition of liquid phase [array of mol frac]
c        y--composition of vapor phase [array of mol frac]
c           if only one phase is present, x = y = z
c        q--vapor quality on a MOLAR basis [moles vapor/total moles]
c           q < 0 indicates subcooled (compressed) liquid
c           q = 0 indicates saturated liquid
c           q = 1 indicates saturated vapor
c           q > 1 indicates superheated vapor
c           q = 998 superheated vapor, but quality not defined (in most situations, t > Tc)
c           q = 999 indicates supercritical state (t > Tc) and (p > Pc)
c        e--overall (bulk) internal energy [J/mol]
c        h--overall (bulk) enthalpy [J/mol]
c        s--overall (bulk) entropy [J/mol-K]
c       Cv--isochoric (constant V) heat capacity [J/mol-K]
c       Cp--isobaric (constant p) heat capacity [J/mol-K]
c        w--speed of sound [m/s]
c           Cp, w are not defined for 2-phase states
c           in such cases, a flag = -9.99998d6 is returned
c     ierr--error flag:  0 = successful
c                      210 = CRITP did not converge
c                      248 = iteration did not converge
c                      249 = b out of range
c     herr--error string (character*255 variable if ierr<>0)
c
c  written by E.W. Lemmon, NIST Thermophysics Division, Boulder, Colorado
c  05-13-99 EWL, original version
c  01-19-01 EWL, converted from DHFLSH to DBFLSH and made it generic
c  08-14-02 EWL, if DBLF2 returns q<=0 or q>=1, then return an error
c  12-16-02 EWL, calculate p using q for a pure or pseudo-pure fluid
c  01-14-05 EWL, add special case for helium
c  11-21-12 EWL, specify better values of q after call to ABFL1
c
cx DEC$ ATTRIBUTES DLLEXPORT :: DBFLSH
c
      include 'commons.for'
      character*1 bt
      character*2 ab
      character*255 herr,herr2,herrl
      dimension z(ncmax),x(ncmax),y(ncmax)
c
      bt=ab(2:2)
      ierr=0
      herr=' '
      t=0.d0
      p=0.d0
      Dl=0.d0
      Dv=0.d0
      e=0.d0
      h=0.d0
      s=0.d0
      cv=0.d0
      cp=0.d0
      w=0.d0
      q=999.d0     !quality undefined
c
c  initialize output liquid and vapor compositions to input values
c  zero output values for undefined components
      call ISPURE (z,icomp)
      if (icomp.eq.0) then
        do i=1,nc
          x(i)=z(i)
          y(i)=z(i)
        enddo
      else
        do i=1,nc
          x(i)=0.d0
          y(i)=0.d0
        enddo
        x(icomp)=1.d0
        y(icomp)=1.d0
      endif
c
c  check that input conditions are within limits
c
      call CRITP (z,tc,pc,rhoc,ierr,herr2)
      if (ierr.gt.0) then
        ierr=210
        write (herr,1008) ab,herr2(1:235),hnull
 1008   format ('[',a2,'FLSH error 210] ',a235,a1)
        call ERRMSG (ierr,herr)
        RETURN
      end if
c
      t=tc
      call LIMITX ('EOS',t,D,p,z,tmin,tmax,rhomax,pmax,ierrl,herrl)
      if (ierrl.lt.0) then
c  one or inputs are outside limits--if just a warning proceed w/ calc
        write (herr,1006) ab,ierrl,herrl(1:234),hnull
 1006   format ('[',a2,'FLSH warning',i3,'] ',a234,a1)
        call ERRMSG (ierrl,herr)
c  if error (as opposed to warning) set output density to zero and return
      else if (ierrl.gt.0) then
        write (herr,1007) ab,ierrl,herrl(1:236),hnull
 1007   format ('[',a2,'FLSH error',i3,'] ',a236,a1)
        call ERRMSG (ierrl,herr)
        ierr=ierrl
        RETURN
      end if
c
      call SATD (d,z,0,kr,t,p,rhol,rhov,x,y,ierr,herr)
      if (tc.lt.6) then   !special case for helium
        if (tc.gt.5 .and. icomp.ne.0 .and. d.gt.36.5d0) then
          call ABFL1 (d,b,z,0,ab,0.d0,0.d0,t,p,dd,ierr,herr2)
          bsat=b-.000001d0
          goto 110
        endif
      endif
      if (bt.eq.'H') call ENTHAL (t,d,z,bsat)
      if (bt.eq.'E') call ENERGY (t,d,z,bsat)
      if (bt.eq.'S') call ENTRO (t,d,z,bsat)
      if (b.ge.bsat) then
        call ABFL1 (d,b,z,0,ab,0.d0,0.d0,t,p,dd,ierr,herr2)
      else
        call DBFL2 (d,b,z,0,ab,t,p,Dl,Dv,x,y,q,ierr,herr)
        if (q.ge.1.d0 .or. q.le.0.d0) ierr=248
      endif
 110  continue
      if (ierr.ne.0) then
        ierr=215
        write (herr,1215) ab,herr2(1:183),hnull
 1215   format ('[',a2,'FLSH error 248] iteration ',
     &          'did not converge:  ',a183,a1)
        call ERRMSG (ierr,herr)
        RETURN
      end if
      if (b.gt.bsat) then
        call THERM (t,d,z,p,e,h,s,cv,cp,w,hjt)
        if (p.gt.pc .and. t.gt.tc) then
          q=999.d0     !quality undefined
        elseif (p.gt.pc) then
          q=-998.d0    !subcooled
        elseif (t.gt.tc) then
          q=998.d0     !superheated
        elseif (d.gt.rhoc) then
          q=-998.d0    !subcooled
        elseif (d.lt.rhoc) then
          q=998.d0     !superheated
        end if
      else
c  compute remaining properties for 2-phase states
        call THERM (t,Dl,x,pl,el,hl,sl,cvl,cp,w,hjt)
        call THERM (t,Dv,y,pv,ev,hv,sv,cvv,cp,w,hjt)
        alpha=1.0d0-q
        D=1.0d0/(alpha/Dl+q/Dv)
        p=alpha*pl+q*pv
        e=alpha*el+q*ev
        h=alpha*hl+q*hv
        s=alpha*sl+q*sv
        w=xnotd       !Cp,w not defined for 2-phase states
        cp=xnotd
        cv=xnotd
      endif
c
c  if limits check resulted in warning (as opposed to error) return
c  that message; do this again in case intermediate iteration did not
c  converge (thereby overwriting any warning message from LIMITX)
c
      call LIMITX ('EOS',t,D,p,z,tmin,tmax,rhomax,pmax,ierrl,herrl)
      if (ierrl.lt.0) then
c  one or inputs are outside limits--if just a warning proceed w/ calc
        ierr=ierrl
        write (herr,2006) ab,ierrl,herrl(1:234),hnull
 2006   format ('[',a2,'FLSH warning',i3,'] ',a234,a1)
        call ERRMSG (ierr,herr)
c  if error (as opposed to warning) set output density to zero and return
      else if (ierrl.gt.0) then
        write (herr,1007) ab,ierrl,herrl(1:236),hnull
        ierr=ierrl
        call ERRMSG (ierrl,herr)
        RETURN
      end if
c
      RETURN
      end                                             !subroutine DBFLSH
c
c ======================================================================
c
      subroutine ABFL1 (a,b,x,kph,ab,dmin,dmax,t,p,D,ierr,herr)
c
c  General single phase flash calculation given two inputs and composition.
c  Valid properties for the first input are temperature, pressure, and
c  density.  Valid properties for the second input are density, energy,
c  enthalpy, or entropy.  The character string ab specifies the inputs.
c  Note that the inputs TP and TD are not allowed here, but are done by
c  calling TPFLSH or TDFLSH and their associated routines.
c
c  This routine accepts only single-phase inputs, it is intended primarily
c  for use with the more general flash routine ABFLSH.
c
c  inputs:
c        a--first property (either temperature, pressure, or density)
c        b--second property (density, energy, enthalpy, or entropy)
c        x--composition [array of mol frac]
c      kph--phase flag:  1 = liquid
c                        2 = vapor
c       ab--character*2 string defining the inputs, e.g., 'TH' or 'PS'
c     Dmin--lower bound on density [mol/L]          (for t inputs)
c     Dmax--upper bound on density [mol/L]          (for t inputs)
c        t--initial guess for temperature [K]       (for P inputs)
c        D--initial guess for molar density [mol/L] (for P inputs)
c
c  outputs:
c        t--temperature [K]
c        p--pressure [kPa]
c        D--molar density [mol/L]
c     ierr--error flag:  0 = successful
c                      247 = TPRHO did not converge
c                      248 = single-phase iteration did not converge
c     herr--error string (character*255 variable if ierr<>0)
c
c  rewritten by E.W. Lemmon, NIST Physical & Chemical Properties Div, Boulder, CO
c  01-18-01 EWL, original version, rewritten by combining code of McLinden
c                from several different versions of FL1 routines to make
c                one unified routine
c  07-17-06 EWL, change fzneg and fzpos to 1.d20, and only update these
c                if the new guess is closer than the current bounds
c  07-17-06 EWL, if TPRHO fails, call it up to twice more with increased T
c  07-17-06 EWL, after 100 iterations, do not go outside of zneg and zpos;
c                helps in convergence very close to the critical point
c  02-16-10 EWL, increase tolerance at it=180
c  02-11-11 EWL, after 10 failures, change z(j) by 1.1 instead of 1.01
c  09-15-11  MK, add additional code for Reguli-falsi
c  05-08-12 EWL, get liquid and vapor entropy after call to SATT and use it for region check.
c
cx DEC$ ATTRIBUTES DLLEXPORT :: ABFL1
c
      include 'commons.for'
      character*1 at,bt
      character*2 ab
      character*255 herr,herr1
      logical lpos,lneg
      dimension x(ncmax),xliq(ncmax),xvap(ncmax)
      dimension z(3),fz(2)      !z is current guess for temperature
c
      itmax=200   !large value needed to find low density roots
      at=ab(1:1)
      bt=ab(2:2)
      call CRITP (x,tc,pc,rhoc,ierr1,herr1)
c
      ierr=0
      herr=' '
      p=0
      ib=0
      if (at.eq.'T') t=a
      if (at.eq.'S') s=a
      if (at.eq.'P') p=a
      if (at.eq.'D') then
        call DBFL1 (a,b,x,ab,t,p,ierr,herr)
        D=a
        RETURN
      elseif (ab.eq.'PD') then
        call DBFL1 (b,a,x,'DP',t,p,ierr,herr)
        D=b
        RETURN
      endif
      tol=1.0d-8
      ispflag=0
      lRegFalsi=.false.
c
      j=1
      lpos=.false.              !initialize flags for reguli-false
      lneg=.false.
      zneg=0.0d0
      zpos=0.0d0
      fzneg=1.0d20
      fzpos=1.0d20
      delz=0.d0
c
      if (at.eq.'P' .or. at.eq.'S') then
        if (t.le.0d0) t=tc
        z(1)=t
      elseif (at.eq.'T') then
c  first & second guesses for density are the bounds
        z(1)=Dmin
        z(2)=Dmax
      endif
      do 200 it=1,itmax
      if (at.eq.'T') then
        D=z(j)
      elseif (at.eq.'P' .or. at.eq.'S') then
        t=z(j)
        t=max(t,1.d-12)
c  Do not call TPRHO giving it an initial guess (which comes from the previous
c  iteration).  This guess can often lead it into the two-phase and return
c  a bogus value.
        if (at.eq.'P') then
          call TPRHO (t,p,x,kph,0,D,ierr,herr1)  !find density
        elseif (at.eq.'S') then
          dmin1=dmin
          dmax1=dmax
          if (t.lt.tc) then
            call ENTRO (tc,rhoc,x,sc)
            i=1
            if (s.gt.sc) i=2
            call SATT (t,x,i,pp,Dl,Dv,xliq,xvap,ierr,herr1)
c 05-08-12  EWL  Add following two lines and change check for s<sc and s>sc to s<scl and s>scv
            call ENTRO (t,dl,x,scl)
            call ENTRO (t,dv,x,scv)
            if (s.lt.scl) dmin1=dl
            if (s.gt.scv) dmax1=dv
          endif
          call ABFL1x (t,s,x,kph,'TS',dmin1,dmax1,tt,pp,D,ierr,herr1)
c     write (*,'(20f10.5)') t,d,dmin1,dmax1,s,sc,ierr
          if (ierr.ne.0) then
            ib=ib+1
            z(j)=z(j)*1.01d0
            if (ib.gt.10) z(j)=z(j)*1.1d0
            goto 200
          endif
        endif
c  if TPRHO fails on first routine, try new initial guess
        if (ierr.ne.0 .and. it.eq.1 .and. at.eq.'P') then
          z(1)=300.0d0
          t=z(j)
          call TPRHO (t,p,x,kph,0,D,ierr,herr1)
        elseif (ierr.ne.0 .and. at.eq.'P') then
c  if TPRHO fails, try midpoint
          z(j)=(z(1)+z(2))/2.d0
          t=z(j)
          call TPRHO (t,p,x,kph,0,D,ierr,herr1)
          if (ierr.eq.203) then
            z(j)=t*1.001d0
            t=z(j)
            call TPRHO (t,p,x,kph,0,D,ierr,herr1)
            if (ierr.eq.203) then
              z(j)=t*1.001d0
              t=z(j)
              call TPRHO (t,p,x,kph,0,D,ierr,herr1)
c  if still failing, call SATP
              if (ierr.eq.203) then
                call SATP (p,x,kph,t,D,Dv,xliq,xvap,ierr,herr1)
                if (kph.eq.2 .or. kph.eq.-2) d=dv
              endif
            endif
          endif
        endif
        if (it.eq.80 .and. p.le.pc .and. at.eq.'P') then
          call SATP (p,x,kph,t,D,Dv,xliq,xvap,ierr,herr1)
          if (kph.eq.2 .or. kph.eq.-2) d=dv
          z(j)=t
          ispflag=1
        endif
        if (ierr.ne.0) then
          ierr=247
          write (herr,1247) ab,herr1(1:172),hnull
 1247     format ('[',a2,'FLSH error 247] density iteration for ',
     &            'single-phase state did not converge:  ',a172,a1)
          call ERRMSG (ierr,herr)
          RETURN
        end if
      endif
      if (bt.eq.'E') call ENERGY (t,D,x,bj) !find energy for current t
      if (bt.eq.'H') call ENTHAL (t,D,x,bj) !find enthalpy for current t
      if (bt.eq.'S') call ENTRO (t,D,x,bj)  !find entropy for current t
      fz(j)=b-bj
      if (ispflag.eq.1) then
        if (fz(j).lt.0.) fzneg=1.d20
        if (fz(j).gt.0.) fzpos=1.d20
        ispflag=0
      endif
c     write (*,1020) it,j,z(j),D,p,b,bj,fz(j)
c1020 format (1x,'ABFL1: it,j,t,D,p,b,bj,ft: ',2i4,f10.5,f12.7,4f15.6)
      b1=1.d0
      if (ABS(b).gt.1.d0) b1=b
      if (ABS(fz(j)/b1).lt.tol) then
        call PRESS (t,D,x,p)
        ierr=0
        herr=' '
        RETURN
      elseif (lRegFalsi) then
        if (fz(j).gt.0.d0) then
          zpos=z(j)
          fzpos=fz(j)
          z(1) =zneg
          fz(1)=fzneg
        else
          zneg=z(j)
          fzneg=fz(j)
          z(1) =zpos
          fz(1)=fzpos
        endif
c     elseif (fz(j).lt.0.0d0) then
      elseif (fz(j).lt.0.0d0 .and. abs(fz(j)).lt.abs(fzneg)) then
c  store "negative" guess for use in possible reguli-falsi iteration
        lneg=.true.
        zneg=z(j)
        fzneg=fz(j)
c     else
      elseif (fz(j).ge.0.0d0 .and. abs(fz(j)).lt.abs(fzpos)) then
c  store "positive" guess for use in possible reguli-falsi iteration
        lpos=.true.
        zpos=z(j)
        fzpos=fz(j)
      end if
      if (j.eq.1) then
c  define second guess for temperature
        if (at.eq.'P' .or. at.eq.'S') then
          call THERM (z(1),D,x,ptherm,e1,h1,s1,cv,cp,w,hjt)
          if (bt.eq.'H') delz=fz(1)/cp
          if (bt.eq.'E') delz=fz(1)/cv
          if (bt.eq.'S') delz=fz(1)/cv
          if (ABS(delz).lt.0.0005d0*z(1)) delz=sign(0.0005d0*z(1),delz)
          z(2)=z(1)+delz
        endif
        j=2
      else
c  general case--define next guess for temperature by secant method
        if (ABS(fz(2)-fz(1)).gt.1.0d-12) then  !check for divide by zero
          z(3)=z(2)-fz(2)*(z(2)-z(1))/(fz(2)-fz(1))
        else
          z(3)=z(2)+0.5d0*(z(2)-z(1))
        end if
        zz=1.01d0
        if (it.gt.100) zz=1
        if (it.eq.150) tol=tol*100
        if (it.eq.180) tol=tol*10
        if (lneg .and. lpos .and.
     &     (z(3).gt.max(zpos,zneg)*zz .or.
     &      z(3).lt.min(zpos,zneg)/zz)) then
c  secant method has yielded guess further from solution, use reguli-falsi
          z(3)=zpos-fzpos*(zpos-zneg)/(fzpos-fzneg)
          lRegFalsi=.true.
c         write (*,*) '      next temperature by reguli-falsi: ',z(3)
        end if
        if (at.eq.'T' .and.
     &     (d.lt.dmin*.98d0 .or. d.gt.dmax*1.02d0)) then
          if (ABS(z(3)).gt.1.d5) goto 210
          if (d.lt.dmin .and. z(1).lt.z(2)) then
            z(3)=(dmin+z(2))/2.d0
          elseif (d.lt.dmin .and. z(2).lt.z(1)) then
            z(3)=(dmin+z(1))/2.d0
          elseif (d.gt.dmax .and. z(1).gt.z(2)) then
            z(3)=(dmax+z(2))/2.d0
          elseif (d.gt.dmax .and. z(2).gt.z(1)) then
            z(3)=(dmax+z(1))/2.d0
          endif
        endif
        if (.not. lRegFalsi) then
          z(1)=z(2)
          z(2)=z(3)
          fz(1)=fz(2)
        else
          z(2)=z(3)
        endif
      end if
      if (at.ne.'T') then
        if (ABS(z(2)-z(1)).gt.0.25*z(1)) then
c  do not permit too large a step
          z(2)=z(1)+z(1)*sign(0.25d0,z(2)-z(1))
        end if
      endif
 200  continue
c
c  iteration has not converged
c
 210  continue
      ierr=248
      if (at.eq.'S') write (herr,1248) ab,z(j),fz(j),hnull
      if (at.eq.'P') write (herr,1248) ab,z(j),fz(j),hnull
      if (at.eq.'T') write (herr,1249) ab,z(j),fz(j),hnull
 1248 format ('[',a2,'FLSH error 248] single-phase iteration did not ',
     &        'converge, T, deltaT =',2(g12.5),' K.',a1)
 1249 format ('[',a2,'FLSH error 248] single-phase iteration did not ',
     &        'converge, D, deltaD =',2(g12.5),' mol/L.',a1)
      call ERRMSG (ierr,herr)
c
      RETURN
      end                                              !subroutine ABFL1
c
c ======================================================================
c
      subroutine ABFL1x (a,b,x,kph,ab,dmin,dmax,t,p,D,ierr,herr)
c
c  This is a duplicate of ABFL1, called while calculating H,S inputs.
c  Without it, ABFL1 would have to call itself once, recursively, which
c  is not allowed by some compilers.
c
c  07-07-10 EWL, add check for z(1)=z(3) in reguli-falsi method
c  02-11-11 EWL, check for stuck at high densities with root at low densities
c
      include 'commons.for'
      character*1 at,bt
      character*2 ab
      character*255 herr,herr1
      logical lpos,lneg
      dimension x(ncmax),xliq(ncmax),xvap(ncmax)
      dimension z(3),fz(2)      !z is current guess for temperature
c
      itmax=200   !large value needed to find low density roots
      at=ab(1:1)
      bt=ab(2:2)
      call CRITP (x,tc,pc,rhoc,ierr1,herr1)
c
      ierr=0
      herr=' '
      p=0
      if (at.eq.'T') t=a
      if (at.eq.'S') s=a
      if (at.eq.'P') p=a
      if (at.eq.'D') then
        call DBFL1 (a,b,x,ab,t,p,ierr,herr)
        D=a
        RETURN
      elseif (ab.eq.'PD') then
        call DBFL1 (b,a,x,'DP',t,p,ierr,herr)
        D=b
        RETURN
      endif
      tol=1.0d-8
      lRegFalsi=.false.
c
      j=1
      lpos=.false.              !initialize flags for reguli-false
      lneg=.false.
      zneg=0.0d0
      zpos=0.0d0
      fzneg=1.0d20
      fzpos=1.0d20
      delz=0.d0
c
      if (at.eq.'P' .or. at.eq.'S') then
        if (t.le.0d0) t=tc
        z(1)=t
      elseif (at.eq.'T') then
c  first & second guesses for density are the bounds
        z(1)=Dmin
        z(2)=Dmax
      endif
      call ENTRO (tc,rhoc,x,sc)
      do 200 it=1,itmax
      if (at.eq.'T') then
        D=z(j)
c check for case where it is stuck at high densities, but root is at low densities
        if (it.gt.5 .and. bt.eq.'S') then
          if (bj.lt.sc .and. abs(z(1)-z(2)).lt.1.d-10) then
            if (fz(1).gt.1.d0) z(j)=z(j)/10.d0
            D=z(j)
          endif
        endif
      elseif (at.eq.'P' .or. at.eq.'S') then
        t=z(j)
        t=max(t,1.d-12)
c  Do not call TPRHO giving it an initial guess (which comes from the previous
c  iteration).  This guess can often lead it into the two-phase and return
c  a bogus value.
        if (at.eq.'P') then
          call TPRHO (t,p,x,kph,0,D,ierr,herr1)  !find density
        elseif (at.eq.'S') then
          dmin1=dmin
          dmax1=dmax
          if (t.lt.tc) then
            i=1
            if (s.gt.sc) i=2
            call SATT (t,x,i,pp,Dl,Dv,xliq,xvap,ierr,herr1)
            if (s.lt.sc) dmin1=dl
            if (s.gt.sc) dmax1=dv
          endif
          call TSFL1 (t,s,x,dmin1,dmax1,D,ierr,herr1)
c     write (*,'(20f10.5)') t,d,dmin1,dmax1,s,sc,ierr
          if (ierr.ne.0) then
            z(j)=z(j)*1.01d0
            goto 200
          endif
        endif
c  if TPRHO fails on first routine, try new initial guess
        if (ierr.ne.0 .and. it.eq.1 .and. at.eq.'P') then
          z(1)=300.0d0
          t=z(j)
          call TPRHO (t,p,x,kph,0,D,ierr,herr1)
        elseif (ierr.ne.0 .and. at.eq.'P') then
c  if TPRHO fails, try midpoint
          z(j)=(z(1)+z(2))/2.d0
          t=z(j)
          call TPRHO (t,p,x,kph,0,D,ierr,herr1)
          if (ierr.eq.203) then
            z(j)=t*1.001d0
            t=z(j)
            call TPRHO (t,p,x,kph,0,D,ierr,herr1)
            if (ierr.eq.203) then
              z(j)=t*1.001d0
              t=z(j)
              call TPRHO (t,p,x,kph,0,D,ierr,herr1)
            endif
          endif
        endif
        if (ierr.ne.0) then
          ierr=247
          write (herr,1247) ab,herr1(1:172),hnull
 1247     format ('[',a2,'FLSH error 247] density iteration for ',
     &            'single-phase state did not converge:  ',a172,a1)
          call ERRMSG (ierr,herr)
          RETURN
        end if
      endif
      if (bt.eq.'E') call ENERGY (t,D,x,bj) !find energy for current t
      if (bt.eq.'H') call ENTHAL (t,D,x,bj) !find enthalpy for current t
      if (bt.eq.'S') call ENTRO (t,D,x,bj)  !find entropy for current t
      fz(j)=b-bj
c     write (*,1020) it,j,z(j),D,p,b,bj,fz(j)
c1020 format (1x,'ABFL1: it,j,t,D,p,b,bj,ft: ',2i4,f10.5,f12.7,4f15.6)
      b1=1.d0
      if (ABS(b).gt.1.d0) b1=b
      if (ABS(fz(j)/b1).lt.tol) then
        call PRESS (t,D,x,p)
        ierr=0
        herr=' '
        RETURN
      elseif (lRegFalsi) then
        if (fz(j).gt.0.d0) then
          zpos=z(j)
          fzpos=fz(j)
          z(1) =zneg
          fz(1)=fzneg
        else
          zneg=z(j)
          fzneg=fz(j)
          z(1) =zpos
          fz(1)=fzpos
        endif
c     elseif (fz(j).lt.0.0d0) then
      elseif (fz(j).lt.0.0d0 .and. abs(fz(j)).lt.abs(fzneg)) then
c  store "negative" guess for use in possible reguli-falsi iteration
        lneg=.true.
        zneg=z(j)
        fzneg=fz(j)
c     else
      elseif (fz(j).ge.0.0d0 .and. abs(fz(j)).lt.abs(fzpos)) then
c  store "positive" guess for use in possible reguli-falsi iteration
        lpos=.true.
        zpos=z(j)
        fzpos=fz(j)
      end if
      if (j.eq.1) then
c  define second guess for temperature
        if (at.eq.'P' .or. at.eq.'S') then
          call THERM (z(1),D,x,ptherm,e1,h1,s1,cv,cp,w,hjt)
          if (bt.eq.'H') delz=fz(1)/cp
          if (bt.eq.'E') delz=fz(1)/cv
          if (bt.eq.'S') delz=fz(1)/cv
          if (ABS(delz).lt.0.0005d0*z(1)) delz=sign(0.0005d0*z(1),delz)
          z(2)=z(1)+delz
        endif
        j=2
      else
c  general case--define next guess for temperature by secant method
        if (ABS(fz(2)-fz(1)).gt.1.0d-12) then  !check for divide by zero
          z(3)=z(2)-fz(2)*(z(2)-z(1))/(fz(2)-fz(1))
        else
          z(3)=z(2)+0.5d0*(z(2)-z(1))
        end if
        zz=1.01d0
        if (it.gt.100) zz=1
        if (it.eq.150) tol=tol*2
        if (lneg .and. lpos .and.
     &     (z(3).gt.max(zpos,zneg)*zz .or.
     &      z(3).lt.min(zpos,zneg)/zz)) then
c  secant method has yielded guess further from solution, use reguli-falsi
c         write (*,*) 'ABFL1--using reguli-falsi; t by secant: ',z(3)
          z(3)=zpos-fzpos*(zpos-zneg)/(fzpos-fzneg)
          lRegFalsi=.true.
c         write (*,*) '      next temperature by reguli-falsi: ',z(3)
        end if
        if (at.eq.'T' .and.
     &     (d.lt.dmin*.98d0 .or. d.gt.dmax*1.02d0)) then
          if (ABS(z(3)).gt.1.d5) goto 210
          if (d.lt.dmin .and. z(1).lt.z(2)) then
            z(3)=(dmin+z(2))/2.d0
          elseif (d.lt.dmin .and. z(2).lt.z(1)) then
            z(3)=(dmin+z(1))/2.d0
          elseif (d.gt.dmax .and. z(1).gt.z(2)) then
            z(3)=(dmax+z(2))/2.d0
          elseif (d.gt.dmax .and. z(2).gt.z(1)) then
            z(3)=(dmax+z(1))/2.d0
          endif
        endif
        if (.not. lRegFalsi) then
          z(1)=z(2)
          z(2)=z(3)
          fz(1)=fz(2)
        else
          z(2)=z(3)
        endif
      end if
      if (at.ne.'T') then
        if (ABS(z(2)-z(1)).gt.0.25*z(1)) then
c  do not permit too large a step
          z(2)=z(1)+z(1)*sign(0.25d0,z(2)-z(1))
        end if
      endif
 200  continue
c
c  iteration has not converged
c
 210  continue
      ierr=248
      if (at.eq.'S') write (herr,1248) ab,z(j),fz(j),hnull
      if (at.eq.'P') write (herr,1248) ab,z(j),fz(j),hnull
      if (at.eq.'T') write (herr,1249) ab,z(j),fz(j),hnull
 1248 format ('[',a2,'FLSH error 248] single-phase iteration did not ',
     &        'converge, T, deltaT =',2(g12.5),' K.',a1)
 1249 format ('[',a2,'FLSH error 248] single-phase iteration did not ',
     &        'converge, D, deltaD =',2(g12.5),' mol/L.',a1)
      call ERRMSG (ierr,herr)
c
      RETURN
      end                                             !subroutine ABFL1x
c
c ======================================================================
c
      subroutine DBFL1 (d,b,x,ab,t,p,ierr,herr)
c
c  General single-phase calculation given density, composition, and either
c  pressure, energy, enthalpy, or entropy.  The character string ab
c  specifies the inputs.  This routine should ONLY be called by ABFL1.
c
c  inputs:
c        d--molar density [mol/L]
c        b--second property (pressure, energy, enthalpy, or entropy)
c        x--composition [array of mol frac]
c       ab--character*2 string defining the inputs: 'DH', 'DS', 'DE', or 'DP'
c
c  outputs:
c        t--temperature [K]
c        p--pressure [kPa]
c     ierr--error flag:  0 = successful
c                      200 = CRITP did not converge
c                      202 = liquid-phase iteration did not converge
c                      203 = vapor-phase iteration did not converge
c     herr--error string (character*255 variable if ierr<>0)
c
c  rewritten by E.W. Lemmon, NIST Physical & Chemical Properties Div, Boulder, CO
c  01-18-01 EWL, original version
c  02-27-12 EWL, reset ierr after call to CRITP
c  05-25-12 EWL, move calculation of p and dpdt inside IF block
c
cx DEC$ ATTRIBUTES DLLEXPORT :: DBFL1
c
      include 'commons.for'
      character*1 bt
      character*2 ab
      character*255 herr,herr1
      dimension x(ncmax)
      parameter (itmax=30)
c
      bt=ab(2:2)
      tolr=1.0d-6
      p=b
      ierr=0
      herr=' '
c     write (*,1001) b,rho,(x(i),i=1,5)
c1001 format (1x,' DBFL1--input b,rho,x:           ',f10.5,f14.6,5f10.6)
c
      call Rmix (x)
      if (b.lt.1.0d-14 .and. bt.eq.'P') then
c  ideal-gas
        t=b/(R*d)
        RETURN
      end if
c
      call CRITP (x,tc,pc,rhoc,ierr,herr1)
      if (ierr.gt.0) then
        ierr=200
        write (herr,1200) herr1(1:236),hnull
 1200   format ('[TPRHO error 200] ',a236,a1)
        call ERRMSG (ierr,herr)
        RETURN
      end if
      ierr=0
      herr=' '
c
c  set initial guess for temperature based on region
      t=tc
      if (bt.eq.'P' .and. b.gt.pc*100) t=tc*2
c     write (*,1082) t,b,d,(x(i),i=1,nc)
c1082 format (1x,' DBFL1--t,b,rho,x: ',5f10.5)
c
c  enter Newton's method iteration
      do it=1,itmax
        if (bt.eq.'P') then
          call PRESS (t,d,x,b1)
          call DPDT (t,d,x,dbdt)
        elseif (bt.eq.'H') then
          call DPDT (t,d,x,dpt)
          call CVCP (t,d,x,cv,cp)
          call ENTHAL (t,d,x,b1)
          dbdt=cv+R*p/d/R/t-p/d/t+dpt/d  !dh/dT at constant d
        elseif (bt.eq.'E') then
          call CVCP (t,d,x,cv,cp)
          call ENERGY (t,d,x,b1)
          dbdt=cv                        !de/dT at constant d
        elseif (bt.eq.'S') then
          call CVCP (t,d,x,cv,cp)
          call ENTRO (t,d,x,b1)
          dbdt=cv/t                      !ds/dT at constant d
        endif
c       write (*,1010) it,p/1000.0d0,d,x(1),t,p1
c1010   format (1x,'it,p,rho,x(1),t,p: ',i3,2f8.3,f8.4,2f14.8)
        t=t+(b-b1)/dbdt
        if (t.le.0) t=tc/2.d0
        b2=1.d0
        if (ABS(b).gt.1.d0) b2=b
        if (ABS((b-b1)/b2).lt.tolr) then
          call PRESS (t,d,x,p)
          RETURN
        endif
      enddo
c  iteration has not converged
      ierr=203
      write (herr1,1203) ab,d,t,(x(j),j=1,MIN(nc,5))
 1203 format ('[',a2,'FL1 error 203] iteration has not ',
     &        'converged for rho =',g12.5,' mol/L,',
     &        ' T (last guess) = ',g12.5,
     &        ' K, x (mol frac) =',5(0pf8.5))
      herr=herr1(1:254)//hnull
      call ERRMSG (ierr,herr)
c     write (*,*) ' DBFL1 final t (not converged): ',t
      t=0
      RETURN
c
      end                                              !subroutine DBFL1
c
c ======================================================================
c
      subroutine ABFL2 (a,b,z,kq,ksat,ab,
     &                  tbub,tdew,pbub,pdew,Dlbub,Dvdew,ybub,xdew,
     &                  t,p,Dl,Dv,x,y,q,ierr,herr)
c
c  General flash calculation given two inputs and composition.  Valid
c  properties for the first input are temperature and pressure.  Valid
c  properties for the second input are density, energy, enthalpy, entropy,
c  or quality.  The character string ab specifies the inputs.  Note that
c  the input TP is not allowed here, but is done by calling TPFLSH or
c  TPFL2.
c
c  This routine calls TPFL2 within a secant-method iteration for
c  pressure to find a solution.  Initial guesses are based on liquid
c  density at the bubble point and vapor density at the dew point.
c
c  inputs:
c        a--first property (either temperature or pressure)
c        b--second property (density, energy, enthalpy, entropy, or quality)
c        z--overall (bulk) composition [array of mol frac]
c       ab--character*2 string defining the inputs, e.g., 'TD' or 'PQ'
c       kq--flag specifying units for input quality when b=quality
c           kq = 1 quality on MOLAR basis [moles vapor/total moles]
c           kq = 2 quality on MASS basis [mass vapor/total mass]
c     ksat--flag for bubble and dew point limits
c           0 = dew and bubble point limits computed here
c           1 = must provide values for the following:
c  (for a=pressure):
c     tbub--bubble point temperature [K] at (p,x=z)
c     tdew--dew point temperature [K] at (p,y=z)
c  (for a=temperature):
c     pbub--bubble point pressure [kPa] at (t,x=z)
c     pdew--dew point pressure [kPa] at (t,y=z)
c  (for either case):
c    Dlbub--liquid density [mol/L] at bubble point
c    Dvdew--vapor density [mol/L] at dew point
c     ybub--vapor composition [array of mol frac] at bubble point
c     xdew--liquid composition [array of mol frac] at dew point
c
c  outputs:
c        t--temperature [K]
c        p--pressure [kPa]
c       Dl--molar density [mol/L] of the liquid phase
c       Dv--molar density [mol/L] of the vapor phase
c        x--composition of liquid phase [array of mol frac]
c        y--composition of vapor phase [array of mol frac]
c        q--vapor quality on a MOLAR basis [moles vapor/total moles]
c     ierr--error flag:  0 = successful
c                      223 = bubble point calculation did not converge
c                      224 = dew point calculation did not converge
c                      225 = TPFL2 did not converge
c                      226 = 2-phase iteration did not converge
c                      227 = input is outside saturation limits
c                      228 = input is outside saturation limits
c     herr--error string (character*255 variable if ierr<>0)
c
c  rewritten by E.W. Lemmon, NIST Physical & Chemical Properties Div, Boulder, CO
c  12-12-00 EWL, original version, rewritten by combining code of McLinden
c                from several different versions of FL2 routines to make
c                one unified routine
c  12-16-02 EWL, call PTANC upon completion for a pseudo-pure fluid
c  02-18-02 EWL, remove check for closeness to phase boundary for nc=1
c  09-02-04 EWL, add check for tbub-tdew<.001
c  05-28-08 EWL, move check for near azeotropes after call to PTANC
c  08-04-11 EWL, add check for d<dv
c
cx DEC$ ATTRIBUTES DLLEXPORT :: ABFL2
c
      include 'commons.for'
      character*1 at,bt
      character*2 ab
      character*255 herr,herr1
      dimension z(ncmax),x(ncmax),y(ncmax),aj(3),faj(2),
     &          xdew(ncmax),ydew(ncmax),xbub(ncmax),ybub(ncmax),
     &          x1(ncmax),y1(ncmax),xkg(ncmax),ykg(ncmax)
      parameter (itmax=30)
c
      at=ab(1:1)
      bt=ab(2:2)
      ajpos=0.d0
      ajneg=0.d0
      aratio=0.d0
      fajpos=0.d0
      fajneg=0.d0
      lRegFalsi=.false.
      hvap=0.d0
      aliq=0.d0
      avap=0.d0
      dl1=0.d0
      dv1=0.d0
      q1=0.d0
      call ISPURE (z,icomp)
      if (icomp.eq.0) then
        do i=1,nc
          x(i)=z(i)
          y(i)=z(i)
        enddo
      else
        do i=1,nc
          x(i)=0.d0
          y(i)=0.d0
        enddo
        x(icomp)=1.d0
        y(icomp)=1.d0
      endif

c
c  calculate bubble and dew points to establish bounds on iteration;
c  store results for use in possible reguli-falsi
      if (at.eq.'T') t=a
      if (at.eq.'P') p=a
      if (ksat.ne.1) then
        if (at.eq.'T') then
          call SATT (t,z,1,pbub,Dlbub,Dvbub,xbub,ybub,ierr,herr1)
        elseif (at.eq.'P') then
          call SATP (p,z,1,tbub,Dlbub,Dvbub,xbub,ybub,ierr,herr1)
        endif
        if (ierr.ne.0) then
          ierr=223
          write (herr,1223) ab,herr1(1:164),hnull
 1223     format ('[',a2,'FLSH error 223] bubble point calculation did',
     &            ' not converge (2-phase initial guess):  ',a164,a1)
          call ERRMSG (ierr,herr)
          q=999.d0     !quality undefined
          RETURN
        end if
        if (at.eq.'T') then
          call SATT (t,z,2,pdew,Dldew,Dvdew,xdew,ydew,ierr,herr1)
        elseif (at.eq.'P') then
          call SATP (p,z,2,tdew,Dldew,Dvdew,xdew,ydew,ierr,herr1)
        endif
        if (ierr.ne.0) then
          ierr=224
          write (herr,1224) ab,herr1(1:167),hnull
 1224     format ('[',a2,'FLSH error 224] dew point calculation did ',
     &            'not converge (2-phase initial guess):  ',a167,a1)
          call ERRMSG (ierr,herr)
          q=999.d0     !quality undefined
          RETURN
        end if
      end if
      if (at.eq.'T') then
        tbub=t
        tdew=t
        ajpos=pbub
        ajneg=pdew
        aratio=pbub/pdew-1.0d0
      elseif (at.eq.'P') then
        ajpos=tbub
        ajneg=tdew
        aratio=tdew/tbub-1.0d0
      endif
      ajmax=max(ajpos,ajneg)
      ajmin=min(ajpos,ajneg)
c  base convergence tolerance on abub/adew ratio:  otherwise, near-
c  azeotropes present impossible iteration (yet initial guesses are
c  very good)
c         write (*,*) ' ABFL2--adjusted tolb:  ',tolb
      tolb=5.0d-6
      if (ABS(aratio).lt.1.0d-8) aratio=1.0d-8
      tolb=MAX(tolb/1.0d2,MIN(tolb*1.0d2,0.02d0*tolb/aratio))
      if (bt.eq.'D') then
        fajpos=b*(1.0d0/b-1.0d0/Dlbub)
        fajneg=b*(1.0d0/b-1.0d0/Dvdew)
      elseif (bt.eq.'H' .or. bt.eq.'S' .or. bt.eq.'E') then
        if (bt.eq.'H') then
          call ENTHAL (tbub,Dlbub,z,blbub)
          call ENTHAL (tdew,Dvdew,z,bvdew)
        elseif (bt.eq.'S') then
          call ENTRO (tbub,Dlbub,z,blbub)
          call ENTRO (tdew,Dvdew,z,bvdew)
        elseif (bt.eq.'E') then
          call ENERGY (tbub,Dlbub,z,blbub)
          call ENERGY (tdew,Dvdew,z,bvdew)
        endif
c  input is outside of saturation limits
        if (b.lt.blbub .or. b.gt.bvdew) then
          ierr=227
          if (b.gt.bvdew) ierr=228
          write (herr,1227) ab,ierr,hnull
 1227     format ('[',a2,'FLSH error ',i3,'] input is outside',
     &            ' saturation bounds',a1)
          call ERRMSG (ierr,herr)
          q=999.d0     !quality undefined
          RETURN
        endif
c  normalize by pseudo enthalpy of vaporization
        hvap=blbub-bvdew
        if (ABS(hvap).lt.1.d0) hvap=1.d0
        fajpos=(b-blbub)/hvap
        fajneg=(b-bvdew)/hvap
      elseif (bt.eq.'Q') then
        if (kq.eq.2) then
c  input is on mass basis
          call QMASS (0.d0,z,ybub,qkg,xkg,ykg,wliq,wvap,ierr1,herr1)
          fajpos=b-qkg
          call QMASS (1.d0,xdew,z,qkg,xkg,ykg,wliq,wvap,ierr1,herr1)
          fajneg=b-qkg
        else
          fajpos=b
          fajneg=b-1.d0
        end if
      endif
c  check to see if initial guess is near solution
      if (icomp.eq.0) then
        if (ABS(fajpos).lt.tolb .and. ksat.eq.0) then
          if (at.eq.'T') p=ajpos
          if (at.eq.'P') t=ajpos
          dl=Dlbub
          dv=Dvbub
          do i=1,nc
            x(i)=xbub(i)
            y(i)=ybub(i)
          enddo
          q=0
          RETURN
        elseif (ABS(fajneg).lt.tolb .and. ksat.eq.0) then
          if (at.eq.'T') p=ajneg
          if (at.eq.'P') t=ajneg
          dl=Dldew
          dv=Dvdew
          do i=1,nc
            x(i)=xdew(i)
            y(i)=ydew(i)
          enddo
          q=1.d0
          RETURN
        endif
      endif
      aj(1)=ajneg
      faj(1)=fajneg
      j=2
c     write (*,1004) ajpos,fajpos,ajneg,fajneg
c1004 format (1x,' ABFL2--p,fp bounds:  ',4f12.6)
c     write (*,1006) -1,0,ajpos,Dlbub,xnotd,z(1),ybub(1),fajpos
c     write (*,1006)  0,1,aj(1),xnotd,Dvdew,xdew(1),z(1),faj(1)
c1006 format (' ABFL2: it,j,aj,Dl,Dv,x,y,faj: ',2i3,5(1x,f12.6),f18.10)
c
c  initial guesses for quality, liquid & vapor composition
      if (bt.eq.'D') then
        q=(1.0d0/b-1.0d0/Dlbub)/(1.0d0/Dvdew-1.0d0/Dlbub)
      elseif (bt.eq.'H' .or. bt.eq.'S' .or. bt.eq.'E') then
        q=(b-blbub)/(bvdew-blbub)
      elseif (bt.eq.'Q') then
        q=b
      endif
      dl=Dlbub
      dv=Dvdew
      if (at.eq.'T') p=pbub
      if (at.eq.'P') t=tbub
      if (icomp.ne.0) then        !Finished for pure fluid
        if (ianc(icomp).eq.1) call PTANC (t,p,q,b,bt,Dl,Dv)
        RETURN
      endif
      if (at.eq.'P' .and. abs(tbub-tdew).lt.0.001d0) then
c  for very near azeotropes or when q is nearly 0 or 1, ABFL2 may not
c  converge so return a simple solution
        t=tbub*(1.d0-q)+q*tdew
        RETURN
      endif
c
      nfail=0
 230  continue
      if (q.gt.1.d0) q=0.95d0
      if (q.lt.0.d0) q=0.05d0
      xsum=0.0d0
      ysum=0.0d0
      do i=1,nc
        x(i)=(1.0d0-q)*z(i)+q*xdew(i)
        y(i)=q*z(i)+(1.0d0-q)*ybub(i)
        xsum=xsum+x(i)
        ysum=ysum+y(i)
      enddo
      do i=1,nc
        x(i)=x(i)/xsum
        y(i)=y(i)/ysum
        if (nfail.eq.0) then
          x1(i)=x(i)         !save initial guesses for use in case
          y1(i)=y(i)         !TPFL2 does not converge
        endif
      enddo
      ierr1=0
c
      if (at.eq.'T') then
        call SATT (t,x,1,pliq,Dlx,Dvx,xbub,ybub,ierr1,herr1)
        aliq=pliq
      elseif (at.eq.'P') then
        call SATP (p,x,1,tliq,Dlx,Dvx,xbub,ybub,ierr1,herr1)
        aliq=tliq
      endif
      if (ierr1.ne.0) then
        ierr=223
        write (herr,2223) ab,herr1(1:164),hnull
 2223   format ('[',a2,'FLSH error 223] bubble point calculation did ',
     &          'not converge within 2-phase iteration:  ',a164,a1)
        call ERRMSG (ierr,herr)
        q=999.d0     !quality undefined
        RETURN
      end if
      if (at.eq.'T') then
        call SATT (t,y,2,pvap,Dly,Dvy,xdew,ydew,ierr1,herr1)
        avap=pvap
      elseif (at.eq.'P') then
        call SATP (p,y,2,tvap,Dly,Dvy,xdew,ydew,ierr1,herr1)
        avap=tvap
      endif
      if (ierr1.ne.0) then
        ierr=224
        write (herr,2224) ab,herr1(1:167),hnull
 2224   format ('[',a2,'FLSH error 224] dew point calculation did ',
     &          'not converge within 2-phase iteration:  ',a167,a1)
        call ERRMSG (ierr,herr)
        q=999.d0     !quality undefined
        RETURN
      end if
      Dl=1.0d0/((1.0d0-q)/Dlx+q/Dly)  !initial guesses for use in TPFL2
      Dv=1.0d0/((1.0d0-q)/Dvx+q/Dvy)  !based on volumes
      aj(2)=(1.0d0-q)*aliq+q*avap
c     write (*,1244) aj(2),q,(x(i),i=1,3),(y(i),i=1,3)
c1244 format (1x,' ABFL2 initial guesses--p,q,x,y = ',8f12.7)
      aj1=aj(2)
      if (nfail.eq.0) then
        Dl1=Dl             !save initial guesses for use in case
        Dv1=Dv             !TPFL2 does not converge
        q1=q
      endif
      if (bt.eq.'D' .and. nfail.lt.5) then
        if (b.lt.dv) then
          nfail=nfail+1
          q=q*20.d0  !Initial q not very good (usually very small).
          goto 230
        endif
      endif
      do 200 it=2,itmax
      if (it.eq.7) tolb=tolb*10
      if (it.eq.10) tolb=tolb*10
      if (it.eq.15) tolb=tolb*10
      if (at.eq.'T') p=aj(j)
      if (at.eq.'P') t=aj(j)
      q2=q
c  find density and composition for each phase
c  note that the initial guesses for Dl,Dv,x,y,q are refined in TPFL2
      call TPFL2 (t,p,z,Dl,Dv,x,y,q,ierr1,herr1)
      if (ierr1.ne.0) then
c  TPFL2 has not converged
        nfail=nfail+1
c       write (*,1016) aj(j)/1000.d0,q,herr1
c1016   format (1x,' ABFL2--TPFL2 returns error for p = ',f14.6,
c    &             ' MPa, quality = ',f10.6,': ',a255)
        if (nfail.ge.25) then
c  TPFL2 has not converged several times--return the initial guesses
          do i=1,nc
            x(i)=x1(i)         !retrieve initial guesses
            y(i)=y1(i)
          enddo
          Dl=Dl1
          Dv=Dv1
          if (at.eq.'T') p=aj1
          if (at.eq.'P') t=aj1
          q=q1
          if (q.lt.0.005d0 .or. q.gt.0.995d0) then
c  initial guesses are excellent very close to saturation
            ierr=0
            herr=' '
c           write (*,*) ' ABFL2--returning initial guesses'
          else
            ierr=225
            write (herr,2225) ab,hnull
 2225       format ('[',a2,'FLSH error 225] TPFL2 did not converge',
     &          ' in two-phase iteration; returning initial guesses',
     &          ' based on dew and bubble points',a1)
            call ERRMSG (ierr,herr)
          end if
          RETURN
        end if
c  set next guess for pressure by moving 2 % of way towards q = 0.5
        q=q2+SIGN(0.02d0,0.5d0-q2)
c       write (*,1034) q
c1034   format (1x,' ABFL2--next guess for quality = ',33x,f10.6)
        goto 230
      end if
      if (bt.eq.'D') then
        Vj=(1.0d0-q)/Dl+q/Dv       !bulk volume for current iteration
        faj(j)=b*(1.0d0/b-Vj)      !objective function
      elseif (bt.eq.'H') then
        call ENTHAL (t,Dl,x,bl)
        call ENTHAL (t,Dv,y,bv)
        faj(j)=(b-(1.0d0-q)*bl-q*bv)/hvap    !objective function
      elseif (bt.eq.'S') then
        call ENTRO (t,Dl,x,bl)
        call ENTRO (t,Dv,y,bv)
        faj(j)=(b-(1.0d0-q)*bl-q*bv)/hvap    !objective function
      elseif (bt.eq.'E') then
        call ENERGY (t,Dl,x,bl)
        call ENERGY (t,Dv,y,bv)
        faj(j)=(b-(1.0d0-q)*bl-q*bv)/hvap    !objective function
      elseif (bt.eq.'Q') then
        if (kq.eq.2) then
c    input is on mass basis
          call QMASS (q,x,y,qkg,xkg,ykg,wliq,wvap,ierr1,herr1)
          faj(j)=b-qkg
        else
          faj(j)=b-q
        end if
c     write (*,1040) it,j,aj(j),Dl,Dv,x(1),y(1),faj(j)
c1040 format (' ABFL2: it,j,aj,Dl,Dv,x,y,faj: ',2i3,5(1x,f12.6),f18.10)
      endif
      if (ABS(faj(j)).lt.tolb) then
c  iteration has converged
        if (at.eq.'T') p=aj(j)
        if (at.eq.'P') t=aj(j)
        if (ierr1.ne.0) then
          ierr=ierr1
          herr=herr1
        endif
        RETURN
      elseif (lRegFalsi) then
        if (faj(j).gt.0.d0) then
          ajpos=aj(j)
          fajpos=faj(j)
          aj(1) =ajneg
          faj(1)=fajneg
        else
          ajneg=aj(j)
          fajneg=faj(j)
          aj(1) =ajpos
          faj(1)=fajpos
        endif
      else if (faj(j).lt.0.0d0) then
c  store "negative" guess for use in possible reguli-falsi iteration
        ajneg=aj(j)
        fajneg=faj(j)
      else
c  store "positive" guess for use in possible reguli-falsi iteration
        ajpos=aj(j)
        fajpos=faj(j)
      end if

c  define next guess for pressure by secant method
      if (ABS(faj(2)-faj(1)).gt.1.0d-12) then  !check: divide by zero
        aj(3)=aj(2)-faj(2)*(aj(2)-aj(1))/(faj(2)-faj(1))
      else
        aj(3)=aj(2)+0.5d0*(aj(2)-aj(1))
      end if
      amax=max(ajpos,ajneg)
      amin=min(ajpos,ajneg)
      if (aj(3).gt.amax*1.2d0 .or. aj(3).lt.amin*0.8d0) then
c  secant method has yielded guess further from solution, use reguli-falsi
c       write (*,*) 'ABFL2--using reguli-falsi; p by secant: ',aj(3)
        if (ABS(ajpos-ajneg).gt.0.01d0) then
          aj(3)=ajpos-fajpos*(ajpos-ajneg)/(fajpos-fajneg)
          lRegFalsi=.true.
        endif
c       write (*,*) '         next pressure by reguli-falsi: ',aj(3)
      end if
      if (aj(3).gt.ajmax) then
        aj(3)=(ajmax+amax)/2.d0
        if (ABS(ajmax-amax).lt.0.001) aj(3)=(amax+amin)/2.d0
      elseif (aj(3).lt.ajmin) then
        aj(3)=(ajmin+amin)/2.d0
        if (ABS(ajmin-amin).lt.0.001) aj(3)=(amax+amin)/2.d0
      end if
      if (.not. lRegFalsi) then
        aj(1)=aj(2)
        aj(2)=aj(3)
        faj(1)=faj(2)
      else
        aj(2)=aj(3)
      endif
      if (ABS(aj(2)-aj(1)).gt.0.25*aj(1))
c  do not permit too large a step
     &  aj(2)=aj(1)+aj(1)*SIGN(0.25d0,aj(2)-aj(1))
 200  continue
c
c  iteration has not converged
c
      if (at.eq.'P') t=aj(j)
      ierr=226
      write (herr,1226) ab,aj(j)/1000.d0,faj(j),hnull
 1226 format ('[',a2,'FLSH error 226] 2-phase iteration did not',
     &        ' converge, X, delta =',2(g12.5),a1)
      call ERRMSG (ierr,herr)
c
      RETURN
      end                                              !subroutine ABFL2
c
c ======================================================================
c
      subroutine DBFL2 (d,b,z,kq,ab,t,p,Dl,Dv,x,y,q,ierr,herr)
c
c  General flash calculation given density, composition, and either
c  energy, enthalpy, entropy, or quality.  The character string ab
c  specifies the inputs.
c
c  inputs:
c        d--overall (bulk) molar density [mol/L]
c        b--second property (energy, enthalpy, entropy, or quality)
c        z--overall (bulk) composition [array of mol frac]
c       kq--flag specifying units for input quality when b=quality
c           kq = 1 quality on MOLAR basis [moles vapor/total moles]
c           kq = 2 quality on MASS basis [mass vapor/total mass]
c       ab--character*2 string defining the inputs: 'DH', 'DS', 'DE', or 'DQ'
c
c  outputs:
c        t--temperature [K]
c        p--pressure [kPa]
c       Dl--molar density [mol/L] of the liquid phase
c       Dv--molar density [mol/L] of the vapor phase
c        x--composition of liquid phase [array of mol frac]
c        y--composition of vapor phase [array of mol frac]
c        q--vapor quality on a MOLAR basis [moles vapor/total moles]
c     ierr--error flag:  0 = successful
c                      223 = bubble point calculation did not converge
c                      224 = dew point calculation did not converge
c                      225 = TPFL2 did not converge
c                      226 = 2-phase iteration did not converge
c     herr--error string (character*255 variable if ierr<>0)
c
c  rewritten by E.W. Lemmon, NIST Physical & Chemical Properties Div, Boulder, CO
c  12-13-00 EWL, original version
c  01-21-04 EWL, increase itmax to 50 for a pure fluid (helps in critical region)
c  01-21-04 EWL, add t=aj(j) at very bottom for nonconvergence
c  05-05-09 EWL, change the parameter x to z in the call to CRITP
c
cx DEC$ ATTRIBUTES DLLEXPORT :: DBFL2
c
      include 'commons.for'
      character*2 ab,tb
      character*255 herr
      dimension z(ncmax),x(ncmax),y(ncmax),aj(3),faj(2),
     &          xdew(ncmax),ydew(ncmax),xbub(ncmax),ybub(ncmax)
c
      itmax=20
      call ISPURE (z,icomp)
      if (icomp.eq.0) then
        do i=1,nc
          x(i)=z(i)
          y(i)=z(i)
        enddo
      else
        do i=1,nc
          x(i)=0.d0
          y(i)=0.d0
        enddo
        x(icomp)=1.d0
        y(icomp)=1.d0
      endif
      if (icomp.ne.0) itmax=50
      tb=ab
      tb(1:1)='T'
      tt=300.d0
      pp=0.d0
      dd=0.d0
c   get upper and lower bounds on T, do not initially call the ABFL2 routine
c   at the lower bound because T may be too low.
      call LIMITX ('EOS',tt,dd,pp,z,tmin,tmax,Dmax,pmax,ierr,herr)
      call SATD (d,z,1,kr,tmax,p,Dldew,Dvbub,xbub,ydew,ierr,herr)
      if (ierr.ne.0) call CRITP (z,tmax,pc,rhoc,ierr,herr)
      ajpos=tmin
      ajneg=tmax
c     fajneg=0.d0
c     fajpos=0.d0
      tolb=1.0d-4
c  use initial guess 1/3 and 2/3 of the way from tmin to tmax
      aj(1)=tmin+(tmax-tmin)/3.d0
      aj(2)=tmin+(tmax-tmin)/3.d0*2.d0
      it=1
 300  continue
      call ABFL2 (aj(1),b,z,kq,0,tb,
     &            tbub,tdew,pbub,pdew,Dlbub,Dvdew,ybub,xdew,
     &            tt,p,Dl,Dv,x,y,q,ierr,herr)
      if (ierr.eq.227 .or. ierr.eq.228) then
        it=it+1
        if (it.gt.itmax) RETURN
        if (ierr.eq.227) then
          aj(1)=(aj(1)+tmin)/2.d0
        elseif (ierr.eq.228) then
          aj(2)=(aj(2)+tmax)/2.d0
          aj(1)=(aj(1)+aj(2))/2.d0
        endif
        goto 300
      endif
      faj(1)=d
      if (Dl.gt.0 .and. Dv.gt.0) faj(1)=d-1.d0/((1.0d0-q)/Dl+q/Dv)
      j=2
      do 200 it=2,itmax
        call ABFL2 (aj(2),b,z,kq,0,tb,
     &              tbub,tdew,pbub,pdew,Dlbub,Dvdew,ybub,xdew,
     &              tt,p,Dl,Dv,x,y,q,ierr,herr)
        if (ierr.eq.227) then
          aj(2)=(aj(2)+aj(1))/2.d0
          goto 200
        endif
        faj(j)=d-1.d0/((1.0d0-q)/Dl+q/Dv)
        if (ABS(faj(j)).lt.tolb .and. ierr.eq.0) then
          t=aj(j)
          RETURN
        else if (faj(j).lt.0.0d0) then
          ajneg=aj(j)
c         fajneg=faj(j)
        else
          ajpos=aj(j)
c         fajpos=faj(j)
        end if
c   define next guess for pressure by secant method
        if (ABS(faj(2)-faj(1)).gt.1.0d-12) then  !check: divide by zero
          aj(3)=aj(2)-faj(2)*(aj(2)-aj(1))/(faj(2)-faj(1))
        else
          aj(3)=aj(2)+0.5d0*(aj(2)-aj(1))
        end if
        amax=max(ajpos,ajneg)
        amin=min(ajpos,ajneg)
c   keep root within tmin to tmax
        if (aj(3).gt.tmax) then
          aj(3)=(tmax+amax)/2.d0
          if (ABS(tmax-amax).lt.0.001) aj(3)=(amax+amin)/2.d0
        elseif (aj(3).lt.tmin) then
          aj(3)=(tmin+amin)/2.d0
          if (ABS(tmin-amin).lt.0.001) aj(3)=(amax+amin)/2.d0
        end if
        if (aj(3).gt.amax*1.001d0 .or. aj(3).lt.amin*0.999d0) then
          aj(3)=(amax+amin)/2.d0
        endif
c   if not converging, try cutting bounds in half for next guess
        if (it.gt.7 .and. it.eq.INT(it/2)*2) aj(3)=(amax+amin)/2.d0
        aj(1)=aj(2)
        aj(2)=aj(3)
        faj(1)=faj(2)
 200  continue
      t=aj(j)
      if (ierr.ne.0) herr(2:2)='D'
      RETURN
      end                                              !subroutine DBFL2
c
c ======================================================================
c
      subroutine PTANC (t,p,q,b,bt,Dl,Dv)
c
c  For a pseudo-pure fluid, find a saturated pressure that agrees with
c  calculations given temperature as an input.  This problem occurs since
c  the pseudo-pure fluid equations cannot calculate equilibrium phases.
c  Any given input temperature has an associated pbub and pdew.  At a
c  pressure between these two, there are associated values of tbub and tdew.
c  Thus, there are four state points that could be attributed to the two-phase
c  input.  To maintain consistency, the two points associated with tbub
c  and tdew are used through out REFPROP, and an iterative solution is
c  required when p is one of the inputs to find the right state point.
c
c  arguments:
c        t--temperature [K] (output, but requires an initial guess)
c        p--pressure [kPa] (input)
c        q--vapor quality on a MOLAR basis [moles vapor/total moles]
c        b--density, energy, enthalpy, or entropy, depending on bt
c       bt--input of second property (Q, D, E, H, or S)
c
c  outputs:
c       Dl--molar density [mol/L] of the liquid phase
c       Dv--molar density [mol/L] of the vapor phase
c
c  written by E.W. Lemmon, NIST Physical & Chemical Properties Div, Boulder, CO
c  12-17-02 EWL, original version
c
      include 'commons.for'
      character*255 herr
      character*1 bt
      dimension z(ncmax),x(ncmax),y(ncmax)
c
      t1=t*1.001d0
      p1=p*1.01d0
      i=0
      z(1)=1.d0
 10   continue
        call SATT (t,z,1,pl,Dl,Dvbub,x,y,ierr,herr)
        call SATT (t,z,2,pv,Dldew,Dv,x,y,ierr,herr)
        if (bt.eq.'Q') then
        elseif (bt.eq.'D') then
          q=(1.0d0/b-1.0d0/Dl)/(1.0d0/Dv-1.0d0/Dl)
        else
          call THERM (t,Dl,z,pl,el,hl,sl,cv,cp,w,hjt)
          call THERM (t,Dv,z,pv,ev,hv,sv,cv,cp,w,hjt)
          if (bt.eq.'E') then
            q=(b-el)/(ev-el)
          elseif (bt.eq.'H') then
            q=(b-hl)/(hv-hl)
          elseif (bt.eq.'S') then
            q=(b-sl)/(sv-sl)
          endif
        endif
        pp=(1.d0-q)*pl+q*pv
        dt=t1-t
        dp=p1-pp
        t1=t
        p1=pp
        if (ABS(dp).gt.1.d-20) t=t+dt/dp*(p-pp)
        i=i+1
      if (i.lt.20 .and. abs(dp).gt.1.d-5) goto 10
      RETURN
      end                                              !subroutine PTANC
c
c ======================================================================
c
      subroutine CSTAR (t,p,v,x,cs,ts,Ds,ps,ws,ierr,herr)
c
c  Calculate the critical flow factor, C*, for nozzle flow of a gas
c  (subroutine was originally named CCRIT)
c
c  inputs:
c        t--temperature [K]
c        p--pressure [kPa]
c        v--plenum velocity [m/s] (should generally be set to 0 for
c                                  calculating stagnation conditions)
c        x--composition [array of mol frac]
c
c  outputs:
c       cs--critical flow factor [dimensionless]
c       ts--nozzle throat temperature [K]
c       Ds--nozzle throat molar density [mol/L]
c       ps--nozzle throat pressure [kPa]
c       ws--nozzle throat speed of sound [m/s]
c     ierr--error flag:  0 = successful
c                      200 = CSTAR did not converge
c                      201 = Final state may be 2-phase
c     herr--error string (character*255 variable if ierr<>0)
c
c  written by E.W. Lemmon, NIST Physical & Chemical Properties Div, Boulder, CO
c  11-05-02 EWL, original version
c  12-19-07 EWL, implement new method proposed by Aaron Johnson
c
cx DEC$ ATTRIBUTES DLLEXPORT :: CSTAR
c
      include 'commons.for'
      character*255 herr
      dimension x(ncmax),xliq(ncmax),xvap(ncmax)
c
      cs=0.d0
      ts=0.d0
      Ds=0.d0
      ps=0.d0
      ws=0.d0
      itmax=20
      if (p.le.0.d0) RETURN
      wmm=WMOL (x)
      call CRITP (x,tc,pc,dc,ierr,herr)
c     call TPRHO (t,p,x,2,0,ds,ierr,herr)
c     call THERM (t,ds,x,pp,e,h,s,cv,cp,ws,hjt)
      call TPFLSH (t,p,x,ds,Dl,Dv,xliq,xvap,q,e,h,s,cv,cp,ws,ierr,herr)
      i=0
      ts=t

c...old method used in version 8.0, which didn't always converge
c     dmax=dc
c     if (t.gt.tc) dmax=4.d0*dc
c     if (t.lt.0.95*tc .and. ds.lt.dc) dmax=dc/2.d0
c     dh=0.d0
c10   continue
c       i=i+1
c       dhold=dh
c       dh=(ws**2-v**2)/2.d0*wmm/1000.d0    !calculate change in enthalpy
c       hs=h-dh
c       ss=s
c       call HSFL1 (hs,ss,x,0.d0,dmax,ts,ds,ierr,herr)   !flow is assumed isentropic, ds=0
c       call THERM (ts,ds,x,ps,e,hs,ss,cv,cp,ws,hjt)
c     if (abs(dh-dhold).gt.1.d-4 .and. i.lt.20 .and. ierr.eq.0) goto 10

c...new method (which is about 10 times faster than the old method)
      dt=-1.d0
      eta=0.d0
 10   continue
        i=i+1
        t1=ts
        eta1=eta
        ss=s         !flow is assumed isentropic, ds=0
        ts=ts+dt
        dmax=dc
        dmin=0.d0
        if (ts.gt.tc) dmax=4.d0*dc
        if (ts.lt.0.95*tc .and. ds.lt.dc) dmax=dc/2.d0
        if (ts.lt.tc .and. ds.gt.dc) then
          dmax=4.d0*dc
          dmin=dc
          if (ts.lt.0.95*tc) dmin=dc*2.d0
        endif
        call TSFL1 (ts,ss,x,dmin,dmax,ds,ierr,herr)
        q=0
        if (ierr.gt.0) then
          kr=1
          call TSFLSH (ts,ss,x,kr,ps,ds,Dl,Dv,xliq,xvap,q,e,hs,cv,cp,ws,
     &                 ierr,herr)
        else
          call THERM (ts,ds,x,ps,e,hs,ss,cv,cp,ws,hjt)
        endif
        if (ierr.gt.0) RETURN
        if ((q.gt.0.d0 .and. q.lt.1.d0) .or. ws.le.0.d0
     &                                  .or. ps.le.0.d0) then
          ierr=201
          herr='[CSTAR error 201] final state may be 2-phase'
          call ERRMSG (ierr,herr)
          RETURN
        endif
        dh=(ws**2-v**2)/2.d0*wmm/1000.d0    !calculate change from input state in enthalpy
        eta=(hs+dh)/h-1.d0
        if (i.gt.1) dt=-eta/((eta1-eta)/(t1-ts))    !Newton's first order method
c       write (*,'(i3,f12.7,8f12.4)') ierr,dt,ss,ts,ds,dmin,dmax
        if (abs(eta).lt.1.d-8) then
c  See NASA Tech Note D-2565 by R.C. Johnson for C* equation
c  see also Stewart, D.G., Watson, J.T.R., Vaidya, A.M., Flow Measurement and Instrumentation, 10:27-34, 1999.
          cs=ds*ws*sqrt(t*r*wmm/1000.d0)/p
          RETURN
        endif
      if (i.lt.itmax) goto 10

      ierr=200
      herr='[CSTAR error 200] iteration failed to converge'
      call ERRMSG (ierr,herr)
      RETURN
      end                                              !subroutine CSTAR
c
c        1         2         3         4         5         6         7
c23456789012345678901234567890123456789012345678901234567890123456789012
c
c ======================================================================
c                                                      end file flash2.f
c ======================================================================
c  begin file flsh_sub.f
c
c  This file contains iterative flash routines which call the
c  intermediate-level routines
c
c  contained here are:
c     subroutine TPRHO (t,p,x,kph,kguess,rho,ierr,herr)
c     subroutine TPFLSH (t,p,z,D,Dl,Dv,x,y,q,e,h,s,cv,cp,w,ierr,herr)
c     subroutine TPFL2 (t,p,z,Dl,Dv,x,y,q,ierr,herr)
c     subroutine TDFLSH (t,D,z,p,Dl,Dv,x,y,q,e,h,s,cv,cp,w,ierr,herr)
c     subroutine TDFL2 (t,D,z,ksat,pbub,pdew,Dlbub,Dvdew,ybub,xdew,
c    &                  p,Dl,Dv,x,y,q,ierr,herr)
c     subroutine PDFLSH (p,D,z,t,Dl,Dv,x,y,q,e,h,s,cv,cp,w,ierr,herr)
c     subroutine PDFL1 (p,rho,x,t,ierr,herr)
c     subroutine PDFL2 (p,d,z,ksat,tbub,tdew,Dlbub,Dvdew,ybub,xdew,
c    &                  t,Dl,Dv,x,y,q,ierr,herr)
c     subroutine PHFLSH (p,h,z,t,D,Dl,Dv,x,y,q,e,s,cv,cp,w,ierr,herr)
c     subroutine PHFL1 (p,h,x,kph,t,D,ierr,herr)
c     subroutine PHFL2 (p,h,z,ksat,tbub,tdew,Dlbub,Dvdew,ybub,xdew,
c    &                  t,Dl,Dv,x,y,q,ierr,herr)
c     subroutine PSFLSH (p,s,z,t,D,Dl,Dv,x,y,q,e,h,cv,cp,w,ierr,herr)
c     subroutine PSFL1 (p,s,x,kph,t,D,ierr,herr)
c     subroutine PSFL2 (p,s,z,ksat,tbub,tdew,Dlbub,Dvdew,ybub,xdew,
c    &                  t,Dl,Dv,x,y,q,ierr,herr)
c     subroutine PEFLSH (p,e,z,t,D,Dl,Dv,x,y,q,h,s,cv,cp,w,ierr,herr)
c     subroutine PEFL1 (p,e,x,kph,t,D,ierr,herr)
c     subroutine PEFL2 (p,e,z,ksat,tbub,tdew,Dlbub,Dvdew,ybub,xdew,
c    &                  t,Dl,Dv,x,y,q,ierr,herr)
c     subroutine PBFLSH (p,b,z,ab,t,D,Dl,Dv,x,y,q,e,h,s,cv,cp,w,
c    &                   ierr,herr)
c
c  these routines use the following common blocks from other files
c     common /Gcnst/ R,tz(n0:nx),rhoz(n0:nx)
c     common /HCHAR/ htab,hnull
c
c  various arrays are dimensioned with parameter statements
c
c ======================================================================
c ======================================================================
c
      subroutine TPRHO (t,p,x,kph,kguess,rho,ierr,herr)
c
c  iterate for density as a function of temperature, pressure, and
c  composition for a specified phase
c
c***********************************************************************
c  WARNING:
c  Invalid densities will be returned for T & P outside range of validity,
c  i.e., pressure > melting pressure, pressure less than saturation
c  pressure for kph=1, etc.
c
c***********************************************************************
c  inputs:
c        t--temperature [K]
c        p--pressure [kPa]
c        x--composition [array of mol frac]
c      kph--phase flag:  1 = liquid
c                        2 = vapor
c                 N.B.:  0 = stable phase--NOT ALLOWED (use TPFLSH)
c                            (unless an initial guess is supplied for rho)
c                       -1 = force the search in the liquid phase (for metastable points)
c                       -2 = force the search in the vapor phase (for metastable points)
c   kguess--input flag:  1 = first guess for rho provided
c                        0 = no first guess provided
c      rho--first guess for molar density [mol/L], only if kguess = 1
c
c  outputs:
c      rho--molar density [mol/L]
c     ierr--error flag:  0 = successful
c                      200 = CRITP did not converge
c                      201 = illegal input (kph <= 0)
c                      202 = liquid-phase iteration did not converge
c                      203 = vapor-phase iteration did not converge
c     herr--error string (character*255 variable if ierr<>0)
c
c  written by M. McLinden, NIST Thermophysics Division, Boulder, Colorado
c  04-03-95  MM, original version
c  09-11-95  MM, add error string to argument list
c  10-11-95  MM, RETURN if any error detected
c  11-29-95  MM, variable lower limit on coefficient/constant arrays
c                to accommodate ECS reference fluid
c  01-22-95  MM, check that input rho > 0 before using as initial guess
c  01-23-95  MM, use Rackett technique for liquid density initial guess
c  02-27-96  MM, parameter n0=-ncmax to accommodate ECS-thermo model
c  03-07-96  MM, change tolr from 1.0d-6 to 1.0d-8
c  10-16-96  MM, change call from DPRHO to DPDD
c  12-02-96  MM, add check that vapor density guess does not give p < 0
c  01-07-97  MM, error message bug (do not concatenate herr with itself)
c  02-11-97 EWL, reduced tolerance after 10 and after 15 iterations
c  04-22-97  MM, add additional iteration for low-p (allow p = 0)
c  05-16-97  MM, do not apply step limitation for t > 1.5*tc
c  06-03-97 EWL, add second order Newton's solution to increase convergence speed
c  06-05-97 EWL, remove checks in liquid solution for large jumps in density
c                change initial guess in liquid phase to 2*Dc
c  07-15-97  MM, renumber and add detail to error messages
c  09-22-97 EWL, modify test to select liquid or vapor iteration
c  09-23-97  MM, increase itmax from 20 to 30 to aid in near-critical convergence
c  10-01-97  MM, add compiler switch to allow access by DLL
c  11-13-97 EWL, revert to 1st order Newton's method if 2nd order gives bad result
c  11-18-97 EWL, ditto for liquid-phase iteration
c  12-31-97  MM, check derivative dP/dD for liquid-phase initial guess
c  02-11-98  MM, check for t > Tc before switching liq to vapor iteration
c  03-31-98 EWL, check for Dguess>Dmax in liquid iteration
c  08-14-98  MM, do not check input rho<0 unless kguess=1 (@stmt 10)
c  09-30-98 EWL, if liquid iteration fails and t>tc, call vapor iteration
c  12-18-98 EWL, increase max value of fvdpl to 2 on check of 1st order Newton's
c  12-22-98 EWL, recalculate R for mixtures based on values for pure fluids
c  02-02-99 EWL, increase max value of fvdpl to 25 on check of 1st order Newton's
c  11-09-00 EWL, allow kph=0 if an initial guess is supplied for rho
c  01-17-02 EWL, allow kph=-1 and -2 to force searches in liquid or vapor
c  02-13-02 EWL, change pressure bound where the ideal gas law kicks in
c  11-02-04 EWL, check for p=0 and kph=1
c  07-20-05 EWL, check for very large rho
c  10-03-05 EWL, change itmax from 30 to 40
c  06-07-06 EWL, slight changes to check for T=Tc or P=Pc
c  10-01-09 EWL, change 0.1d0 to 0.11d0 to avoid rho=rho2, resulting in unreported errors
c  04-12-10 EWL, add check in liquid phase iteration for p app. equal to p2
c  04-27-10 EWL, add check for d(p)/d(rho)/d(T)<0
c  05-11-10 EWL, at it=12 or 18, add 30% to liquid rho in case iteration is stuck in 2-phase
c  09-24-12 EWL, add checks on initial density for d2PdD2 and d2PdTD for liquid root solver
c  10-09-12 EWL, remove check on rho<1 after call to PR, and very small rho for kph=1
c
cx DEC$ ATTRIBUTES DLLEXPORT :: TPRHO
c
      include 'commons.for'
      character*255 herr,herr1
      dimension x(ncmax)
c
      itmax=40
      tolr=1.0d-8
      ierr=0
      herr=' '
c     write (*,1001) t,p,(x(i),i=1,5)
c1001 format (1x,' TPRHO--input t,p,x:           ',f10.5,f14.6,5f10.6)
c
c  determine which iteration to use:
c  For liquids (or fluids above the critical pressure) the iteration is
c  carried out in transformed coordinates of log(V).  For vapor (or
c  fluids at supercritical temperatures but pressures below the critical
c  value) the iteration is in terms of log(V) and log(p).  For very low
c  pressure vapors a simple iteration in rho and p is used.  The iteration
c  has converged when the pressure calculated from the equation of state
c  agrees with the input pressure within a convergence tolerance.
c
      call Rmix (x)
      if (p.lt.1.0d-8) then
        if (kph.ne.1) then
c  ideal-gas
          if (t.gt.0.d0) rho=p/(R*t)
          RETURN
        elseif (ABS(p).lt.1.d-60) then   !EWL changed from 1.d-16 to 1.d-60, 6/18/07
          rho=0.d0
          RETURN
        endif
      end if
c
c  call Peng-Robinson routines if in use
c
      i=-1
      call PREOS(i)
      if (i.eq.1) then
        call TPRHOPR (t,p,x,rho1,rho2)
        if (rho1.gt.1.d8) goto 100
        if (rho2.lt.1.d-12) then
          rho=rho1
        else
          if (abs(kph).eq.1) then
            rho=rho1
          elseif (abs(kph).eq.2) then
            rho=rho2
          else
            if (ABS(rho-rho1).lt.ABS(rho-rho2)) then
              rho=rho1
            else
              rho=rho2
            endif
          endif
        endif
c  if the pressure is less than 1 kPa and the density is in the liquid phase,
c  continue on with iterative routine to make sure that the cubic solver got
c  the right answer
c       if (p.gt.1.d0 .or. rho.lt.1.d0 .or. kph.eq.2) RETURN
        if (p.gt.1.d0 .or. kph.eq.2) RETURN
        if (kph.eq.1 .and. rho.lt.1.d-6) rho=0.d0
      endif
c
      call CRITP (x,tc,pc,rhoc,ierr,herr1)
      rhom2=rhoc
      rhom1=0.d0
      if (ierr.gt.0) then
        ierr=200
        write (herr,1200) herr1(1:236),hnull
 1200   format ('[TPRHO error 200] ',a236,a1)
        call ERRMSG (ierr,herr)
        RETURN
      end if
      ierr=0
      vc=1.0d0/rhoc
      if (vc.le.0.d0) vc=1.d0
      vclog=LOG(vc)
      if (kph.eq.-1) then
        lliq=.true.
      elseif (kph.eq.-2) then
        lliq=.false.
c  EWL modification to aid near-critical convergence;
c  following approximates the pressure along the critical isochore
      elseif (p.lt..99*pc*(1.0d0+7.0d0*(t/tc-1.0d0)) .and. t.gt.tc) then
c  use 'vapor phase' iteration
        lliq=.false.
      else if (p.ge.pc .or. t.ge.tc) then
c  use 'liquid phase' iteration
        lliq=.true.
c  possible new code for very close to critical but with rho<rhoc
c       call PRESS(t,rhoc,x,ptest)
c       if (p.lt.ptest) lliq=.false.
      else if (kph.le.0) then
        if (kguess.ne.0) then
          lliq=.true.
          if (rho.lt.rhoc) lliq=.false.
        else
c  illegal input to TPRHO (two-phase state)
          ierr=201
          herr='[TPRHO error 201] illegal input to TPRHO (kph <= 0); '
     &           //'use TPFLSH instead'//hnull
          call ERRMSG (ierr,herr)
          RETURN
        endif
      else
c  use input phase specification to find solution
        if (kph.eq.1) then
          lliq=.true.
        else
          lliq=.false.
        end if
      end if
c
c  set initial guess for density
      kgrho=1      !flag is set to 0 if input rho<0
      vlog=0.d0
 10   continue
      if (kguess.eq.1) then
        if (rho.gt.0.0d0) then
c  use input density as initial guess
          vlog=LOG(1.0d0/rho)
        else
c  set flag to trigger initial guess algorithm below
          kgrho=0
        end if
      end if
      if (kguess.eq.0 .or. kgrho.eq.0) then
c  initial guess based on region
        if (p.gt.pc .and. t.gt.tc) then
          vlog=LOG(0.5d0*vc)
        else if (lliq) then
c         vlog=LOG(0.5d0*vc)
c  initial guess for sub-critical liquid density based on modified
c  Rackett technique (Reid, Prausnitz, and Poling (1987), Properties
c  of Gases and Liquids, 4th edition) except that Zra = Zc
          Rtp=R*tc/pc
          Zc=vc/Rtp
c         vlog=LOG(Rtp*Zc**(1.0d0+(1.0d0-t/tc)**(2.0d0/7.0d0)))
          Dguess=1.0d0/(Rtp*Zc**(1.0d0+ABS(1.0d0-t/tc)**(2.0d0/7.0d0)))
          call LIMITS ('EOS',x,tmin,tmax,Dmax,pmax)
          if (Dguess.gt.Dmax) Dguess=Dmax
          iguess=1
 20       continue
          call THERM2 (t,Dguess,x,pp,e,h,s,cv,cp,w,Z,hjt,A,G,
     &                 xkappa,beta,dPdrho,d2PdD2,dPT,drhodT,drhodP,
     &                 d2PT2,d2PdTD,spare3,spare4)
          if (dpdrho.lt.0.d0 .or.
     &       (d2PdD2.lt.0.d0 .and. t.lt.tc) .or.
     &       (d2PdTD.lt.0.d0 .and. abs(d2PdTD+9999990.d0).gt..1)) then
c  initial guess is in two-phase region, set to higher density
            if (iguess.le.8) then
              Dguess=1.1d0*Dguess
              iguess=iguess+1
              goto 20
            endif
          end if
          vlog=LOG(1.0d0/Dguess)
          if (vlog.gt.LOG(0.5d0*vc)) vlog=LOG(0.5d0*vc)
        else
          vlog=LOG(R*t/p)
        end if
        if (.not.lliq) vlog=LOG(R*t/p)
      end if
c     write (*,1082) kph,kguess,t,p,1.0/EXP(vlog),(x(i),i=1,nc)
c1082 format (1x,' TPRHO--kph,kguess,t,p,rho,x: ',2i4,3e14.6,5f10.5)
c
c  enter Newton's method iteration, separate loops for liquid and vapor
c
      rho2=0.0d0
      if (lliq) then
c  liquid phase iteration
        rhom1=100.d0
        do it=1,itmax
          if (it.eq.12 .or. it.eq.18) then
            rho=rho*1.3d0
            vlog=LOG(1.d0/rho)
          endif
          vlog0=vlog
c         write (*,*) ' TPRHO (liquid) vlog: ',vlog
          rho=1.0d0/exp(vlog)
          if (rho.gt.1.d8) goto 100
          call PRESS (t,rho,x,p2)
          call DPDD (t,rho,x,dpd)
          call DPDD2 (t,rho,x,dpd2)
c  keep track of the last best guess (rhom1) for density for cases where no root is
c  available.  This point will be near the spinodal in the valid metastable region.
          if(dpd.le.0.d0 .and. rho.gt.rhom2) rhom2=rho
          if(dpd.gt.0.d0 .and. rho.lt.rhom1 .and. rho.gt.rhom2)rhom1=rho
c         write (*,1010) it,t,x(1),p,p2,dpd,rho
c1010     format (1x,'it,t,x(1),p,p2,dpd,rho (liquid): ',i3,2f8.3,4e16.8)
          if (dpd.le.0.0d0) then
c  unstable portion of two-phase region, make another guess
c           write (*,1012) it,1.0/exp(vlog)
c1012       format (1x,'unstable 2-phase in liquid, it, rho = ',i4,d16.8)
            vlog=vlog-0.10d0
          else
            dpd2=dpd2+dpd/rho              !2nd order Newton's method
            fvdp=(p-p2)/(dpd2*(p-p2)/2.0d0/dpd+dpd)/rho
            if (ABS(fvdp).gt.100.0d0) then
c  revert to 1st order Newton's method if too large step from 2nd order
              dpdlv=-rho*dpd
              fvdp=(p2-p)/dpdlv            !1st order Newton's method
            endif
c           write (*,1014) dpdlv,dpd,fvdp
c1014       format (1x,' TPRHO (liquid) dpdlv,dpd,fvdp: ',3d16.8)
c  if calculation has not converged after 10 or 15 iterations, loosen
c  tolerance (original tolr was too tight near critical)
            if (it.eq.10) tolr=tolr*10.d0
            if (it.eq.15) tolr=tolr*10.d0
c  The rho-rho2 check is only important for very low pressures on the
c  liquid surface (propane or R124).  In this case, the change in density
c  required to get the correct pressure is less than machine precision.
            if ((ABS(fvdp/p).lt.0.0001d0*tolr .or.
     &          ABS(rho-rho2).lt.1.0d-11) .and.
     &         abs(p-p2).lt.0.001d0) then
c  iteration has converged
              rho=1.0d0/exp(vlog-fvdp)
c             call PRESS (t,rho,x,p2)        !convergence testing only
c             write (*,1016) it,t,p,p2,rho
c1016         format (1x,8x,'% TPRHO converged (liq); it,t,p,p2,rho  ',
c    &              i3,f8.3,2e18.10,e18.10)
c             write (*,*) ' TPRHO final rho-liq: ',rho
              goto 999
            end if
c  next guess
            vlog=vlog0-fvdp
c  do not allow too great of a change in density between iterations
c  for liquid states
            if (ABS(vlog-vlog0).gt.0.1d0 .and. t.lt.1.5d0*tc) then
              vlog=vlog0+SIGN(0.11d0,vlog-vlog0)  !Do NOT use 0.1d0
            end if
            if (vlog.gt.vclog .and. t.lt.tc) then
              vlog=0.5d0*(vlog0+vclog)
            end if
c  switch to the "vapor" iteration
            if (vlog.lt.-5.0d0 .and. t.ge.tc) then
c               write (*,*) ' TPRHO--switching to the vapor iteration'
              lliq=.false.
              goto 10
            end if
            rho2=rho
          end if
        enddo
c  iteration has not converged
        rho=1.0d0/exp(vlog)
        if (t.ge.tc) then
          lliq=.false.
          goto 10
        endif
        goto 100
c
c      else if (lowp) then
c   low-pressure vapor iteration
c   disabled--not required
c        do it=1,itmax
c          call PRESS (t,rho,x,p2)
c          call DPDD (t,rho,x,dpd)
c          delp=p2-p
c          if (ABS(delp).lt.0.0001*tolr) then
c   iteration has converged
c            write (*,1024) it,t,p,p2,delp,rho
c 1024       format (9x,'% TPRHO converged (low-p); it,t,p,p2,delp,rho  ',
c     &              i3,f8.3,3e18.10,e18.10)
c            RETURN
c          else
c   next guess
c            rho=rho-delp/dpd
c          end if
c        enddo
c   iteration has not converged
c        rho=p/(R*t)
c        ierr=1
c        write (herr,1002) t,p,rho,hnull
c        call ERRMSG (ierr,herr)
c 1002   format (' ERROR--TPRHO has not converged (low-p),  t,p,rho =',
c     &          f8.3,2e14.6,a1)
c        RETURN
c
      else
c  vapor phase iteration
        plog=LOG(p)
        do it=1,itmax
          vlog0=vlog
          rho=1.0d0/exp(vlog)
          call PRESS (t,rho,x,p2)
          call DPDD (t,rho,x,dpd)
          call DPDD2 (t,rho,x,dpd2)
c  keep track of the last best guess (rhom1) for density for cases where no root is
c  available.  This point will be near the spinodal in the valid metastable region.
          if(dpd.le.0.d0 .and. rho.lt.rhom2) rhom2=rho
          if(dpd.gt.0.d0 .and. rho.gt.rhom1 .and. rho.lt.rhom2)rhom1=rho
c         write (*,1030) it,t,x(1),p,p2,dpd,rho
c1030 format (1x,'it,t,x(1),p,p2,dpd,rho (vapor):  ',i3,2f8.3,4e18.10)
          if (dpd.lt.0.0d0 .or. p2.le.0.0d0) then
c  unstable portion of two-phase region or p2<0, make another guess
c         write (*,1032) it,1.0/exp(vlog)
c1032     format (1x,'unstable 2-phase in vapor or p2 < 0, it, rho = ',
c    &            i4,d16.8)
            vlog=vlog+0.10d0
          else

            dpd2=dpd2/p2-(dpd/p2)**2+dpd/rho/p2
            fvdpl=(plog-LOG(p2))/(p2*dpd2*(plog-LOG(p2))
     &            /2.0d0/dpd+dpd/p2)/rho      !2nd order Newton's method
c  if 2nd order Newton's method gives unreasonable result, revert to
c  first order method (large value of fvdpl corresponds to huge change
c  in next guess for volume)
            if (ABS(fvdpl).gt.1.0d0) then
              dpdlv=-rho*dpd
              fvdpl=(LOG(p2)-plog)*p2/dpdlv   !1st order Newton's method
            endif
c  the following used was original set at '.gt.2.d0', but was changed to
c  '.gt.25.d0'.  Vapor densities were failing to converge for a mixture of
c  47% methane, 16% ethane, 7% propane, and 30% i-butane.  This may now cause
c  other areas to fail.
            if (ABS(fvdpl).gt.25.d0) fvdpl=0.1d-5
c  if calculation has not converged after 10 or 15 iterations, loosen
c  tolerance (original tolr was too tight near critical)
            if (it.eq.10) tolr=tolr*10.d0
            if (it.eq.15) tolr=tolr*10.d0
            if (ABS(fvdpl).lt.0.0001d0*tolr) then
c  iteration has converged
              rho=1.0d0/exp(vlog)
              call PRESS (t,rho,x,p2)        !convergence testing only
c              write (*,1034) it,t,p,p2,rho
c1034       format (1x,8x,'% TPRHO converged (vap); it,t,p,p2,rho  ',
c    &              i3,f8.3,2e18.10,e18.10)
c              write (*,*) ' TPRHO final rho-vap: ',rho
              goto 999
            else
c  next guess
              vlog=vlog-fvdpl
c             if (ABS(vlog-vlog0).gt.0.5d0) then
c               vlog=vlog0+SIGN(0.5d0,vlog-vlog0)
c             end if
c             if (vlog.lt.vclog .and. t.lt.tc) then
c               vlog=0.5d0*(vlog0+vclog)
c             end if
            end if
          end if
        enddo
c  iteration has not converged
c       write (*,*) ' TPRHO final rho-vap (not converged): ',rho
      end if
 103  continue
      rho=1.0d0/exp(vlog)
      if (rhom1.gt.0.d0) rho=rhom1
      ierr=203
      write (herr1,1203) t,p/1000.d0,rho,(x(j),j=1,MIN(nc,5))
 1203 format ('[TPRHO error 203] vapor iteration has not ',
     &        'converged for T =',g12.5,' K, P =',g12.5,
     &        ' MPa, rho (last guess) = ',g12.5,
     &        ' mol/L, x (mol frac) =',5(0pf8.5))
      herr=herr1(1:254)//hnull
      call ERRMSG (ierr,herr)
      RETURN
c
 100  continue
      if (rhom1.gt.0.d0) rho=rhom1
      ierr=202
      write (herr1,1202) t,p/1000.d0,rho,(x(i),i=1,MIN(nc,5))
 1202 format ('[TPRHO error 202] liquid iteration has not ',
     &        'converged for T =',g12.5,' K, P =',g12.5,
     &        ' MPa, rho (last guess) = ',g12.5,' mol/L,',
     &        ' compositions = ',5(0pf9.5))
      herr=herr1(1:196)//hnull
      call ERRMSG (ierr,herr)
c     write (*,*) ' TPRHO final rho-liq (not converged): ',rho
      RETURN
 999  if (t.lt.tc*1.2d0 .and.
     &    rho.gt.rhoc*0.2d0 .and. rho.lt.rhoc*2.0d0) then
c  if solution is less than Tc and the densities are within a region
c  that is semi-critical, check d(p)/d(rho) and d^2(p)/[d(rho)*d(T)]
c  to make sure that root is valid
        call THERM2 (t,rho,x,pp,e,h,s,cv,cp,w,Z,hjt,A,G,
     &               xkappa,beta,dPdrho,d2PdD2,dPT,drhodT,drhodP,
     &               d2PT2,d2PdTD,spare3,spare4)
        if (dpdrho.lt.0.d0 .or.
     &     (d2PdTD.lt.0.d0 .and. abs(d2PdTD+9999990.d0).gt..1)) then
          if (nc.eq.1 .and. hcas(1).eq.'124-38-9' .and.
     &        d2PdTD.gt.-23.d0) then
c           If CO2, real state points can go down to -0.023 J/mol-K
          else
            if (kph.eq.1) goto 100
            goto 103
          endif
        endif
      endif
c
      end                                              !subroutine TPRHO
c
c ======================================================================
c
      subroutine TPFLSH (t,p,z,D,Dl,Dv,x,y,q,e,h,s,cv,cp,w,ierr,herr)
c
c  flash calculation given temperature, pressure, and bulk composition
c
c  This routine accepts both single-phase and two-phase states as the
c  input; if the phase is known, the subroutine TPRHO is faster.
c
c  inputs:
c        t--temperature [K]
c        p--pressure [kPa]
c        z--overall (bulk) composition [array of mol frac]
c
c  outputs:
c        D--overall (bulk) molar density [mol/L]
c       Dl--molar density [mol/L] of the liquid phase
c       Dv--molar density [mol/L] of the vapor phase
c           if only one phase is present, Dl = Dv = D
c        x--composition of liquid phase [array of mol frac]
c        y--composition of vapor phase [array of mol frac]
c           if only one phase is present, x = y = z
c        q--vapor quality on a MOLAR basis [moles vapor/total moles]
c           q < 0 indicates subcooled (compressed) liquid
c           q = 0 indicates saturated liquid
c           q = 1 indicates saturated vapor
c           q > 1 indicates superheated vapor
c           q = 998 superheated vapor, but quality not defined (in most situations, t > Tc)
c           q = 999 indicates supercritical state (t > Tc) and (p > Pc)
c        e--overall (bulk) internal energy [J/mol]
c        h--overall (bulk) enthalpy [J/mol]
c        s--overall (bulk) entropy [J/mol-K]
c       Cv--isochoric (constant V) heat capacity [J/mol-K]
c       Cp--isobaric (constant p) heat capacity [J/mol-K]
c        w--speed of sound [m/s]
c           Cp, w are not defined for 2-phase states
c           in such cases, a flag = -9.99998d6 is returned
c     ierr--error flag:  0 = successful
c                        1 = Tin < Tmin
c                        4 = Pin < 0
c                        5 = T and P out of range
c                        8 = x out of range (component and/or sum < 0
c                            or > 1)
c                        9 = x and T out of range
c                       12 = x out of range and P < 0
c                       13 = x and T and P out of range
c                      210 = CRITP did not converge
c                      211 = SATT did not converge at bubble point
c                      212 = SATT did not converge at dew point
c                      213 = TPRHO did not converge for liquid state
c                      214 = TPRHO did not converge for vapor state
c                      215 = TPRHO did not convg for supercritical state
c                      216 = TPRHO did not convg for liq in 2-phase it
c                      217 = TPRHO did not convg for vap in 2-phase it
c                      218 = liquid frac for 2-phase it did not converge
c                      219 = composition for 2-phase it did not converge
c     herr--error string (character*255 variable if ierr<>0)
c
c  written by M. McLinden, NIST Thermophysics Division, Boulder, Colorado
c  09-11-95  MM, original version
c  09-12-95  MM, change argument list (add e, h, s, etc.)
c  09-20-95  MM, define output xl, xv for single-component super-critical
c  09-25-95  MM, rearrange argument list (outputs in order rho, x, q)
c  10-11-95  MM, RETURN if any error detected
c  11-29-95  MM, variable lower limit on coefficient/constant arrays
c                to accommodate ECS reference fluid
c  12-12-95  MM, restructure logic to accommodate mixtures
c                first guess for 2-phase mix from ratio of dew & bubble
c  12-13-95  MM, set undefined output compositions to zero
c                initial rho guess for 1-phase vapor based on p/pdew
c  12-14-95  MM, bug on call to CRITP:  pass z (not x)
c  12-28-95  MM, add full 2-phase mixture iteration using fugacities
c  12-29-95  MM, move 2-phase iteration to separate routine TPFL2
c  02-27-96  MM, parameter n0=-ncmax to accommodate ECS-thermo model
c  05-31-96  MM, check input t,p,z against limits
c  06-03-96  MM, add 'EOS' to calling list for LIMITX
c  01-07-97  MM, error message bug (do not concatenate herr with itself)
c  04-09-97  MM, initialize x,y to z
c  04-22-97  MM, use h, rather than s, to compute q (h converges at p = 0)
c  05-15-97  MM, use V to compute q for comp. liq. (T,h can be double-valued)
c                add q = 998 case for t > Tc, but p < Pc
c  07-15-97  MM, renumber and add detail to error messages
c                get flags for 'not defined' from common /FLAGS/
c  10-01-97  MM, add compiler switch to allow access by DLL
c  02-11-98  MM, check that computed density is within bounds
c  09-15-98 EWL, if T>Tc-5, use critical parameters if call to SATT fails.
c  12-28-98 EWL, if SATT fails (vapor), check for liquid state before failing
c  03-05-99 EWL, add check for region below Ttriple in the vapor phase
c  10-21-99 EWL, do not check satt if pressure is less than .8pc at tc,
c                .1pc at .85tc and the area in between (on a log plot).
c  01-11-00 EWL, remove ierr from line 1008 and several other places in flsh_sub.for
c  01-02-01 EWL, add check for d<dl and d>dv in single phase routine
c  05-21-01 EWL, call PSATT if an ancillary vapor pressure eq. exists (for nc=1)
c  09-11-02 EWL, drop psat by factor of 10 to check for two phase before doing 1 phase
c  12-16-02 EWL, add checks for pseudo-pure fluid
c  12-30-08 EWL, change x to z in call to PSATT
c  04-29-10 EWL, add tcex to check if T>Tc*Tcex for mixtures since Tc is not upper limit
c  05-06-10 EWL, add pcex to check if p>pc*pcex for mixtures since Pc is not upper limit
c  05-06-10 EWL, return last best metastable rho when no root for input phase exists
c  07-29-10 EWL, decrease psat calculation at low temperatures
c  10-10-10 EWL, drop psat by an additional factor of 100 to check for two phase before doing 1 phase, very important for water/air mixtures
c  02-23-11 EWL, add check for CO2 with d2P/d(rho)/dT < 0 near the critical point
c  04-27-11 EWL, change tc=tc*1.1d0 to t=tc*1.1d0
c  08-04-11 EWL, set dlbub, dldew, dvbub, and dvdew to rhoc if SATT fails
c
cx DEC$ ATTRIBUTES DLLEXPORT :: TPFLSH
c
      include 'commons.for'
      character*255 herr,herr1,herr2,herrl
      dimension z(ncmax),x(ncmax),y(ncmax)
      dimension xdew(ncmax),ydew(ncmax),ybub(ncmax),xbub(ncmax)
c
      call ISPURE (z,icomp)
      ierr=0
      pbub=0
      pdew=0
      herr=' '
      q=999.d0     !quality undefined
c
c  initialize output liquid and vapor compositions to input values
c  zero output values for undefined components
      if (icomp.eq.0) then
        do i=1,nc
          x(i)=z(i)
          y(i)=z(i)
        enddo
      else
        do i=1,nc
          x(i)=0.d0
          y(i)=0.d0
        enddo
        x(icomp)=1.d0
        y(icomp)=1.d0
      endif
      if (p.lt.1.0d-14) then
c  ideal-gas
        D=p/(R*t)
        Dl=D
        Dv=D
        call THERM (t,D,z,ptherm,e,h,s,cv,cp,w,hjt)
      endif
c
c  check that input conditions are within limits
c
      rhodum=0.0d0
      call LIMITX ('EOS',t,rhodum,p,z,tmin,tmax,rhomax,pmax,ierrl,herrl)
      if (ierrl.lt.0) then
c  one or inputs are outside limits--if just a warning proceed w/ calc
        write (herr,1006) ierrl,herrl(1:234),hnull
 1006   format ('[TPFLSH warning',i3,'] ',a234,a1)
        call ERRMSG (ierrl,herr)
c  if error (as opposed to warning) set output density to zero and return
      else if (ierrl.gt.0) then
        write (herr,1007) ierrl,herrl(1:236),hnull
 1007   format ('[TPFLSH error',i3,'] ',a236,a1)
        call ERRMSG (ierrl,herr)
        D=0.0d0
        Dl=0.0d0
        Dv=0.0d0
        if (t.gt.0) call THERM (t,D,z,ptherm,e,h,s,cv,cp,w,hjt)
        q=999.d0     !quality undefined
        ierr=ierrl
        RETURN
      end if
c
      call CRITP (z,tc,pc,rhoc,ierr,herr2)
      if (ierr.gt.0) then
        ierr=210
        write (herr,1008) herr2(1:235),hnull
 1008   format ('[TPFLSH error 210] ',a235,a1)
        call ERRMSG (ierr,herr)
        q=999.d0     !quality undefined
        RETURN
      end if
c
 150  continue
      psat=0.d0
      tcex=1.d0
      pcex=1.d0
      if (icomp.eq.0) then
        tcex=1.5d0  !Extra amount to add to Tc for mixtures
        pcex=1.5d0
      endif
      if (t.le.tc) psat=exp(13.85d0*(t/tc)-14.073d0)*pc
      if (t.le.tc*0.7d0) psat=psat/10.d0  !Some fluids have lower pressures than this equation below 70% of Tc
      if (t.le.tc*0.6d0) psat=psat/100.d0
      if (t.le.tc*0.5d0) psat=psat/100.d0
      if (t.le.tc*0.4d0) psat=psat/100.d0
      if (icomp.ne.0 .and. t.le.tc) then
        ierr=1
        if (hpsk(icomp).ne.'NBS') call PSATT (t,z,psat2,ierr,herr)
        if (ierr.eq.0) psat=0.95d0*psat2 !Drop 5% to allow for error
      else
c  drop cutoff for single phase vapor check by factor of 10
        psat=psat/10.d0
        if (nc.gt.1) psat=psat/100.d0
      endif
      if (icomp.ne.0 .and. t.lt.ttpn(icomp)) then
c  temperature less than triple point temperature, but in the gas phase.
        kph=2
        kguess=1
        D=p/(R*t)
        call TPRHO (t,p,z,kph,kguess,D,ierr,herr2)
        call THERM (t,D,z,ptherm,e,h,s,cv,cp,w,hjt)
        Dl=D
        Dv=D
        if (ierr.ne.0) then
          ierr=214
          write (herr,1214) herr2(1:190),hnull
          call ERRMSG (ierr,herr)
          q=999.d0     !quality undefined
          RETURN
        end if
      elseif (t.ge.tc*tcex .or. p.lt.psat .or. p.gt.pc*pcex) then
c  supercritical and vapor states (x = y = z as set above)
c       write (*,*) ' TPFLSH--supercritical'
        kph=2
        if (t.lt.tc .and. p.gt.pc) kph=1
        kguess=0
        call TPRHO (t,p,z,kph,kguess,D,ierr,herr2)
        call THERM (t,D,z,ptherm,e,h,s,cv,cp,w,hjt)
        Dl=D
        Dv=D
        if (p.le.pc) then
          q=998.d0     !superheated, but cannot define quality
        elseif (p.gt.pc .and. t.lt.tc) then
          q=-998.d0    !subcooled, but cannot define quality
        else
          q=999.d0     !quality undefined
        end if
        if (ierr.ne.0) then
          ierr=215
          write (herr,1215) herr2(1:175),hnull
 1215     format ('[TPFLSH error 215] supercritical or vapor density ',
     &            'iteration did not converge:  ',a175,a1)
          call ERRMSG (ierr,herr)
c  call two phase states if t is close to tc for a mixture
          if (icomp.eq.0 .and. t.lt.tc*1.1d0) then
            t=tc*1.1d0
            goto 150
          endif
          RETURN
        end if
c       do i=1,nc
c         x(i)=z(i)
c         y(i)=z(i)
c       enddo
      else
c  subcritical state--call saturation routine to determine liq or vap
        i=iprnterr
        iprnterr=0
        call SATT (t,z,2,pdew,Dldew,Dvdew,xdew,ydew,ierr,herr2)
        iprnterr=i
        iflag=0
        if (ierr.ne.0 .and. t.gt.tc-5) then
          pdew=pc
          Dldew=rhoc
          Dvdew=rhoc
        elseif (ierr.ne.0 .and. icomp.ne.0) then
          ierr=212
          write (herr,1212) herr2(1:193),hnull
 1212     format ('[TPFLSH error 212] dew point calculation ',
     &            'did not converge:  ',a193,a1)
          call ERRMSG (ierr,herr)
          D=0.0d0
          Dl=0.0d0
          Dv=0.0d0
          q=999.d0     !quality undefined
          RETURN
        else if (ierr.ne.0) then
c  do not exit yet, check if valid liquid state
          iflag=1
          pdew=0
        end if
        if (p.lt.pdew) then
c  single-phase vapor (x = y = z as set above)
c         write (*,*) ' TPFLSH--single-phase vapor'
          kph=2
          kguess=1
          D=Dvdew*p/pdew                     !initial guess for density
          call TPRHO (t,p,z,kph,kguess,D,ierr,herr2)
          Dl=D
          Dv=D
          if (ierr.ne.0) then
            ierr=214
            write (herr,1214) herr2(1:190),hnull
 1214       format ('[TPFLSH error 214] vapor density iteration ',
     &              'did not converge:  ',a190,a1)
            call ERRMSG (ierr,herr)
            q=999.d0     !quality undefined
            RETURN
          end if
          call THERM (t,D,z,ptherm,e,h,s,cv,cp,w,hjt)
          q=998.d0
          if (ianc(icomp).eq.0 .and. t.lt.tc) then
            call ENTHAL (t,Dldew,xdew,hldew)
            call ENTHAL (t,Dvdew,z,hvdew)
            q=(h-hldew)/(hvdew-hldew)
            if (q.gt.0.0d0 .and. q.lt.1.0d0) q=998.d0
          endif
        else
          if (icomp.ne.0 .and. ianc(icomp).eq.0) then
c  special case:  pure component single-phase liquid
c           write (*,*) ' TPFLSH--pure fluid single-phase liquid'
            kph=1
            kguess=1
            D=Dldew
            call TPRHO (t,p,z,kph,kguess,D,ierr,herr2)
            Dl=D
            Dv=D
            if (ierr.ne.0) then
              ierr=213
              write (herr,1213) herr2(1:189),hnull
 1213         format ('[TPFLSH error 213] liquid density iteration ',
     &                'did not converge:  ',a189,a1)
              call ERRMSG (ierr,herr)
              q=999.d0     !quality undefined
              RETURN
            end if
            call THERM (t,D,z,ptherm,e,h,s,cv,cp,w,hjt)
c  compute quality based on volumes (possible for T,h to be
c  double-valued in compressed liquid)
            q=(1.0d0/D-1.0d0/Dldew)/(1.0d0/Dvdew-1.0d0/Dldew)
          else
c  mixture:  calculate bubble point to determine if liquid or 2-phase
            call SATT (t,z,1,pbub,Dlbub,Dvbub,xbub,ybub,ierr,herr2)
            if (ierr.ne.0 .and. t.gt.tc-5.0d0) then
              pbub=pc
              Dlbub=rhoc
              Dvbub=rhoc
            elseif (ierr.ne.0) then
              ierr=211
              write (herr,1211) herr2(1:190),hnull
 1211         format ('[TPFLSH error 211] bubble point calculation ',
     &                'did not converge:  ',a190,a1)
              call ERRMSG (ierr,herr)
              D=0.0d0
              Dl=0.0d0
              Dv=0.0d0
              q=999.d0     !quality undefined
              RETURN
            end if
            if (p.ge.pbub) then
c  mixture single-phase liquid
c             write (*,*) ' TPFLSH--mixture single-phase liquid'
              kph=1
              kguess=1
              D=Dlbub
              call TPRHO (t,p,z,kph,kguess,D,ierr,herr2)
              Dl=D
              Dv=D
              if (ierr.ne.0 .or. (d.lt.dlbub .and. d.gt.dvdew)) then
                ierr=213
                write (herr,1213) herr2(1:189),hnull
                call ERRMSG (ierr,herr)
                q=999.d0     !quality undefined
                RETURN
              end if
              call THERM (t,D,z,ptherm,e,h,s,cv,cp,w,hjt)
c  compute quality based on volumes (possible for T,h to be
c  double-valued in compressed liquid
              if (abs(dvdew-dlbub).gt.1.d-12)
     &            q=(1.0d0/D-1.0d0/Dlbub)/(1.0d0/Dvdew-1.0d0/Dlbub)
            else
c
c  two-phase mixture
c             write (*,*) ' TPFLSH--two-phase mixture'
c
c  generate initial guesses for x and y by interpolating input pressure
c  with dew and bubble point pressures
c
              if (iflag.eq.1) then
c  dew point did not converge, location of state point is either two-phase
c  or vapor phase
                ierr=212
                write (herr,1212) herr2(1:193),hnull
                call ERRMSG (ierr,herr)
                D=0.0d0
                Dl=0.0d0
                Dv=0.0d0
                q=999.d0     !quality undefined
                RETURN
              endif
              if (ABS(1.0d0-pbub/pdew).lt.1.0d-6
     &           .and. ianc(icomp).eq.0) then
c  possible azeotrope
                q=0.5d0
              else
                q=1.0d0-(p-pdew)/(pbub-pdew)
              end if
              Dl=Dlbub                 !initial guess for liquid density
              Dv=Dvdew                 !initial guess for vapor density
              if (icomp.eq.0 .or. ianc(icomp).eq.0) then
                xsum=0.0d0
                ysum=0.0d0       !sums for normalization of compositions
                do i=1,nc
                  x(i)=(1.0d0-q)*z(i)+q*xdew(i)
                  y(i)=q*z(i)+(1.0d0-q)*ybub(i)
                  xsum=xsum+x(i)
                  ysum=ysum+y(i)
                enddo
                do i=1,nc
                  x(i)=x(i)/xsum
                  y(i)=y(i)/ysum
                enddo
                call TPFL2 (t,p,z,Dl,Dv,x,y,q,ierr,herr)
                if (ierr.ne.0) then
c  two-phase iteration did not converge--error message written by TPFL2
                  q=999.d0     !quality undefined
                  d=rhoc
                  RETURN
                end if
c  compute 2-phase properties and load output variables
c  call TPRHO to ensure consistency of t, p, rho
                kguess=1
                call TPRHO (t,p,x,1,kguess,Dl,ierr1,herr1)
                call TPRHO (t,p,y,2,kguess,Dv,ierr1,herr1)
                if (ierr1.ne.0) then
                  herr2='[TPFLSH error] (mix, 2-phase):  '//herr1
                  call ERRMSG (ierr1,herr2)
                  RETURN
                end if
              endif
              call THERM (t,Dl,x,ptherm,el,hl,sl,cvl,cp,w,hjt)
              call THERM (t,Dv,y,ptherm,ev,hv,sv,cvv,cp,w,hjt)
              cp=xnotd                   !Cp, w not defined for 2-phase
              w=xnotd
              cv=xnotd
c  bulk properties are weighted average of liquid and vapor phases
              alpha=1.0d0-q               !alpha is liq fraction,
              D=1.0d0/(alpha/Dl+q/Dv)     !q is vapor frac
              e=alpha*el+q*ev
              h=alpha*hl+q*hv
              s=alpha*sl+q*sv
            end if
          end if
        end if
      end if
c
c  if limits check resulted in warning (as opposed to error) return
c  that message; do this again in case intermediate iteration did not
c  converge (thereby overwriting any warning message from LIMITX)
c
      if (ierrl.lt.0) then
        ierr=ierrl
        write (herr,2006) ierrl,herrl(1:234),hnull
 2006   format ('[TPFLSH warning',i3,'] ',a234,a1)
        call ERRMSG (ierr,herr)
      end if
c
      if (D.gt.rhomax) then
c  check that computed (output) density is within bounds of EOS
        ierr=2
        write (herr,2008) ierr,t,p/1000.0d0,hnull
 2008   format ('[TPFLSH error',i3,']; input T,p correspond to ',
     &          'a density above the limit of the EOS; T =',g12.5,
     &          ' K, p =',g12.5,' MPa.',a1)
        call ERRMSG (ierr,herr)
      end if
c
      RETURN
      end                                             !subroutine TPFLSH
c
c ======================================================================
c
      subroutine TPFL2 (t,p,z,Dl,Dv,x,y,q,ierr,herr)
c
c  flash calculation given temperature, pressure, and bulk composition
c
c  This routine accepts only two-phase states as input; if the phase is
c  not known use TPFLSH.  Use TPRHO for single-phase states.
c
c  inputs:
c        t--temperature [K]
c        p--pressure [kPa]
c        z--overall (bulk) composition [array of mol frac]
c       Dl--initial guess for molar density [mol/L] of the liquid phase
c       Dv--initial guess for molar density [mol/L] of the vapor phase
c        x--initial guess for composition of liquid phase
c           [array of mol frac]
c        y--initial guess for composition of vapor phase
c           [array of mol frac]
c        q--initial guess for vapor quality on a MOLAR basis
c           [moles vapor/total moles]
c
c  outputs:
c       Dl--molar density [mol/L] of the liquid phase
c       Dv--molar density [mol/L] of the vapor phase
c        x--composition of liquid phase [array of mol frac]
c        y--composition of vapor phase [array of mol frac]
c        q--vapor quality on a MOLAR basis [moles vapor/total moles]
c     ierr--error flag:  (these are also passed up to TPFLSH for output)
c                        0 = successful
c                      216 = TPRHO did not converge for liquid
c                      217 = TPRHO did not converge for vapor
c                      218 = inner loop (liquid frac) did not converge
c                      219 = outer loop (composition) did not converge
c     herr--error string (character*255 variable if ierr<>0)
c
c  written by M. McLinden, NIST Thermophysics Division, Boulder, Colorado
c  12-29-95  MM, original version, extracted from TPFLSH
c  02-27-96  MM, parameter n0=-ncmax to accommodate ECS-thermo model
c  04-09-97  MM, fix bug:  converged value of q not returned
c  04-11-97  MM, fix divide by zero on saturation boundary
c                adjust tolr --> d-7; allow alpha outside 0,1 by d-5
c  07-15-97  MM, renumber and add detail to error messages
c                get flags for 'not defined' from common /FLAGS/
c  10-01-97  MM, add compiler switch to allow access by DLL
c  11-01-00 EWL, change tol from -7 to -9 so that TPFLSH finds a better root.
c  12-13-00 EWL, changed the calculation of y from x*xk to y*fliq/fvap.  Before
c                this, sum(y) was always equal to one on the first iteration
c                and the program exited prematurely
c  02-20-01 EWL, changed the tolerance after 15 iterations to increase the
c                chance of converging
c  02-26-01 EWL, if dpdrho is too large, liquid root is no good,
c                use SATP to get dl
c  08-09-01 EWL, made the data statement for tolr into a regular executable line
c  09-11-02 EWL, increase itmax to 80
c  09-11-02 EWL, at every 10th iteration, use average of old and new compositions
c                to get next composition.  Helps when x and y are jumping back and forth
c  07-22-03 EWL, modify how alpha(3) is calculated
c  08-23-06 EWL, changed the tolerance after 50 iterations
c  12-04-09 EWL, add call to new routine of Diego Ortiz
c  12-04-12 EWL, add xinc and xdir to flip values of x(1) back and forth instead of just up
c
cx DEC$ ATTRIBUTES DLLEXPORT :: TPFL2
c
      include 'commons.for'
      character*255 herr,herr2
      dimension z(ncmax),x(ncmax),y(ncmax),xs(ncmax),ys(ncmax)
      dimension xbub(ncmax),xdew(ncmax)
      dimension alpha(3),falpha(2),fliq(ncmax),fvap(ncmax),xk(ncmax)
      parameter (itmax=80)
c
      tolr=1.0d-9
      ierr=0
      herr=' '
c
c  call new code first to see if it finds a root
      if (iSatFlg.eq.0) then
        iFlash=0
        call SATTP(t,p,z,iFlash,1,d,Dl,Dv,x,y,q,ierr,herr)
        if (ierr.gt.0)
     &    call SATTP(t,p,z,iFlash,0,d,Dl,Dv,x,y,q,ierr,herr)
        if (ierr.eq.0) return
      endif
c
c  begin outer iteration loop for the vapor composition
c
      alpha(1)=1.0d0-q
      kguess=1
      j=1
      do i=1,nc
        ys(i)=y(i)
      enddo
      xinc=0.01d0
      xdir=1.d0
      do 200 iy=1,itmax
      if (iy.eq.12) tolr=tolr*100.d0
      if (iy.eq.24) tolr=tolr*100.d0
      if (iy.eq.50) tolr=tolr*100.d0
c  compute densities and fugacities for each phase
c     write (*,1001) t,p,(x(i),i=1,5)
c1001 format (1x,' TPFL2 call TPRHO; liq t,p,x:  ',f10.5,f14.6,5f10.6)
      call TPRHO (t,p,x,1,kguess,Dl,ierr,herr2)
      call DPDD (t,Dl,x,dpdrho)
      if (ABS(dpdrho).gt.1.d7) then
        call SATP (p,x,1,tt,Dl,Dvdew,xbub,xdew,ierr2,herr2)
      endif
      if (ierr.ne.0) then
c  try modifying the composition to get a workable solution.
        x(1)=x(1)+xdir*xinc
        do i=2,nc
          x(i)=x(i)-xdir*xinc/DBLE(nc-1)
        enddo
        xinc=xinc+0.01d0
        xdir=-xdir
        if (x(1).lt.1.d0 .and. x(1).gt.0.d0) goto 200
        ierr=216
        write (herr,1216) herr2(1:170),hnull
 1216   format ('[TPFLSH error 216] liquid density iteration for ',
     &          '2-phase state did not converge:  ',a170,a1)
        call ERRMSG (ierr,herr)
        goto 840
      end if
      xinc=0.01d0
      xdir=1.d0
      call FGCTY2 (t,Dl,x,fliq,ierr,herr)
c     write (*,1002) t,p,(y(i),i=1,5)
c1002 format (1x,' TPFL2 call TPRHO; vap t,p,x:  ',f10.5,f14.6,5f10.6)
      call TPRHO (t,p,y,2,kguess,Dv,ierr,herr2)
      if (ierr.ne.0) then
        do i=1,nc
          y(i)=0.8d0*y(i)+0.2d0*ys(i)
        enddo
        goto 200
c       ierr=217
c       write (herr,1217) herr2(1:170),hnull
c1217   format ('[TPFLSH error 217] vapor density iteration for ',
c    &          '2-phase state did not converge:  ',a170,a1)
c       call ERRMSG (ierr,herr)
c       goto 840
      end if
      call FGCTY2 (t,Dv,y,fvap,ierr,herr)
c  compute k-factors (assume constant for a given guess of y)
      do i=1,nc
        if (z(i).gt.0.d0 .and. x(i).gt.0.d0) then
          xk(i)=fliq(i)*y(i)/(x(i)*fvap(i))
        else
c  zero composition for component i
          xk(i)=0.0d0
        end if
      enddo
c
c     write (*,1004) iy,(xk(i),i=1,nc)
c1004 format (1x,' TPFL2 ity,k-factors: ',i4,5e18.10)
c
c  begin inner iteration loop for the liquid fraction (alpha)
c
      j=1                      !iteration flag
c     lfapos=.false.           !flags for reguli-falsi iteration
c     lfaneg=.false.
      do i=1,nc
        xs(i)=x(i)
      enddo
      do ix=1,itmax
c       write (*,1040) ix,(x(i),i=1,nc)
c1040 format (1x,' TPFL2 itx,old liq comps:  ',i4,10x,5f16.12)
        xsum=0.0d0
        do i=1,nc
          if (z(i).gt.0.0d0) then
c  compute new guess for liquid composition
            x(i)=z(i)/(alpha(j)+xk(i)*(1.0d0-alpha(j)))
          else
c  zero composition for component i
            x(i)=0.0d0
          end if
          xsum=xsum+x(i)
        enddo
c  normalize liquid composition
        do i=1,nc
          x(i)=x(i)/xsum
        enddo
c       write (*,1050) ix,xsum,(x(i),i=1,nc)
c1050 format (1x,' TPFL2 itx,xsum,new comps: ',i4,6f16.12)
        falpha(j)=1.0d0-xsum
c       write (*,1056) ix,alpha(j),xsum,(x(i),i=1,3)
c1056 format (1x,' TPFL2:',i4,35x,2f10.6,3f10.6)
        if (ABS(falpha(j)).lt.1.0d-2*tolr) then
c  inner loop has converged
c  (tolerance on inner loop must be tighter than outer loop)
          goto 640
        else
c  store variables for possible use in reguli-falsi
c  reguli-falsi actually seems to slow convergence--comment out
c       if (falpha(j).lt.0.0d0) then
c         lfaneg=.true.
c         aneg=alpha(j)
c         faneg=falpha(j)
c       else
c         lfapos=.true.
c         apos=alpha(j)
c         fapos=falpha(j)
        end if
c  generate next guess for liquid fraction
        if (j.eq.1) then
c  for second iteration, move 5 % of way to alpha = 1.0
c         alpha(2)=alpha(1)+0.05d0*(1.0d0-alpha(1))
c  above could result in alpha(2) = alpha(1) if alpha(1) = 1
c  try moving towards alpha = 0.5 !MM 04-11-97
          j=2
          alpha(2)=alpha(1)+SIGN(0.05d0,0.5d0-alpha(1))
        else
c  for subsequent iterations, use secant method
          if (ABS(falpha(2)-falpha(1)).gt.1.0d-2*tolr) then
            alpha(3)=alpha(2)-falpha(2)*(alpha(2)-alpha(1))/
     &               (falpha(2)-falpha(1))
          else
            alpha(3)=alpha(1)+SIGN(tolr,0.5d0-alpha(1))
          end if
c  new guess for alpha must lie within bounds of zero and one
c  but allow small tolerance for slop in TPRHO and thus fugacities.
c         write (*,1060) ix,(alpha(i),i=1,3),(falpha(i),i=1,2)
c1060   format (1x,' TPFL2 itx,alpha,falpha:   ',i4,5f16.12)
c  alpha(3) generally goes out of bounds when the slope of falpha vs. x
c  is near flat.  Use next guess of half of alpha(2).
          if (alpha(3).gt.1.0d0+1.0d2*tolr) then
            alpha(3)=alpha(2)/2.d0
          else if (alpha(3).lt.0.0d0-1.0d2*tolr) then
            alpha(3)=alpha(2)/2.d0
          end if
c  check that new guess is not outside previous bounds
c         if (lfaneg .and. lfapos .and. (alpha(3).gt.MAX(fapos,faneg)
c    &       .or. alpha(3).lt.MIN(fapos,faneg))) then
c  if so, use reguli-falsi
c           alpha(3)=apos-fapos*(apos-aneg)/(fapos-faneg)
c         end if
c  discard oldest iteration
          alpha(1)=alpha(2)
          alpha(2)=alpha(3)
          falpha(1)=falpha(2)
        end if
      enddo
c  inner iteration loop has not converged, issue warning and proceed
      ierr=-218
      write (herr,1218) hnull
 1218 format ('[TPFLSH warning 218] inner iteration loop for liquid ',
     &        'fraction in 2-phase state did not converge:  ',a1)
      call ERRMSG (ierr,herr)
c
c  end of inner iteration loop for liquid fraction
c
 640  continue
      ysum=0.0d0
c  compute next guess for vapor composition, using x(i) from inner loop
      do i=1,nc
c       y(i)=x(i)*xk(i)                !Old way, but incorrect
        if (fliq(i).eq.xerr .or. fvap(i).eq.xerr) goto 210
        ys(i)=y(i)
        if (fvap(i).ne.0.d0) y(i)=y(i)*fliq(i)/fvap(i)
        ysum=ysum+y(i)
      enddo
c  normalize vapor compositions
      do i=1,nc
        y(i)=y(i)/ysum
      enddo
c     write (*,1076) iy,t,Dl,Dv,ysum,(y(i),i=1,3)
c1076 format (1x,' TPFL2:',i4,f7.2,2e14.6,10x,f10.6,3f10.6)
      if (ABS(1.0d0-ysum).lt.tolr) then
c  outer loop has converged (also check for warning from inner loop)
        if (ierr.ne.0) then
          ierr=218
          write (herr,2218) hnull
 2218     format ('[TPFLSH error 218] inner iteration loop for liquid ',
     &            'fraction in 2-phase state did not converge:  ',a1)
          call ERRMSG (ierr,herr)
        end if
        if (iy.gt.1) goto 840
      end if
      if (int(iy/10)*10.eq.iy) then
        do i=1,nc
          x(i)=(x(i)+xs(i))/2.d0
          y(i)=(y(i)+ys(i))/2.d0
        enddo
      endif
 200  continue
c  outer iteration loop has not converged, issue error and return
 210  ierr=219
      write (herr,1219) hnull
 1219 format ('[TPFLSH error 219] outer iteration loop for ',
     &        'composition in 2-phase state did not converge:  ',a1)
      call ERRMSG (ierr,herr)
c
c  end of outer iteration loop for vapor composition
c
 840  continue
      q=1.0d0-alpha(j)
c
c  call new saturation solver to attempt to get convergence
c     if (ierr.gt.0 .and. nc.gt.1 .and. iSatFlg.eq.0) then
c       call SATTP(t,p,z,0,0,d,Dl,Dv,x,y,q,ierr,herr)
c     endif
c
      RETURN
      end                                              !subroutine TPFL2
c
c ======================================================================
c
      subroutine TDFLSH (t,D,z,p,Dl,Dv,x,y,q,e,h,s,cv,cp,w,ierr,herr)
c
c  flash calculation given temperature, bulk density, & bulk composition
c
c  This routine accepts both single-phase and two-phase states as input,
c  if the phase is known, then subroutine THERM is (much) faster.
c
c  inputs:
c        t--temperature [K]
c        D--overall (bulk) molar density [mol/L]
c        z--overall (bulk) composition [array of mol frac]
c
c  outputs:
c        p--pressure [kPa]
c       Dl--molar density [mol/L] of the liquid phase
c       Dv--molar density [mol/L] of the vapor phase
c           if only one phase is present, Dl = Dv = D
c        x--composition of liquid phase [array of mol frac]
c        y--composition of vapor phase [array of mol frac]
c           if only one phase is present, xl = xv = x
c        q--vapor quality on a MOLAR basis [moles vapor/total moles]
c           q < 0 indicates subcooled (compressed) liquid
c           q = 0 indicates saturated liquid
c           q = 1 indicates saturated vapor
c           q > 1 indicates superheated vapor
c           q = 998 superheated vapor, but quality not defined (in most situations, t > Tc)
c           q = 999 indicates supercritical state (t > Tc) and (p > Pc)
c        e--overall (bulk) internal energy [J/mol]
c        h--overall (bulk) enthalpy [J/mol]
c        s--overall (bulk) entropy [J/mol-K]
c       Cv--isochoric (constant V) heat capacity [J/mol-K]
c       Cp--isobaric (constant p) heat capacity [J/mol-K]
c        w--speed of sound [m/s]
c           Cp, w are not defined for 2-phase states
c           in such cases, a flag = -9.99998d6 is returned
c     ierr--error flag:  0 = successful
c                        1 = Tin < Tmin
c                        2 = Din > Dmax or Din < 0
c                        3 = T and D out of range
c                        8 = x out of range (component and/or sum < 0
c                            or > 1)
c                        9 = x and T out of range
c                       10 = x and D out of range
c                       11 = x and T and D out of range
c                      220 = CRITP did not converge
c                      221 = SATT did not converge at bubble point
c                      222 = SATT did not converge at dew point
c                      223 = SATT (bubble pt) did not converge for 2-ph
c                      224 = SATT (dew pt) did not converge for 2-phase
c                      225 = TPFL2 did not converge
c                      226 = 2-phase iteration did not converge
c     herr--error string (character*255 variable if ierr<>0)
c
c  written by M. McLinden, NIST Thermophysics Division, Boulder, Colorado
c  09-20-95  MM, original version
c  09-25-95  MM, rearrange argument list (outputs in order rho, x, q)
c  10-11-95  MM, RETURN if any error detected
c  11-08-95  MM, patch to allow testing of GUI with mixtures
c  11-29-95  MM, variable lower limit on coefficient/constant arrays
c                to accommodate ECS reference fluid
c  12-13-95  MM, set undefined output compositions to zero
c  02-27-96  MM, parameter n0=-ncmax to accommodate ECS-thermo model
c  01-07-97  MM, error message bug (do not concatenate herr with itself)
c  01-21-97  MM, return error message for mixtures (not yet implemented)
c  04-09-97  MM, add mixture calculations; restructure cases
c                add limits checks
c  04-22-97  MM, use h, rather than s, to compute q (h converges at p = 0)
c  05-15-97  MM, use V to compute q for comp. liq. (T,h can be double-valued),
c                add q = 998 case for t > Tc, but p < Pc
c  07-15-97  MM, renumber and add detail to error messages
c                get flags for 'not defined' from common /FLAGS/
c  10-01-97  MM, add compiler switch to allow access by DLL
c  10-16-97  MM, fix bug--out of range errors not caught properly
c  12-01-97  MM, error code not passed correctly if inputs out of range
c  02-11-98  MM, check that computed pressure is within bounds
c  03-05-99 EWL, remove check on pressure, and call LIMITX to check for
c                p>pmax or p>melt
c  12-16-02 EWL, add checks for pseudo-pure fluid, calculate p using q
c
cx DEC$ ATTRIBUTES DLLEXPORT :: TDFLSH
c
      include 'commons.for'
      character*255 herr,herr1,herr2,herrl
      dimension x(ncmax),y(ncmax),z(ncmax)
      dimension xbub(ncmax),xdew(ncmax),ybub(ncmax),ydew(ncmax)
c
      call ISPURE (z,icomp)
      ierr=0
      herr=' '
c
c  set output liquid and vapor compositions to input values
c  zero output values for undefined components
      if (icomp.eq.0) then
        do i=1,nc
          x(i)=z(i)
          y(i)=z(i)
        enddo
      else
        do i=1,nc
          x(i)=0.d0
          y(i)=0.d0
        enddo
        x(icomp)=1.d0
        y(icomp)=1.d0
      endif
c     if (nc.lt.ncmax) then
c       do i=nc+1,ncmax
c         x(i)=0.0d0
c         y(i)=0.0d0
c       enddo
c     end if
      if (d.lt.1.0d-14) then
c  ideal-gas
        p=D*R*t
        Dl=D
        Dv=D
        call THERM (t,D,z,ptherm,e,h,s,cv,cp,w,hjt)
        RETURN
      endif
c
c  check that input conditions are within limits
c
      pdum=0.0d0
      call LIMITX ('EOS',t,D,pdum,z,tmin,tmax,rhomax,pmax,ierrl,herrl)
      if (ierrl.lt.0) then
c  one or inputs are outside limits--if just a warning proceed w/ calc
        write (herr,1006) ierrl,herrl(1:234),hnull
 1006   format ('[TDFLSH warning',i3,'] ',a234,a1)
        call ERRMSG (ierrl,herr)
c  if error (as opposed to warning) set output density to zero and return
      else if (ierrl.gt.0) then
        write (herr,1007) ierrl,herrl(1:236),hnull
 1007   format ('[TDFLSH error',i3,'] ',a236,a1)
        call ERRMSG (ierrl,herr)
        q=999.d0     !quality undefined
        ierr=ierrl
        RETURN
      end if
c
      call CRITP (z,tc,pc,rhoc,ierr,herr2)
      if (ierr.gt.0) then
        ierr=220
        write (herr,1008) herr2(1:235),hnull
 1008   format ('[TDFLSH error 220] ',a235,a1)
        call ERRMSG (ierr,herr)
        q=999.d0     !quality undefined
        RETURN
      end if
c
      if (icomp.ne.0 .and. t.lt.ttpn(icomp)) then
c  temperature less than triple point temperature, but in the gas phase.
        call THERM (t,D,z,p,e,h,s,cv,cp,w,hjt)
        Dl=D
        Dv=D
      elseif (t.ge.tc .or. D.lt.1.0d-10) then
c  super-critical state or rho = 0 (x = y = z as set above)
        call THERM (t,D,z,p,e,h,s,cv,cp,w,hjt)
        Dl=D
        Dv=D
        if (p.le.pc) then
          q=998.d0     !superheated, but cannot define quality
        else
          q=999.d0     !quality undefined
        end if
      else
c  sub-critical state--call saturation routine to determine phase
        call SATT (t,z,2,pdew,Dldew,Dvdew,xdew,ydew,ierr,herr1)
        if (ierr.ne.0) then
          ierr=222
          write (herr,1222) herr1(1:193),hnull
 1222     format ('[TDFLSH error 222] dew point calculation ',
     &            'did not converge:  ',a193,a1)
          call ERRMSG (ierr,herr)
          D=0.0d0
          Dl=0.0d0
          Dv=0.0d0
          q=999.d0     !quality undefined
          RETURN
        end if
        if (icomp.ne.0 .and. ianc(icomp).eq.0) then
c  if pure, bubble point density provided by call to SATT at dew point
          Dlbub=Dldew
          Dvbub=Dvdew
          pbub=pdew
        else
c  if mixture, call saturation routine again at bubble point
          call SATT (t,z,1,pbub,Dlbub,Dvbub,xbub,ybub,ierr,herr1)
          if (ierr.ne.0) then
            ierr=221
            write (herr,1221) herr1(1:190),hnull
 1221       format ('[TPFLSH error 221] bubble point calculation ',
     &              'did not converge:  ',a190,a1)
            call ERRMSG (ierr,herr)
            D=0.0d0
            Dl=0.0d0
            Dv=0.0d0
            q=999.d0     !quality undefined
            RETURN
          end if
        end if
        if (D.le.Dvdew .or. D.ge.Dlbub) then
c  single-phase (liq or vapor) (pure or mixture) (x = y = z as set above)
          call THERM (t,D,z,p,e,h,s,cv,cp,w,hjt)
          Dl=D
          Dv=D
          call ENTHAL (t,Dvdew,z,hvdew)
c         call ENTHAL (t,Dlbub,z,hlbub)
c         q=(h-hlbub)/(hvdew-hlbub)
c  compute quality based on volumes (possible for T,h to be
c  double-valued in compressed liquid)
          if (abs(dvdew-dlbub).gt.1.d-12)
     &        q=(1.0d0/D-1.0d0/Dlbub)/(1.0d0/Dvdew-1.0d0/Dlbub)
        else
          if (icomp.ne.0) then
c  special case:  pure-fluid two-phase (x = y = z as set above)
            if (abs(dvdew-dlbub).gt.1.d-12)
     &          q=(1.0d0/D-1.0d0/Dlbub)/(1.0d0/Dvdew-1.0d0/Dlbub)
            p=q*pdew+(1.0d0-q)*pbub
            Dl=Dlbub
            Dv=Dvdew
          else
c  general case:  mixture 2-phase
            ksat=1   !bubble and dew point data provided to TDFL2
            call TDFL2 (t,D,z,ksat,pbub,pdew,Dlbub,Dvdew,ybub,xdew,
     &                  p,Dl,Dv,x,y,q,ierr,herr)
            if (ierr.ne.0) then
c  two-phase iteration did not converge--error message written by TDFL2
              q=999.d0     !quality undefined
              RETURN
            end if
c           write (*,1225) p,q,(x(i),i=1,3),(y(i),i=1,3)
c1225       format (1x,' TDFLSH--TDFL2 return   p,q,x,y = ',8f12.7)
          end if
c  compute remaining properties for 2-phase states
          call THERM (t,Dl,x,ptherm,el,hl,sl,cvl,cp,w,hjt)
          call THERM (t,Dv,y,ptherm,ev,hv,sv,cvv,cp,w,hjt)
          if (nc.ge.2) p=ptherm
          e=q*ev+(1.0d0-q)*el
          h=q*hv+(1.0d0-q)*hl
          s=q*sv+(1.0d0-q)*sl
          w=xnotd     !Cp,w not defined for 2-phase states
          cp=xnotd
          cv=xnotd
        end if
      end if
c
      call LIMITX ('EOS',t,D,p,z,tmin,tmax,rhomax,pmax,ierr,herrl)
      if (ierr.lt.0) then
c  one or inputs are outside limits--if just a warning proceed w/ calc
        write (herr,1006) ierr,herrl(1:234),hnull
        call ERRMSG (ierr,herr)
c  if error (as opposed to warning) set output density to zero and return
      else if (ierr.gt.0) then
        write (herr,1007) ierr,herrl(1:236),hnull
        call ERRMSG (ierr,herr)
        q=999.d0     !quality undefined
      end if
c
      RETURN
      end                                             !subroutine TDFLSH
c
c ======================================================================
c
      subroutine TDFL2 (t,D,z,ksat,pbub,pdew,Dlbub,Dvdew,ybub,xdew,
     &                  p,Dl,Dv,x,y,q,ierr,herr)
c
c  flash calculation given temperature, bulk density, and composition
c
c  This routine accepts only two-phase states as input; it is intended
c  primarily for use by the general temperature-density flash routine
c  TDFLSH.  It may be called independently if the state is known to be
c  two-phase.  But beware--this routine does not check limits, and it
c  will be significantly faster than TDFLSH only if the bubble and dew
c  point limits can be provided (ksat = 1 option).
c
c  inputs:
c        t--temperature [K]
c        D--overall (bulk) molar density [mol/L]
c        z--overall (bulk) composition [array of mol frac]
c     ksat--flag for bubble and dew point limits
c           0 = dew and bubble point limits computed here
c           1 = must provide values for the following:
c     pbub--bubble point pressure [kPa] at (t,x=z)
c     pdew--dew point pressure [kPa] at (t,y=z)
c    Dlbub--liquid density [mol/L] at bubble point
c    Dvdew--vapor density [mol/L] at dew point
c     ybub--vapor composition [array of mol frac] at bubble point
c     xdew--liquid composition [array of mol frac] at dew point
c
c  outputs:
c        p--pressure [kPa]
c       Dl--molar density [mol/L] of the liquid phase
c       Dv--molar density [mol/L] of the vapor phase
c        x--composition of liquid phase [array of mol frac]
c        y--composition of vapor phase [array of mol frac]
c        q--vapor quality on a MOLAR basis [moles vapor/total moles]
c     ierr--error flag:  0 = successful
c     herr--error string (character*255 variable if ierr<>0)
c
cx DEC$ ATTRIBUTES DLLEXPORT :: TDFL2
c
      include 'commons.for'
      character*255 herr
      dimension z(ncmax),x(ncmax),y(ncmax),xdew(ncmax),ybub(ncmax)
c
      call ABFL2 (t,d,z,1,ksat,'TD',
     &                 tbub,tdew,pbub,pdew,Dlbub,Dvdew,ybub,xdew,
     &                 tt,p,Dl,Dv,x,y,q,ierr,herr)
c
      RETURN
      end                                              !subroutine TDFL2
c
c ======================================================================
c
      subroutine PDFLSH (p,D,z,t,Dl,Dv,x,y,q,e,h,s,cv,cp,w,ierr,herr)
c
c  flash calculation given density, pressure, and bulk composition
c
c  This routine accepts both single-phase and two-phase states as the
c  input; for single-phase calculations, the subroutine PDFL1 is faster.
c
c  inputs:
c        D--overall (bulk) molar density [mol/L]
c        p--pressure [kPa]
c        z--overall (bulk) composition [array of mol frac]
c
c  outputs:
c        t--temperature [K]
c       Dl--molar density [mol/L] of the liquid phase
c       Dv--molar density [mol/L] of the vapor phase
c           if only one phase is present, Dl = Dv = D
c        x--composition of liquid phase [array of mol frac]
c        y--composition of vapor phase [array of mol frac]
c           if only one phase is present, x = y = z
c        q--vapor quality on a MOLAR basis [moles vapor/total moles]
c           q < 0 indicates subcooled (compressed) liquid
c           q = 0 indicates saturated liquid
c           q = 1 indicates saturated vapor
c           q > 1 indicates superheated vapor
c           q = 998 superheated vapor, but quality not defined (in most situations, t > Tc)
c           q = 999 indicates supercritical state (t > Tc) and (p > Pc)
c        e--overall (bulk) internal energy [J/mol]
c        h--overall (bulk) enthalpy [J/mol]
c        s--overall (bulk) entropy [J/mol-K]
c       Cv--isochoric (constant V) heat capacity [J/mol-K]
c       Cp--isobaric (constant p) heat capacity [J/mol-K]
c        w--speed of sound [m/s]
c           Cp, w are not defined for 2-phase states
c           in such cases, a flag = -9.99998d6 is returned
c     ierr--error flag:  0 = successful
c                      210 = CRITP did not converge
c                      211 = SATT did not converge at bubble point
c                      212 = SATT did not converge at dew point
c                      213 = TPRHO did not converge for liquid state
c                      214 = TPRHO did not converge for vapor state
c                      215 = TPRHO did not convg for supercritical state
c                      216 = TPRHO did not convg for liq in 2-phase it
c                      217 = TPRHO did not convg for vap in 2-phase it
c                      218 = liquid frac for 2-phase it did not converge
c                      219 = composition for 2-phase it did not converge
c     herr--error string (character*255 variable if ierr<>0)
c
c  written by E.W. Lemmon, NIST Thermophysics Division, Boulder, Colorado
c  03-03-99 EWL, original version
c  03-14-00 EWL, change name from DPFLSH to PDFLSH
c  05-25-00 EWL, set t=-1 in initial call to LIMITX
c  12-16-02 EWL, add checks for pseudo-pure fluid, calculate t using q
c  11-21-12 EWL, return q=-998 when p>pc and t<tc
c
cx DEC$ ATTRIBUTES DLLEXPORT :: PDFLSH
c
      include 'commons.for'
      character*255 herr,herr2,herrl
      dimension z(ncmax),x(ncmax),y(ncmax)
      dimension xdew(ncmax),ydew(ncmax),ybub(ncmax),xbub(ncmax)
c
      call ISPURE (z,icomp)
      ierr=0
      herr=' '
      t=0.d0
      Dl=0.d0
      Dv=0.d0
      e=0.d0
      h=0.d0
      s=0.d0
      cv=0.d0
      cp=0.d0
      w=0.d0
      q=999.0d0
c
c  initialize output liquid and vapor compositions to input values
c  zero output values for undefined components
      if (icomp.eq.0) then
        do i=1,nc
          x(i)=z(i)
          y(i)=z(i)
        enddo
      else
        do i=1,nc
          x(i)=0.d0
          y(i)=0.d0
        enddo
        x(icomp)=1.d0
        y(icomp)=1.d0
      endif
c     if (nc.lt.ncmax) then
c       do i=nc+1,ncmax
c         x(i)=0.0d0
c         y(i)=0.0d0
c       enddo
c     end if

      if (p.lt.1.0d-14 .or. d.lt.1.0d-14) then
c  ideal-gas
        if (D.gt.0.d0) t=p/(R*D)
        RETURN
      end if
c
c  check that input conditions are within limits
c
      call CRITP (z,tc,pc,rhoc,ierr,herr2)
      if (ierr.gt.0) then
        ierr=210
        write (herr,1008) herr2(1:235),hnull
 1008   format ('[PDFLSH error 210] ',a235,a1)
        call ERRMSG (ierr,herr)
        RETURN
      end if
c
      t=-1
      call LIMITX ('EOS',t,D,p,z,tmin,tmax,rhomax,pmax,ierrl,herrl)
      if (ierrl.lt.0) then
c  one or inputs are outside limits--if just a warning proceed w/ calc
        write (herr,1006) ierrl,herrl(1:234),hnull
 1006   format ('[PDFLSH warning',i3,'] ',a234,a1)
        call ERRMSG (ierrl,herr)
c  if error (as opposed to warning) set output density to zero and return
      else if (ierrl.gt.0) then
        write (herr,1007) ierrl,herrl(1:236),hnull
 1007   format ('[PDFLSH error',i3,'] ',a236,a1)
        call ERRMSG (ierrl,herr)
        ierr=ierrl
        RETURN
      end if
c
      if (p.ge.pc) then
c  supercritical state (x = y = z as set above)
c       write (*,*) ' PDFLSH--supercritical'
        call PDFL1 (p,D,z,t,ierr,herr2)
        if (ierr.ne.0) then
          ierr=215
          write (herr,1215) herr2(1:183),hnull
 1215     format ('[PDFLSH error 215] supercritical density iteration ',
     &            'did not converge:  ',a183,a1)
          call ERRMSG (ierr,herr)
          RETURN
        end if
        Dl=D
        Dv=D
        call THERM (t,D,z,ptherm,e,h,s,cv,cp,w,hjt)
        if (t.le.tc) q=-998.d0
      else
c  subcritical state--call saturation routine to determine liq or vap
        i=iprnterr
        iprnterr=0
        ierr=0
        Dvdew=D
        Dldew=D
        tdew=0
c  do not call SATP if P<triple point pressure for pure fluids
        if (icomp.eq.0 .or. p.gt.ptpn(icomp) .or. ianc(icomp).ne.0) then
          call SATP (p,z,2,tdew,Dldew,Dvdew,xdew,ydew,ierr,herr2)
        endif
        iprnterr=i
        iflag=0
        if (ierr.ne.0 .and. icomp.ne.0) then
          ierr=212
          write (herr,1212) herr2(1:193),hnull
 1212     format ('[PDFLSH error 212] dew point calculation ',
     &            'did not converge:  ',a193,a1)
          call ERRMSG (ierr,herr)
          RETURN
        elseif (ierr.ne.0) then
c  do not exit yet, check if valid liquid state
          iflag=1
        end if
        if (D.le.Dvdew+1.0d-12) then
c  single-phase vapor (x = y = z as set above)
c         write (*,*) ' PDFLSH--single-phase vapor'
          call PDFL1 (p,D,z,t,ierr,herr2)
          if (ierr.ne.0) then
            ierr=214
            write (herr,1214) herr2(1:190),hnull
 1214       format ('[PDFLSH error 214] vapor density iteration ',
     &              'did not converge:  ',a190,a1)
            call ERRMSG (ierr,herr)
            t=0.0d0
            RETURN
          end if
          Dl=D
          Dv=D
          call THERM (t,D,z,ptherm,e,h,s,cv,cp,w,hjt)
          q=998.d0
          if (tdew.gt.0 .and. ianc(icomp).eq.0) then
            call ENTHAL (tdew,Dldew,xdew,hldew)
            call ENTHAL (tdew,Dvdew,z,hvdew)
            q=(h-hldew)/(hvdew-hldew)
          endif
        else
c  mixture:  calculate bubble point to determine if liquid or 2-phase
          if (icomp.ne.0 .and. ianc(icomp).eq.0) then
            Dlbub=Dldew
            Dvbub=Dvdew
            tbub=tdew
          else
            call SATP (p,z,1,tbub,Dlbub,Dvbub,xbub,ybub,ierr,herr2)
          endif
          if (ierr.ne.0) then
            ierr=211
            write (herr,1211) herr2(1:190),hnull
 1211       format ('[PDFLSH error 211] bubble point calculation ',
     &              'did not converge:  ',a190,a1)
            call ERRMSG (ierr,herr)
            RETURN
          end if
          if (D.gt.Dlbub) then
c  mixture single-phase liquid
c           write (*,*) ' TPFLSH--mixture single-phase liquid'
            call PDFL1 (p,D,z,t,ierr,herr2)
            if (ierr.ne.0) then
              ierr=213
              write (herr,1213) herr2(1:189),hnull
 1213         format ('[PDFLSH error 213] liquid density iteration ',
     &                'did not converge:  ',a189,a1)
              call ERRMSG (ierr,herr)
              t=0.0d0
              RETURN
            end if
            Dl=D
            Dv=D
            call THERM (t,D,z,ptherm,e,h,s,cv,cp,w,hjt)
c  compute quality based on volumes
            q=(1.0d0/D-1.0d0/Dlbub)/(1.0d0/Dvdew-1.0d0/Dlbub)
c           write (*,*) ' PDFLSH--comp liq q by volumes:  ',q
          else
c
c  two-phase pure fluid
            if (icomp.ne.0) then
              Dl=Dlbub
              Dv=Dvdew
              q=(1.0d0/D-1.0d0/Dl)/(1.0d0/Dv-1.0d0/Dl)
              t=(1.d0-q)*tbub+q*tdew
              if (ianc(icomp).eq.1) call PTANC (t,p,q,d,'D',Dl,Dv)
c  two-phase mixture
c             write (*,*) ' PDFLSH--two-phase mixture'
c
c  generate initial guesses for x and y by interpolating input pressure
c  with dew and bubble point pressures
c
            else
              if (iflag.eq.1) then
c  dew point did not converge, location of state point is either two-phase
c  or vapor phase
                ierr=212
                write (herr,1212) herr2(1:193),hnull
                call ERRMSG (ierr,herr)
                t=0.0d0
                RETURN
              endif
              ksat=1   !bubble and dew point data provided to PDFL2
              call PDFL2 (p,D,z,ksat,tbub,tdew,Dlbub,Dvdew,ybub,xdew,
     &                    t,Dl,Dv,x,y,q,ierr,herr)
              if (ierr.ne.0) then
c  two-phase iteration did not converge--error message written by PDFL2
                q=999.d0     !quality undefined
                RETURN
              end if
c             write (*,1225) p,q,(x(i),i=1,3),(y(i),i=1,3)
c1225         format (1x,' TDFLSH--TDFL2 return   p,q,x,y = ',8f12.7)
            endif
            call THERM (t,Dl,x,ptherm,el,hl,sl,cv,cp,w,hjt)
            call THERM (t,Dv,y,ptherm,ev,hv,sv,cv,cp,w,hjt)
            cp=xnotd                   !Cp, w not defined for 2-phase
            w=xnotd
            cv=xnotd
c  bulk properties are weighted average of liquid and vapor phases
            alpha=1.0d0-q               !alpha is liq fraction,
            e=alpha*el+q*ev
            h=alpha*hl+q*hv
            s=alpha*sl+q*sv
          end if
        end if
      end if
c
c  if limits check resulted in warning (as opposed to error) return
c  that message; do this again in case intermediate iteration did not
c  converge (thereby overwriting any warning message from LIMITX)
c
      call LIMITX ('EOS',t,D,p,z,tmin,tmax,rhomax,pmax,ierrl,herrl)
      if (ierrl.lt.0) then
c  one or inputs are outside limits--if just a warning proceed w/ calc
        ierr=ierrl
        write (herr,2006) ierrl,herrl(1:234),hnull
 2006   format ('[PDFLSH warning',i3,'] ',a234,a1)
        call ERRMSG (ierr,herr)
c  if error (as opposed to warning) set output density to zero and return
      else if (ierrl.gt.0) then
        write (herr,1007) ierrl,herrl(1:236),hnull
        ierr=ierrl
        call ERRMSG (ierrl,herr)
        RETURN
      end if
c
      RETURN
      end                                             !subroutine PDFLSH
c
c ======================================================================
c
      subroutine PDFL1 (p,rho,x,t,ierr,herr)
c
c  iterate for single-phase temperature as a function of density, pressure,
c  and composition
c
c  inputs:
c      rho--molar density [mol/L]
c        p--pressure [kPa]
c        x--composition [array of mol frac]
c
c  outputs:
c        t--temperature [K]
c     ierr--error flag:  0 = successful
c     herr--error string (character*255 variable if ierr<>0)
c
cx DEC$ ATTRIBUTES DLLEXPORT :: PDFL1
c
      include 'commons.for'
      character*255 herr
      dimension x(ncmax)
c
      call ABFL1 (rho,p,x,0,'DP',0.d0,0.d0,t,pp,dd,ierr,herr)
      RETURN
      end                                              !subroutine PDFL1
c
c ======================================================================
c
      subroutine PDFL2 (p,d,z,ksat,tbub,tdew,Dlbub,Dvdew,ybub,xdew,
     &                  t,Dl,Dv,x,y,q,ierr,herr)
c
c  flash calculation given pressure, bulk density, and composition
c
c  This routine accepts only two-phase states as input; it is intended
c  primarily for use by the general pressure-density flash routine
c  PDFLSH.  It may be called independently if the state is known to be
c  two-phase.  But beware--this routine does not check limits, and it
c  will be significantly faster than PDFLSH only if the bubble and dew
c  point limits can be provided (ksat = 1 option).
c
c  inputs:
c        p--pressure [kPa]
c        d--overall (bulk) density [mol/L]
c        z--overall (bulk) composition [array of mol frac]
c     ksat--flag for bubble and dew point limits
c           0 = dew and bubble point limits computed here
c           1 = must provide values for the following:
c     tbub--bubble point temperature [K] at (p,x=z)
c     tdew--dew point temperature [K] at (p,y=z)
c    Dlbub--liquid density [mol/L] at bubble point
c    Dvdew--vapor density [mol/L] at dew point
c     ybub--vapor composition [array of mol frac] at bubble point
c     xdew--liquid composition [array of mol frac] at dew point
c
c  outputs:
c        t--temperature [K]
c       Dl--molar density [mol/L] of the liquid phase
c       Dv--molar density [mol/L] of the vapor phase
c        x--composition of liquid phase [array of mol frac]
c        y--composition of vapor phase [array of mol frac]
c        q--vapor quality on a MOLAR basis [moles vapor/total moles]
c     ierr--error flag:  0 = successful
c     herr--error string (character*255 variable if ierr<>0)
c
cx DEC$ ATTRIBUTES DLLEXPORT :: PDFL2
c
      include 'commons.for'
      character*255 herr
      dimension z(ncmax),x(ncmax),y(ncmax),xdew(ncmax),ybub(ncmax)
c
      call ABFL2 (p,d,z,1,ksat,'PD',
     &                  tbub,tdew,pbub,pdew,Dlbub,Dvdew,ybub,xdew,
     &                  t,pp,Dl,Dv,x,y,q,ierr,herr)
c
      RETURN
      end                                              !subroutine PDFL2
c
c ======================================================================
c
      subroutine PHFLSH (p,h,z,t,D,Dl,Dv,x,y,q,e,s,cv,cp,w,ierr,herr)
c
c  flash calculation given pressure, bulk enthalpy, and bulk composition
c
c  inputs:
c        p--pressure [kPa]
c        h--overall (bulk) enthalpy [J/mol]
c        z--composition [array of mol frac]
c
c  outputs:
c        t--temperature [K]
c        D--overall (bulk) molar density [mol/L]
c       Dl--molar density [mol/L] of the liquid phase
c       Dv--molar density [mol/L] of the vapor phase
c           if only one phase is present, Dl = Dv = D
c        x--composition [array of mol frac] for liquid phase
c        y--composition [array of mol frac] for vapor phase
c           if only one phase is present, x = y = z
c        q--vapor quality on a MOLAR basis [moles vapor/total moles]
c           q < 0 indicates subcooled (compressed) liquid
c           q = 0 indicates saturated liquid
c           q = 1 indicates saturated vapor
c           q > 1 indicates superheated vapor
c           q = -998 subcooled liquid, but quality not defined (p > Pc)
c           q = 999 indicates supercritical state (t > Tc) and (p > Pc)
c        e--overall (bulk) internal energy [J/mol]
c        s--overall (bulk) entropy [J/mol-K]
c       Cv--isochoric (constant V) heat capacity [J/mol-K]
c       Cp--isobaric (constant p) heat capacity [J/mol-K]
c        w--speed of sound [m/s]
c           Cp, w are not defined for 2-phase states
c           in such cases, a flag = -9.99998d6 is returned
c     ierr--error flag:  0 = successful (see PBFLSH for others)
c     herr--error string (character*255 variable if ierr<>0)
c
c  written by M. McLinden, NIST Thermophysics Division, Boulder, Colorado
c  09-20-95  MM, original version
c  09-25-95  MM, rearrange argument list (outputs in order rho, x, q)
c  10-11-95  MM, correct: t not returned for two-phase pure-component
c  10-11-95  MM, RETURN if any error detected
c  11-29-95  MM, variable lower limit on coefficient/constant arrays
c                to accommodate ECS reference fluid
c  12-13-95  MM, set undefined output compositions to zero
c  02-27-96  MM, parameter n0=-ncmax to accommodate ECS-thermo model
c  01-07-97  MM, error message bug (do not concatenate herr with itself)
c  04-30-97  MM, restructure logic to parallel TDFLSH
c  05-15-97  MM, add q = -998 case for p > Pc, but t < Tc
c  05-21-97  MM, call ENTHAL at rho = 1d-10 to define hmax
c  07-15-97  MM, renumber and add detail to error messages
c                get flags for 'not defined' from common /FLAGS/
c  10-01-97  MM, add compiler switch to allow access by DLL
c  10-16-97  MM, evaluate hmin at p = 100 kPa, rather than p = pmax
c  02-11-98  MM, check that computed density is within bounds
c  05-25-00 EWL, call limitx with tdum=-1 to avoid check on tmelt
c  05-26-00 EWL, check for p<ptrp after calling SATP
c  06-06-00  MM, input h may have been changed by call to THERM
c  08-20-00 EWL, change initial guess from tc to tc+10
c  01-18-01 EWL, remove code and call generic PBFLSH
c
cx DEC$ ATTRIBUTES DLLEXPORT :: PHFLSH
c
      include 'commons.for'
      character*255 herr
      dimension x(ncmax),y(ncmax),z(ncmax)
c
      call PBFLSH (p,h,z,'PH',t,D,Dl,Dv,x,y,q,e,hh,s,cv,cp,w,ierr,herr)
      RETURN
      end                                             !subroutine PHFLSH
c
c ======================================================================
c
      subroutine PHFL1 (p,h,x,kph,t,D,ierr,herr)
c
c  flash calculation given pressure, enthalpy, and composition.  This routine
c  accepts only single-phase inputs, it is intended primarily for use with
c  the more general flash routine PHFLSH.
c
c  inputs:
c        p--pressure [kPa]
c        h--enthalpy [J/mol]
c        x--composition [array of mol frac]
c      kph--phase flag:  1 = liquid
c                        2 = vapor
c        t--initial guess for temperature [K]
c        D--initial guess for molar density [mol/L]
c
c  outputs:
c        t--temperature [K]
c        D--molar density [mol/L]
c     ierr--error flag:  0 = successful
c     herr--error string (character*255 variable if ierr<>0)
c
cx DEC$ ATTRIBUTES DLLEXPORT :: PHFL1
c
      include 'commons.for'
      character*255 herr
      dimension x(ncmax)
c
      call ABFL1 (p,h,x,kph,'PH',0.d0,0.d0,t,pp,D,ierr,herr)
      RETURN
      end                                              !subroutine PHFL1
c
c ======================================================================
c
      subroutine PHFL2 (p,h,z,ksat,tbub,tdew,Dlbub,Dvdew,ybub,xdew,
     &                  t,Dl,Dv,x,y,q,ierr,herr)
c
c  flash calculation given pressure, bulk enthalpy, and composition
c
c  This routine accepts only two-phase states as input; it is intended
c  primarily for use by the general pressure-enthalpy flash routine
c  PHFLSH.  It may be called independently if the state is known to be
c  two-phase.  But beware--this routine does not check limits, and it
c  will be significantly faster than PHFLSH only if the bubble and dew
c  point limits can be provided (ksat = 1 option).
c
c  inputs:
c        p--pressure [kPa]
c        h--overall (bulk) molar enthalpy [J/mol]
c        z--overall (bulk) composition [array of mol frac]
c     ksat--flag for bubble and dew point limits
c           0 = dew and bubble point limits computed here
c           1 = must provide values for the following:
c     tbub--bubble point temperature [K] at (p,x=z)
c     tdew--dew point temperature [K] at (p,y=z)
c    Dlbub--liquid density [mol/L] at bubble point
c    Dvdew--vapor density [mol/L] at dew point
c     ybub--vapor composition [array of mol frac] at bubble point
c     xdew--liquid composition [array of mol frac] at dew point
c
c  outputs:
c        t--temperature [K]
c       Dl--molar density [mol/L] of the liquid phase
c       Dv--molar density [mol/L] of the vapor phase
c        x--composition of liquid phase [array of mol frac]
c        y--composition of vapor phase [array of mol frac]
c        q--vapor quality on a MOLAR basis [moles vapor/total moles]
c     ierr--error flag:  0 = successful
c     herr--error string (character*255 variable if ierr<>0)
c
cx DEC$ ATTRIBUTES DLLEXPORT :: PHFL2
c
      include 'commons.for'
      character*255 herr
      dimension z(ncmax),x(ncmax),y(ncmax),xdew(ncmax),ybub(ncmax)
c
      call ABFL2 (p,h,z,1,ksat,'PH',
     &                  tbub,tdew,pbub,pdew,Dlbub,Dvdew,ybub,xdew,
     &                  t,pp,Dl,Dv,x,y,q,ierr,herr)
c
      RETURN
      end                                              !subroutine PHFL2
c
c ======================================================================
c
      subroutine PSFLSH (p,s,z,t,D,Dl,Dv,x,y,q,e,h,cv,cp,w,ierr,herr)
c
c  flash calculation given pressure, bulk entropy, and bulk composition
c
c  inputs:
c        p--pressure [kPa]
c        s--overall (bulk) entropy [J/mol-K]
c        z--composition array (mol frac)
c
c  outputs:
c        t--temperature [K]
c        D--overall (bulk) molar density [mol/L]
c       Dl--molar density [mol/L] of the liquid phase
c       Dv--molar density [mol/L] of the vapor phase
c           if only one phase is present, Dl = Dv = D
c        x--composition [array of mol frac] for liquid phase
c        y--composition [array of mol frac] for vapor phase
c           if only one phase is present, xl = xv = x
c        q--vapor quality on a MOLAR basis [moles vapor/total moles]
c           q < 0 indicates subcooled (compressed) liquid
c           q = 0 indicates saturated liquid
c           q = 1 indicates saturated vapor
c           q > 1 indicates superheated vapor
c           q = -998 subcooled liquid, but quality not defined (p > Pc)
c           q = 999 indicates supercritical state (t > Tc) and (p > Pc)
c        e--overall (bulk) internal energy [J/mol]
c        h--overall (bulk) enthalpy [J/mol]
c       Cv--isochoric (constant V) heat capacity [J/mol-K]
c       Cp--isobaric (constant p) heat capacity [J/mol-K]
c        w--speed of sound [m/s]
c           Cp, w are not defined for 2-phase states
c           in such cases, a flag = -9.99998d6 is returned
c     ierr--error flag:  0 = successful (see PBFLSH for others)
c     herr--error string (character*255 variable if ierr<>0)
c
c  written by M. McLinden, NIST Thermophysics Division, Boulder, Colorado
c  09-22-95  MM, original version
c  09-25-95  MM, rearrange argument list (outputs in order rho, x, q)
c  10-11-95  MM, RETURN if any error detected
c  11-29-95  MM, variable lower limit on coefficient/constant arrays
c                to accommodate ECS reference fluid
c  12-13-95  MM, set undefined output compositions to zero
c  02-27-96  MM, parameter n0=-ncmax to accommodate ECS-thermo model
c  01-07-97  MM, error message bug (do not concatenate herr with itself)
c  05-01-97  MM, restructure logic to parallel TDFLSH, PHFLSH
c  05-15-97  MM, add q = -998 case for p > Pc, but t < Tc
c  07-15-97  MM, renumber and add detail to error messages
c                get flags for 'not defined' from common /FLAGS/
c  10-01-97  MM, add compiler switch to allow access by DLL
c  10-16-97  MM, evaluate smin at p = 100 kPa, rather than p = pmax
c  02-11-98  MM, check that computed density is within bounds
c  03-31-00 EWL, call limitx at very end to ensure that p<pmelt and d<dmax
c  03-31-00 EWL, if routine for p>pc fails, try another initial t before quitting
c  05-26-00 EWL, check for p<ptrp after calling SATP
c  06-06-00  MM, inputs may have been changed by call to THERM
c  01-18-01 EWL, remove code and call generic PBFLSH
c
cx DEC$ ATTRIBUTES DLLEXPORT :: PSFLSH
c
      include 'commons.for'
      character*255 herr
      dimension x(ncmax),y(ncmax),z(ncmax)
c
      call PBFLSH (p,s,z,'PS',t,D,Dl,Dv,x,y,q,e,h,ss,cv,cp,w,ierr,herr)
      RETURN
      end                                             !subroutine PSFLSH
c
c ======================================================================
c
      subroutine PSFL1 (p,s,x,kph,t,D,ierr,herr)
c
c  flash calculation given pressure, entropy, and composition.  This routine
c  accepts only single-phase inputs, it is intended primarily for use with
c  the more general flash routine PSFLSH.
c
c  inputs:
c        p--pressure [kPa]
c        s--entropy [J/mol-K]
c        x--composition [array of mol frac]
c      kph--phase flag:  1 = liquid
c                        2 = vapor
c        t--initial guess for temperature [K]
c        D--initial guess for molar density [mol/L]
c
c  outputs:
c        t--temperature [K]
c        D--molar density [mol/L]
c     ierr--error flag:  0 = successful
c     herr--error string (character*255 variable if ierr<>0)
c
cx DEC$ ATTRIBUTES DLLEXPORT :: PSFL1
c
      include 'commons.for'
      character*255 herr
      dimension x(ncmax)
c
      call ABFL1 (p,s,x,kph,'PS',0.d0,0.d0,t,pp,D,ierr,herr)
      RETURN
      end                                              !subroutine PSFL1
c
c ======================================================================
c
      subroutine PSFL2 (p,s,z,ksat,tbub,tdew,Dlbub,Dvdew,ybub,xdew,
     &                  t,Dl,Dv,x,y,q,ierr,herr)
c
c  flash calculation given pressure, bulk entropy, and composition
c
c  This routine accepts only two-phase states as input; it is intended
c  primarily for use by the general pressure-entropy flash routine
c  PSFLSH.  It may be called independently if the state is known to be
c  two-phase.  But beware--this routine does not check limits, and it
c  will be significantly faster than PSFLSH only if the bubble and dew
c  point limits can be provided (ksat = 1 option).
c
c  inputs:
c        p--pressure [kPa]
c        s--overall (bulk) molar entropy [J/mol-K]
c        z--overall (bulk) composition [array of mol frac]
c     ksat--flag for bubble and dew point limits
c           0 = dew and bubble point limits computed here
c           1 = must provide values for the following:
c     tbub--bubble point temperature [K] at (p,x=z)
c     tdew--dew point temperature [K] at (p,y=z)
c    Dlbub--liquid density [mol/L] at bubble point
c    Dvdew--vapor density [mol/L] at dew point
c     ybub--vapor composition [array of mol frac] at bubble point
c     xdew--liquid composition [array of mol frac] at dew point
c
c  outputs:
c        t--temperature [K]
c       Dl--molar density [mol/L] of the liquid phase
c       Dv--molar density [mol/L] of the vapor phase
c        x--composition of liquid phase [array of mol frac]
c        y--composition of vapor phase [array of mol frac]
c        q--vapor quality on a MOLAR basis [moles vapor/total moles]
c     ierr--error flag:  0 = successful
c     herr--error string (character*255 variable if ierr<>0)
c
cx DEC$ ATTRIBUTES DLLEXPORT :: PSFL2
c
      include 'commons.for'
      character*255 herr
      dimension z(ncmax),x(ncmax),y(ncmax),xdew(ncmax),ybub(ncmax)
c
      call ABFL2 (p,s,z,1,ksat,'PS',
     &                 tbub,tdew,pbub,pdew,Dlbub,Dvdew,ybub,xdew,
     &                 t,pp,Dl,Dv,x,y,q,ierr,herr)
c
      RETURN
      end                                              !subroutine PSFL2
c
c ======================================================================
c
      subroutine PEFLSH (p,e,z,t,D,Dl,Dv,x,y,q,h,s,cv,cp,w,ierr,herr)
c
c  flash calculation given pressure, bulk energy, and bulk composition
c
c  inputs:
c        p--pressure [kPa]
c        e--overall (bulk) internal energy [J/mol]
c        z--composition [array of mol frac]
c
c  outputs:
c        t--temperature [K]
c        D--overall (bulk) molar density [mol/L]
c       Dl--molar density [mol/L] of the liquid phase
c       Dv--molar density [mol/L] of the vapor phase
c           if only one phase is present, Dl = Dv = D
c        x--composition [array of mol frac] for liquid phase
c        y--composition [array of mol frac] for vapor phase
c           if only one phase is present, x = y = z
c        q--vapor quality on a MOLAR basis [moles vapor/total moles]
c           q < 0 indicates subcooled (compressed) liquid
c           q = 0 indicates saturated liquid
c           q = 1 indicates saturated vapor
c           q > 1 indicates superheated vapor
c           q = -998 subcooled liquid, but quality not defined (p > Pc)
c           q = 999 indicates supercritical state (t > Tc) and (p > Pc)
c        h--overall (bulk) enthalpy [J/mol]
c        s--overall (bulk) entropy [J/mol-K]
c       Cv--isochoric (constant V) heat capacity [J/mol-K]
c       Cp--isobaric (constant p) heat capacity [J/mol-K]
c        w--speed of sound [m/s]
c           Cp, w are not defined for 2-phase states
c           in such cases, a flag = -9.99998d6 is returned
c     ierr--error flag:  0 = successful (see PBFLSH)
c     herr--error string (character*255 variable if ierr<>0)
c
c  written by E.W. Lemmon, NIST Thermophysics Division, Boulder, Colorado
c  01-18-01 EWL, original version
c
cx DEC$ ATTRIBUTES DLLEXPORT :: PEFLSH
c
      include 'commons.for'
      character*255 herr
      dimension x(ncmax),y(ncmax),z(ncmax)
c
      call PBFLSH (p,e,z,'PE',t,D,Dl,Dv,x,y,q,ee,h,s,cv,cp,w,ierr,herr)
      RETURN
      end                                             !subroutine PEFLSH
c
c ======================================================================
c
      subroutine PEFL1 (p,e,x,kph,t,D,ierr,herr)
c
c  flash calculation given pressure, energy, and composition.  This routine
c  accepts only single-phase inputs, it is intended primarily for use with
c  the more general flash routine PEFLSH.
c
c  inputs:
c        p--pressure [kPa]
c        e--energy [J/mol]
c        x--composition [array of mol frac]
c      kph--phase flag:  1 = liquid
c                        2 = vapor
c        t--initial guess for temperature [K]
c        D--initial guess for molar density [mol/L]
c
c  outputs:
c        t--temperature [K]
c        D--molar density [mol/L]
c     ierr--error flag:  0 = successful
c     herr--error string (character*255 variable if ierr<>0)
c
cx DEC$ ATTRIBUTES DLLEXPORT :: PEFL1
c
      include 'commons.for'
      character*255 herr
      dimension x(ncmax)
c
      call ABFL1 (p,e,x,kph,'PE',0.d0,0.d0,t,pp,D,ierr,herr)
      RETURN
      end                                              !subroutine PEFL1
c
c ======================================================================
c
      subroutine PEFL2 (p,e,z,ksat,tbub,tdew,Dlbub,Dvdew,ybub,xdew,
     &                  t,Dl,Dv,x,y,q,ierr,herr)
c
c  flash calculation given pressure, bulk energy, and composition
c
c  This routine accepts only two-phase states as input; it is intended
c  primarily for use by the general pressure-energy flash routine
c  PEFLSH.  It may be called independently if the state is known to be
c  two-phase.  But beware--this routine does not check limits, and it
c  will be significantly faster than PEFLSH only if the bubble and dew
c  point limits can be provided (ksat = 1 option).
c
c  inputs:
c        p--pressure [kPa]
c        e--overall (bulk) molar energy [J/mol]
c        z--overall (bulk) composition [array of mol frac]
c     ksat--flag for bubble and dew point limits
c           0 = dew and bubble point limits computed here
c           1 = must provide values for the following:
c     tbub--bubble point temperature [K] at (p,x=z)
c     tdew--dew point temperature [K] at (p,y=z)
c    Dlbub--liquid density [mol/L] at bubble point
c    Dvdew--vapor density [mol/L] at dew point
c     ybub--vapor composition [array of mol frac] at bubble point
c     xdew--liquid composition [array of mol frac] at dew point
c
c  outputs:
c        t--temperature [K]
c       Dl--molar density [mol/L] of the liquid phase
c       Dv--molar density [mol/L] of the vapor phase
c        x--composition of liquid phase [array of mol frac]
c        y--composition of vapor phase [array of mol frac]
c        q--vapor quality on a MOLAR basis [moles vapor/total moles]
c     ierr--error flag:  0 = successful
c     herr--error string (character*255 variable if ierr<>0)
c
cx DEC$ ATTRIBUTES DLLEXPORT :: PEFL2
c
      include 'commons.for'
      character*255 herr
      dimension z(ncmax),x(ncmax),y(ncmax),xdew(ncmax),ybub(ncmax)
c
      call ABFL2 (p,e,z,1,ksat,'PE',
     &                  tbub,tdew,pbub,pdew,Dlbub,Dvdew,ybub,xdew,
     &                  t,pp,Dl,Dv,x,y,q,ierr,herr)
c
      RETURN
      end                                              !subroutine PEFL2
c
c ======================================================================
c
      subroutine PBFLSH (p,b,z,ab,t,D,Dl,Dv,x,y,q,e,h,s,cv,cp,w,
     &                   ierr,herr)
c
c  flash calculation given pressure, bulk composition, and either
c  enthalpy, entropy, or energy
c
c  inputs:
c        p--pressure [kPa]
c        b--second property (energy, enthalpy, or entropy)
c        z--composition array (mol frac)
c       ab--character*2 string defining the inputs: 'PH', 'PS', or 'PE'
c
c  outputs:
c        t--temperature [K]
c        D--overall (bulk) molar density [mol/L]
c       Dl--molar density [mol/L] of the liquid phase
c       Dv--molar density [mol/L] of the vapor phase
c           if only one phase is present, Dl = Dv = D
c        x--composition [array of mol frac] for liquid phase
c        y--composition [array of mol frac] for vapor phase
c           if only one phase is present, x = y = z
c        q--vapor quality on a MOLAR basis [moles vapor/total moles]
c           q < 0 indicates subcooled (compressed) liquid
c           q = 0 indicates saturated liquid
c           q = 1 indicates saturated vapor
c           q > 1 indicates superheated vapor
c           q = -998 subcooled liquid, but quality not defined (p > Pc)
c           q = 999 indicates supercritical state (t > Tc) and (p > Pc)
c        e--overall (bulk) internal energy [J/mol]
c        h--overall (bulk) enthalpy [J/mol]
c        s--overall (bulk) entropy [J/mol-K]
c       Cv--isochoric (constant V) heat capacity [J/mol-K]
c       Cp--isobaric (constant p) heat capacity [J/mol-K]
c        w--speed of sound [m/s]
c           Cp, w are not defined for 2-phase states
c           in such cases, a flag = -9.99998d6 is returned
c     ierr--error flag:  0 = successful
c                        4 = Pin < 0
c                        8 = x out of range (< 0 or > 1)
c                       12 = x out of range and P < 0
c                      240 = CRITP did not converge
c                      241 = SATP did not converge at bubble point
c                      242 = SATP did not converge at dew point
c                      243 = SATP (bubble pt) did not converge for 2-ph
c                      244 = SATP (dew pt) did not converge for 2-phase
c                      245 = TPFL2 did not converge
c                      246 = 2-phase iteration did not converge
c                      247 = TPRHO did not converge for single-phase
c                      248 = single-phase iteration did not converge
c                      249 = H out of range
c                      250 = S out of range
c     herr--error string (character*255 variable if ierr<>0)
c
c  rewritten by E.W. Lemmon, NIST Physical & Chemical Properties Div, Boulder, CO
c  01-18-01 EWL, original version, rewritten by combining code of McLinden
c                from PHFLSH and PSFLSH routines to make one unified routine
c  05-16-01 EWL, add checks for h and s in the single phase
c  11-07-02 EWL, check for bmin>bmax
c  12-16-02 EWL, add checks for pseudo-pure fluid, calculate t using q
c  02-12-09 EWL, add check for solid phase for pure fluid when t<tmin (below sublimation line)
c  02-17-09 EWL, add check between ttrp and tmelt
c  04-28-10 EWL, remove call to SATT with tbub for pure fluid
c  04-29-10 EWL, check for dldew=0 in call to SATP that occurs when p<p_triple
c  05-17-11 EWL, add check for ierr2>0 on first call to TPRHO
c  08-15-11 EWL, add check for b<bmin for water mixtures
c  11-21-12 EWL, specify better values of q after call to ABFL1
c  11-26-12 EWL, if point is vapor phase, skip calculation of bubble point
c
cx DEC$ ATTRIBUTES DLLEXPORT :: PBFLSH
c
      include 'commons.for'
      character*1 bt
      character*2 ab
      character*255 herr,herr1,herr2
      dimension x(ncmax),y(ncmax),z(ncmax),
     &          xdew(ncmax),ydew(ncmax),xbub(ncmax),ybub(ncmax)
c
      bt=ab(2:2)
      call ISPURE (z,icomp)
      ierr=0
      herr=' '
      D=0.d0
      Dl=0.d0
      Dv=0.d0
c
c  set output liquid and vapor compositions to input values
c  zero output values for undefined components
      if (icomp.eq.0) then
        do i=1,nc
          x(i)=z(i)
          y(i)=z(i)
        enddo
      else
        do i=1,nc
          x(i)=0.d0
          y(i)=0.d0
        enddo
        x(icomp)=1.d0
        y(icomp)=1.d0
      endif
c
      call CRITP (z,tc,pc,Dc,ierr,herr1)
      t=tc
      if (ierr.gt.0) then
        ierr=240
        write (herr,1002) ab,herr1(1:234),hnull
 1002   format ('[',a2,'FLSH error 240] ',a234,a1)
        call ERRMSG (ierr,herr)
        q=999.d0     !quality undefined
        RETURN
      end if
c
c  check that input conditions are within limits
c
      tdum=-1.0d0
      Ddum=0.0d0
      call LIMITX ('EOS',tdum,Ddum,p,z,tmin,tmax,Dmax,pmax,ierr,herr1)
c  calculate approx limits:
c  lower limit at (tmin,pmax); upper limit at (1.5tmax,rho = 0)
c  !MM, 10-16-97, because of curvature of isotherms, h at pmax is not
c  the minimum, use a lower pressure instead

      p0=100.0d0 !kPa
 10   continue
      call TPRHO (tmin,p0,z,1,0,D0,ierr2,herr2)
      if (ierr2.gt.0) then
        tmin=tmin+5
        goto 10
      endif
      if (bt.eq.'H') call ENTHAL (tmin,D0,z,bmin)
      if (bt.eq.'E') call ENERGY (tmin,D0,z,bmin)
      if (bt.eq.'S') call ENTRO  (tmin,D0,z,bmin)
      if (bt.eq.'S' .and. icomp.ne.0) then
c  check in small region below the triple point temperature and above the melting line
        tmlt=0.d0
        if (hcas(icomp).eq.'7732-18-5') tmlt=251.18d0 !water
        if (hcas(icomp).eq.'124-38-9' ) tmlt=244.8d0  !co2
        if (hcas(icomp).eq.'7664-41-7') tmlt=200.2d0  !ammonia
        if (hcas(icomp).eq.'7440-59-7') tmlt=2.178d0  !helium
        if (tmlt.gt.0.d0) then
          call MELTT (tmlt,z,pmlt,ierr2,herr2)
          if (ierr2.eq.0) then
            call TPRHO (tmlt,pmlt,z,1,0,D0,ierr2,herr2)
            if (ierr2.eq.0) then
              call ENTRO (tmlt,D0,z,bmin2)
              if (abs(bmin2).gt.1.d-20 .and. bmin2.lt.bmin) bmin=bmin2
            endif
          endif
        endif
      endif
      tmax=1.5d0*tmax
      rho0=1.0d-6
      if (bt.eq.'H') call ENTHAL (tmax,rho0,z,bmax)
      if (bt.eq.'S') call ENTRO  (tmax,rho0,z,bmax)
      if (bt.eq.'E') call ENERGY (tmax,rho0,z,bmax)
      if (bmin.gt.bmax) then
c  just in case tmin was so low that the EOS did weird things, raise tmin:
        tmin=tmin+20
        call TPRHO (tmin,p0,z,1,0,D0,ierr2,herr2)
        if (bt.eq.'H') call ENTHAL (tmin,D0,z,bmin)
        if (bt.eq.'S') call ENTRO  (tmin,D0,z,bmin)
        if (bt.eq.'E') call ENERGY (tmin,D0,z,bmin)
      endif
c  for mixtures with water, the H/E/S values can loop back on itself on a T-b
c  diagram, thus the minimum b will not be at the low T, but slightly higher.
c  this will not return the exact point since there will be even lower values
c  of b at high pressures
      if (b.lt.bmin) then
        tminw=tmin
 20     continue
        tminw=tminw+1.d0
        call TPRHO (tminw,p0,z,1,1,D0,ierr2,herr2)
        if (bt.eq.'H') call ENTHAL (tminw,D0,z,bminw)
        if (bt.eq.'S') call ENTRO  (tminw,D0,z,bminw)
        if (bt.eq.'E') call ENERGY (tminw,D0,z,bminw)
        if (bminw.lt.bmin .and. ierr2.eq.0) then
          bmin=bminw
          goto 20
        endif
        if (abs(tminw-tmin).gt.1.1d0) bmin=bmin-2.d0*(bminw-bmin)   !Decrease slightly to include saturated state points missed by using an increment of 1 K.
      endif

c     write (*,1004) tmin,tmax,bmin,bmax
c1004 format (1x,' ABFLSH--limits on t,b:  ',2f8.2,2f12.2)
c  if inputs are outside limits set outputs equal to critical
c  point values and return
      if (ierr.lt.-1) then     !ignore ierr = -1 (t out of range)
c  one or inputs are outside limits--if just a warning proceed w/ calc
        write (herr,1006) ab,ierr,herr1(1:233),hnull
 1006   format ('[',a2,'FLSH warning',i4,'] ',a233,a1)
        call ERRMSG (ierr,herr)
      else
        if (ierr.gt.1) then
c  ignore ierr=1 out of LIMITX (t out of range, but t not an input)
          write (herr,1007) ab,ierr,herr1(1:235),hnull
 1007     format ('[',a2,'FLSH error',i4,'] ',a235,a1)
        else if (b.lt.bmin .or. b.gt.bmax) then
          ierr=249
          write (herr,1008) ab,ierr,bt,b,bmin,bmax,hnull
 1008     format ('[',a2,'FLSH error',i4,'] Input value is ',
     &            'outside limits; ',a1,' =',g12.5,', min,max =',
     &            2(g12.5),a1)
        end if
        if (ierr.gt.1) then
          call ERRMSG (ierr,herr)
          t=tc
          D=Dc
          Dl=Dc
          Dv=Dc
          call THERM (t,D,z,ptherm,e,h,s,cv,cp,w,hjt)
          q=999.d0     !quality undefined
          RETURN
        end if
      end if
c
      iflag1=0
      if (p.ge.pc .or. p.lt.1.0d-12) then
        iflag1=1     !Single phase
      else
c  if the input enthalpy is greater than h at the critical temperature and zero
c  density, the inputs are single phase.
        if (bt.eq.'H') then
          call enthal(tc,0.d0,x,htc0)
          if (b.gt.htc0) iflag1=1
        endif
c  if the input entropy is greater than S at the critical temperature and given
c  pressure, the inputs are single phase.
        if (bt.eq.'S') then
          call TPRHO (tc,p,x,2,0,dtcp,ierr,herr)
          call entro(tc,dtcp,x,stcp)
          if (b.gt.stcp .and. ierr.eq.0) iflag1=1
        endif
      endif
      if (iflag1.eq.1) then
c  super-critical state or special case for p = 0 (x = y = z as set above)
        kph=2                          !use vapor iteration
        t=tc+10                        !initial guesses
        if (p.ge.pc) then
          D=Dc*2.d0
        else
          D=0.0d0
        end if
        call ENTHAL (tc,dc,z,h)
        call ENERGY (tc,dc,z,e)
        if (bt.eq.'H' .and. b.lt.h/2) t=tc*.8d0
        if (bt.eq.'E' .and. b.lt.e/2) t=tc*.8d0
        call ABFL1 (p,b,z,kph,ab,0.d0,0.d0,t,pp,D,ierr,herr)
        if (ierr.ne.0) then
c  single-phase iteration did not converge--error message written by ABFL1
c  try again with different initial input
          t=tc*1.2d0
          call ABFL1 (p,b,z,kph,ab,0.d0,0.d0,t,pp,D,ierr,herr)
          if (ierr.ne.0) then
            t=tc
            call ABFL1 (p,b,z,kph,ab,0.d0,0.d0,t,pp,D,ierr,herr)
            if (ierr.ne.0) then
              q=999.d0     !quality undefined
              RETURN
            end if
          endif
        end if
        call THERM (t,D,z,ptherm,e,h,s,cv,cp,w,hjt)
        Dl=D
        Dv=D
        if (p.gt.pc .and. t.gt.tc) then
          q=999.d0     !quality undefined
        elseif (p.gt.pc) then
          q=-998.d0    !subcooled
        elseif (t.gt.tc) then
          q=998.d0     !superheated
        elseif (d.gt.Dc) then
          q=-998.d0    !subcooled
        elseif (d.lt.Dc) then
          q=998.d0     !superheated
        end if
      else
c  sub-critical state--call saturation routine to determine phase
        call SATP (p,z,2,tdew,Dldew,Dvdew,xdew,ydew,ierr,herr1)
        if (dldew.le.0.d0 .and. tdew.lt.tmin .and. bt.eq.'H') then
          call ENTHAL (tdew,Dvdew,z,hdew)
          if (b.lt.hdew) then
            ierr=250
            write (herr,2009) ab,ierr,hnull
            call ERRMSG (ierr,herr)
            q=999.d0     !quality undefined
            RETURN
          endif
        endif
        if (dldew.le.0.d0) Dldew=Dvdew
        if (ierr.eq.2) then     !p<ptrp
          tdew=tmin
          call SATT (tdew,z,2,pp,Dldew,Dvdew,xdew,ydew,ierr,herr1)
        elseif (ierr.ne.0) then
c  if the dew point iteration fails, make a check to see if the point is
c  in the liquid phase below the liquid saturation state.
          call SATP (p,z,1,tbub,Dlbub,Dvbub,xbub,ybub,ierr2,herr2)
          if (ierr2.eq.0) then
            if (bt.eq.'H') then
              call ENTHAL (tbub,Dlbub,z,blbub)
            elseif (bt.eq.'S') then
              call ENTRO (tbub,Dlbub,z,blbub)
            elseif (bt.eq.'E') then
              call ENERGY (tbub,Dlbub,z,blbub)
            endif
            if (b.le.blbub) then
              kph=1
              t=tbub
              D=Dlbub
              call ABFL1 (p,b,z,kph,ab,0.d0,0.d0,t,pp,D,ierr2,herr2)
              call THERM (t,D,z,ptherm,e,h,s,cv,cp,w,hjt)
              Dl=D
              Dv=D
              if (ierr2.eq.0) goto 100
            endif
          endif
          ierr=242
          write (herr,1242) ab,herr1(1:192),hnull
          call ERRMSG (ierr,herr)
 1242     format ('[',a2,'FLSH error 242] dew point calculation ',
     &            'did not converge:  ',a192,a1)
          q=999.d0     !quality undefined
          RETURN
        end if
c  calculate b at the dew point
        if (bt.eq.'H') then
          call ENTHAL (tdew,Dvdew,z,bvdew)
        elseif (bt.eq.'S') then
          call ENTRO (tdew,Dvdew,z,bvdew)
        elseif (bt.eq.'E') then
          call ENERGY (tdew,Dvdew,z,bvdew)
        endif
        q=998
        if (b.lt.bvdew) then  !Don't need to do the following if state is single phase vapor
          if (icomp.ne.0 .and. ianc(icomp).eq.0) then
c  if pure, bubble point density provided by call to SATT at dew point
            Dlbub=Dldew
            tbub=tdew
          else
c  if mixture, call saturation routine again at bubble point
            call SATP (p,z,1,tbub,Dlbub,Dvbub,xbub,ybub,ierr,herr1)
            if (ierr.ne.0 .and. p.gt.pc*0.9d0) then
              tbub=tc
              Dlbub=dc
            elseif (ierr.ne.0) then
              ierr=241
              write (herr,1241) ab,herr1(1:188),hnull
 1241         format ('[',a2,'FLSH error 241] bubble point calculation',
     &                ' did not converge:  ',a188,a1)
              call ERRMSG (ierr,herr)
              RETURN
            end if
          end if
c  calculate b at the bubble point
          if (bt.eq.'H') then
            call ENTHAL (tbub,Dlbub,z,blbub)
          elseif (bt.eq.'S') then
            call ENTRO (tbub,Dlbub,z,blbub)
          elseif (bt.eq.'E') then
            call ENERGY (tbub,Dlbub,z,blbub)
          endif
          if (abs(bvdew-blbub).gt.1.d-20) q=(b-blbub)/(bvdew-blbub)
        endif
        if (b.le.blbub .or. b.ge.bvdew) then
c  single-phase (liq or vapor) (pure or mixture) (x = y = z as set above)
c  set initial guesses, depending on phase
          if (b.le.blbub) then
            kph=1                        !liquid
            t=tbub                       !initial guesses
            D=Dlbub
          else
            kph=2                        !vapor
            t=tdew                       !initial guesses
            D=Dvdew
          end if
          call ABFL1 (p,b,z,kph,ab,0.d0,0.d0,t,pp,D,ierr,herr)
          if (ierr.ne.0) then
c  single-phase iteration did not converge--error message written by ABFL1
            call ERRMSG (ierr,herr)
            q=999.d0     !quality undefined
            RETURN
          end if
          call THERM (t,D,z,ptherm,e,h,s,cv,cp,w,hjt)
          Dl=D
          Dv=D
        else
          if (icomp.ne.0) then
c  special case:  pure-fluid two-phase (x = y = z as set above)
            t=(1.d0-q)*tbub+q*tdew
            Dl=Dlbub
            Dv=Dvdew
            if (ianc(icomp).eq.1) call PTANC (t,p,q,b,bt,Dl,Dv)
            if (t.lt.tmin) then       !Sublimation line exists
              ierr=250
              write (herr,2009) ab,ierr,hnull
 2009         format ('[',a2,'FLSH error',i4,']; input state is',
     &                ' solid or two-phase solid-vapor',a1)
              call ERRMSG (ierr,herr)
              q=999.d0     !quality undefined
              RETURN
            endif
          else
c  general case:  mixture 2-phase
            ksat=1   !bubble and dew point data provided to ABFL2
            call ABFL2 (p,b,z,1,ksat,ab,
     &                  tbub,tdew,pbub,pdew,Dlbub,Dvdew,ybub,xdew,
     &                  t,pp,Dl,Dv,x,y,q,ierr,herr)
            if (ierr.ne.0) then
c  two-phase iteration did not converge--error message written by ABFL2
              call ERRMSG (ierr,herr)
              q=999.d0     !quality undefined
              RETURN
            end if
c           write (*,1225) t,q,(x(i),i=1,3),(y(i),i=1,3)
c1225       format (1x,' PBFLSH--ABFL2 return   t,q,x,y = ',8f12.7)
          end if
c  compute remaining properties for 2-phase states
          call THERM (t,Dl,x,ptherm,el,hl,sl,cvl,cp,w,hjt)
          call THERM (t,Dv,y,ptherm,ev,hv,sv,cvv,cp,w,hjt)
          alpha=1.0d0-q
          D=1.0d0/(alpha/Dl+q/Dv)
          e=alpha*el+q*ev
          h=alpha*hl+q*hv
          s=alpha*sl+q*sv
          w=xnotd       !Cp,w not defined for 2-phase states
          cp=xnotd
          cv=xnotd
        end if
      end if
c
c  check that computed output is within bounds of EOS
 100  continue
      call LIMITX ('EOS',t,d,p,z,tmin,tmax,Dmax,pmax,ierr,herr1)
      if (ierr.ne.0) then
        write (herr,2008) ab,ierr,herr1
 2008   format ('[',a2,'FLSH error',i3,']; ',a235)
        call ERRMSG (ierr,herr)
      end if
c
      RETURN
      end                                             !subroutine PBFLSH
c
c        1         2         3         4         5         6         7
c23456789012345678901234567890123456789012345678901234567890123456789012
c
c ======================================================================
c                                                    end file flsh_sub.f
c ======================================================================
c  begin file idealgas.f
c
c  This file contains the routines implementing the ideal-gas part of
c  the thermodynamic functions.  They call the corresponding "core"
c  routines for the specified component(s).
c
c  contained here are:
c     function CP0 (t,x)
c     function CPI (t,x)
c     function CPT (t,x)
c     function PHI0 (itau,idel,t,rho,x)
c     function CP0K (icomp,t)
c     function PHI0K (icomp,itau,idel,t,rho)
c     block data BDCNST
c
c  these routines set the values in the following common blocks
c     common /Gcnst/ R,tz(n0:nx),rhoz(n0:nx)
c
c  these routines use the following common blocks from other files
c
c ======================================================================
c ======================================================================
c
      function CP0 (t,x)
c
c  return mixture Cp0 calculated by appropriate core CP0xxx routine(s)
c
c  inputs:
c        t--temperature (K)
c        x--composition array (mol frac)
c  output (as function value):
c      cp0--ideal gas heat capacity, Cp0 (J/(mol-K))
c
c  written by M. McLinden, NIST Thermophysics Division, Boulder, Colorado
c  07-24-95  MM, original version
c  10-03-95  MM, change /CPMOD/:  models specified by strings
c  11-08-95  MM, change to mixtures (x, rather than icomp, is input)
c  11-26-95  MM, rearrange argument list (x at end)
c  11-29-95  MM, variable lower limit on coefficient/constant arrays
c                to accommodate ECS reference fluid
c  02-27-96  MM, parameter n0=-ncmax to accommodate ECS-thermo model
c  03-22-96  MM, replace /CPMOD/ with /EOSMOD/
c  05-14-96  MM, add call to PH0 model (Helmholtz form)
c  06-17-96  MM, check only 'CP' rather than 'CPP' to allow CP1
c  12-24-02 EWL, ditto for 'PH' rather than 'PH0'
c  06-13-06 EWL, split into pure fluid and mixture sections
c
      include 'commons.for'
      dimension x(ncmax)
c
      cp0sum=0.0d0
      call ISPURE (x,icomp)
      if (icomp.ne.0) then
        if (hmodcp(icomp)(1:2).eq.'CP') then
          cp0sum=CP0CPP(icomp,t)
        else if (hmodcp(icomp)(1:2).eq.'PH') then
          rho=0.0d0
          cp0sum=R*(1.0-PH0PH0(icomp,2,0,t,rho))
        else
          cp0sum=0.0d0
        end if
      else
        do i=1,nc
          if (hmodcp(i)(1:2).eq.'CP') then
c  polynomial fit
            cp0i=CP0CPP(i,t)
          else if (hmodcp(i)(1:2).eq.'PH') then
c  Helmholtz form ("fundamental equation")
            rho=0.0d0
            cp0i=R*(1.0-PH0PH0(i,2,0,t,rho))
          else
c           write (*,*) ' CP0:  ERROR--model input to CP0 not found'
            cp0i=0.0d0
          end if
          cp0sum=cp0sum+x(i)*cp0i
        enddo
      endif
      CP0=cp0sum
c
      RETURN
      end                                                  !function CP0
c
c ======================================================================
c
      function CPI (t,x)
c
c  return mixture integral of Cp0 over limits of Tref to T
c  calculated by appropriate core CPIxxx routine(s),
c  for use in enthalpy calculation
c
c  inputs:
c        t--temperature [K]
c        x--composition array [mol frac]
c  output (as function value):
c      cpi--integral of (Cp0 dT) over limits T-Tref [J/mol]
c
c  written by M. McLinden, NIST Thermophysics Division, Boulder, Colorado
c  07-24-95  MM, original version
c  10-03-95  MM, change /CPMOD/:  models specified by strings
c  11-08-95  MM, change to mixtures (x, rather than icomp, is input)
c  11-26-95  MM, rearrange argument list (x at end)
c  11-29-95  MM, variable lower limit on coefficient/constant arrays
c                to accommodate ECS reference fluid
c  02-27-96  MM, parameter n0=-ncmax to accommodate ECS-thermo model
c  03-22-96  MM, replace /CPMOD/ with /EOSMOD/
c  06-17-96  MM, check only 'CP' rather than 'CPP' to allow CP1
c  06-13-06 EWL, split into pure fluid and mixture sections
c
      include 'commons.for'
      dimension x(ncmax)
c
      cpisum=0.0d0
      call ISPURE (x,icomp)
      if (icomp.ne.0) then
        if (hmodcp(icomp)(1:2).eq.'CP') then
          cpisum=CPICPP(icomp,t)
        else
          cpisum=0.0d0
        end if
      else
        do i=1,nc
          if (hmodcp(i)(1:2).eq.'CP') then
c  polynomial fit
            cpii=CPICPP(i,t)
          else
c           write (*,*) ' CPI:  ERROR--model input to CPI not found'
            cpii=0.0d0
          end if
          cpisum=cpisum+x(i)*cpii
        enddo
      endif
      CPI=cpisum
c
      RETURN
      end                                                  !function CPI
c
c ======================================================================
c
      function CPT (t,x)
c
c  return mixture integral of Cp0/T over limits of Tref to T
c  calculated by appropriate core CPTxxx routine(s),
c  for use in entropy calculation
c
c  inputs:
c        t--temperature [K]
c        x--composition array [mol frac]
c  output (as function value):
c      cpt--integral of (Cp0/T dT) over limits T-Tref [J/(mol-K)]
c
c  written by M. McLinden, NIST Thermophysics Division, Boulder, Colorado
c  07-24-95  MM, original version
c  10-03-95  MM, change /CPMOD/:  models specified by strings
c  11-08-95  MM, change to mixtures (x, rather than icomp, is input)
c  11-26-95  MM, rearrange argument list (x at end)
c  11-29-95  MM, variable lower limit on coefficient/constant arrays
c                to accommodate ECS reference fluid
c  02-27-96  MM, parameter n0=-ncmax to accommodate ECS-thermo model
c  03-22-96  MM, replace /CPMOD/ with /EOSMOD/
c  06-17-96  MM, check only 'CP' rather than 'CPP' to allow CP1
c  06-13-06 EWL, split into pure fluid and mixture sections
c
      include 'commons.for'
      dimension x(ncmax)
c
      cptsum=0.0d0
      call ISPURE (x,icomp)
      if (icomp.ne.0) then
        if (hmodcp(icomp)(1:2).eq.'CP') then
          cptsum=CPTCPP(icomp,t)
        else
          cptsum=0.0d0
        end if
      else
        do i=1,nc
          if (hmodcp(i)(1:2).eq.'CP') then
c  polynomial fit
            cpti=CPTCPP(i,t)
          else
c           write (*,*) ' CPT:  ERROR--model input to CPT not found'
            cpti=0.0d0
          end if
          cptsum=cptsum+x(i)*cpti
        enddo
      endif
      CPT=cptsum
c
      RETURN
      end                                                  !function CPT
c
c ======================================================================
c
      function PHI0 (itau,idel,t,rho,x)
c
c  compute the ideal gas part of the reduced Helmholtz energy or a
c  derivative as functions of temperature and pressure for a mixture;
c  for use with the Helmholtz-explicit models (e.g. FEQ and HMX)
c
c  inputs:
c     itau--flag specifying order of temperature derivative to calc
c     idel--flag specifying order of density derivative to calculate
c           (the density derivatives are not used in the calculation
c           of any property, and are not implemented)
c           when itau = 0 and idel = 0, compute A0/RT
c           when itau = 1 and idel = 0, 1st temperature derivative
c           when itau = 2 and idel = 0, 2nd temperature derivative
c        t--temperature [K]
c      rho--density [mol/L]
c        x--composition array [mol frac]
c  output (as function value):
c     PHI0--ideal-gas part of the reduced Helmholtz energy (A/RT);
c           derivatives (as specified by itau and idel) are multiplied
c           by the corresponding power of tau; i.e. when itau = 1, the
c           quantity returned is tau*d(PHI0)/d(tau) and when itau = 2,
c           the quantity returned is tau*tau*d2(PHI0)/d(tau)**2,
c           where the tau's are the Tc/T evaluated for each component
c
c  N.B.  While the real-gas part of the Helmholtz energy is calculated
c        in terms of dimensionless temperature and density, the ideal-
c        gas part is calculated in terms of absolute temperature and
c        density.  (This distinction is necessary for mixtures.)
c
c        The Helmholtz energy consists of ideal-gas and residual
c        (real-gas) terms; this routine calculates only the ideal part.
c
c  written by M. McLinden, NIST Thermophysics Division, Boulder, Colorado
c  08-04-95  MM, original version
c  08-21-95  MM, put saved variables into common (rather than save stmt)
c  10-03-95  MM, change /MODEL/ + /CPMOD/:  models specified by strings
c  11-08-95  MM, change to mixtures (x, rather than icomp, is input)
c  11-26-95  MM, rearrange argument list (x at end)
c  11-29-95  MM, variable lower limit on coefficient/constant arrays
c                to accommodate ECS reference fluid
c  02-27-96  MM, parameter n0=-ncmax to accommodate ECS-thermo model
c  03-21-96  MM, delete reference to /MODEL/, not used
c  03-22-96  MM, replace /CPMOD/ with /EOSMOD/
c  04-19-96  MM, change input from pressure to density
c  05-14-96  MM, add call to PH0 model (Helmholtz form)
c  06-17-96  MM, check only 'CP' rather than 'CPP' to allow CP1
c  07-03-96  MM, bug fix:  x*log(x) terms apply only if itau = 0
c  07-05-96  MM, note that PH0xxx models return tau*phi_tau, etc.
c                (no change in this routine)
c  12-02-98 EWL, split into pure fluid and mixture sections
c
      include 'commons.for'
      dimension x(ncmax)
c
c     write (*,1002) itau,idel,t,rho
c1002 format (1x,' PHI0--itau,idel,t,rho: ',2i4,2e14.6)
c     write (*,1004) nc,(x(j),j=1,nc)
c1004 format (1x,' PHI0--nc,x(i): ',i4,5f14.8)
c  compute reduced Helmholtz energy
c  pure fluid calculation
      call ISPURE (x,icomp)
      if (icomp.ne.0) then
        if (hmodcp(icomp)(1:2).eq.'CP') then
c  polynomial fit of isobaric heat capacity for the ideal gas state
          phisum=PH0CPP(icomp,itau,idel,t,rho)
        else if (hmodcp(icomp)(1:2).eq.'PH') then
c  Helmholtz form ("fundamental equation")
          phisum=PH0PH0(icomp,itau,idel,t,rho)
        else
c  additional model
c         write (*,*) ' PHI0:  ERROR--model input to PHI0 not found'
          phisum=0.0d0
        end if
c       write (*,1018) i,phisum
c1018   format (1x,' PHI0--i,PHIsum:  ',i3,d25.15)
c  mixture calculation
      else
        phisum=0.0d0
        do i=1,nc
c  compute only if component composition >0 and <=1
          if (x(i).gt.1.0d-10 .and. x(i).le.1.0000000001d0) then
            if (hmodcp(i)(1:2).eq.'CP') then
c  polynomial fit of isobaric heat capacity for the ideal gas state
              phi0i=PH0CPP(i,itau,idel,t,rho)
            else if (hmodcp(i)(1:2).eq.'PH') then
c  Helmholtz form ("fundamental equation")
              phi0i=PH0PH0(i,itau,idel,t,rho)
            else
c  additional model
c             write (*,*) ' PHI0:  ERROR--model input to PHI0 not found'
              phi0i=0.0d0
            end if
            phisum=phisum+x(i)*phi0i
            if (itau.eq.0) then
              phisum=phisum+x(i)*log(x(i))
            end if
c           write (*,1018) i,x(i),phi0i,phisum
c1018       format (1x,' PHI0--i,x(i),PHIi,PHIsum:  ',i3,3d25.15)
          else if (x(i).gt.1.0d0) then
c           write (*,1020) i,x(i)
c1020       format (1x,' PHI0 ERROR--composition',i4,' out of range:',d16.6)
          end if
        enddo
      endif
      PHI0=phisum
c     write (*,1022) itau,t,rho,PHI0
c1022 format (1x,' PHI0:  itau,t,rho,output phi: ',i4,3e14.6)
c
      RETURN
      end                                                 !function PHI0
c
c ======================================================================
c
      function CP0K (icomp,t)
c
c  return pure fluid Cp0 calculated by appropriate core CP0xxx routine
c
c  inputs:
c    icomp--component number in mixture (1..nc)
c           0 for ECS reference fluid
c        t--temperature [K]
c  output (as function value):
c      cp0--ideal gas heat capacity, Cp0 [J/(mol-K)]
c
c  written by M. McLinden, NIST Thermophysics Division, Boulder, Colorado
c  12-12-95  MM, original version, adapted from function CP0
c  02-27-96  MM, parameter n0=-ncmax to accommodate ECS-thermo model
c  03-22-96  MM, replace /CPMOD/ with /EOSMOD/
c  05-14-96  MM, add call to PH0 model (Helmholtz form)
c  06-17-96  MM, check only 'CP' rather than 'CPP' to allow CP1
c  10-10-96  MM, this routine never called, comment out
c  10-15-96  MM, needed in some of the new transport routines, restore
c
      include 'commons.for'
c
      if (hmodcp(icomp)(1:2).eq.'CP') then
c  polynomial fit
        CP0K=CP0CPP(icomp,t)
      else if (hmodcp(icomp)(1:2).eq.'PH') then
c  Helmholtz form ("fundamental equation")
        rho=0.0d0
        CP0K=R*(1.0-PH0PH0(icomp,2,0,t,rho))
      else
c       write (*,*) ' CP0K:  ERROR--model input to CP0K not found'
        CP0K=0.0d0
      end if
c
      RETURN
      end                                                 !function CP0K
c
c ======================================================================
c
      function PHI0K (icomp,itau,idel,t,rho)
c
c  compute the ideal gas part of the reduced Helmholtz energy or a
c  derivative as functions of temperature and pressure for a specified
c  component
c
c  analogous to PHI0, except for component icomp, this is used by CVCPK
c  which, in turn, is used by transport routines to calculate Cv & Cp
c  for the reference fluid (component zero)
c
c  inputs:
c    icomp--component number in mixture (1..nc); 1 for pure fluid
c     itau--flag specifying order of temperature derivative to calc
c     idel--flag specifying order of density derivative to calculate
c           (the density derivatives are not used in the calculation
c           of any property, and are not implemented)
c           when itau = 0 and idel = 0, compute A0/RT
c           when itau = 1 and idel = 0, 1st temperature derivative
c           when itau = 2 and idel = 0, 2nd temperature derivative
c        t--temperature [K]
c      rho--density [mol/L]
c  output (as function value):
c    PHI0K--ideal-gas part of the reduced Helmholtz energy (A/RT);
c           derivatives (as specified by itau and idel) are multiplied
c           by the corresponding power of tau; i.e. when itau = 1, the
c           quantity returned is tau*d(PHI0)/d(tau) and when itau = 2,
c           the quantity returned is tau*tau*d2(PHI0)/d(tau)**2,
c           where the tau's are the Tc/T evaluated for each component
c
c  N.B.  While the real-gas part of the Helmholtz energy is calculated
c        in terms of dimensionless temperature and density, the ideal-
c        gas part is calculated in terms of absolute temperature and
c        density.  (This distinction is necessary for mixtures.)
c
c        The Helmholtz energy consists of ideal-gas and residual
c        (real-gas) terms; this routine calculates only the ideal part.
c
c  written by M. McLinden, NIST Physical & Chem Properties Div, Boulder, CO
c  06-16-97  MM, original version; based on PHIO
c
      include 'commons.for'
c
      if (hmodcp(icomp)(1:2).eq.'CP') then
c  polynomial fit of isobaric heat capacity for the ideal gas state
        PHI0K=PH0CPP(icomp,itau,idel,t,rho)
      else if (hmodcp(icomp)(1:2).eq.'PH') then
c  Helmholtz form ("fundamental equation")
        PHI0K=PH0PH0(icomp,itau,idel,t,rho)
      else
c  additional model
c       write (*,*) ' PHI0K:  ERROR--model input to PHI0K not found'
        PHI0K=0.0d0
      end if
c     write (*,1022) itau,t,rho,PHI0K
c1022 format (1x,' PHI0K:  itau,t,rho,output phi: ',i4,3e14.6)
c
      RETURN
      end                                                !function PHI0K
c
c        1         2         3         4         5         6         7
c23456789012345678901234567890123456789012345678901234567890123456789012
c
c ======================================================================
c                                                    end file idealgas.f
c ======================================================================
c  begin file Mix_AGA8.f
c
c  This file contains the routines implementing the AGA8 equation of
c  state for hydrocarbon mixtures
c
c  contained here are:
c     function PHIAGA (itau,idel,tau,del,x)
c     subroutine SETAGA (ierr,herr)
c     subroutine UNSETAGA
c     subroutine SETAG (x)
c     block data AGA8CF
c
c ======================================================================
c ======================================================================
c
      function PHIAGA (itau,idel,tau,del,x)
c
c  compute reduced Helmholtz energy or a derivative as functions
c  of dimensionless temperature and density for the AGA8
c  equation of state
c
c  based on the DETAIL compressibility factor equation of:
c  Starling, K.E. and Savidge, J.L.
c  Compressibility Factors of Natural Gas and Other Related Hydrocarbon
c  Gases,
c  Transmission Measurement Committee Report No. 8, Catalog No. XQ9212,
c  American Gas Association, 1994.
c
c  inputs:
c     itau--flag specifying order of temperature derivative to calc
c     idel--flag specifying order of density derivative to calculate
c           when itau = 0 and idel = 0, compute A/RT
c           when itau = 0 and idel = 1, compute 1st density derivative
c           when itau = 1 and idel = 1, compute cross derivative
c           etc.
c      tau--dimensionless temperature (To/T)
c      del--dimensionless density (D/Do)
c  output (as function value):
c      phi--residual (real-gas) part of the AGA8 equation, or one
c           of its derivatives (as specified by itau and idel),
c           in reduced form (A/RT)
c           itau  idel    output (dimensionless for all cases)
c             0    0      A/RT
c             1    0      tau*[d(A/RT)/d(tau)]
c             2    0      tau**2*[d**2(A/RT)/d(tau)**2]
c             0    1      del*[d(A/RT)/d(del)]
c             0    2      del**2*[d**2(A/RT)/d(del)**2]
c             1    1      tau*del*[d**2(A/RT)/d(tau)d(del)]
c                         etc.
c
c  written by E.W. Lemmon, NIST Thermophysics Division, Boulder, Colorado
c  10-31-02 EWL, original version
c
      include 'commons.for'
      dimension a0(64),x(ncmax)
c
      call SETAG(x)
      call REDX (x,t0,rho0)
      t=t0/tau
      rho=del*rho0
      D=Kaga**3*rho
      d1=D
      d2=D*D
      d3=d2*D
      d4=d3*D
      d5=d4*D
      d6=d5*D
      d7=d6*D
      d8=d7*D
      d9=d8*D
      e0=exp(0.d0)
      e1=exp(-d1)
      e2=exp(-d2)
      e3=exp(-d3)
      e4=exp(-d4)
      t5    =sqrt(t)
      t15   =t5*t
      t10   =t
      t20   =t*t
      t30   =t20*t
      t40   =t30*t
      t50   =t40*t
      t60   =t50*t
      t70   =t60*t
      t80   =t70*t
      t90   =t80*t
      t35   =t30*t5
      t45   =t40*t5
      t75   =t70*t5
      t95   =t90*t5
      t110  =t90*t20
      t120  =t110*t
      t125  =t120*t5
      t210  =t120*t90
      t220  =t210*t
      t230  =t220*t
      tn5   =1.d0/t5
      tn130 =1.d0/t120/t
      tn10  =1.d0/t
      tn60  =1.d0/t60
c
      a0(1) =D* bsaga(1)
      a0(2) =D* bsaga(2)          /t5
      a0(3) =D* bsaga(3)          /t10
      a0(4) =D* bsaga(4)          /t35
      a0(5) =D* bsaga(5)          /tn5
      a0(6) =D* bsaga(6)          /t45
      a0(7) =D* bsaga(7)          /t5
      a0(8) =D* bsaga(8)          /t75
      a0(9) =D* bsaga(9)          /t95
      a0(10)=D* bsaga(10)         /t60
      a0(11)=D* bsaga(11)         /t120
      a0(12)=D* bsaga(12)         /t125
      a0(59)=D*(bsaga(13)-cnsaga(13))/tn60
      a0(60)=D*(bsaga(14)-cnsaga(14))/t20
      a0(61)=D*(bsaga(15)-cnsaga(15))/t30
      a0(62)=D*(bsaga(16)-cnsaga(16))/t20
      a0(63)=D*(bsaga(17)-cnsaga(17))/t20
      a0(64)=D*(bsaga(18)-cnsaga(18))/t110
c
      a0(13)=cnsaga(13)/tn60 *d1*e3
      a0(14)=cnsaga(14)/t20  *d1*e2
      a0(15)=cnsaga(15)/t30  *d1*e2
      a0(16)=cnsaga(16)/t20  *d1*e2
      a0(17)=cnsaga(17)/t20  *d1*e4
      a0(18)=cnsaga(18)/t110 *d1*e4
      a0(19)=cnsaga(19)/tn5  *d2*e0
      a0(20)=cnsaga(20)/t5   *d2*e0
      a0(21)=cnsaga(21)      *d2*e2
      a0(22)=cnsaga(22)/t40  *d2*e2
      a0(23)=cnsaga(23)/t60  *d2*e2
      a0(24)=cnsaga(24)/t210 *d2*e4
      a0(25)=cnsaga(25)/t230 *d2*e4
      a0(26)=cnsaga(26)/t220 *d2*e4
      a0(27)=cnsaga(27)/tn10 *d2*e4
      a0(28)=cnsaga(28)/tn5  *d3*e0
      a0(29)=cnsaga(29)/t70  *d3*e1
      a0(30)=cnsaga(30)/tn10 *d3*e1
      a0(31)=cnsaga(31)/t60  *d3*e2
      a0(32)=cnsaga(32)/t40  *d3*e2
      a0(33)=cnsaga(33)/t10  *d3*e3
      a0(34)=cnsaga(34)/t90  *d3*e3
      a0(35)=cnsaga(35)/tn130*d3*e4
      a0(36)=cnsaga(36)/t210 *d3*e4
      a0(37)=cnsaga(37)/t80  *d3*e4
      a0(38)=cnsaga(38)/tn5  *d4*e0
      a0(39)=cnsaga(39)      *d4*e0
      a0(40)=cnsaga(40)/t20  *d4*e2
      a0(41)=cnsaga(41)/t70  *d4*e2
      a0(42)=cnsaga(42)/t90  *d4*e2
      a0(43)=cnsaga(43)/t220 *d4*e4
      a0(44)=cnsaga(44)/t230 *d4*e4
      a0(45)=cnsaga(45)/t10  *d5*e0
      a0(46)=cnsaga(46)/t90  *d5*e2
      a0(47)=cnsaga(47)/t30  *d5*e2
      a0(48)=cnsaga(48)/t80  *d5*e4
      a0(49)=cnsaga(49)/t230 *d5*e4
      a0(50)=cnsaga(50)/t15  *d6*e0
      a0(51)=cnsaga(51)/t50  *d6*e2
      a0(52)=cnsaga(52)/tn5  *d7*e0
      a0(53)=cnsaga(53)/t40  *d7*e2
      a0(54)=cnsaga(54)/t70  *d8*e1
      a0(55)=cnsaga(55)/t30  *d8*e2
      a0(56)=cnsaga(56)      *d8*e2
      a0(57)=cnsaga(57)/t10  *d9*e2
      a0(58)=cnsaga(58)      *d9*e2
c
      if (idel.eq.1) then
        a0(19)=a0(19)*2d0
        a0(20)=a0(20)*2d0
        a0(28)=a0(28)*3d0
        a0(38)=a0(38)*4d0
        a0(39)=a0(39)*4d0
        a0(45)=a0(45)*5d0
        a0(50)=a0(50)*6d0
        a0(52)=a0(52)*7d0
        a0(13)=a0(13)*(1d0-3d0*d3)
        a0(14)=a0(14)*(1d0-2d0*d2)
        a0(15)=a0(15)*(1d0-2d0*d2)
        a0(16)=a0(16)*(1d0-2d0*d2)
        a0(17)=a0(17)*(1d0-4d0*d4)
        a0(18)=a0(18)*(1d0-4d0*d4)
        a0(21)=a0(21)*(2d0-2d0*d2)
        a0(22)=a0(22)*(2d0-2d0*d2)
        a0(23)=a0(23)*(2d0-2d0*d2)
        a0(24)=a0(24)*(2d0-4d0*d4)
        a0(25)=a0(25)*(2d0-4d0*d4)
        a0(26)=a0(26)*(2d0-4d0*d4)
        a0(27)=a0(27)*(2d0-4d0*d4)
        a0(29)=a0(29)*(3d0-    d1)
        a0(30)=a0(30)*(3d0-    d1)
        a0(31)=a0(31)*(3d0-2d0*d2)
        a0(32)=a0(32)*(3d0-2d0*d2)
        a0(33)=a0(33)*(3d0-3d0*d3)
        a0(34)=a0(34)*(3d0-3d0*d3)
        a0(35)=a0(35)*(3d0-4d0*d4)
        a0(36)=a0(36)*(3d0-4d0*d4)
        a0(37)=a0(37)*(3d0-4d0*d4)
        a0(40)=a0(40)*(4d0-2d0*d2)
        a0(41)=a0(41)*(4d0-2d0*d2)
        a0(42)=a0(42)*(4d0-2d0*d2)
        a0(43)=a0(43)*(4d0-4d0*d4)
        a0(44)=a0(44)*(4d0-4d0*d4)
        a0(46)=a0(46)*(5d0-2d0*d2)
        a0(47)=a0(47)*(5d0-2d0*d2)
        a0(48)=a0(48)*(5d0-4d0*d4)
        a0(49)=a0(49)*(5d0-4d0*d4)
        a0(51)=a0(51)*(6d0-2d0*d2)
        a0(53)=a0(53)*(7d0-2d0*d2)
        a0(54)=a0(54)*(8d0-    d1)
        a0(55)=a0(55)*(8d0-2d0*d2)
        a0(56)=a0(56)*(8d0-2d0*d2)
        a0(57)=a0(57)*(9d0-2d0*d2)
        a0(58)=a0(58)*(9d0-2d0*d2)
c
      elseif (idel.eq.2) then
        do n=1,12
          a0(n)=0
        enddo
        do n=59,64
          a0(n)=0
        enddo
        a0(19)=a0(19)*2d0
        a0(20)=a0(20)*2d0
        a0(28)=a0(28)*6d0
        a0(38)=a0(38)*12d0
        a0(39)=a0(39)*12d0
        a0(45)=a0(45)*20d0
        a0(50)=a0(50)*30d0
        a0(52)=a0(52)*42d0
        a0(13)=a0(13)*((1d0-3d0*d3)*(   -3d0*d3)- 9d0*d3)
        a0(14)=a0(14)*((1d0-2d0*d2)*(   -2d0*d2)- 4d0*d2)
        a0(15)=a0(15)*((1d0-2d0*d2)*(   -2d0*d2)- 4d0*d2)
        a0(16)=a0(16)*((1d0-2d0*d2)*(   -2d0*d2)- 4d0*d2)
        a0(17)=a0(17)*((1d0-4d0*d4)*(   -4d0*d4)-16d0*d4)
        a0(18)=a0(18)*((1d0-4d0*d4)*(   -4d0*d4)-16d0*d4)
        a0(21)=a0(21)*((2d0-2d0*d2)*(1d0-2d0*d2)- 4d0*d2)
        a0(22)=a0(22)*((2d0-2d0*d2)*(1d0-2d0*d2)- 4d0*d2)
        a0(23)=a0(23)*((2d0-2d0*d2)*(1d0-2d0*d2)- 4d0*d2)
        a0(24)=a0(24)*((2d0-4d0*d4)*(1d0-4d0*d4)-16d0*d4)
        a0(25)=a0(25)*((2d0-4d0*d4)*(1d0-4d0*d4)-16d0*d4)
        a0(26)=a0(26)*((2d0-4d0*d4)*(1d0-4d0*d4)-16d0*d4)
        a0(27)=a0(27)*((2d0-4d0*d4)*(1d0-4d0*d4)-16d0*d4)
        a0(29)=a0(29)*((3d0-    d1)*(2d0-    d1)-     d1)
        a0(30)=a0(30)*((3d0-    d1)*(2d0-    d1)-     d1)
        a0(31)=a0(31)*((3d0-2d0*d2)*(2d0-2d0*d2)- 4d0*d2)
        a0(32)=a0(32)*((3d0-2d0*d2)*(2d0-2d0*d2)- 4d0*d2)
        a0(33)=a0(33)*((3d0-3d0*d3)*(2d0-3d0*d3)- 9d0*d3)
        a0(34)=a0(34)*((3d0-3d0*d3)*(2d0-3d0*d3)- 9d0*d3)
        a0(35)=a0(35)*((3d0-4d0*d4)*(2d0-4d0*d4)-16d0*d4)
        a0(36)=a0(36)*((3d0-4d0*d4)*(2d0-4d0*d4)-16d0*d4)
        a0(37)=a0(37)*((3d0-4d0*d4)*(2d0-4d0*d4)-16d0*d4)
        a0(40)=a0(40)*((4d0-2d0*d2)*(3d0-2d0*d2)- 4d0*d2)
        a0(41)=a0(41)*((4d0-2d0*d2)*(3d0-2d0*d2)- 4d0*d2)
        a0(42)=a0(42)*((4d0-2d0*d2)*(3d0-2d0*d2)- 4d0*d2)
        a0(43)=a0(43)*((4d0-4d0*d4)*(3d0-4d0*d4)-16d0*d4)
        a0(44)=a0(44)*((4d0-4d0*d4)*(3d0-4d0*d4)-16d0*d4)
        a0(46)=a0(46)*((5d0-2d0*d2)*(4d0-2d0*d2)- 4d0*d2)
        a0(47)=a0(47)*((5d0-2d0*d2)*(4d0-2d0*d2)- 4d0*d2)
        a0(48)=a0(48)*((5d0-4d0*d4)*(4d0-4d0*d4)-16d0*d4)
        a0(49)=a0(49)*((5d0-4d0*d4)*(4d0-4d0*d4)-16d0*d4)
        a0(51)=a0(51)*((6d0-2d0*d2)*(5d0-2d0*d2)- 4d0*d2)
        a0(53)=a0(53)*((7d0-2d0*d2)*(6d0-2d0*d2)- 4d0*d2)
        a0(54)=a0(54)*((8d0-    d1)*(7d0-    d1)-     d1)
        a0(55)=a0(55)*((8d0-2d0*d2)*(7d0-2d0*d2)- 4d0*d2)
        a0(56)=a0(56)*((8d0-2d0*d2)*(7d0-2d0*d2)- 4d0*d2)
        a0(57)=a0(57)*((9d0-2d0*d2)*(8d0-2d0*d2)- 4d0*d2)
        a0(58)=a0(58)*((9d0-2d0*d2)*(8d0-2d0*d2)- 4d0*d2)
c
      elseif (idel.eq.3) then
        do n=1,12
          a0(n)=0
        enddo
        do n=59,64
          a0(n)=0
        enddo
        a0(19)=0.d0
        a0(20)=0.d0
        a0(28)=a0(28)*6d0
        a0(38)=a0(38)*24d0
        a0(39)=a0(39)*24d0
        a0(45)=a0(45)*60d0
        a0(50)=a0(50)*120d0
        a0(52)=a0(52)*210d0
        d12=d6*d6
        a0(13)=a0(13)*(  0d0 - d3*24d0  + d6*81d0  - 27d0*d9)
        a0(14)=a0(14)*(  0d0 - d2*6d0   + d4*24d0  - 8d0 *d6)
        a0(15)=a0(15)*(  0d0 - d2*6d0   + d4*24d0  - 8d0 *d6)
        a0(16)=a0(16)*(  0d0 - d2*6d0   + d4*24d0  - 8d0 *d6)
        a0(17)=a0(17)*(  0d0 - d4*60d0  + d8*192d0 - 64d0*d12)
        a0(18)=a0(18)*(  0d0 - d4*60d0  + d8*192d0 - 64d0*d12)
        a0(21)=a0(21)*(  0d0 - d2*24d0  + d4*36d0  - 8d0 *d6)
        a0(22)=a0(22)*(  0d0 - d2*24d0  + d4*36d0  - 8d0 *d6)
        a0(23)=a0(23)*(  0d0 - d2*24d0  + d4*36d0  - 8d0 *d6)
        a0(24)=a0(24)*(  0d0 - d4*120d0 + d8*240d0 - 64d0*d12)
        a0(25)=a0(25)*(  0d0 - d4*120d0 + d8*240d0 - 64d0*d12)
        a0(26)=a0(26)*(  0d0 - d4*120d0 + d8*240d0 - 64d0*d12)
        a0(27)=a0(27)*(  0d0 - d4*120d0 + d8*240d0 - 64d0*d12)
        a0(29)=a0(29)*(  6d0 - d1*18d0  + d2*9d0   - 1d0 *d3)
        a0(30)=a0(30)*(  6d0 - d1*18d0  + d2*9d0   - 1d0 *d3)
        a0(31)=a0(31)*(  6d0 - d2*54d0  + d4*48d0  - 8d0 *d6)
        a0(32)=a0(32)*(  6d0 - d2*54d0  + d4*48d0  - 8d0 *d6)
        a0(33)=a0(33)*(  6d0 - d3*114d0 + d6*135d0 - 27d0*d9)
        a0(34)=a0(34)*(  6d0 - d3*114d0 + d6*135d0 - 27d0*d9)
        a0(35)=a0(35)*(  6d0 - d4*204d0 + d8*288d0 - 64d0*d12)
        a0(36)=a0(36)*(  6d0 - d4*204d0 + d8*288d0 - 64d0*d12)
        a0(37)=a0(37)*(  6d0 - d4*204d0 + d8*288d0 - 64d0*d12)
        a0(40)=a0(40)*( 24d0 - d2*96d0  + d4*60d0  - 8d0 *d6)
        a0(41)=a0(41)*( 24d0 - d2*96d0  + d4*60d0  - 8d0 *d6)
        a0(42)=a0(42)*( 24d0 - d2*96d0  + d4*60d0  - 8d0 *d6)
        a0(43)=a0(43)*( 24d0 - d4*312d0 + d8*336d0 - 64d0*d12)
        a0(44)=a0(44)*( 24d0 - d4*312d0 + d8*336d0 - 64d0*d12)
        a0(46)=a0(46)*( 60d0 - d2*150d0 + d4*72d0  - 8d0 *d6)
        a0(47)=a0(47)*( 60d0 - d2*150d0 + d4*72d0  - 8d0 *d6)
        a0(48)=a0(48)*( 60d0 - d4*444d0 + d8*384d0 - 64d0*d12)
        a0(49)=a0(49)*( 60d0 - d4*444d0 + d8*384d0 - 64d0*d12)
        a0(51)=a0(51)*(120d0 - d2*216d0 + d4*84d0  - 8d0 *d6)
        a0(53)=a0(53)*(210d0 - d2*294d0 + d4*96d0  - 8d0 *d6)
        a0(54)=a0(54)*(336d0 - d1*168d0 + d2*24d0  - 1d0 *d3)
        a0(55)=a0(55)*(336d0 - d2*384d0 + d4*108d0 - 8d0 *d6)
        a0(56)=a0(56)*(336d0 - d2*384d0 + d4*108d0 - 8d0 *d6)
        a0(57)=a0(57)*(504d0 - d2*486d0 + d4*120d0 - 8d0 *d6)
        a0(58)=a0(58)*(504d0 - d2*486d0 + d4*120d0 - 8d0 *d6)
      endif
c
      if (itau.eq.1) then
        do n=1,58
          a0(n)=a0(n)*unaga(n)
        enddo
        do n=59,64
          a0(n)=a0(n)*unaga(n-46)
        enddo
      elseif (itau.eq.2) then
        do n=1,58
          a0(n)=a0(n)*unaga(n)*(unaga(n)-1.d0)
        enddo
        do n=59,64
          a0(n)=a0(n)*unaga(n-46)*(unaga(n-46)-1.d0)
        enddo
      endif
c
      ar=0.d0
      do n=1,64
        ar=ar+a0(n)
      enddo
      phiaga=ar
c
      RETURN
      end                                               !function PHIAGA
c
c ======================================================================
c
      subroutine SETAGA (ierr,herr)
c
c  set up working arrays for use with AGA8 equation of state
c
c  input:
c  outputs:
c     ierr--error flag:  0 = successful
c                        1 = error (e.g. fluid not found)
c     herr--error string (character*255 variable if ierr<>0)
c     [fluid parameters, etc. returned via various common blocks]
c
c  written by E.W. Lemmon, NIST Thermophysics Division, Boulder, Colorado
c  10-31-02 EWL, original version
c  09-30-11 EWL, delete calculation of href and sref so that h=0 and s=0
c                at 298.15 K and 101.325 kPa
c
cx DEC$ ATTRIBUTES DLLEXPORT :: SETAGA
c
      include 'commons.for'
      character*255 herr
c
      ierr=0
      herr=' '
c
      do i=1,nc
        ifpa(i)=0
        if (hcas(i).eq.'74-82-8')    ifpa(i)=1   !Methane
        if (hcas(i).eq.'7727-37-9')  ifpa(i)=2   !Nitrogen
        if (hcas(i).eq.'124-38-9')   ifpa(i)=3   !Carbon Dioxide
        if (hcas(i).eq.'74-84-0')    ifpa(i)=4   !Ethane
        if (hcas(i).eq.'74-98-6')    ifpa(i)=5   !Propane
        if (hcas(i).eq.'7732-18-5')  ifpa(i)=6   !Water
        if (hcas(i).eq.'7783-06-4')  ifpa(i)=7   !Hydrogen Sulfide
        if (hcas(i).eq.'1333-74-0')  ifpa(i)=8   !Hydrogen
        if (hcas(i).eq.'1333-74-0p') ifpa(i)=8   !Hydrogen (para)
        if (hcas(i).eq.'630-08-0')   ifpa(i)=9   !Carbon Monoxide
        if (hcas(i).eq.'7782-44-7')  ifpa(i)=10  !Oxygen
        if (hcas(i).eq.'75-28-5')    ifpa(i)=11  !Isobutane
        if (hcas(i).eq.'106-97-8')   ifpa(i)=12  !Butane
        if (hcas(i).eq.'78-78-4')    ifpa(i)=13  !Isopentane
        if (hcas(i).eq.'109-66-0')   ifpa(i)=14  !Pentane
        if (hcas(i).eq.'110-54-3')   ifpa(i)=15  !Hexane
        if (hcas(i).eq.'142-82-5')   ifpa(i)=16  !Heptane
        if (hcas(i).eq.'111-65-9')   ifpa(i)=17  !Octane
        if (hcas(i).eq.'111-84-2')   ifpa(i)=18  !Nonane
        if (hcas(i).eq.'124-18-5')   ifpa(i)=19  !Decane
        if (hcas(i).eq.'7440-59-7')  ifpa(i)=20  !Helium
        if (hcas(i).eq.'7440-37-1')  ifpa(i)=21  !Argon
        if (hcas(i).eq.'463-82-1')   ifpa(i)=13  !Set neopentane as isopentane
        if (hcas(i).eq.'108-88-3')   ifpa(i)=16  !Set toluene as heptane
        if (hcas(i).eq.'71-43-2')    ifpa(i)=15  !Set benzene as hexane
        if (hcas(i).eq.'74-85-1')    ifpa(i)=4   !Set ethylene as ethane
        if (hcas(i).eq.'115-07-1')   ifpa(i)=5   !Set propylene as propane
        if (hcas(i).eq.'106-98-9')   ifpa(i)=12  !Set butene as butane
        if (ifpa(i).eq.0) then
          ierr=1
          herr='[SETAGA error 1] Not all requested fluids are '//
     &         'available in AGA8, '//hcas(i)//hnull
          call ERRMSG (ierr,herr)
          RETURN
        endif
      enddo
c
      if (heos.ne.'AGA') then
        hagasv=heos
        Rasv=R
        do i=1,nc
          Ragasv(i)   = Reos(i)
          wmagasv(i)  = wmas(i)
          tmagasv(i)  = tmincp(i)
          txagasv(i)  = tmaxcp(i)
          tragasv(i)  = tredcp(i)
          Cragasv(i)  = Credcp(i)
          nagacsv(i)  = ntermc(i)
          nagaesv(i)  = nterme(i)
          ncoshsv(i)  = ncoshc(i)
          nsinhsv(i)  = nsinhc(i)
          Tfagasv(i)  = tref(i)
          Dfagasv(i)  = rhoref(i)
          hfagasv(i)  = href(i)
          sfagasv(i)  = sref(i)
          do j=1,5
            xksv(i,j) = xkc0(i,j)
            xthsv(i,j)= x0th(i,j)
            xhsv(i,j) = xh00(i,j)
            cpcsv(i,j)= cpc0(i,j)
            cphsv(i,j)= cp0h(i,j)
          enddo
        enddo
      endif
c
      heos='AGA'
      R=8.31451d0
      do i=1,nc
        Reos(i)=8.31451d0
      enddo
c
      do i=1,21
        kb2a(i)=kbaga(i)**2.5d0
        eb2a(i)=ebaga(i)**2.5d0
      enddo
      do i=1,20
        do j=i+1,21
          kij2(i,j)=2.d0*(kija(j,i)**5-1.d0)*kb2a(i)*kb2a(j)
          uij2(i,j)=2.d0*(uija(j,i)**5-1.d0)*eb2a(i)*eb2a(j)
          gij2(i,j)=(gijs(j,i)-1.d0)*(gbaga(i)+gbaga(j))
          kij2(j,i)=kij2(i,j)
          uij2(j,i)=uij2(i,j)
          gij2(j,i)=gij2(i,j)
        enddo
      enddo
      do n=1,18
        do i=1,21
        do j=i,21
          eij=eijs(j,i)*sqrt(ebaga(i)*ebaga(j))
          bb=1.d0
          if (n.eq.5 .or. n.eq.6)  bb=gijs(j,i)*(gbaga(i)+gbaga(j))/2.d0
          if (n.eq.7 .or. n.eq.16) bb=qbaga(i)*qbaga(j)
          if (n.eq.8 .or. n.eq.9)  bb=sbaga(i)*sbaga(j)
          if (n.ge.10.and.n.le.12) bb=wbaga(i)*wbaga(j)
          if (n.eq.13)             bb=fbaga(i)*fbaga(j)
          if (i.ne.j) bb=2.d0*bb
          bs2a(n,i,j)=bb*eij**unaga(n)*(kbaga(i)*kbaga(j))**1.5d0
          bs2a(n,j,i)=bs2a(n,i,j)
        enddo
        enddo
      enddo
      do i=1,nc
        wmas(i)=mrbaga(ifpa(i))
        tmincp(i)=100.d0
        tmaxcp(i)=1000.d0
        tredcp(i)=1.d0
        Credcp(i)=4.184d0
        ntermc(i)=1
        nterme(i)=0
        ncoshc(i)=2
        nsinhc(i)=2
        cpc0(i,1)=bcp0(ifpa(i))
        xkc0(i,1)=0.d0
        do j=2,5
          xkc0(i,j)=-2.d0
          x0th(i,j)=-1.d0
          xh00(i,j)=-2.d0
        enddo
        j=ifpa(i)
        cpc0(i,2)=ecp0(j)*fcp0(j)**2
        cp0h(i,2)=fcp0(j)
        cpc0(i,3)=icp0(j)*jcp0(j)**2
        cp0h(i,3)=jcp0(j)
        cpc0(i,4)=ccp0(j)*dcp0(j)**2
        cp0h(i,4)=dcp0(j)
        cpc0(i,5)=gcp0(j)*hcp0(j)**2
        cp0h(i,5)=hcp0(j)
        tref(i)=298.15d0
        rhoref(i)=101.325d0/r/tref(i)
!       t=tref(i)
!        h=acp0(j)+bcp0(j)*t
!     &   +ccp0(j)*dcp0(j)/TANH(dcp0(j)/t)
!     &   -ecp0(j)*fcp0(j)*TANH(fcp0(j)/t)
!     &   +gcp0(j)*hcp0(j)/TANH(hcp0(j)/t)
!     &   -icp0(j)*jcp0(j)*TANH(jcp0(j)/t)
!        s=kcp0(j)+bcp0(j)*LOG(t)
!     &   +ccp0(j)*(dcp0(j)/t/TANH(dcp0(j)/t)-LOG(SINH(dcp0(j)/t)))
!     &   -ecp0(j)*(fcp0(j)/t*TANH(fcp0(j)/t)-LOG(COSH(fcp0(j)/t)))
!     &   +gcp0(j)*(hcp0(j)/t/TANH(hcp0(j)/t)-LOG(SINH(hcp0(j)/t)))
!     &   -icp0(j)*(jcp0(j)/t*TANH(jcp0(j)/t)-LOG(COSH(jcp0(j)/t)))
!        href(i)=0-h*4.184d0
!        sref(i)=0-s*4.184d0
        href(i)=0.d0
        sref(i)=0.d0
      enddo
c
      RETURN
      end                                             !subroutine SETAGA
c
c ======================================================================
c
      subroutine UNSETAGA
c
c  Load original values into arrays changed in the call to SETAGA.  This
c  routine resets the values back to those loaded when SETUP was called.
c
c  written by E.W. Lemmon, NIST Thermophysics Division, Boulder, Colorado
c  01-07-10 EWL, original version
c
cx DEC$ ATTRIBUTES DLLEXPORT :: UNSETAGA
c
      include 'commons.for'
c
      call RESETA
      if (heos.eq.'AGA') then
        heos=hagasv
        R=Rasv
        do i=1,nc
          Reos(i)   = Ragasv(i)
          wmas(i)     = wmagasv(i)
          tmincp(i) = tmagasv(i)
          tmaxcp(i) = txagasv(i)
          tredcp(i) = tragasv(i)
          Credcp(i) = Cragasv(i)
          ntermc(i) = nagacsv(i)
          nterme(i) = nagaesv(i)
          ncoshc(i) = ncoshsv(i)
          nsinhc(i) = nsinhsv(i)
          tref(i)   = Tfagasv(i)
          rhoref(i) = Dfagasv(i)
          href(i)   = hfagasv(i)
          sref(i)   = sfagasv(i)
          do j=1,5
            xkc0(i,j) = xksv(i,j)
            x0th(i,j) = xthsv(i,j)
            xh00(i,j)  = xhsv(i,j)
            cpc0(i,j) = cpcsv(i,j)
            cp0h(i,j) = cphsv(i,j)
          enddo
        enddo
      endif
c
      RETURN
      end                                           !subroutine UNSETAGA
c
c ======================================================================
c
      subroutine SETAG (x)
c
c  set up working arrays for use with the AGA8 equation of state
c
c  written by E.W. Lemmon, NIST Thermophysics Division, Boulder, Colorado
c  10-31-02 EWL, original version
c
      include 'commons.for'
      double precision K3
      dimension x(ncmax),z(ncmax)
c
      sum=0.d0
      do i=1,nc
        sum=sum+x(i)
      enddo
      if (sum.le.0.d0) RETURN
      do i=1,nc
        z(i)=x(i)/sum
      enddo
      Kaga=0.d0
      F=0.d0
      U=0.d0
      Q=0.d0
      G=0.d0
      do i=1,nc
        Kaga=Kaga+z(i)*kb2a(ifpa(i))
        U=U+z(i)*eb2a(ifpa(i))
        F=F+z(i)**2*fbaga(ifpa(i))
        Q=Q+z(i)*qbaga(ifpa(i))
        G=G+z(i)*gbaga(ifpa(i))
      enddo
      Kaga=Kaga**2
      U=U**2
      do i=1,nc-1
        do j=i+1,nc
          xij=z(i)*z(j)
          Kaga=Kaga+xij*kij2(ifpa(i),ifpa(j))
          U=U+xij*uij2(ifpa(i),ifpa(j))
          G=G+xij*gij2(ifpa(i),ifpa(j))
        enddo
      enddo
      Kaga=Kaga**0.2d0
      U=U**0.2d0
c
      Q=Q**2
      K3=Kaga**3
      do n=1,18
        bsaga(n)=0.d0
        do i=1,nc
        do j=i,nc
          bsaga(n)=bsaga(n)+bs2a(n,ifpa(i),ifpa(j))*z(i)*z(j)
        enddo
        enddo
        bsaga(n)=bsaga(n)*anaga(n)/K3
      enddo
      do n=13,58
        cnsaga(n)=anaga(n)*U**unaga(n)
      enddo
      cnsaga(13)=cnsaga(13)*F
      cnsaga(16)=cnsaga(16)*Q
      cnsaga(25)=cnsaga(25)*G
      cnsaga(26)=cnsaga(26)*Q
      cnsaga(27)=cnsaga(27)*F
      cnsaga(28)=cnsaga(28)*Q
      cnsaga(29)=cnsaga(29)*G
      cnsaga(30)=cnsaga(30)*F
      cnsaga(32)=cnsaga(32)*G
      cnsaga(33)=cnsaga(33)*G
      cnsaga(34)=cnsaga(34)*G
      cnsaga(35)=cnsaga(35)*F
      cnsaga(37)=cnsaga(37)*Q
      cnsaga(42)=cnsaga(42)*Q
      cnsaga(47)=cnsaga(47)*Q
      cnsaga(49)=cnsaga(49)*Q
      cnsaga(51)=cnsaga(51)*G
      cnsaga(52)=cnsaga(52)*Q
      cnsaga(54)=cnsaga(54)*G
      cnsaga(56)=cnsaga(56)*G
      cnsaga(58)=cnsaga(58)*Q
c
      RETURN
      end                                              !subroutine SETAG
c
c ======================================================================
c
c     block data AGA8CF
c
c  AGA8 equation of state coefficients taken from the DETAIL
c  compressibility factor equation of:
c
c  Starling, K.E. and Savidge, J.L.
c  Compressibility Factors of Natural Gas and Other Related Hydrocarbon
c  Gases,
c  Transmission Measurement Committee Report No. 8, Catalog No. XQ9212,
c  American Gas Association, 1994.
c
c  written by E.W. Lemmon, NIST Thermophysics Division, Boulder, Colorado
c  10-31-02 EWL, original version
c
c     include 'commons.for'
c
c     data anaga/0.1538326d0,1.341953d0,-2.998583d0,-0.04831228d0,
c    & 0.3757965d0,-1.589575d0,-0.05358847d0,0.88659463d0,-0.71023704d0,
c    & -1.471722d0,1.32185035d0,-0.78665925d0,2.29129D-9,0.1576724d0,
c    & -0.4363864d0,-0.04408159d0,-0.003433888d0,0.03205905d0,
c    & 0.02487355d0,0.07332279d0,-0.001600573d0,0.6424706d0,
c    & -0.4162601d0,-0.06689957d0,0.2791795d0,-0.6966051d0,
c    & -0.002860589d0,-0.008098836d0,3.150547d0,0.007224479d0,
c    & -0.7057529d0,0.5349792d0,-0.07931491d0,-1.418465d0,
c    & -5.99905D-17,0.1058402d0,0.03431729d0,-0.007022847d0,
c    & 0.02495587d0,0.04296818d0,0.7465453d0,-0.2919613d0,7.294616d0,
c    & -9.936757d0,-0.005399808d0,-0.2432567d0,0.04987016d0,
c    & 0.003733797d0,1.874951d0,0.002168144d0,-0.6587164d0,
c    & 0.000205518d0,0.009776195d0,-0.02048708d0,0.01557322d0,
c    & 0.006862415d0,-0.001226752d0,0.002850908d0/
c     data bnaga/18*1,9*2,10*3,7*4,5*5,2*6,2*7,3*8,2*9/
c     data cnaga/12*0,6*1,2*0,7*1,0,9*1,2*0,5*1,0,4*1,0,1,0,6*1/
c     data knaga/12*0,3,3*2,2*4,2*0,3*2,4*4,0,2*1,2*2,2*3,3*4,2*0,3*2,2*4,
c    & 0,2*2,2*4,0,2,0,2,1,4*2/
c     data unaga/0d0,0.5d0,1d0,3.5d0,-0.5d0,4.5d0,0.5d0,7.5d0,9.5d0,6d0,
c    & 12d0,12.5d0,-6d0,2d0,3d0,2d0,2d0,11d0,-0.5d0,0.5d0,0d0,4d0,6d0,
c    & 21d0,23d0,22d0,-1d0,-0.5d0,7d0,-1d0,6d0,4d0,1d0,9d0,-13d0,21d0,
c    & 8d0,-0.5d0,0d0,2d0,7d0,9d0,22d0,23d0,1d0,9d0,3d0,8d0,23d0,1.5d0,
c    & 5d0,-0.5d0,4d0,7d0,3d0,0d0,1d0,0d0/
c     data gnaga/4*0,2*1,18*0,1,3*0,1,2*0,3*1,16*0,1,2*0,1,0,1,2*0/
c     data qnaga/6*0,1,8*0,1,9*0,1,0,1,8*0,1,4*0,1,4*0,1,0,1,2*0,1,5*0,1/
c     data fnaga/12*0,1,13*0,1,2*0,1,4*0,1,23*0/
c     data snaga/7*0,2*1,49*0/
c     data wnaga/9*0,3*1,46*0/
c
c     data mrbaga/16.043d0,28.0135d0,44.01d0,30.07d0,44.097d0,18.0153d0,
c    & 34.082d0,2.0159d0,28.01d0,31.9988d0,58.123d0,58.123d0,72.15d0,
c    & 72.15d0,86.177d0,100.204d0,114.231d0,128.258d0,142.285d0,
c    & 4.0026d0,39.948d0/
c     data ebaga/151.3183d0,99.73778d0,241.9606d0,244.1667d0,298.1183d0,
c    & 514.0156d0,296.355d0,26.95794d0,105.5348d0,122.7667d0,324.0689d0,
c    & 337.6389d0,365.5999d0,370.6823d0,402.636293d0,427.72263d0,
c    & 450.325022d0,470.840891d0,489.558373d0,2.610111d0,119.6299d0/
c     data kbaga/0.4619255d0,0.4479153d0,0.4557489d0,0.5279209d0,
c    & 0.583749d0,0.3825868d0,0.4618263d0,0.3514916d0,0.4533894d0,
c    & 0.4186954d0,0.6406937d0,0.6341423d0,0.6738577d0,0.6798307d0,
c    & 0.7175118d0,0.7525189d0,0.784955d0,0.8152731d0,0.8437826d0,
c    & 0.3589888d0,0.4216551d0/
c     data gbaga/0.d0,0.027815d0,0.189065d0,0.0793d0,
c    & 0.141239d0,0.3325d0,
c    & 0.0885d0,0.034369d0,0.038953d0,0.021d0,0.256692d0,0.281835d0,
c    & 0.332267d0,0.366911d0,0.289731d0,0.337542d0,0.383381d0,
c    & 0.427354d0,0.469659d0,0.d0,0.d0/
c     data qbaga/2*0.d0,0.69d0,2*0.d0,1.06775d0,0.633276d0,14*0.d0/
c     data fbaga/7*0.d0,1.d0,13*0.d0/
c     data sbaga/5*0.d0,1.5822d0,0.39d0,14*0.d0/
c     data wbaga/5*0.d0,1.d0,15*0.d0/
c
c  Binary interaction parameter values
c     data (eijs(1,j),j=1,21)/1.d0,0.97164d0,0.960644d0,1.d0,0.994635d0,
c    & 0.708218d0,0.931484d0,1.17052d0,0.990126d0,1.d0,1.01953d0,
c    & 0.989844d0,1.00235d0,0.999268d0,1.107274d0,0.88088d0,0.880973d0,
c    & 0.881067d0,0.881161d0,1.d0,1.d0/
c     data (eijs(2,j),j=1,21)/2*1.d0,1.02274d0,0.97012d0,0.945939d0,
c    & 0.746954d0,0.902271d0,1.08632d0,1.00571d0,1.021d0,0.946914d0,
c    & 0.973384d0,0.95934d0,0.94552d0,7*1.d0/
c     data (eijs(3,j),j=1,21)/3*1.d0,0.925053d0,0.960237d0,0.849408d0,
c    & 0.955052d0,1.28179d0,1.5d0,1.d0,0.906849d0,0.897362d0,0.726255d0,
c    & 0.859764d0,0.855134d0,0.831229d0,0.80831d0,0.786323d0,0.765171d0,
c    & 2*1.d0/
c     data (eijs(4,j),j=1,21)/4*1.d0,1.02256d0,0.693168d0,0.946871d0,
c    & 1.16446d0,3*1.d0,1.01306d0,1.d0,1.00532d0,7*1.d0/
c     data (eijs(5,j),j=1,21)/7*1.d0,1.034787d0,3*1.d0,1.0049d0,9*1.d0/
c     data (eijs(6,j),j=1,21)/21*1.d0/
c     data (eijs(7,j),j=1,21)/14*1.d0,1.008692d0,1.010126d0,1.011501d0,
c    & 1.012821d0,1.014089d0,2*1.d0/
c     data (eijs(8,j),j=1,21)/8*1.d0,1.1d0,1.d0,1.3d0,1.3d0,9*1.d0/
c     data (eijs(9,j),j=1,21)/21*1.d0/
c     data (eijs(10,j),j=1,21)/21*1.d0/
c     data (eijs(11,j),j=1,21)/21*1.d0/
c     data (eijs(12,j),j=1,21)/21*1.d0/
c     data (eijs(13,j),j=1,21)/21*1.d0/
c     data (eijs(14,j),j=1,21)/21*1.d0/
c     data (eijs(15,j),j=1,21)/21*1.d0/
c     data (eijs(16,j),j=1,21)/21*1.d0/
c     data (eijs(17,j),j=1,21)/21*1.d0/
c     data (eijs(18,j),j=1,21)/21*1.d0/
c     data (eijs(19,j),j=1,21)/21*1.d0/
c     data (eijs(20,j),j=1,21)/21*1.d0/
c     data (eijs(21,j),j=1,21)/21*1.d0/
c     data (uija(1,j),j=1,21)/1.d0,0.886106d0,0.963827d0,
c    & 1.d0,0.990877d0,
c    & 1.d0,0.736833d0,1.15639d0,3*1.d0,0.992291d0,1.d0,1.00367d0,
c    & 1.302576d0,1.191904d0,1.205769d0,1.219634d0,1.233498d0,2*1.d0/
c     data (uija(2,j),j=1,21)/2*1.d0,0.835058d0,0.816431d0,0.915502d0,
c    & 1.d0,0.993476d0,0.408838d0,3*1.d0,0.993556d0,9*1.d0/
c     data (uija(3,j),j=1,21)/3*1.d0,0.96987d0,2*1.d0,1.04529d0,1.d0,
c    & 0.9d0,5*1.d0,1.066638d0,1.077634d0,1.088178d0,1.098291d0,
c    & 1.108021d0,2*1.d0/
c     data (uija(4,j),j=1,21)/4*1.d0,1.065173d0,1.d0,0.971926d0,
c    & 1.61666d0,2*1.d0,4*1.25d0,7*1.d0/
c     data (uija(5,j),j=1,21)/21*1.d0/
c     data (uija(6,j),j=1,21)/21*1.d0/
c     data (uija(7,j),j=1,21)/14*1.d0,1.028973d0,1.033754d0,1.038338d0,
c    & 1.042735d0,1.046966d0,2*1.d0/
c     data (uija(8,j),j=1,21)/21*1.d0/
c     data (uija(9,j),j=1,21)/21*1.d0/
c     data (uija(10,j),j=1,21)/21*1.d0/
c     data (uija(11,j),j=1,21)/21*1.d0/
c     data (uija(12,j),j=1,21)/21*1.d0/
c     data (uija(13,j),j=1,21)/21*1.d0/
c     data (uija(14,j),j=1,21)/21*1.d0/
c     data (uija(15,j),j=1,21)/21*1.d0/
c     data (uija(16,j),j=1,21)/21*1.d0/
c     data (uija(17,j),j=1,21)/21*1.d0/
c     data (uija(18,j),j=1,21)/21*1.d0/
c     data (uija(19,j),j=1,21)/21*1.d0/
c     data (uija(20,j),j=1,21)/21*1.d0/
c     data (uija(21,j),j=1,21)/21*1.d0/
c
c     data (kija(1,j),j=1,21)/1.d0,1.00363d0,0.995933d0,1.d0,1.007619d0,
c    & 1.d0,1.00008d0,1.02326d0,3*1.d0,0.997596d0,1.d0,1.002529d0,
c    & 0.982962d0,0.983565d0,0.982707d0,0.981849d0,0.980991d0,2*1.d0/
c     data (kija(2,j),j=1,21)/2*1.d0,0.982361d0,1.00796d0,2*1.d0,
c    & 0.942596d0,1.03227d0,13*1.d0/
c     data (kija(3,j),j=1,21)/3*1.d0,1.00851d0,2*1.d0,1.00779d0,7*1.d0,
c    & 0.910183d0,0.895362d0,0.881152d0,0.86752d0,0.854406d0,2*1.d0/
c     data (kija(4,j),j=1,21)/4*1.d0,0.986893d0,1.d0,0.999969d0,
c    & 1.02034d0,13*1.d0/
c     data (kija(5,j),j=1,21)/21*1.d0/
c     data (kija(6,j),j=1,21)/21*1.d0/
c     data (kija(7,j),j=1,21)/14*1.d0,0.96813d0,0.96287d0,0.957828d0,
c    & 0.952441d0,0.948338d0,2*1.d0/
c     data (kija(8,j),j=1,21)/21*1.d0/
c     data (kija(9,j),j=1,21)/21*1.d0/
c     data (kija(10,j),j=1,21)/21*1.d0/
c     data (kija(11,j),j=1,21)/21*1.d0/
c     data (kija(12,j),j=1,21)/21*1.d0/
c     data (kija(13,j),j=1,21)/21*1.d0/
c     data (kija(14,j),j=1,21)/21*1.d0/
c     data (kija(15,j),j=1,21)/21*1.d0/
c     data (kija(16,j),j=1,21)/21*1.d0/
c     data (kija(17,j),j=1,21)/21*1.d0/
c     data (kija(18,j),j=1,21)/21*1.d0/
c     data (kija(19,j),j=1,21)/21*1.d0/
c     data (kija(20,j),j=1,21)/21*1.d0/
c     data (kija(21,j),j=1,21)/21*1.d0/
c
c
c     data (gijs(1,j),j=1,21)/2*1.d0,.807653d0,4*1.d0,1.95731d0,13*1.d0/
c     data (gijs(2,j),j=1,21)/2*1.d0,0.982746d0,18*1.d0/
c     data (gijs(3,j),j=1,21)/3*1.d0,0.370296d0,1.d0,1.67309d0,15*1.d0/
c     data (gijs(4,j),j=1,21)/21*1.d0/
c     data (gijs(5,j),j=1,21)/21*1.d0/
c     data (gijs(6,j),j=1,21)/21*1.d0/
c     data (gijs(7,j),j=1,21)/21*1.d0/
c     data (gijs(8,j),j=1,21)/21*1.d0/
c     data (gijs(9,j),j=1,21)/21*1.d0/
c     data (gijs(10,j),j=1,21)/21*1.d0/
c     data (gijs(11,j),j=1,21)/21*1.d0/
c     data (gijs(12,j),j=1,21)/21*1.d0/
c     data (gijs(13,j),j=1,21)/21*1.d0/
c     data (gijs(14,j),j=1,21)/21*1.d0/
c     data (gijs(15,j),j=1,21)/21*1.d0/
c     data (gijs(16,j),j=1,21)/21*1.d0/
c     data (gijs(17,j),j=1,21)/21*1.d0/
c     data (gijs(18,j),j=1,21)/21*1.d0/
c     data (gijs(19,j),j=1,21)/21*1.d0/
c     data (gijs(20,j),j=1,21)/21*1.d0/
c     data (gijs(21,j),j=1,21)/21*1.d0/
c
c  Cp0 coefficients given in:
c  McFall, R.L., M.S. Thesis, University of Oklahoma, 1984.
c  Aly, F.A. and Lee, L.L., Fluid Phase Equilib., 6:169, 1981.
c
c     data acp0/-29776.4d0,-3495.34d0,20.7307d0,-37524.4d0,-56072.1d0,
c    & -13773.1d0,-10085.4d0,-5565.6d0,-2753.49d0,-3497.45d0,-72387.d0,
c    & -72674.8d0,-91505.5d0,-83845.2d0,-94982.5d0,-103353.d0,
c    & -109674.d0,-122599.d0,-133564.d0,0d0,0d0/
c     data bcp0/7.95454d0,6.95587d0,6.96237d0,7.98139d0,8.14319d0,
c    & 7.97183d0,7.9468d0,6.66789d0,6.95854d0,6.96302d0,17.8143d0,
c    & 18.6383d0,21.3861d0,22.5012d0,26.6225d0,30.4029d0,34.0847d0,
c    & 38.5014d0,42.7143d0,4.968d0,4.968d0/
c     data ccp0/43.9417d0,0.272892d0,2.68645d0,24.3668d0,37.0629d0,
c    & 6.27078d0,-0.0838d0,2.33458d0,2.02441d0,2.40013d0,58.2062d0,
c    & 57.4178d0,74.341d0,69.5789d0,80.3819d0,90.6941d0,100.253d0,
c    & 111.446d0,122.173d0,0.d0,0.d0/
c     data dcp0/1037.09d0,662.738d0,500.371d0,752.32d0,735.402d0,
c    & 2572.63d0,433.801d0,2584.98d0,1541.22d0,2522.05d0,1787.39d0,
c    & 1792.73d0,1701.58d0,1719.58d0,1718.49d0,1669.32d0,1611.55d0,
c    & 1646.48d0,1654.85d0,100.d0,100.d0/
c     data ecp0/1.56373d0,-0.291318d0,-2.56429d0,3.5399d0,9.38159d0,
c    & 2.0501d0,2.85539d0,0.749019d0,0.096774d0,2.21752d0,40.7621d0,
c    & 38.6599d0,47.0587d0,46.2164d0,55.6598d0,63.2028d0,69.7675d0,
c    & 80.5015d0,90.2255d0,0.d0,0.d0/
c     data fcp0/813.205d0,-680.562d0,-530.443d0,272.846d0,247.19d0,
c    & 1156.72d0,843.792d0,559.656d0,3674.81d0,1154.15d0,808.645d0,
c    & 814.151d0,775.899d0,802.174d0,802.069d0,786.001d0,768.847d0,
c    & 781.588d0,785.564d0,100.d0,100.d0/
c     data gcp0/-24.9027d0,1.7898d0,3.91921d0,8.44724d0,13.4556d0,
c    & 0.d0,6.31595d0,0.d0,0.d0,0.d0,0.d0,0.d0,0.d0,0.d0,0.d0,0.d0,0.d0,
c    & 0.d0,0.d0,0.d0,0.d0/
c     data hcp0/1019.98d0,1740.06d0,500.198d0,1020.13d0,1454.78d0,
c    & 100.d0,1481.43d0,100.d0,100.d0,100.d0,100.d0,100.d0,100.d0,
c    & 100.d0,100.d0,100.d0,100.d0,100.d0,100.d0,100.d0,100.d0/
c     data icp0/-10.1601d0,0.d0,2.1329d0,-13.2732d0,-11.7342d0,
c    & 0.d0,-2.88457d0,0.d0,0.d0,0.d0,0.d0,0.d0,0.d0,0.d0,0.d0,0.d0,
c    & 0.d0,0.d0,0.d0,0.d0,0.d0/
c     data jcp0/1070.14d0,100.d0,2197.22d0,869.51d0,984.518d0,
c    & 100.d0,1102.23d0,100.d0,100.d0,100.d0,100.d0,100.d0,100.d0,
c    & 100.d0,100.d0,100.d0,100.d0,100.d0,100.d0,100.d0,100.d0/
c     data kcp0/-20.0615d0,4.49823d0,5.81381d0,-22.401d0,-24.0426d0,
c    & -3.24989d0,-0.51551d0,-7.94821d0,6.23387d0,9.19749d0,-44.1341d0,
c    & -46.1938d0,-60.2474d0,-62.2197d0,-77.5366d0,-92.0164d0,
c    & -106.149d0,-122.444d0,-138.006d0,1.8198d0,8.6776d0/
c     end
c
c        1         2         3         4         5         6         7
c23456789012345678901234567890123456789012345678901234567890123456789012
c
c ======================================================================
c                                                    end file MIX_AGA8.f
c ======================================================================
c  begin file mix_HMX.f
c
c  This file contains the routines implementing the mixture Helmholtz
c  equation of state of Lemmon and Jacobsen and of Kunz and Wagner.
c
c  contained here are:
c     function PHIHMX (itau,idel,tau,del,x)
c     function PHIMIX (i,j,itau,idel,tau,del,x)
c     subroutine CRTHMX (x,tc,pc,Dc,ierr,herr)
c     subroutine REDHMX (x,tred,Dred)
c     subroutine RDXHMX (ix,icmp,icmp2,x,tred,Dred,ierr,herr)
c     subroutine SETHMX (hfmix,ierr,herr)
c     subroutine RDBNC (nread,icomp,jcomp,ibin,ierr,herr)
c     subroutine RDMIX (nread,icomp,jcomp,hmodij,lij,ierr,herr)
c     subroutine ESTBNC (i,j,ibin,ierr,herr)
c     subroutine ESTTC (i,j,ierr,herr)
c     subroutine ESTVC (i,j,ierr,herr)
c     subroutine AMH2OR
c
c ======================================================================
c ======================================================================
c
      function PHIHMX (itau,idel,tau,del,x)
c
c  compute reduced Helmholtz energy or a derivative as functions
c  of dimensionless temperature and density for the mixture Helmholtz
c  equation of state
c
c  based on notes of E.W. Lemmon and R.T Jacobsen, U. Idaho, 1995
c
c  inputs:
c     itau--flag specifying order of temperature derivative to calc
c     idel--flag specifying order of density derivative to calculate
c           when itau = 0 and idel = 0, compute A/RT
c           when itau = 0 and idel = 1, compute 1st density derivative
c           when itau = 1 and idel = 1, compute cross derivative
c           etc.
c      tau--dimensionless temperature (To/T)
c      del--dimensionless density (D/Do)
c        x--composition array (mol frac)
c  output (as function value):
c      phi--residual (real-gas) part of the Helmholtz energy, or one
c           of its derivatives (as specified by itau and idel),
c           in reduced form (A/RT)
c
c  N.B.  The reducing parameters To and Do are often, but not
c        necessarily, equal to the critical temperature and density.
c
c        The Helmholtz energy consists of ideal gas and residual (real-
c        gas) terms.  The residual term consists of ideal-solution and
c        mixing terms.  This routine calculates only the residual term.
c
c  written by M. McLinden, NIST Thermophysics Division, Boulder, Colorado
c  11-02-95  MM, original version
c  11-26-95  MM, rearrange argument list (x at end)
c  11-29-95  MM, variable lower limit on coefficient/constant arrays
c                to accommodate ECS reference fluid
c  02-27-96  MM, parameter n0=-ncmax to accommodate ECS-thermo model
c  02-29-96  MM, replace calls to PHIBWR, PHIFEQ with general PHIK
c  03-21-96  MM, delete reference to /MODEL/, not used
c  07-01-96  MM, move x(i)*x(j) multiplier here (remove from PHIMIX)
c  06-03-97 EWL, add third derivative of Helmholtz energy with respect to density.
c  01-07-98  MM, move x(i)*x(j) multiplier back to PHIMIX
c  09-00-00 EWL, switch order of execution, check x=0 before call to PHIMIX
c
      include 'commons.for'
      dimension x(ncmax)
c
      phihmx=0.0d0
      if (del.le.1.d-10) RETURN  !trivial solution at zero density
c
      phisum=0.d0
      do i=1,nc
        if (x(i).gt.1.d-12) then
c  calculate ideal solution term
          phiii=PHIK(i,itau,idel,tau,del)
          phisum=phisum+x(i)*phiii
c         write (*,1200) i,i,x(1),x(2),x(3),phiii,phisum
c1200     format (1x,' PHIHMX--i,j,x,phi_ij:  ',2i4,3f8.5,1pe14.6)
        end if
      enddo
c!$omp parallel private(phisum)
      do i=1,nc-1
c  calculate mixing term
        if (x(i).gt.1.d-12) then
          do j=i+1,nc
            if (x(j).gt.1.d-12) then
              phiij=PHIMIX(i,j,itau,idel,tau,del,x)
              phisum=phisum+phiij
            end if
          enddo
        endif
      enddo
c!$omp end parallel
      phihmx=phisum
c
      RETURN
      end                                               !function PHIHMX
c
c ======================================================================
c
      function PHIMIX (icomp,jcomp,itau,idel,tau,del,x)
c
c  compute reduced Helmholtz energy of mixing (or a derivative)
c  for the binary interaction of components i and j as a function of
c  composition and dimensionless temperature and density for the
c  mixture Helmholtz equation of state
c
c  inputs:
c    icomp--component i
c    jcomp--component j
c     itau--flag specifying order of temperature derivative to calc
c     idel--flag specifying order of density derivative to calculate
c           when itau = 0 and idel = 0, compute Amix/RT
c           when itau = 0 and idel = 1, compute 1st density derivative
c           when itau = 1 and idel = 1, compute cross derivative
c           etc.
c      tau--dimensionless temperature (To/T)
c      del--dimensionless density (D/Do)
c        x--composition array (mol frac)
c  output (as function value):
c      phi--mixture interaction (excess) part of the Helmholtz energy,
c           or one of its derivatives (as specified by itau and idel),
c           in reduced form (Amix/RT)
c
c        The Helmholtz energy consists of ideal gas and residual (real-
c        gas) terms.  The residual term consists of ideal-solution and
c        mixing terms.  This routine calculates only the mixing term.
c
c  N.B.  This routine incorporates the mixture-specific multiplier
c        (e.g. the Fpq of the Lemmon & Jacobsen model).
c
c  written by M. McLinden, NIST Thermophysics Division, Boulder, Colorado
c  11-02-95  MM, original version
c  11-26-95  MM, rearrange argument list (x at end)
c  11-29-95  MM, variable lower limit on coefficient/constant arrays
c                to accommodate ECS reference fluid
c  01-10-96  MM, add commons /CFXHMX/ and /CFIHMX/
c  02-27-96  MM, parameter n0=-ncmax to accommodate ECS-thermo model
c  03-21-96  MM, delete reference to /MODEL/, not used
c  05-06-96  MM, add /MIXMOD/, cases for different mix models
c  06-12-96  MM, add /HMXSAV/, LJi and LMi models
c  07-01-96  MM, move x(i)*x(j) multiplier to PHIHMX; remove x from inputs
c  11-04-96  MM, replace van der Waals rule with linear (LIN),
c                change nmxpar from 4 to 6
c  11-26-97 APP, add mixture model for Ammonia-Water and common block /AMMWAT/
c  12-01-97  MM, add composition to inputs (used by ammonia-water)
c  01-07-98  MM, move x(i)*x(j) back to here from PHIHMX
c  12-22-98 EWL, reorganize ammonia-water code
c  12-22-98 EWL, fix errors in derivatives of ammonia-water equation
c  12-24-98 EWL, add third derivative of tau to LJ model
c  12-24-98 EWL, change AMMWAT common block to FLAGS2 common block
c  09-00-00 EWL, add logic to return old value if inputs are same
c  09-00-00 EWL, change del^d, etc. to LOG format to increase calculation speed
c  09-00-00 EWL, add exponential pieces to mixture terms
c  02-14-01 EWL, increase dimension on amix to 4
c                change use of iexpmx(i,j,k) to amix(i,j,k,4)
c  07-30-01 EWL, move iamwat=0 to beginning of code
c  08-08-01 EWL, change -delli to delli to mimic core_feq routines
c  08-17-06 EWL, update program for GERG-2004 equation of Kunz and Wagner
c  10-19-06 EWL, change calculation of ncode2 to work with "KW"
c  04-16-10 EWL, increase nmsav from 25 to 55 to allow KWA, KWB, KWC, etc.
c
      include 'commons.for'
      dimension x(ncmax)
c
      phimix=0.0d0
      if (del.le.1.0d-10) then    !trivial solution at zero density
        RETURN                    !for any and all derivatives
      end if
      if (tau.le.0.0d0) RETURN
c
      i=icomp
      j=jcomp
      ncode2=0
      if (hmodmx(i,j)(1:2).eq.'LJ') ncode2=ichar(hmodmx(i,j)(3:3))-47
      if (hmodmx(i,j)(1:2).eq.'KW') ncode2=ichar(hmodmx(i,j)(3:3))-37
      if (hmodmx(i,j)(1:2).eq.'LM') ncode2=ichar(hmodmx(i,j)(3:3))-27
      if (ncode2.lt.0 .or. ncode2.gt.nmsav) then
        phimix=1.d20
        RETURN
      endif
      if (hmodmx(i,j).eq.'LIN' .or. i.eq.j) then
c
c  linear mixing rules:  all departures from ideal solution are
c  contained in the reducing parameters (i.e. Kt and/or Kv)
c
        phimix=0.0d0
c
      elseif (ncode2.ne.0) then
        ncode=idel*4+itau+1
c
c  Lemmon-Jacobsen or modified Lemmon-Jacobsen mixing function
c
        phisum=0.0d0
        ifij=3
        if (hmodmx(i,j)(1:2).eq.'KW') ifij=5
        if (abs(tau-tausvh(ncode2)).lt.1.0d-12 .and.
     &      abs(del-delsvh(ncode2)).lt.1.0d-12) then
          if (drvflh(ncode2)(ncode:ncode).eq.'1') then
            PHIMIX=x(i)*x(j)*fmix(i,j,ifij)*drvsvh(ncode2,ncode)
            RETURN
          endif
c  retrieve value from previous call
        else
c  otherwise, compute new values and save for possible future use
          drvflh(ncode2)='0000000000000000'
          do k=1,namix(i,j)
            dellih(ncode2,k)=0
            if (abs(amix(i,j,k,4)).gt.1.d-20)
     &          dellih(ncode2,k)=del**amix(i,j,k,4)
            savijk=amix(i,j,k,1)*EXP(amix(i,j,k,2)*log(tau)
     &            +amix(i,j,k,3)*log(del)-dellih(ncode2,k))
            phisvh(ncode2,k)=savijk
            phisum=phisum+savijk
c           write (*,1010) k,phisvh(ncode2,k),phisum
c1010       format (1x,i3,2d30.20)   !write out each term for debugging
          enddo
          if (namix2(i,j).ne.0) then
            do k=namix(i,j)+1,namix(i,j)+namix2(i,j)
              dellih(ncode2,k)=amix(i,j,k,4)*(del-amix(i,j,k,5))**2
              delli2         =amix(i,j,k,6)*(del-amix(i,j,k,7))
              savijk=amix(i,j,k,1)*EXP(amix(i,j,k,2)*log(tau)
     &              +amix(i,j,k,3)*log(del)-dellih(ncode2,k)
     &                                     -delli2)
              phisvh(ncode2,k)=savijk
              phisum=phisum+savijk
            enddo
          endif
          tausvh(ncode2)=tau
          delsvh(ncode2)=del
          drvsvh(ncode2,1)=phisum
          drvflh(ncode2)(1:1)='1'
        end if
c
c  check if derivatives are requested, calculations make use of fact
c  that terms in derivative summations are very similar to A/RT terms
c
        if (idel.eq.1) then
c  compute derivative w.r.t. del (dimensionless density)
c  save individual terms for possible use in cross derivative
          phisum=0.0d0
          do k=1,namix(i,j)
            phix01(k)=phisvh(ncode2,k)
     &              *(amix(i,j,k,3)-amix(i,j,k,4)*dellih(ncode2,k))
            phisum=phisum+phix01(k)
          enddo
          if (namix2(i,j).ne.0) then
            do k=namix(i,j)+1,namix(i,j)+namix2(i,j)
              phix01(k)=phisvh(ncode2,k)
     &                *(amix(i,j,k,3)
     &   -2.d0*del*amix(i,j,k,4)*(del-amix(i,j,k,5))-del*amix(i,j,k,6))
              phisum=phisum+phix01(k)
            enddo
          endif
        elseif (idel.eq.2) then
c  compute 2nd derivative w.r.t. del (dimensionless density)
          phisum=0.0d0
          do k=1,namix(i,j)
            ax3=amix(i,j,k,3)
            dell=amix(i,j,k,4)*dellih(ncode2,k)
            phix02(k)=phisvh(ncode2,k)
     &           *(ax3**2-ax3-dell*(2.0d0*ax3+amix(i,j,k,4)-1.0d0-dell))
            phisum=phisum+phix02(k)
c         end if
          enddo
          if (namix2(i,j).ne.0) then
            do k=namix(i,j)+1,namix(i,j)+namix2(i,j)
              aa3=amix(i,j,k,3)
              aa4=amix(i,j,k,4)
              phix02(k)=phisvh(ncode2,k)
     &  *(del**2*(aa3/del-2.d0*aa4*(del-amix(i,j,k,5))-amix(i,j,k,6))**2
     &  -aa3-2.d0*aa4*del**2)
              phisum=phisum+phix02(k)
            enddo
          endif
        elseif (idel.eq.3) then
c  compute 3nd derivative w.r.t. del (dimensionless density)
          phisum=0.0d0
          do k=1,namix(i,j)
            ax3=amix(i,j,k,3)
            dell=amix(i,j,k,4)*dellih(ncode2,k)
            dl=amix(i,j,k,4)
            phix03(k)=phisvh(ncode2,k)
     &      *(2.0d0*ax3-3.0d0*ax3*ax3+ax3**3+dell*(-2.0d0+3.0d0*dl-dl**2
     &       +6.0d0*ax3-3.0d0*ax3*dl-3.0d0*ax3**2
     &       +dell*(-3.0d0+3.0d0*dl+3.0d0*ax3-dell)))
            phisum=phisum+phix03(k)
          enddo
          if (namix2(i,j).ne.0) then
            do k=namix(i,j)+1,namix(i,j)+namix2(i,j)
c  3rd derivative has not been implemented yet
c             phix03(k)=...
c             phisum=phisum+phix03(k)
            enddo
          endif
        end if
c
        if (itau.eq.1) then
c  compute derivative w.r.t. tau (dimensionless temperature)
c  save individual terms for possible use in cross derivative
          phisum=0.0d0
          do k=1,namix(i,j)+namix2(i,j)
            phix10(k)=phisvh(ncode2,k)*amix(i,j,k,2)
            phisum=phisum+phix10(k)
          enddo
        elseif (itau.eq.2) then
c  compute 2nd derivative w.r.t. tau (dimensionless temperature)
          phisum=0.0d0
          do k=1,namix(i,j)+namix2(i,j)
            ax2=amix(i,j,k,2)
            phix20(k)=phisvh(ncode2,k)*ax2*(ax2-1.0d0)
            phisum=phisum+phix20(k)
          enddo
        elseif (itau.eq.3) then
c  compute 3rd derivative w.r.t. tau (dimensionless temperature)
          phisum=0.0d0
          do k=1,namix(i,j)+namix2(i,j)
            ax2=amix(i,j,k,2)
            phisum=phisum+phisvh(ncode2,k)*ax2*(ax2-1.0d0)*(ax2-2.0d0)
          enddo
        end if
c
        if (itau.eq.1 .and. idel.eq.1) then
c  compute cross derivative using terms from 1st derivatives
          phisum=0.0d0
          do k=1,namix(i,j)+namix2(i,j)
            if (ABS(phisvh(ncode2,k)).gt.1.d-20)
     &          phisum=phisum+phix10(k)*phix01(k)/phisvh(ncode2,k)
          enddo
        end if
        drvsvh(ncode2,ncode)=phisum
        drvflh(ncode2)(ncode:ncode)='1'
        PHIMIX=x(i)*x(j)*fmix(i,j,ifij)*phisum    !fmix(i,j,3) is Fpq
c
      elseif (hmodmx(i,j).eq.'TR1') then
c
c  ammonia-water model of Tillner-Roth
c
c  flip compositions; fmix(i,j,5) is gamma
         ij=iamwat
         phisum=0.0d0
c
         do k=1,14
           ak=amix(i,j,k,1)
           tk=amix(i,j,k,2)
           dk=amix(i,j,k,3)
           ik=amix(i,j,k,4)
           xk=1.0d0
           if (k.ge.7) xk=x(ij)
           if (k.eq.14) xk=xk**2
           delik=-del**ik
           bk=1.0d0
           if (ik.gt.0) bk=exp(delik)
           aka=xk*ak*tau**tk*del**dk*bk
c
           if (itau.eq.0 .and. idel.eq.0) then           !no deriv
             phisum=phisum+aka
           elseif (itau.eq.0 .and. idel.eq.1) then    !1st deriv of del
             phisum=phisum+aka*(dk+ik*delik)
           elseif (itau.eq.0 .and. idel.eq.2) then    !2nd deriv of del
             phisum=phisum+aka*(dk*(dk-1.0d0)
     &             +ik*delik*(ik-1.0d0+2.0d0*dk+ik*delik))
           elseif (itau.eq.0 .and. idel.eq.3) then    !3rd deriv of del
             dki = ik*delik
             phisum=phisum+(dk*(dk-1.0d0)*(dk-2.0d0)
     &         +dki*(3.0d0*dk*((dk-2.0d0)+ik)+(ik-1.0d0)*(ik-2.0d0)
     &         +3.0d0*dki*(dk+(ik-1.0d0))+dki*dki))*aka
           elseif (itau.eq.1 .and. idel.eq.0) then    !1st deriv of tau
             phisum=phisum+tk*aka
           elseif (itau.eq.2 .and. idel.eq.0) then    !2nd deriv of tau
             phisum=phisum+tk*(tk-1.0d0)*aka
           elseif (itau.eq.3 .and. idel.eq.0) then    !3rd deriv of tau
             phisum=phisum+tk*(tk-1.0d0)*(tk-2.0d0)*aka
           elseif (itau.eq.1 .and. idel.eq.1) then!deriv of tau and del
             phisum=phisum+aka*tk*(dk+ik*delik)
           end if
         enddo
         PHIMIX=phisum*x(ij)*(1.0d0-x(ij)**fmix(i,j,5))
      else
c
c  space for additional mixing rule
c
        PHIMIX=0.0d0                !not currently implemented
c       write (*,*) ' PHIMIX ERROR--unknown mixing rule'
      end if
c
      RETURN
      end                                               !function PHIMIX
c
c ======================================================================
c
      subroutine CRTHMX (x,tc,pc,Dc,ierr,herr)
c
c  returns critical parameters associated with mixture Helmholtz EOS
c
c  N.B.  these critical parameters are estimates based on polynomial
c        fits to the binary critical lines and (for 3 or more components)
c        combining rules applied to the constituent binaries
c
c  input:
c        x--composition array (mol frac)
c  outputs:
c       tc--critical temperature (K)
c       pc--critical pressure (kPa)
c       Dc--molar density (mol/L) at critical point
c     ierr--error flag:  0 = successful
c                        1 = did not converge
c                     -131 = coefficients not available for calculation,
c                            this occurs because either the binary has
c                            not been fit (i.e., beta versions of the program)
c                            or the mixture is not type 1
c                     -132 = spline curves are available, but no solution available
c     herr--error string (character*255 variable if ierr<>0)
c
c  written by M. McLinden, NIST Thermophysics Division, Boulder, Colorado
c  11-02-95  MM, original version
c  11-29-95  MM, variable lower limit on coefficient/constant arrays
c                to accommodate ECS reference fluid
c  01-29-96  MM, critical parameters based on average of pure fluid
c  02-27-96  MM, parameter n0=-ncmax to accommodate ECS-thermo model
c                add Zcrit to common /CCON/
c  03-19-19  MM, add dipole moment to /CCON/
c  05-06-96  MM, replace temporary func for crit pars with reducing pars
c  11-19-96  MM, add empirical function for critical line(s)
c  11-14-97 EWL, fix bug in critical line correlation
c  11-24-97  MM, Tsum = x(i)*x(j)*Tij, not xij*tcij, ditto for Vsum
c  01-21-98 APP, add Rainwater's ammonia-water critical line equations
c                for hmodmx(i,j) = 'TR1'
c  12-01-98 EWL, add Reos and triple point pressure and density to /CCON/
c  12-22-98 EWL, if x(i)=1 for any component, return with pure fluid parameters
c  12-23-98 EWL, rearrange code to eliminate extra calculations with amm-water
c  03-04-02 EWL, check sum(x)=0
c  08-17-06 EWL, update program for GERG-2004 equation of Kunz and Wagner
c  08-21-06 EWL, if TC1 or VC1 are not available, return reducing parameters instead of an error message
c  02-13-13 EWL, return values from spline curves if available
c
      include 'commons.for'
      character*255 herr
      dimension x(ncmax)
c
      ierr=0
      herr=' '
      call ISPURE (x,icomp)
      if (icomp.ne.0) then
        tc=Tcrit(icomp)
        Dc=Dcrit(icomp)
        pc=Pcrit(icomp)
        RETURN
      end if
      if (iSpline.ne.0) then
        if (ierrcrt.eq.0) then
          ix=1
          do i=1,nc
            if (abs(x(i)-xspln(i)).gt.1.d-6) ix=0
          enddo
          if (ix.eq.1) then
            tc=crtt
            pc=crtp
            Dc=crtd
            RETURN
          endif
        endif
      end if

c
      tsum=0.0d0
      vsum=0.0d0
      xsum=0.0d0
c     write (*,1010) (x(k),k=1,nc),(tcrit(k),k=1,nc)
c1010 format (' CRTHMX input x,Tc:  ',10f10.4)
      do i=1,nc-1
        if (x(i).gt.0.d0) then
        do j=i+1,nc
          if (x(j).gt.0.d0) then
            xsum=xsum+x(i)*x(j)
c  the tcij and Vcij are the binary critical line correlations, and
c  these terms (ONLY) are evaluated at the pseudo-binary compositions
c  defined by xi and xj:
            xi=0.5d0*(x(i)+(1.0d0-x(j)))
            xj=0.5d0*(x(j)+(1.0d0-x(i)))
            xij=xi*xj
            if (hmodtc(i,j).eq.'TC1') then
              if (abs(ftcij(i,j,1)).lt.1.d-12) then
                ierr=-131
                herr='[CRTHMX error -131] coefficients not available '//
     &               'for critical line calculation, mixture may not '//
     &               'be type 1'//hnull
              endif
              tcij=xi*Tcrit(i)+xj*Tcrit(j)+xij*ftcij(i,j,1)
c  terms assuming mixture specified in same order as in hmx.bnc file
     &            +xj*xi*(ftcij(i,j,2)+(ftcij(i,j,3)+(ftcij(i,j,4)
     &            +(ftcij(i,j,5)+ftcij(i,j,6)*xi)*xi)*xi)*xi)*xi
c  extra terms to allow specifying mix in opposite order (j,i)
c  note:  either terms 2-6 or 7-11 should be set to zero in RDBNC
     &            +xi*xj*((ftcij(i,j,7)+(ftcij(i,j,8)+(ftcij(i,j,9)
     &            +(ftcij(i,j,10)+ftcij(i,j,11)*xj)*xj)*xj)*xj)*xj)
c           write (*,*) 'Tcij using mixture model TC1:  ',i,j,tcij
            else
c             ierr=1
c             herr='[CRTHMX error] Tcrit model not found'//hnull
c             call ERRMSG (ierr,herr)
c             tcij=xi*tcrit(i)+xj*tcrit(j)
              call REDHMX (x,tc,Dc)
              goto 100
            end if
            tsum=tsum+x(i)*x(j)*tcij
            if (hmodvc(i,j).eq.'VC1') then
              Vcij=xi/Dcrit(i)+xj/Dcrit(j)+xij*fvcij(i,j,1)
c  terms assuming mixture specified in same order as in hmx.bnc file
     &            +xj*xi*((fvcij(i,j,2)+(fvcij(i,j,3)+(fvcij(i,j,4)
     &            +(fvcij(i,j,5)+fvcij(i,j,6)*xi)*xi)*xi)*xi)*xi)
c  extra terms to allow specifying mix in opposite order (j,i)
c  note:  either terms 2-6 or 7-11 should be set to zero in RDBNC
     &            +xi*xj*((fvcij(i,j,7)+(fvcij(i,j,8)+(fvcij(i,j,9)
     &            +(fvcij(i,j,10)+fvcij(i,j,11)*xj)*xj)*xj)*xj)*xj)
            else
c             ierr=1
c             herr='[CRTHMX error] Vcrit model not found'//hnull
c             call ERRMSG (ierr,herr)
c             Vcij=xi/Dcrit(i)+xj/Dcrit(j)
              call REDHMX (x,tc,Dc)
              goto 100
            end if
            vsum=vsum+x(i)*x(j)*Vcij
          endif
c         write (*,1016) i,j,tcij,Vcij,xsum
c1016     format (' CRTHMX:  i,j,Tc_ij,Vc_ij,xsum:  ',2i3,3f12.6)
c         write (*,1017) i,j,(ftcij(i,j,k),k=1,nmxtc)
c1017     format (' CRTHMX:  i,j,ftcij:  ',2i3,8f10.6)
        enddo
        endif
      enddo
      if (xsum.gt.1.0d-12) then
        tc=tsum/xsum
        Dc=xsum/vsum
      else
        tc=300
        Dc=10
        pc=10
        ierr=1
        herr='[CRTHMX error] sum(x)=0'//hnull
        call ERRMSG (ierr,herr)
      end if
c
c  base Pc on Tc, Dc
 100  continue
      call PRESS (tc,Dc,x,pc)
      if (pc.lt.0) pc=Pcrit(1)
      if (ierrcrt.gt.0 .and. iSpline.ne.0 .and. ierr.eq.0) then
        ierr=-132
        herr='[CRTHMX error -132] Failed to find critical point from'//
     &       ' splines, values given here used TC1 and VC1'//
     &       ' coefficients'//hnull
      endif
c     write (*,1024) tc,1.0/Dc,pc
c1024 format (' CRTHMX:  Tc,Vc,Pc:  ',15x,3f12.6)
c
      RETURN
      end                                             !subroutine CRTHMX
c
c ======================================================================
c
      subroutine REDHMX (x,tred,Dred)
c
c  01-26-10 EWL, rename original routine with new inputs, keep this routine
c                for old applications.
c
      include 'commons.for'
      character*255 herr
      dimension x(ncmax)
c
      call RDXHMX (0,0,0,x,tred,Dred,ierr,herr)
      end                                             !subroutine REDHMX
c
c ======================================================================
c
      subroutine RDXHMX (ix,icmp,icmp2,x,tred,Dred,ierr,herr)
c
c  returns reducing parameters and their derivatives associated with
c  the mixture Helmholtz EOS; these are used to calculate the 'tau' and 'del'
c  that are the independent variables in the EOS.
c
c  input:
c        x--composition array [mol frac]
c     icmp--component number for which derivative will be calculated
c    icmp2--second component number for which derivative will be calculated
c       ix--flag specifying order of composition derivative to calculate
c           when ix = 0, compute T(red) and rho(red)
c         for icmp2=0:
c           when ix = 1, compute 1st derivative with respect to x(icmp)
c           when ix = 2, compute 2nd derivative with respect to x(icmp)
c         for icmp<>0 and icmp2<>0:
c           when ix = 11, compute cross derivative with respect
c                         to x(icmp) and x(icmp2)
c  outputs:
c     tred--reducing temperature [K] or derivative
c     Dred--reducing molar density [mol/L] or derivative of reducing volume
c           (ix=0: rhoc; ix=1: dvc/dxi; ix=2: d^2vc/dxi^2; ix=11: d^2vc/dxidxj)
c     ierr--error flag:  0 = successful
c                      190 = Mixing rule not found for i,j
c                      191 = Derivative not available
c     herr--error string (character*255 variable if ierr<>0)
c
c  written by M. McLinden, NIST Thermophysics Division, Boulder, Colorado
c  11-02-95  MM, original version
c  11-29-95  MM, variable lower limit on coefficient/constant arrays
c                to accommodate ECS reference fluid
c  02-27-96  MM, parameter n0=-ncmax to accommodate ECS-thermo model
c                add Zcrit to common /CCON/
c  03-19-19  MM, add dipole moment to /CCON/
c  03-21-96  MM, replace call to REDFEQ with general REDX, delete /MODEL/
c  05-06-96  MM, add /MIXMOD/,/CFXHMX/,/CFIHMX/; add Kt, Kv dependence;
c                branch for arithmetic or geometric mean of temperature
c  05-14-96  MM, modify volume mixing rule for VDW model; use arithmetic
c                average of critical volumes, rather than Reiner's rule
c  06-10-96  MM, modify volume mixing rule for VDW model (again); use
c                average of cube root of critical volumes
c                add Lemmon-Jacobsen mixing rules
c  06-12-96  MM, add LMx mixing rules (Lemmon-Jacobsen modified to be of
c                form compatible with van der Waal's (VDW) model
c  07-01-96  MM, fix bug--missing **3 in VDW volume term
c  11-04-96  MM, replace van der Waals rule with linear (LIN),
c                change nmxpar from 4 to 6
c  11-08-96  MM, fix wrong array reference for Kv
c  11-14-96  MM, fix wrong array reference for zeta, xi (LJi model)
c  05-22-97  MM, bug fix:  beta, gamma were applied to V, should not be
c  11-26-97 APP, add Ammonia-Water model and common block /AMMWAT/
c  12-01-98 EWL, add Reos and triple point pressure and density to /CCON/
c  12-24-98 EWL, change AMMWAT common block to FLAGS2 common block
c  12-24-98 EWL, fix ammonia-water code to fit within do-loop
c  12-24-98 EWL, avoid reducing values of 0 when a fluid has not been loaded
c  02-14-01 EWL, increase dimension on amix to 4
c                change use of iexpmx(i,j,k) to amix(i,j,k,4)
c  08-08-01 EWL, remove the 0.5* in tc12= and vc12= used in the linear and LM models
c  08-17-06 EWL, update program for GERG-2004 equation of Kunz and Wagner
c  08-21-06 EWL, add Kunz and Wagner mixing rules
c  03-05-07 EWL, add fmix2 array in case fluids are entered in opposite order as required by Kunz and Wagner
c  01-26-10 EWL, rename subroutine
c  01-26-10 EWL, add derivatives with respect to composition
c  02-13-13 EWL, change error numbers
c
      include 'commons.for'
      character*255 herr
      dimension x(ncmax)
c
      ierr=0
      herr=' '
      tsum=0.0d0
      vsum=0.0d0
      onethrd=-0.33333333333333333333d0
c
      if (ix.le.0) then
        do i=1,nc
          if (x(i).gt.0.d0) then
          do j=i,nc
            if (x(j).gt.0.d0) then



            if (ix.eq.-1) then
c-----------------------------------------------------------------------
c  These are the full Kunz-Wagner relations, but should only be used
c  for numerical testing of analytical derivatives.  If used in combination
c  with other mixing rules (e.g., LJ6 or TR1), the computations will not
c  be correct.  These equations work when sum(x(k))<>0, as is the case
c  when taking a numerical derivative of a property with respect to x(i)
c  holding all other compositions constant.
              if (hmodmx(ione1,itwo2)(1:2).eq.'KW') then
                tc12=SQRT(tz(i)*tz(j))
                vc12=(rhoz(i)**onethrd+rhoz(j)**onethrd)**3/8.d0
                xij=x(i)*x(j)*(x(i)+x(j))
                if (i.eq.j) then
                  ftij=xij/(x(i)+x(j))
                  fvij=xij/(x(i)+x(j))
                  ctij=tc12
                  cvij=vc12
                else
                  ftij=xij/(fmix(i,j,1)**2*x(i)+fmix2(i,j,1)**2*x(j))
                  fvij=xij/(fmix(i,j,3)**2*x(i)+fmix2(i,j,3)**2*x(j))
                  ctij=2.d0*fmix(i,j,1)*fmix2(i,j,1)*fmix(i,j,2)*tc12
                  cvij=2.d0*fmix(i,j,3)*fmix2(i,j,3)*fmix(i,j,4)*vc12
                endif
                tsum=tsum+ctij*ftij
                vsum=vsum+cvij*fvij
c  original Lemmon-Jacobsen rule using zeta, xi
              elseif (hmodmx(ione1,itwo2)(1:2).eq.'LJ') then
                if (i.eq.j) then
                  tsum=tsum+x(i)*tz(i)
                  vsum=vsum+x(i)/rhoz(i)
                else
                  xij=x(i)*x(j)
                  xijt=x(i)**fmix(i,j,4)*x(j)**fmix(i,j,5)
                  tsum=tsum+xijt*fmix(i,j,1)
                  vsum=vsum+xij*fmix(i,j,2)
                endif
              endif
c-----------------------------------------------------------------------



c  special case when i = j
            elseif (i.eq.j) then
              tsum=tsum+x(i)*tz(i)
              vsum=vsum+x(i)/rhoz(i)

c  Kunz-Wagner rule
            elseif (hmodmx(i,j)(1:2).eq.'KW' .and. heos.ne.'PR') then
              tc12=SQRT(tz(i)*tz(j))
              vc12=(rhoz(i)**onethrd+rhoz(j)**onethrd)**3/8.d0
              xij=x(i)*x(j)*(x(i)+x(j))
              ftij=xij/(fmix(i,j,1)**2*x(i)+fmix2(i,j,1)**2*x(j))
              fvij=xij/(fmix(i,j,3)**2*x(i)+fmix2(i,j,3)**2*x(j))
              ctij=2.d0*fmix(i,j,1)*fmix2(i,j,1)*fmix(i,j,2)*tc12
              cvij=2.d0*fmix(i,j,3)*fmix2(i,j,3)*fmix(i,j,4)*vc12
              tsum=tsum+ctij*ftij
              vsum=vsum+cvij*fvij
c  the following addition allows the use of linear mixture rules x(i)*Tc(i)
c  when the specified rule (as in this case for the GERG-2004 equation) is
c  not linear:  x(i)^2*Tc(i)
              tsum=tsum-x(i)*x(j)*(tz(i)+tz(j))
              vsum=vsum-x(i)*x(j)*(1.d0/rhoz(i)+1.d0/rhoz(j))

c  original Lemmon-Jacobsen rule using zeta, xi
            elseif (hmodmx(i,j)(1:2).eq.'LJ' .and. heos.ne.'PR') then
              xij=x(i)*x(j)
              xijt=x(i)**fmix(i,j,4)*x(j)**fmix(i,j,5) !fmix(i,j,5) = gamma
              tsum=tsum+xijt*fmix(i,j,1)               !fmix(i,j,1) = zeta(T)
              vsum=vsum+xij*fmix(i,j,2)                !fmix(i,j,2) = xi  (x)

c  mixing parameters for the Ammonia-Water model
c  fmix(i,j,1)=Kt, fmix(i,j,2)=Kv, fmix(i,j,3)=alpha, fmix(i,j,4)=beta
            elseif (hmodmx(i,j).eq.'TR1' .and. heos.ne.'PR') then
              ij=i
              if (iamwat.eq.2) ij=j
              tc12=tz(i)+tz(j)
              vc12=1.0d0/rhoz(i)+1.0d0/rhoz(j)
             tsum=tsum+x(ij)*(1.0d0-x(ij)**fmix(i,j,3))*fmix(i,j,1)*tc12
     &                -x(i)*x(j)*tc12
             vsum=vsum+x(ij)*(1.0d0-x(ij)**fmix(i,j,4))*fmix(i,j,2)*vc12
     &                -x(i)*x(j)*vc12

c  simple linear mixing rules
            elseif (hmodmx(i,j).eq.'LIN') then        !Not used in hmx.bnc
              xij=x(i)*x(j)
              tc12=(tz(i)+tz(j))
              vc12=(1.0d0/rhoz(i)+1.0d0/rhoz(j))
              tsum=tsum+xij*(fmix(i,j,1)-1.0d0)*tc12   !fmix(i,j,1) = Kt(i,j)
              vsum=vsum+xij*(fmix(i,j,2)-1.0d0)*vc12   !fmix(i,j,2) = Kv(i,j)

c  Lemmon-Jacobsen rule modified to use Kt, Kv, rather than zeta, xi
            elseif (hmodmx(i,j)(1:2).eq.'LM') then    !obsolete (from version 6)
              xij=x(i)*x(j)
              xijt=x(i)**fmix(i,j,4)*x(j)**fmix(i,j,5) !fmix(i,j,4) = beta
              tc12=(tz(i)+tz(j))                       !fmix(i,j,5) = gamma
              vc12=(1.0d0/rhoz(i)+1.0d0/rhoz(j))
              tsum=tsum+xijt*(fmix(i,j,1)-1.0d0)*tc12  !fmix(i,j,1) = Kt(i,j)
              vsum=vsum+xij*(fmix(i,j,2)-1.0d0)*vc12   !fmix(i,j,2) = Kv(i,j)

c  mixing rule not specified or not found--should not get here
c  call ERRMSG anyways in case error messages are being written to the screen
            else
              ierr=190
              herr='[RDXHMX error 190] Mixing rule not found for i,j'
              call ERRMSG (ierr,herr)
            end if
            end if
          enddo
          end if
        enddo
        if (ABS(tsum).gt.0.5d-12 .and. ABS(vsum).gt.0.5d-12) then
          tred=tsum
          Dred=1.0d0/vsum
        else
          tred=100
          Dred=10
        endif

c  calculate derivatives of Tc and vc
      else
        if (heos.eq.'PR') goto 100
        do k=1,nc
         if (x(k).gt.0.d0 .and. x(icmp).gt.0.d0) then
c         if (ix.eq.1 .and. k.eq.icmp) then                 !LJ linear mixing rules
c           tsum=tsum+1.d0*tz(icmp)                !Needs to be 2.d0* to work with KW, but 1.0 for LJ
c           vsum=vsum+1.d0/rhoz(icmp)

          if (k.eq.icmp .and. ix.eq.1) then
            tsum=tsum+2.d0*x(icmp)*tz(icmp)
            vsum=vsum+2.d0*x(icmp)/rhoz(icmp)
          elseif (k.eq.icmp .and. ix.eq.2) then
            tsum=tsum+2.d0*tz(icmp)
            vsum=vsum+2.d0/rhoz(icmp)
          elseif (ix.eq.11 .and. k.eq.icmp) then
          elseif (hmodmx(k,icmp)(1:2).eq.'KW') then
c  Kunz-Wagner mixing rules
            tc12=SQRT(tz(k)*tz(icmp))
            vc12=(rhoz(k)**onethrd+rhoz(icmp)**onethrd)**3/8.d0
            ctij=2.d0*fmix(k,icmp,1)*fmix2(k,icmp,1)*fmix(k,icmp,2)*tc12
            cvij=2.d0*fmix(k,icmp,3)*fmix2(k,icmp,3)*fmix(k,icmp,4)*vc12
            xij=x(k)+x(icmp)
            f11=fmix (k,icmp,1)**2
            f13=fmix (k,icmp,3)**2
            f21=fmix2(k,icmp,1)**2
            f23=fmix2(k,icmp,3)**2
            if (k.lt.icmp) then
              ftij=f11*x(k)+f21*x(icmp)
              fvij=f13*x(k)+f23*x(icmp)
              st=f21/ftij
              sv=f23/fvij
              ut=f11/ftij
              uv=f13/fvij
            else
              ftij=f21*x(k)+f11*x(icmp)
              fvij=f23*x(k)+f13*x(icmp)
              st=f11/ftij
              sv=f13/fvij
              ut=f21/ftij
              uv=f23/fvij
            endif
            if (ix.eq.1) then
              ftij=x(k)/ftij*(xij+x(icmp)*(1.d0-st*xij))
              fvij=x(k)/fvij*(xij+x(icmp)*(1.d0-sv*xij))
            elseif (ix.eq.2) then
              ftij=x(k)/ftij*(1.d0-st*xij)*(2.d0-x(icmp)*2.d0*st)
              fvij=x(k)/fvij*(1.d0-sv*xij)*(2.d0-x(icmp)*2.d0*sv)
            elseif (ix.eq.11) then
              if (k.eq.icmp2) then
                ftij=(xij+x(k)*(1.d0-ut*xij)+x(icmp)*(1.d0-st*xij)
     &              -x(icmp)*x(k)*(st+ut-2.d0*st*ut*xij))/ftij
                fvij=(xij+x(k)*(1.d0-uv*xij)+x(icmp)*(1.d0-sv*xij)
     &              -x(icmp)*x(k)*(sv+uv-2.d0*sv*uv*xij))/fvij
              endif
            endif
            if (ix.ne.11 .or. (ix.eq.11 .and. k.eq.icmp2)) then
              tsum=tsum+ctij*ftij
              vsum=vsum+cvij*fvij
            endif

c  Lemmon-Jacobsen mixing rules (not working due to linear vs. quadratic terms for i=j)
c         elseif (hmodmx(k,icmp)(1:2).eq.'LJ') then
c           goto 100
c           if (ix.eq.1) then
c             if (fmix(k,icmp,4).ne.1.d0.or.fmix(k,icmp,5).ne.1.d0) then
c               goto 100
c             else
c               tsum=tsum+fmix(k,icmp,1)*x(k)
c               vsum=vsum+fmix(k,icmp,2)*x(k)
c             endif
c           elseif (ix.eq.11 .and. k.eq.icmp2) then
c             tsum=tsum+fmix(icmp,icmp2,1)
c             vsum=vsum+fmix(icmp,icmp2,2)
c           endif

c  All others
          elseif (hmodmx(k,icmp).ne.'i=j') then
            goto 100
          endif
          endif
        enddo
        tred=tsum
        Dred=vsum
      endif
c
c     write (*,*) "tred and dred for X:",x(1),x(2),tred,Dred
c1120 format ('  RDXHMX--x,t0,D0: ',f10.7,f10.3,f10.5)
c
      RETURN
c
 100  continue
      ierr=191
      herr='[RDXHMX error 191] Derivative not available'
      call ERRMSG (ierr,herr)
      RETURN
      end                                             !subroutine RDXHMX
c
c ======================================================================
c
      subroutine SETHMX (hfmix,ierr,herr)
c
c  read parameters for the HMX mixture model from a file
c
c  input:
c    hfmix--file name containing mixture parameters [character*255]
c  outputs:
c     ierr--error flag:  0 = successful
c                        1 = error (e.g. fluid not found)
c     herr--error string (character*255 variable if ierr<>0)
c     [fluid parameters, etc. returned via various common blocks]
c
c  written by M. McLinden, NIST Thermophysics Division, Boulder, Colorado
c  01-09-96  MM, original version
c  02-27-96  MM, parameter n0=-ncmax to accommodate ECS-thermo model
c                add Zcrit to common /CCON/
c  03-19-96  MM, add dipole moment to /CCON/
c  03-22-96  MM, replace /MODEL/ with /EOSMOD/
c  05-06-96  MM, add /MIXMOD/ to specify model for binary pairs;
c                initialize j,i same as i,j; initialize i = j to 1.0
c  05-07-96  MM, move read of binary model(s) to RDMIX
c  05-08-96  MM, add /MXINFO/ and read corresponding info from file
c  11-19-96  MM, move initialization of common blocks to RDBNC, ESTBNC
c  03-27-97  MM, if file not found, search in likely directories
c  07-03-97  MM, pass any error from ESTBNC up the chain
c  08-22-97  MM, use double backslash on file open to avoid problem with Unix machines
c  11-26-97 APP, additions for Ammonia-Water calculations, new common block /AMMWAT/
c  04-15-98 EWL, add check for nist14 directory
c  07-08-98 EWL, change character strings from *80 to *255
c  12-24-98 EWL, change AMMWAT common block to FLAGS2 common block
c  12-24-98 EWL, restructure check for ammonia-water mixtures
c  01-10-01 EWL, only call checks for estimation scheme if ierr1<>0, not ierr
c  02-02-01 EWL, remove double backslash, which caused problems in Windows
c  02-14-01 EWL, increase dimension on amix to 4
c                change use of iexpmx(i,j,k) to amix(i,j,k,4)
c  01-23-02 EWL, split common block MXINFO into 2 pieces for some compilers
c  07-13-04 EWL, read in a version number on the second line of hmx.bnc
c  09-28-05  DT, change occurrences of a backslash to 'char(92)' for compatibility
c                with some compilers using F77
c  08-17-06 EWL, update program for GERG-2004 equation of Kunz and Wagner
c  09-06-06 EWL, change nbrule to 20
c  01-24-13 MLH, check for alchohols in mixtures
c
      include 'commons.for'
      character*3 htype
      character*255 hfmix
      character*255 herr,herr1
      logical lmix,lij(nx,nx),lfbnc,lftc,lfvc
c
c  commons associated with the binary mixing rule(s)
c  the amix(i,j,k,1..3) are the coefs for the (general) mixing term
c  the fmix(i,j,1..nmxpar) are the parameters for the i-j binary
c  the namix(i,j) are the number of afeq(i,j,k,1..3) terms
c  /MXINFO/ contains information on the mixing rules and parameters
c  hmfile specifies the files from which mixing rules originate
c  (stored in order 1,2  1,3  2,3; element zero is file called in SETUP)
c  hbin provides documentation for the current binary parameters
c  hrule contains descriptions of the currently available mixing rules
c  hbpar contains descriptions of the binary parameters (e.g. Kt, Kv)
c  associated with the currently available mixing rules
c
      hmfile(0)=hfmix
      ierr=0
      ierr1=0
      herr=' '
      do i=1,nx
        do j=1,nx
          do k=1,nmxprb
            fprkij(i,j,k)=0.d0
          enddo
        enddo
      enddo
c  (re)initialize contents of /HMXSAV/ when a new mixture is read in
      do i=1,nmsav
        delsvh(i)=0.0d0
        tausvh(i)=0.0d0
        do k=0,nmxtrm
          phisvh(i,k)=0.0d0
        enddo
      enddo
      iamwat=0
c
c  initialize the diagonal terms (i = j)
c
      do i=1,nc
        hmodmx(i,i)='i=j'
        hmodtc(i,i)='i=j'
        hmodvc(i,i)='i=j'
        hprkij(i,i)='   '
c  the i = j terms in the fmix summation should not be called (neither
c  the i > j), but set the number of terms to zero as precaution
        namix(i,i)=0
        namix2(i,i)=0
        do k=1,nmxpar
          fmix(i,i,k)=0.0d0
          fmix2(i,i,k)=0.0d0
        enddo
        do k=1,nmxtc
          ftcij(i,i,k)=0.0d0
        enddo
        do k=1,nmxvc
          fvcij(i,i,k)=0.0d0
        enddo
      enddo
c
      if (hfmix(1:5).eq.'BDATA' .or. hfmix(1:5).eq.'bdata') then
c  get coefficients from common blocks--not currently implemented
        ierr=1
        herr='[SETHMX error] Block data option not available'//hnull
        call ERRMSG (ierr,herr)
        RETURN
      else
c
c  read parameters for the binary pairs from file
c
c        write (*,1105) hfmix
c1105   format (/1x,'reading mixture coefficients from file: (',a40,')')
        nread=12             !logical unit for file reads
        call OPENFL (nread,hfmix,1,ierr,herr)
        if (ierr.ne.0) goto 999
        rewind (nread)
        read (nread,2003) htype
        if (htype.ne.heos) then
          ierr=1
          herr='[SETHMX error] Mixture file does not match model'//hnull
          call ERRMSG (ierr,herr)
          RETURN
        end if
        read (nread,'(i2)') ivrsnm
        ibin=0     !initialize counter for binary pair number
        do i=1,nc-1
          do j=i+1,nc
            ibin=ibin+1
            hmfile(ibin)=hfmix
            call RDBNC (nread,i,j,ibin,ierr1,herr1)
            if (ierr1.ne.0 .and. ierr.le.0) then
              ierr=ierr1
              herr=herr1
            endif
c  check if any binary parameters need to be estimated
            lfbnc=.true.
            lftc=.true.
            lfvc=.true.
            if (ierr1.ne.0) then
              if (ierr.lt.0) then
                ierr2=-ierr-80
                if (mod(ierr2,4).eq.0) then
                  lfvc=.true.
                  ierr2=ierr2-4
                end if
                if (mod(ierr2,2).eq.0) then
                  lftc=.true.
                  ierr2=ierr2-2
                end if
                if (ierr2.eq.1) then
                  lfbnc=.true.
                end if
              end if
              if (lfbnc) then
                call ESTBNC (i,j,ibin,ierr1,herr1)
                hmfile(ibin)='estimated by ESTBNC'
                if (ierr1.ne.0 .and. ierr.le.0) then
                  ierr=ierr1
                  herr=herr1
                endif
              end if
              if (lftc) call ESTTC (i,j,ierr1,herr1)
              if (lfvc) call ESTVC (i,j,ierr1,herr1)
c  any error from ESTBNC takes precedence over those from ESTTC or ESTVC
              if (ierr1.ne.0 .and. ierr.le.0) then
                ierr=ierr1
                herr=herr1
              end if
            end if
c  check to see if Peng-Robinson parameters need to be estimated
            if (abs(fprkij(i,j,1)).lt.1.d-20)
     &          call ESTPR (i,j,ibin,ierr1,herr1)
          enddo
        enddo
c
c  read coefficients for general mixing rule(s) from file
c
        call RDMIX (nread,icomp,jcomp,'ALL',lij,ierr1,herr1)
        if (ierr1.ne.0 .and. ierr.le.0) then
          ierr=ierr1
          herr=herr1
        end if
c  check that mixing term for each binary has been found
        lmix=.true.
        do i=1,nc-1
          do j=i+1,nc
            lmix=lmix.and.lij(i,j)
c           write (*,1024) i,j,lij(i,j),lmix
c1024       format (1x,' SETHMX  i,j,lij,lmix:        ',2i3,1x,2i2)
          enddo
        enddo
c
c  check for the presence of water in the mixture
        do i=1,nc
          if (hcas(i).eq.'7732-18-5') iwat=i
        enddo
c
c  check for the presence of alcohols in the mixture
        do i=1,nc
          if (hcas(i).eq.'67-56-1')   ialc=i   !methanol
          if (hcas(i).eq.'64-17-5')   ialc=i   !ethanol
          if (hcas(i).eq.'71-23-8')   ialc=i   !propanol
          if (hcas(i).eq.'67-63-0')   ialc=i   !ipropanol
          if (hcas(i).eq.'71-36-3')   ialc=i   !1-butanol
          if (hcas(i).eq.'78-83-1')   ialc=i   !isobutanol
          if (hcas(i).eq.'78-92-2')   ialc=i   !2-butanol
        end do
c
c  Convert LJ model to KW
        do i=1,nc-1
          do j=i+1,nc
            if (hmodmx(i,j).eq.'LJ6') then
              if (fmix(i,j,4).eq.1.d0 .and. fmix(i,j,5).eq.1.d0 .and.
     &            fmix(i,j,3).eq.0.d0) then  !Only do this last one if converting to KW0 to enforce no excess function
                onethrd=-0.33333333333333333333d0
                tc12=SQRT(tz(i)*tz(j))
                tc12=(fmix(i,j,1)+tz(i)+tz(j))/2.d0/tc12
                vc12=(rhoz(i)**onethrd+rhoz(j)**onethrd)**3/8.d0
                vc12=(fmix(i,j,2)+1.d0/rhoz(i)+1.d0/rhoz(j))/2.d0/vc12
                fij=fmix(i,j,3)
                do k=1,4
                  fmix(i,j,k)=1.d0
                  fmix(j,i,k)=1.d0
                  fmix2(i,j,k)=1.d0
                  fmix2(j,i,k)=1.d0
                enddo
                fmix(i,j,5)=fij
                fmix(j,i,5)=fij
                fmix(i,j,2)=tc12
                fmix(j,i,2)=tc12
                fmix(i,j,4)=vc12
                fmix(j,i,4)=vc12
                hmodmx(i,j)='KW0'
                hmodmx(j,i)='KW0'
              endif
            endif
          enddo
        enddo

c
c  check for Ammonia-Water model
        if (hmodmx(ione1,itwo2).eq.'TR1') then
c  set whether mixture is water-ammonia or ammonia-water
          if (hcas(ione1).eq.'7664-41-7'.and.hcas(itwo2).eq.'7732-18-5')
     &        iamwat=1
          if (hcas(ione1).eq.'7732-18-5'.and.hcas(itwo2).eq.'7664-41-7')
     &        iamwat=2
          if (iamwat.eq.0) then
            ierr=106
            herr='[SETMHX error 106] Wrong components; '//
     &           'model TR1 valid for ammonia + water only'//hnull
            call ERRMSG (ierr,herr)
          endif
          if (nc.ne.2) then
            ierr=107
            herr='[SETMHX error 107] Wrong number of components;'//
     &           ' model TR1 valid for binary mixtures only'//hnull
            call ERRMSG (ierr,herr)
          end if
        end if
c
        if (.not.lmix .and. abs(ierr).ne.117) then
          ierr=-117
          herr='[SETHMX error] Mixing term not found for one or '//
     &         'more binary pair(s)'//hnull
          call ERRMSG (ierr,herr)
        end if
c  rewind and close the file
        rewind (nread)
        close (nread)
c
c  write all parameters for debugging
c       write (*,*)
c       write (*,*) ' SETHMX:  mixing parameters'
c       write (*,1281)
c1281   format ('   i  j  mod    par_1     par_2     par_3',
c    &           '     par_4     par_5     par_6'/)
c       do i=1,nc
c       do j=1,nc
c       write (*,1280) i,j,hmodmx(i,j),(fmix(i,j,k),k=1,nmxpar)
c       enddo
c       enddo
c1280   format (1x,2i3,2x,a3,11f10.5)
c       write (*,*)
c       write (*,*) ' SETHMX:  critical line (Tc) parameters'
c       write (*,1283)
c1283   format ('   i  j  mod    par_1     par_2     par_3',
c    &           '     par_4     par_5     par_6     par_7',
c    &           '     par_8     par_9    par_10    par_11'/)
c       do i=1,nc
c       do j=1,nc
c       write (*,1280) i,j,hmodtc(i,j),(ftcij(i,j,k),k=1,nmxtc)
c       enddo
c       enddo
c       write (*,*)
c       write (*,*) ' SETHMX:  critical line (Vc) parameters'
c       write (*,1283)
c       do i=1,nc
c       do j=1,nc
c       write (*,1280) i,j,hmodvc(i,j),(fvcij(i,j,k),k=1,nmxvc)
c       enddo
c       enddo
        RETURN
      end if
c
c  error terminations
c
 999  continue
      ierr=111
      herr='[SETHMX error] Error in opening mixture file'//hnull
      call ERRMSG (ierr,herr)
      RETURN
c
 2003 format (a3)
c
      end                                             !subroutine SETHMX
c
c ======================================================================
c
      subroutine RDBNC (nread,icomp,jcomp,ibin,ierr,herr)
c
c  read binary parameters for the HMX mixture model and also the
c  critical line model from a file
c
c  inputs:
c    nread--file to read data from
c           <= 0 get data from block data (not currently implemented)
c           >0 read from logical unit n (file should have already
c              been opened and pointer set by subroutine SETHMX)
c    icomp--component i
c    jcomp--component j
c     ibin--counter for binary pair (1,2 = 1; 1,3 = 2; 2,3 = 3; etc.)
c  outputs:
c     ierr--error flag:  0 = successful
c                     -114 = critical temperature line will be estimated
c                     -115 = critical volume line will be estimated
c                     -116 = critical temperature and volume lines will be estimated
c                     -117 = binary pair not found, all parameters will be estimated
c                     -118 = binary pair found, but no thermo interaction parameters
c                      118 = error in reading mixture file
c     herr--error string (character*255 variable if ierr<>0)
c     other outputs written to common
c
c  written by M. McLinden, NIST Thermophysics Division, Boulder, Colorado
c  01-10-96  MM, original version
c  01-12-96  MM, call ESTBNC if binary parameter not found in file
c  02-27-96  MM, parameter n0=-ncmax to accommodate ECS-thermo model
c  05-07-96  MM, change inputs from CAS numbers to icomp, jcomp
c  05-08-96  MM, add /MXINFO/ and read corresponding info from file
c  11-04-96  MM, add gamma to LJi and LMi models (i,j not eq to j,i),
c                change nmxpar from 4 to 6
c  11-19-96  MM, move initialization of common blocks to RDBNC, ESTBNC
c                read critical line coefficients
c  02-19-97  MM, fix bug: parameter name is ncvc, not ncvv
c  05-22-97  MM, change format to read coeff from f10.x to f12.x
c  06-04-97 EWL, change value of nctc and ncvc to read in six coefficients
c  11-28-97 APP, add code for Ammonia-Water model and common /AMMWAT/
c  12-22-98 EWL, remove common /AMMWAT/
c  05-26-00 EWL, make the i,j and j,i entries in the fvcij and ftcij identical
c  12-05-00  MM, set either 7-11 or 2-6 of ftcij and fvcij to zero's (allow for
c                specified mixture order to be opposite that in coeff file)
c  01-23-02 EWL, split common block MXINFO into 2 pieces for some compilers
c  07-15-04 EWL, read in kij for Peng-Robinson equation of state
c  10-08-04 MLH, initialize PR coefficients to zero
c  08-17-06 EWL, redo logic to make more efficient and allow nonformatted inputs
c  08-17-06 EWL, update program for GERG-2004 equation of Kunz and Wagner
c  12-24-06 MLH, allow for 4 binary interaction parameters for viscosity
c  01-09-07 EWL, modify the code so that other entries than just 'KW#' or 'LJ#'
c                can be on the same line as the CAS numbers (thus, the KW or LJ
c                entries do not have to exist)
c  01-28-07 MLH, allow for 3 binary interaction parameters for thermal conductivity
c  03-05-07 EWL, add fmix2 array in case fluids are entered in opposite order as required by Kunz and Wagner
c  05-27-08 MLH, add one more binary int par for dilute gas viscosity xdij in trnbin
c  06-11-08 MLH, add second bin int for dilute gas vis xdij2
c  07-08-10 EWL, add check for official GERG2004 coefficients
c
      include 'commons.for'
      include 'comtrn.for'
      character*1 hstar,h1
      character*3 hmodij,hmodt,hmodv
      character*3 hmodc,hmodz
      character*3 hflag,htype
      character*12 hcas1,hcas2,hcasi,hcasj
      character*255 herr,hbinp,h255,hmdijx,hmodtx,hmodvx
      character*255 hmodcx,hmodzx
c
      ierr=0
      herr=' '
      i=icomp
      j=jcomp
      hcasi=hcas(icomp)
      hcasj=hcas(jcomp)
      ifmt=27   !Starting location of all LJ1, KW1, etc., identifiers
c
c  initialize arrays storing coeff for critical lines
      xljs(i,j)=0.0d0
      xljs(j,i)=0.0d0
      xlje(i,j)=0.0d0
      xlje(j,i)=0.0d0
      xkij(i,j)=0.0d0
      xkij(j,i)=0.0d0
      xlij(i,j)=0.0d0
      xlij(j,i)=0.0d0
      xaji(i,j)=0.0d0
      xaji(j,i)=0.0d0
      xkijk(i,j)=0.0d0
      xkijk(j,i)=0.0d0
      xlijk(i,j)=0.0d0
      xlijk(j,i)=0.0d0
      xdij(i,j)=0.0d0
      xdij(j,i)=0.0d0
      xdij2(i,j)=0.0d0
      xdij2(j,i)=0.0d0
      do k=1,nmxpar
        fmix(i,j,k)=0.0d0
        fmix(j,i,k)=0.0d0
        fmix2(i,j,k)=0.0d0
        fmix2(j,i,k)=0.0d0
      enddo
      do k=1,nmxtc
        ftcij(i,j,k)=0.0d0
        ftcij(j,i,k)=0.0d0
      enddo
      do k=1,nmxvc
        fvcij(i,j,k)=0.0d0
        fvcij(j,i,k)=0.0d0
      enddo
      do k=1,nmxprb
        fprkij(i,j,k)=0.0d0
        fprkij(j,i,k)=0.0d0
      enddo
c
      if (nread.le.0) then
c  get coefficients from common blocks--not currently implemented
        ierr=1
        herr='[RDBNC error] Block data option not available'//hnull
        call ERRMSG (ierr,herr)
        RETURN
      else
c
c  rewind file and read coefficients
c
        rewind (nread)
c
c  search for key characters in cols 1 and 2-4 and branch accordingly
c  hstar = '#' or '@' indicates start of model specification
c  hflag indicates type of model:
c       'BNC' = binary mixture coefficients
c       'MXM' = mixture model specification
c
        do iline=1,20000
        read (nread,2013,end=199,err=199) hstar,hflag
        if (hstar.eq.'@' .and. (hflag.eq.'END'.or.hflag.eq.'end')) then
          ierr=-117
          herr='[RDBNC error] Binary pair not found (end of file):  '//
     &         hcasi//hcasj//hnull
          call ERRMSG (ierr,herr)
          RETURN
        end if
        if (hstar.eq.'#' .or. hstar.eq.'@') then
          read (nread,2003) htype
 100      continue
          read (nread,2001) h1
          if (h1.eq.'?') goto 100   !comment block terminated by '!'
        end if
        if (hflag.eq.'BNC' .and. htype.eq.'BNC') then
 110      continue
            hmodij=' '
            hmdijx=' '
            hmodt =' '
            hmodtx=' '
            hmodv =' '
            hmodvx=' '
            hmodc =' '
            hmodcx=' '
            hmodz =' '
            hmodzx=' '
            hbinp =' '
            hcas1 =' '
            hcas2 =' '
c  read in one block of interaction parameters at a time
 115        continue
            read (nread,2255,err=199,end=199) h255
            if (h255(1:1).eq.'?') then
              if (hbinp.eq.' ') then
                hbinp=h255(2:255)
              else
                ii=index(hbinp,'                     ')
                hbinp=hbinp(1:ii)//char(92)//h255(2:255)
              endif
              goto 115
            elseif (h255(1:1).eq.'!') then
            elseif (h255(ifmt:ifmt+1).ne.' ') then
              if (h255(1:ifmt-1).ne.' ') then
                ii=index(h255(1:ifmt-1),'/')
                if (ii.gt.0) then
                  hcas1=h255(1:ii-1)
                  hcas2=h255(ii+1:ifmt-1)
                else
                  goto 199
                endif
              endif
              if (h255(ifmt:ifmt+1).eq.'KW' .or.
     &            h255(ifmt:ifmt+1).eq.'GE' .or.
     &            h255(ifmt:ifmt+1).eq.'LJ' .or.
     &            h255(ifmt:ifmt+1).eq.'LM' .or.
     &            h255(ifmt:ifmt+2).eq.'TR1') then
                hmodij=h255(ifmt:ifmt+2)
                hmdijx=h255(ifmt+3:255)
              elseif (h255(ifmt:ifmt+1).eq.'TC') then
                hmodt =h255(ifmt:ifmt+2)
                hmodtx=h255(ifmt+3:255)
              elseif  (h255(ifmt:ifmt+1).eq.'VC') then
                hmodv =h255(ifmt:ifmt+2)
                hmodvx=h255(ifmt+3:255)
              elseif  (h255(ifmt:ifmt+1).eq.'PR') then
                hmodc =h255(ifmt:ifmt+2)
                hmodcx=h255(ifmt+3:255)
              elseif  (h255(ifmt:ifmt+2).eq.'TRN') then
                hmodz =h255(ifmt:ifmt+2)
                hmodzx=h255(ifmt+3:255)
              else
                goto 199
              endif
              goto 115
            else
              goto 120
            endif

c  check for match with CAS numbers
            if ((hcasi.eq.hcas1 .and. hcasj.eq.hcas2) .or.
     &          (hcasi.eq.hcas2 .and. hcasj.eq.hcas1)) then

              hbin(ibin)=hbinp
              hmodmx(i,j)=hmodij
              hmodmx(j,i)=hmodij      !pair j,i is same as i,j
              hmodtc(i,j)=hmodt
              hmodtc(j,i)=hmodt       !pair j,i is same as i,j
              hmodvc(i,j)=hmodv
              hmodvc(j,i)=hmodv       !pair j,i is same as i,j
              hprkij(i,j)=hmodc
              hprkij(j,i)=hmodc
              if (hmodij.ne.' ') then
                read (hmdijx,*) (fmix(i,j,k),k=1,nmxpar)
                read (hmdijx,*) (fmix(j,i,k),k=1,nmxpar)
                do k=1,nmxpar
                  fmix2(i,j,k)=1.d0  !These are not in the hmx.bnc file, manually set here
                  fmix2(j,i,k)=1.d0
                enddo
              else
               ierr=-118
               herr='[RDBNC error] Binary pair found, but equilibrium'//
     &              ' interaction parameters are not available:  '//
     &              hcasi//hcasj//hnull
               call ERRMSG (ierr,herr)
              endif
c             write (*,1016) icomp,jcomp,hmodij,(afeq(k),k=1,nmxpar)
c1016         format (1x,' RDBNC--i,j,mod,fij: ',9x,2i3,2x,a3,8f8.4)
c
c  check for specification that critical line(s) are to be estimated,
c  if so, set warning (estimation routine will be called from SETHMX)
              ierr2=0
              if (hmodt.eq.'EST') then
                ierr2=ierr2-1
              end if
              if (hmodv.eq.'EST') then
                ierr2=ierr2-2
              end if
              if (ierr2.lt.0) then
                ierr=-113+ierr2
              end if
c
c  for model TC1, the order i,j vs j,i is significant; first coeff is
c  symmetric, elements 2-6 store coeff for order i,j; 7-11 for j,i
              if (hmodt.eq.'TC1') then
                read (hmodtx,*) (ftcij(i,j,k),k=1,6)
                ftcij(j,i,1)=ftcij(i,j,1)
                do k=2,6
                  ftcij(j,i,k)=ftcij(i,j,k)
                  ftcij(i,j,k+5)=0.0d0
                  ftcij(j,i,k+5)=0.0d0
                enddo
              end if
c
c  for model VC1, the order i,j vs j,i is significant; first coeff is
c  symmetric, elements 2-6 store coeff for order i,j; 7-11 for j,i
              if (hmodv.eq.'VC1') then
                read (hmodvx,*) (fvcij(i,j,k),k=1,6)
                fvcij(j,i,1)=fvcij(i,j,1)
                do k=2,6
                  fvcij(j,i,k)=fvcij(i,j,k)
                  fvcij(i,j,k+5)=0.0d0
                  fvcij(j,i,k+5)=0.0d0
                enddo
              end if
c
c  read in Peng-Robinson interaction parameters
              if (hmodc.eq.'PR1') then
                read (hmodcx,*) (fprkij(i,j,k),k=1,nmxprb)
                do k=1,nmxprb
                  fprkij(j,i,k)=fprkij(i,j,k)
                enddo
              endif
c
c  read in transport interaction parameters
              if (hmodz.eq.'TRN') then
                read (hmodzx,*) xljs(i,j),xlje(i,j),xkij(i,j),xlij(i,j),
     &              xaji(i,j),xkijk(i,j),xlijk(i,j),xdij(i,j),xdij2(i,j)
                xljs(j,i)=xljs(i,j)
                xlje(j,i)=xlje(i,j)
                xkij(j,i)=xkij(i,j)
                xlij(j,i)=xlij(i,j)
                xaji(j,i)=xaji(i,j)
                xkijk(j,i)=xkijk(i,j)
                xlijk(j,i)=xlijk(i,j)
                xdij(j,i)=xdij(i,j)
                xdij2(j,i)=xdij2(i,j)
              end if

              if (hcasi.eq.hcas2 .and. hcasj.eq.hcas1) then
c  specified order is opposite that in file hfmix
c  pair j,i is same as i,j except for beta and gamma parameters in
c  the LJi and LMi models are associated with a particular fluid
                if (hmodij(1:2).eq.'LM' .or. hmodij(1:2).eq.'LJ') then
                  a4=fmix(i,j,4)
                  a5=fmix(i,j,5)
                  fmix(j,i,4)=a5
                  fmix(j,i,5)=a4
                  fmix(i,j,4)=a5
                  fmix(i,j,5)=a4
                end if
                if (hmodij(1:2).eq.'KW' .or. hmodij(1:2).eq.'GE') then
                  fmix2(j,i,1)=fmix(j,i,1)
                  fmix2(j,i,3)=fmix(j,i,3)
                  fmix2(i,j,1)=fmix(i,j,1)
                  fmix2(i,j,3)=fmix(i,j,3)
                  fmix(j,i,1)=1.d0
                  fmix(j,i,3)=1.d0
                  fmix(i,j,1)=1.d0
                  fmix(i,j,3)=1.d0
                end if
                if (hmodt.eq.'TC1') then       !Similar for TC1
                  do k=2,6
                    ftcij(i,j,k+5)=ftcij(i,j,k)
                    ftcij(j,i,k+5)=ftcij(j,i,k)
                    ftcij(i,j,k)=0.d0
                    ftcij(j,i,k)=0.d0
                  enddo
                end if
                if (hmodv.eq.'VC1') then       !Similar for VC1
                  do k=2,6
                    fvcij(i,j,k+5)=fvcij(i,j,k)
                    fvcij(j,i,k+5)=fvcij(j,i,k)
                    fvcij(i,j,k)=0.0d0
                    fvcij(j,i,k)=0.0d0
                  enddo
                end if
              end if
c  Check for official GERG coefficients.
c  If found, change from GE to KW, but keep reading fluid file
c  for additional KW values unless the GERG option has been turned on.
c  The GERG coefficients must be placed in the hmx.bnc file BEFORE the KW values
c  for the same binary mixture.
              if (hmodmx(i,j)(1:2).eq.'GE') then
                hmodmx(i,j)='KW'//hmodmx(i,j)(3:)
                hmodmx(j,i)=hmodmx(i,j)
                if (iGERG04.eq.0) goto 110
              endif
              RETURN
            endif
          goto 110
        end if
 120    continue
        enddo
      end if
      RETURN
c
 199  continue       !abnormal termination
c     write (*,*) ' RDBNC line 199, hstar,hflag: ',hstar,hflag
      ierr=118
      herr='[RDBNC error 118] Error in reading mixture file in RDBNC'
     &    //hnull
      call ERRMSG (ierr,herr)
      RETURN
c
 2001 format (a1)
 2003 format (a3)
 2013 format (a1,a3)
 2255 format (a255)
c
      end                                              !subroutine RDBNC
c
c ======================================================================
c
      subroutine RDMIX (nread,icomp,jcomp,hmodij,lij,ierr,herr)
c
c  read coefficients for mixing rule(s) from file
c
c  inputs:
c    nread--file to read data from
c           <= 0 get data from block data (not currently implemented)
c           >0 read from logical unit nread (file should have already
c              been opened by subroutine SETHMX)
c    icomp--component i; ignored if hmodij='ALL'
c    jcomp--component j; ignored if hmodij='ALL'
c   hmodij--model for binary interaction of i and j [character*3]
c           'ALL' indicates read model(s) for all binary pair(s)
c                 (used when this routine is called from SETHMX)
c           when a specific model is specified (e.g. 'LJ1' or 'MKT')
c                 read only that model (used when called from SETKTV)
c  outputs:
c      lij--flags indicating if mixing term found for binary pair (i,j)
c           [logical array of dimension (nc,nc)]; used only in
c           conjunction with hmodij='ALL'
c     ierr--error flag:  0 = successful
c                      118 = error in reading mixture file
c     herr--error string (character*255 variable if ierr<>0)
c
c  written by M. McLinden, NIST Thermophysics Division, Boulder, Colorado
c  05-07-96  MM, original version (extracted from SETHMX)
c  05-08-96  MM, add /MXINFO/ and read corresponding info from file
c  05-10-96  MM, read default binary parameters (used only by interface)
c  11-04-96  MM, change nmxpar from 4 to 6
c  12-00-00 EWL, add bideal variable, storing fideal
c  02-14-01 EWL, increase dimension on aterm to 4, change use of iexp to aterm
c  01-23-02 EWL, split common block MXINFO into 2 pieces for some compilers
c  07-08-02 EWL, initialize 4th term in amix to 0
c  08-17-06 EWL, update program for GERG-2004 equation of Kunz and Wagner
c  01-03-07 EWL, change the 2000 to 20000 in 'do iline=1,2000' to read in more lines
c
      include 'commons.for'
      character*1 hstar,h1
      character*3 hmodij
      character*3 hflag,htype
      character*8 hpar(nmxpar)
      character*251 hinfo
      character*255 herr
      dimension aterm(nmxtrm,nmxcof),fideal(nmxpar)
      logical lij(nx,nx)
c
c  commons associated with the binary mixing rule(s)
c  the amix(i,j,k,1..3) are the coefs for the (general) mixing term
c  the fmix(i,j,1..nmxpar) are the parameters for the i-j binary
c  the namix(i,j) are the number of afeq(i,j,k,1..3) terms
c  /MXINFO/ contains information on the mixing rules and parameters
c  hmfile specifies the files from which mixing rules originate
c  (stored in order 1,2  1,3  2,3; element zero is file called in SETUP)
c  hbin provides documentation for the current binary parameters
c  hrule contains descriptions of the currently available mixing rules
c  hbpar contains descriptions of the binary parameters (e.g. Kt, Kv)
c  associated with the currently available mixing rules
c
c  search for key characters in cols 1 and 2-4 and branch accordingly
c  hstar = '#' or '@' indicates start of model specification
c  hflag indicates type of model:
c       'BNC' = binary mixture coefficients
c       'MXM' = mixture model specification
c
      ierr=0
      do i=1,nmxtrm
        do j=1,nmxcof
          aterm(i,j)=0
        enddo
      enddo
      if (hmodij.eq.'ALL') then
c  initialize flags indicating if mixing terms have been found
        irule=0
        do i=1,nc-1
          do j=i+1,nc
            lij(i,j)=.false.
          enddo
        enddo
      else
        do k=1,nrule
          if (hmodij.eq.hrule(k)(1:3)) then
            irule=k
            goto 100
          end if
        enddo
        irule=nrule+1
c        write (*,*) ' RDMIX--new mixing rule found',hmodij
 100  continue
      end if
c  rewind file (RDBNC may have left it at the end)
      rewind (nread)
      do iline=1,20000
      read (nread,2013,end=998,err=998) hstar,hflag
      if ((hstar.eq.'#' .or. hstar.eq.'@').and. hflag.eq.'MXM') then
        if (hmodij.eq.'ALL') then
          irule=irule+1
        end if
        read (nread,2053) htype,hinfo
        do k=1,1000             !skip over source comments
          read (nread,2001) h1
          if (h1.ne.'?') goto 110     !comment block terminated by '!'
        enddo
 110    continue
c  read descriptors for binary-specific parameters
        read (nread,2048) (hpar(k),k=1,nmxpar)
c  read default (ideal-solution) parameters
        read (nread,*) (fideal(k),k=1,nmxpar)
c  read coefficients for mixing rule
        nterm=0
        ncoef=0
        nspar=0
        nterm2=0
        ncoef2=0
        read (nread,*,err=120) nterm,ncoef,nspar,nterm2,ncoef2
 120    continue
        if (nspar.eq.1) ncoef=ncoef+1  !Compatibility for version 7.0
c  nterm is number of terms
c  ncoef is number of coefficients per term
        do n=1,nmxtrm
          do k=1,nmxcof
            aterm(n,k)=0.d0
          enddo
        enddo
        do k=1,nterm
          read (nread,*) (aterm(k,n),n=1,ncoef)
        enddo
        if (nterm2.ne.0) then
          do k=1,nterm2
            read (nread,*) (aterm(k+nterm,n),n=1,ncoef2)
          enddo
        endif
        if (hmodij.eq.'ALL') then
          ipair=0               !counter for binary pair
c         write (*,1342) irule,htype,hinfo
c1342     format (1x,' SETHMX--mixing function',i3,' (',a3,'): ',a251)
          hrule(irule)=htype//hinfo
          do k=1,nmxpar
            hbpar(irule,k)=hpar(k)
            bideal(irule,k)=fideal(k)
          enddo
          do i=1,nc-1
            do j=i+1,nc
              if (htype.eq.hmodmx(i,j)) then
c  mixing term found; load coefficients into working arrays
                lij(i,j)=.true.
                ipair=ipair+1
c               write (*,1344) irule,htype,i,j,hrule(irule)
c1344           format (1x,' SETHMX:  use mixing rule #',i3,' (',a3,
c    &                 ') for i,j =',2i3,':  ',a255)
                namix(i,j)=nterm
                namix2(i,j)=nterm2
                do k=1,nterm+nterm2
                  do n=1,nmxcof
                    amix(i,j,k,n)=aterm(k,n)
                  enddo
                enddo
              end if
            enddo
          enddo
          nrule=irule
        elseif (htype.eq.hmodij) then
c  mixing term found; load coefficients into working arrays
          lij(icomp,jcomp)=.true.
c          write (*,1370) htype,icomp,jcomp
c1370     format (1x,' SETKTV:  use ',a3,' mixing term for i,j =',2i3)
c          write (*,*) ' SETHMX--mixing term irule = ',irule,htype,hinfo
          hrule(irule)=htype//hinfo
          do k=1,nmxpar
            hbpar(irule,k)=hpar(k)
            bideal(irule,k)=fideal(k)
          enddo
          namix(icomp,jcomp)=nterm
          namix(jcomp,icomp)=nterm          !pair (j,i) is same as (i,j)
          namix2(icomp,jcomp)=nterm2
          namix2(jcomp,icomp)=nterm2        !pair (j,i) is same as (i,j)
          do k=1,nterm+nterm2
            do n=1,nmxcof
              amix(icomp,jcomp,k,n)=aterm(k,n)
              amix(jcomp,icomp,k,n)=aterm(k,n)!pair (j,i) is same as (i,j)
            enddo
          enddo
        end if
      elseif (hflag.eq.'END') then
c       write (*,*) ' RDMIX end of file encountered'
        RETURN
      end if
      enddo
      RETURN
c
c  error terminations
c
 998  continue
c     write (*,*) ' SETHMX line 998, hstar,hflag: ',hstar,hflag
      ierr=118
      herr='[RDMIX error 118] Error in reading mixture file in RDMIX'
     &    //hnull
      call ERRMSG (ierr,herr)
      RETURN
c
 2001 format (a1)
 2013 format (a1,a3)
c  multiplier in format should match "parameter (nmxpar=6)"
 2048 format (6(a8,1x))     !descriptors for binary-specific parameters
 2053 format (a3,a251)
c
      end                                              !subroutine RDMIX
c
c ======================================================================
c
      subroutine ESTBNC (i,j,ibin,ierr,herr)
c
c  estimate binary parameters for the HMX mixture model
c
c  inputs:
c        i--component i
c        j--component j
c     ibin--counter for binary pair (1,2 = 1; 1,3 = 2; 2,3 = 3; etc.)
c  outputs:
c     ierr--error flag:  0 = successful
c                     -117 = no binary parameters found (warning)
c                      117 = no binary parameters found (critical error)
c     herr--error string (character*255 variable if ierr<>0)
c     other outputs written to common
c
c  written by M. McLinden, NIST Thermophysics Division, Boulder, Colorado
c  01-12-96  MM, original version
c  02-27-96  MM, parameter n0=-ncmax to accommodate ECS-thermo model
c                add Zcrit to common /CCON/
c  03-19-19  MM, add dipole moment to /CCON/
c  05-06-96  MM, change default model to VDW
c  05-08-96  MM, add /MXINFO/ and load corresponding info
c  11-04-96  MM, replace van der Waals rule with linear (LIN),
c                change nmxpar from 4 to 6
c  11-19-96  MM, move initialization of common blocks to RDBNC, ESTBNC
c                change argument list
c  07-03-97  MM, return ierr=117 if this routine is called (causes error
c                alert to appear in GUI); !temporary until prediction in place
c  09-08-97  MM, change error 117 to warning--GUI displayed alert, then quit
c  11-06-97  MM, implement preliminary predictive model of Lemmon
c  12-01-98 EWL, add Reos and triple point pressure and density to /CCON/
c  04-19-99 EWL, do not use estimation scheme with hydrogen sulfide
c  06-14-99 EWL, do not use estimation scheme if estimate value > 200
c  01-23-02 EWL, split common block MXINFO into 2 pieces for some compilers
c  02-05-02 EWL, allow estimation scheme to return values, even if out of range
c  05-09-05 EWL, add check for very small acentric factor ratio
c  09-07-06 EWL, change LJ1 to LJ6
c  09-12-06 EWL, keep fmix(1) bounds within 500 to avoid crashes
c  08-23-10 EWL, remove acetone from list of fluids not allowed in mixtures
c
      include 'commons.for'
      character*255 herr
      logical lest
c
c  commons associated with the binary mixing rule(s)
c  the amix(i,j,k,1..3) are the coefs for the (general) mixing term
c  the fmix(i,j,1..nmxpar) are the parameters for the i-j binary
c
c     write (*,1002) i,j,hcas(i),hcas(j)
c1002 format (1x,' ESTBNC will estimate i,j =   ',2i3,2x,a12,1x,a12)
      lest=.true.   !enable estimation scheme
      if (.not.lest) then
c  return default values for now
        hmodmx(i,j)='LIN'
        hmodmx(j,i)='LIN'
        hbin(ibin)='No mixture data are available for this binary pair.'
     &         //' Ideal solution behavior will be assumed.'
     &         //hnull
        do k=1,2
          fmix(i,j,k)=1.0d0           !fmix(i,j,1) = Kt
          fmix(j,i,k)=1.0d0           !fmix(i,j,2) = Kv
        enddo
        fmix(i,j,3)=0.0d0           !Fpq(i,j)
        fmix(j,i,3)=0.0d0           !Fpq(k,i)
        do k=4,5
          fmix(i,j,k)=1.0d0           !fmix(i,j,4) = beta
          fmix(j,i,k)=1.0d0           !fmix(i,j,5) = gamma
        enddo
        do k=6,nmxpar
          fmix(i,j,k)=0.0d0           !not used
          fmix(j,i,k)=0.0d0
        enddo
c  return warning message to GUI
        ierr=117
        write (herr,1000) hnull
        call ERRMSG (ierr,herr)
        RETURN
      end if
      iflg=0
      do k=1,2
        n=0
        if (k.eq.1) n=i
        if (k.eq.2) n=j
        if (hcas(n).eq.'7732-18-5' ) iflg=1    !water
        if (hcas(n).eq.'7789-20-0' ) iflg=1    !heavy water
        if (hcas(n).eq.'7664-41-7' ) iflg=1    !ammonia
        if (hcas(n).eq.'7440-59-7' ) iflg=1    !helium
        if (hcas(n).eq.'1333-74-0' ) iflg=1    !hydrogen
        if (hcas(n).eq.'7782-39-0' ) iflg=1    !deuterium
        if (hcas(n).eq.'1333-74-0p') iflg=1    !parahydrogen
        if (hcas(n).eq.'67-56-1'   ) iflg=1    !methanol
        if (hcas(n).eq.'64-17-5'   ) iflg=1    !ethanol
c       if (hcas(n).eq.'67-64-1'   ) iflg=1    !acetone
        if (hcas(n).eq.'7782-41-4' ) iflg=1    !fluorine
        if (hcas(n).eq.'7440-01-9' ) iflg=1    !neon
        if (hcas(n).eq.'7783-54-2' ) iflg=1    !NF3
      enddo
      if (iflg.eq.1) then
        ierr=117
        herr='[SETUP error 117] Estimation of mixing parameters is not '
     &    //'possible for most mixtures containing water, heavy water, '
     &    //'helium, hydrogen, parahydrogen, deuterium, neon, ammonia, '
     &    //'fluorine, methanol, or ethanol.'//hnull
        hbin(ibin)='Estimation of mixing parameters is not possible '
     &    //'for this mixture.'//hnull
        hmodmx(i,j)='LJ6'
        hmodmx(j,i)='LJ6'
        call ERRMSG (ierr,herr)
        RETURN
      endif
c
c  return warning message to GUI
      ierr=-117
      herr='[SETUP warning -117] No mixture data are available for one '
     &   //'or more binary pairs in the specified mixture. The mixing '
     &   //'parameters have been estimated.'//hnull
      call ERRMSG (ierr,herr)
c
c  ordering of the components depends on ratio of the dipole moments
c  interim predictive scheme of Lemmon
      hmodmx(i,j)='LJ6'
      hmodmx(j,i)='LJ6'
      hbin(ibin)='No mixture data are available for this binary pair. '
     &         //'The mixing parameters have been estimated.'
     &         //hnull
      k=0
      if (ABS(dipole(i)-dipole(j)).lt.1.0d-5) then
c  special case for equal dipole moments
        if (tcrit(i)/(pcrit(i)*accen(i)).gt.
     &      tcrit(j)/(pcrit(j)*accen(j))) k=1
      else
        if (dipole(i).lt.dipole(j)) k=1
      end if
      if (k.eq.1) then
        tratio=tcrit(i)/tcrit(j)
        pratio=pcrit(i)/pcrit(j)
        accenr=accen(i)/accen(j)
      else
        tratio=tcrit(j)/tcrit(i)
        pratio=pcrit(j)/pcrit(i)
        accenr=accen(j)/accen(i)
      endif
      if (tratio/pratio/accenr.gt.5 .and. abs(accenr).lt.0.1d0) then
        if (tratio .gt. 0.75d0 .and. tratio.lt.1.25d0) then
          tratio=1.d0/tratio
          pratio=1.d0/pratio
          accenr=1.d0/accenr
        endif
      endif
c
c  define the zeta parameter (the one applied to the reducing temperature)
      fmix(i,j,1)=(40.4d0-25.03d0*2.0d0**(tratio/pratio/accenr))/tratio
c
c
c     c1=-4.47546077875894
c     c2=6.95801916004273
c     c3=0.301565763059889
c     c4=0.429854120106733
c     c5=0.869600175257425
c     xx=(tcrit(j)-tcrit(i))*(tcrit(i)/100.d0)**c4/100.d0
c     if (tcrit(i).gt.tcrit(j))
c    &  xx=(tcrit(i)-tcrit(j))*(tcrit(j)/100.d0)**c4/100.d0
c     fmix(i,j,1)=c1+c2*xx+c3*xx**2+c5*xx**3
c
c
c
c
      fmix(j,i,1)=fmix(i,j,1)
c  set remaining parameters to defaults; 2 = xi; 3 = Fpq; 4 = beta; 5 = gamma
      do k=2,3
        fmix(i,j,k)=0.0d0  !k = 2:  xi (term in reducing volume)
        fmix(j,i,k)=0.0d0  !k = 3:  Fpq (multiplier for excess function)
      enddo
      do k=4,5
        fmix(i,j,k)=1.0d0  !k = 4: beta (exponent for first component)
        fmix(j,i,k)=1.0d0  !k = 5: gamma (exponent for second component)
      enddo
      do k=6,nmxpar
        fmix(i,j,k)=0.0d0  !not used
        fmix(j,i,k)=0.0d0
      enddo
      if (ABS(fmix(i,j,1)).gt.200.0d0) then
        if (fmix(i,j,1).gt.500.d0) fmix(i,j,1)=500.d0
        if (fmix(i,j,1).lt.-500.d0) fmix(i,j,1)=-500.d0
        ierr=117
        write (herr,1000) hnull
        call ERRMSG (ierr,herr)
 1000   format('[SETUP error 117] No mixture data are available for',
     &   ' one or more binary pairs in the specified mixture. The',
     &   ' mixture is outside the range of the model and',
     &   ' calculations will not be made.',A1)
      endif
      RETURN
c
      end                                             !subroutine ESTBNC
c
c ======================================================================
c
      subroutine ESTTC (i,j,ierr,herr)
c
c  estimate parameters for binary critical temperature line
c
c  inputs:
c        i--component i
c        j--component j
c  outputs:
c     ierr--error flag:  0 = successful
c                        1 = error
c     herr--error string (character*255 variable if ierr<>0)
c     other outputs written to common
c
c  written by M. McLinden, NIST Thermophysics Division, Boulder, Colorado
c  11-19-96  MM, original version
c  12-01-98 EWL, add Reos and triple point pressure and density to /CCON/
c
      include 'commons.for'
      character*255 herr
c
c     write (*,1002) i,j
c1002 format (1x,' ESTTC will estimate i,j =    ',2i3)
c  return default values for now
      hmodtc(i,j)='TC1'
      hmodtc(j,i)='TC1'
      hprkij(j,i)='   '
      do k=1,nmxtc
        ftcij(i,j,k)=0.0d0
        ftcij(j,i,k)=0.0d0
      enddo
      ierr=0
      herr=' '
      RETURN
c
      end                                              !subroutine ESTTC
c
c ======================================================================
c
      subroutine ESTVC (i,j,ierr,herr)
c
c  estimate parameters for binary critical volume line
c
c  inputs:
c        i--component i
c        j--component j
c  outputs:
c     ierr--error flag:  0 = successful
c                        1 = error
c     herr--error string (character*255 variable if ierr<>0)
c     other outputs written to common
c
c  written by M. McLinden, NIST Thermophysics Division, Boulder, Colorado
c  11-19-96  MM, original version
c  12-01-98 EWL, add Reos and triple point pressure and density to /CCON/
c
      include 'commons.for'
      character*255 herr
c
c     write (*,1002) i,j
c1002 format (1x,' ESTVC will estimate i,j =    ',2i3)
c  return default values for now
      hmodvc(i,j)='VC1'
      hmodvc(j,i)='VC1'
      do k=1,nmxvc
        fvcij(i,j,k)=0.0d0
        fvcij(j,i,k)=0.0d0
      enddo
      ierr=0
      herr=' '
      RETURN
c
      end                                              !subroutine ESTVC
c ======================================================================
c
      subroutine AMH2OR
c
c  check for ammonia-water mixture, if set, use international standard settings
c  check that the user has not modified the reference state for their own use
c
      include 'commons.for'
      character*3 hrf
      character*255 herr
      dimension x0(ncmax)
c
      if (nc.eq.2) then
        i=0
        if (hcas(1).eq.'7732-18-5'.and. hcas(itwo2).eq.'7664-41-7') i=1
        if (hcas(itwo2).eq.'7732-18-5'.and. hcas(1).eq.'7664-41-7') i=2
        if (i.ne.0) then
          if (abs(tref(i)-300.) .lt. 0.001 .and.
     &    abs(hdef(i)-45957.).lt.1. .and. abs(sdef(i)-164.).lt.1. .and.
     &    abs(hdef(3-i)-28945.).lt.1. .and. abs(sdef(3-i)-159.).lt.1.)
     &    then
            reos(i)=8.314471d0
            Credcp(i)=8.314471d0
            hdef(i)=45957.744019720d0
            sdef(i)=164.007259009d0
            hdef(3-i)=28945.5688500127d0
            sdef(3-i)=159.336684302313d0
c           hsvrfs=' '
            ixflag=1
            h0=0.d0
            s0=0.d0
            t0=0.d0
            p0=0.d0
            hrf='DEF'
            call SETREF (hrf,ixflag,x0,h0,s0,t0,p0,ierr,herr)
          endif
        endif
      endif
      end                                             !subroutine AMH2OR
c
c        1         2         3         4         5         6         7
c23456789012345678901234567890123456789012345678901234567890123456789012
c
c ======================================================================
c                                                     end file mix_HMX.f
c ======================================================================
c  begin file prop_sub.f
c
c  This file contains the basic (non-iterative) routines to calculate
c  various properties of fluids and mixtures.  These routines must first
c  be initialized by a call to the subroutine SETUP.
c
c  contained here are:
c     subroutine CRITP (x,tc,pc,Dc,ierr,herr)
c     subroutine MAXT (x,tm,pm,Dm,ierr,herr)
c     subroutine MAXP (x,tm,pm,Dm,ierr,herr)
c     subroutine THERM (t,rho,x,p,e,h,s,cv,cp,w,hjt)
c     subroutine THERM2 (t,rho,x,p,e,h,s,cv,cp,w,Z,hjt,A,G,
c    &                   xkappa,beta,dPdrho,d2PdD2,dPT,drhodT,drhodP,
c    &                   d2PT2,d2PdTD,spare3,spare4)
c     subroutine THERM3 (t,rho,x,
c    &           xkappa,beta,xisenk,xkt,betas,bs,xkkt,thrott,pi,spht)
c     subroutine THERM0 (t,rho,x,p0,e0,h0,s0,cv0,cp00,w0,A0,G0)
c     subroutine RESIDUAL (t,rho,x,pr,er,hr,sr,cvr,cpr,Ar,Gr)
c     subroutine ENTRO (t,rho,x,s)
c     subroutine ENTHAL (t,rho,x,h)
c     subroutine ENERGY (t,rho,x,e)
c     subroutine CVCP (t,rho,x,cv,cp)
c     subroutine CVCPK (icomp,t,rho,cv,cp)
c     subroutine GIBBS (t,rho,x,Ar,Gr)
c     subroutine AG (t,rho,x,a,g)
c     subroutine PRESS (t,rho,x,p)
c     subroutine DPDD (t,rho,x,dpdrho)
c     subroutine DPDDK (icomp,t,rho,dpdrho)
c     subroutine DPDD2 (t,rho,x,d2PdD2)
c     subroutine DPDT (t,rho,x,dpt)
c     subroutine DPDTK (icomp,t,rho,dpt)
c     subroutine DDDP (t,rho,x,drhodp)
c     subroutine DDDT (t,rho,x,drhodt)
c     subroutine DERVPVT (t,rho,x,
c    &                    dPdD,dPdT,d2PdD2,d2PdT2,d2PdTD,
c    &                    dDdP,dDdT,d2DdP2,d2DdT2,d2DdPT,
c    &                    dTdP,dTdD,d2TdP2,d2TdD2,d2TdPD)
c     subroutine DHD1(t,rho,x,dhdt_d,dhdt_p,dhdd_t,dhdd_p,dhdp_t,dhdp_d)
c     subroutine FGCTY (t,rho,x,f)
c     subroutine FGCTY2 (t,rho,x,f,ierr,herr)
c     subroutine FUGCOF (t,rho,x,phi,ierr,herr)
c     subroutine CHEMPOT (t,rho,x,u,ierr,herr)
c     subroutine ACTVY (t,rho,x,actv,gamma,ierr,herr)
c     subroutine PHIDERV (iderv,t,rho,x,dadn,dnadn,ierr,herr)
c     subroutine VIRB (t,x,b)
c     subroutine DBDT (t,x,dbt)
c     subroutine DBDT2 (t,x,dbt2)
c     subroutine VIRC (t,x,c)
c     subroutine DCDT (t,x,dct)
c     subroutine DCDT2 (t,x,dct2)
c     subroutine VIRD (t,x,d)
c     subroutine VIRBA (t,x,ba)
c     subroutine VIRCA (t,x,ca)
c     subroutine VIRBCD (t,x,b,c,d)
c     subroutine B12 (t,x,b)
c     subroutine EXCESS (t,p,x,kph,rho,vE,eE,hE,sE,aE,gE,ierr,herr)
c     subroutine FPV (t,rho,p,x,f)
c     subroutine RMIX (x)
c     subroutine RMIX2 (x,Rgas)
c     subroutine SPECGR (t,rho,p,gr)
c     subroutine HEAT (t,rho,x,hg,hn,ierr,herr)
c     subroutine ENTHHC (icmb,t1,t2,h)
c     subroutine ISPURE (x,icomp)
c     subroutine RIEM (t,rho,x,riemc)
c
c  these routines use the following common blocks from other files
c     common /MODEL/ hrefst,heos,hpheq,h2eos(n0:nx),hmixp,htran,hsten
c     common /CREF/ tref(n0:nx),rhoref(n0:nx),href(n0:nx),sref(n0:nx)
c     common /Gcnst/ R,tz(n0:nx),rhoz(n0:nx)
c
c  various arrays are dimensioned with parameter statements
c
c ======================================================================
c ======================================================================
c
      subroutine CRITP (x,tc,pc,Dc,ierr,herr)
c
c  critical parameters as a function of composition
c
c  input:
c        x--composition [array of mol frac]
c  outputs:
c       tc--critical temperature [K]
c       pc--critical pressure [kPa]
c       Dc--critical density [mol/L]
c     ierr--error flag:  0 = successful
c                        1 = did not converge
c     herr--error string (character*255 variable if ierr<>0)
c
c  written by M. McLinden, NIST Thermophysics Division, Boulder, Colorado
c  11-20-94  MM, original version
c  07-21-95  MM, call CRTBWR instead of accessing arrays directly
c  08-07-95  MM, add call to Fundamental (Helmholtz) EOS
c  09-13-95  MM, add ierr, herr to argument list
c  10-03-95  MM, change /MODEL/--models specified by strings
c  11-02-95  MM, add call mixture Helmholtz model (HMX)
c  11-29-95  MM, variable lower limit on coefficient/constant arrays
c                to accommodate ECS reference fluid
c  02-27-96  MM, parameter n0=-ncmax to accommodate ECS-thermo model
c                add Zcrit to common /CCON/
c                add call to ECS model
c  03-19-19  MM, add dipole moment to /CCON/
c  03-22-96  MM, replace /MODEL/ with /EOSMOD/
c  10-01-97  MM, add compiler switch to allow access by DLL
c  12-01-98 EWL, add Reos and triple point pressure and density to /CCON/
c  03-07-07 EWL, add check for tc, pc, dc less than 0
c  09-15-11 EWL, remove checks for FEQ, BWR, etc., and just return values from common block
c
cx DEC$ ATTRIBUTES DLLEXPORT :: CRITP
c
      include 'commons.for'
      character*255 herr
      dimension x(ncmax)
c
      ierr=0
      herr=' '
      call ISPURE (x,icomp)
      if (icomp.ne.0) then
        tc=Tcrit(icomp)
        pc=Pcrit(icomp)
        Dc=Dcrit(icomp)
      else
        call CRTHMX (x,tc,pc,Dc,ierr,herr)
      end if
      if (tc.le.0) tc=100.d0
      if (pc.le.0) pc=0.d0
      if (dc.le.0) dc=0.d0
c
      RETURN
      end                                              !subroutine CRITP
c
c ======================================================================
c
      subroutine MAXT (x,tm,pm,Dm,ierr,herr)
c
c  values at the maximum temperature along the saturation line, these are
c  returned from the call to SATSPLN and apply only to the composition x
c  sent to SATSPLN.
c
c  input:
c        x--composition [array of mol frac]
c  outputs:
c       tm--temperature [K]
c       pm--pressure [kPa]
c       Dm--density [mol/L]
c     ierr--error flag:  0 = successful
c     herr--error string (character*255 variable if ierr<>0)
c
c  written by E.W. Lemmon, NIST Physical & Chem Properties Div, Boulder, CO
c  12-01-12 EWL, original version
c
      include 'commons.for'
      character*255 herr
      dimension x(ncmax)
c
      tm=300
      pm=0
      dm=0
      ierr=1
      herr='[MAXT error] Maximum temperature not known'
      call ISPURE (x,icomp)
      if (icomp.ne.0) then
        call CRITP (x,tm,pm,Dm,ierr,herr)
      else
        if (iSpline.ne.0) then
          if (ierrtmx.eq.0) then
            ix=1
            do i=1,nc
              if (abs(x(i)-xspln(i)).gt.1.d-6) ix=0
            enddo
            if (ix.eq.1) then
              tm=tmxt
              pm=tmxp
              Dm=tmxd
            endif
          endif
        end if
        if (Dm.gt.0.01) then
          ierr=0
          herr=' '
        endif
      end if
c
      RETURN
      end                                               !subroutine MAXT
c
c ======================================================================
c
      subroutine MAXP (x,tm,pm,Dm,ierr,herr)
c
c  values at the maximum pressure along the saturation line, these are
c  returned from the call to SATSPLN and apply only to the composition x
c  sent to SATSPLN.
c
c  input:
c        x--composition [array of mol frac]
c  outputs:
c       tm--temperature [K]
c       pm--pressure [kPa]
c       Dm--density [mol/L]
c     ierr--error flag:  0 = successful
c     herr--error string (character*255 variable if ierr<>0)
c
c  written by E.W. Lemmon, NIST Physical & Chem Properties Div, Boulder, CO
c  12-01-12 EWL, original version
c
      include 'commons.for'
      character*255 herr
      dimension x(ncmax)
c
      tm=300
      pm=0
      dm=0
      ierr=1
      herr='[MAXP error] Maximum pressure not known'
      call ISPURE (x,icomp)
      if (icomp.ne.0) then
        call CRITP (x,tm,pm,Dm,ierr,herr)
      else
        if (iSpline.ne.0) then
          if (ierrpmx.eq.0) then
            ix=1
            do i=1,nc
              if (abs(x(i)-xspln(i)).gt.1.d-6) ix=0
            enddo
            if (ix.eq.1) then
              tm=pmxt
              pm=pmxp
              Dm=pmxd
            endif
          endif
        end if
        if (Dm.gt.0.01) then
          ierr=0
          herr=' '
        endif
      end if
c
      RETURN
      end                                               !subroutine MAXP
c
c ======================================================================
c
      subroutine THERM (t,rho,x,p,e,h,s,cv,cp,w,hjt)
c
c  compute thermal quantities as a function of temperature, density,
c  and compositions using core functions (Helmholtz free energy, ideal
c  gas heat capacity and various derivatives and integrals)
c
c  Based on derivations in Younglove & McLinden, JPCRD 23 #5, 1994,
c  Appendix A for pressure-explicit equations (e.g. MBWR) and
c  Baehr & Tillner-Roth, Thermodynamic Properties of Environmentally
c  Acceptable Refrigerants, Berlin:  Springer-Verlag (1995) for
c  Helmholtz-explicit equations (e.g. FEQ).
c
c  inputs:
c        t--temperature [K]
c      rho--molar density [mol/L]
c        x--composition [array of mol frac]
c  outputs:
c        p--pressure [kPa]
c        e--internal energy [J/mol]
c        h--enthalpy [J/mol]
c        s--entropy [J/mol-K]
c       Cv--isochoric heat capacity [J/mol-K]
c       Cp--isobaric heat capacity [J/mol-K]
c        w--speed of sound [m/s]
c      hjt--isenthalpic Joule-Thomson coefficient [K/kPa]
c
c  written by M. McLinden, NIST Thermophysics Division, Boulder, Colorado
c  10-11-94  MM, original version
c  08-04-95  MM, add calls to Fundamental (Helmholtz) EOS
c  10-03-95  MM, change /MODEL/--models specified by strings
c  10-10-95  MM, compute ideal gas pressure and pass to PHI0
c  11-03-95  MM, add calls to mixture Helmholtz (HMX) model
c  11-06-95  MM, add calls to mixture ideal gas function
c  11-08-95  MM, convert calls to PHI0, CP0, CPI, CPT to mixture form
c  11-29-95  MM, variable lower limit on coefficient/constant arrays
c                to accommodate ECS reference fluid
c  12-13-95  MM, compute entropy using Cp0, etc rather than PHI0
c  01-18-96  MM, fix s and h ref state for HMX: s = s - sum[x(i)*sref(i)]
c  02-27-96  MM, parameter n0=-ncmax to accommodate ECS-thermo model
c                add Zcrit to common /CCON/
c                replace calls to PHIHMX, PHIFEQ with general PHIX, PHIK
c  03-19-96  MM, add dipole moment to /CCON/
c  03-22-96  MM, replace /MODEL/ with /EOSMOD/
c  04-19-96  MM, change call to PHI0:  pass rho instead of pideal
c                calculate e,h,s using PHI0 rather than Cp0
c  07-05-96  MM, change e, Cv:  PHI0 returns tau*d(phi0)/d(tau), etc.
c  04-22-97  MM, lower bound on rho for s calc set to 1.0d-20
c  10-01-97  MM, add compiler switch to allow access by DLL
c  03-30-98 EWL, add Joule-Thomson coeff to MBWR case
c  03-31-98  MM, special case for Joule-Thomson coeff for rho = 0
c  12-01-98 EWL, add Reos and triple point pressure and density to /CCON/
c  12-02-98 EWL, remove compositional dependence for pure fluids
c  12-02-98 EWL, restructure to closely mimic THERM2
c  12-22-98 EWL, recalculate R for mixtures based on values for pure fluids
c  05-25-00 EWL, moved calculation of Z to bottom AFTER p is calculated!
c  09-00-00 EWL, removed the del from del*phi01, etc.  The del's and tau's
c                are now included in the core routines.  Put the reducing
c                variables tz and rhoz directly in the common blocks.
c  09-05-02 EWL, change check on rho from 1.d-10 to 1.0d-8 to avoid
c                zero's coming back from core_feq at low rhos.
c  10-04-06 EWL, change remaining checks on rho from 1.d-10 to 1.0d-8
c  06-18-07 EWL, change all checks for rho in prop_sub.for from 1.d-20 to 1.d-40
c                for ideal gas situations
c
cx DEC$ ATTRIBUTES DLLEXPORT :: THERM
c
      include 'commons.for'
      dimension x(ncmax)
c
      call RMIX (x)
      RT=R*t
      w2=0.d0
      p=0.d0
      e=0.d0
      h=0.d0
      s=0.d0
      cv=0.d0
      cp=0.d0
      w=0.d0
      hjt=0.d0
      if (t.le.0.d0) return
      if (rho.lt.1.0d-40) then
c  entropy calc will crash if rho = 0
        rhos=1.0d-40
      else
        rhos=rho
      end if
      if (heos.eq.'BWR') then
c  pure fluid MBWR equation of state--call BWR-specific routines
        icomp=1
        p=PBWR(icomp,t,rho)
        a=ABWR(icomp,t,rho)
        dadt=DABWR(icomp,t,rho)
        cpiint=CPI(t,x)
        cptint=CPT(t,x)
        dPdrho=DPDBWR(icomp,t,rho)
        dPT=DPTBWR(icomp,t,rho)
        e=a-t*dadt
c    &    +cpiint-R*(t-tref(icomp))  ! R*tref is const, merge w/ href
     &    +cpiint-RT
     &    -href(icomp)
c
        s=-dadt+R*log(rhoref(icomp)/rhos)+cptint-R*log(t/tref(icomp))
     &    -sref(icomp)
        cv=-t*D2ABWR(icomp,t,rho)+CP0(t,x)-R
        if (rho.gt.1.0d-8) then
          cp=cv+t/rho**2*dPT**2/dPdrho
        else
          cp=CP0(t,x)
        end if
        if (rho.gt.1.0d-8) then
          h=e+p/rho
          hjt=(t/rho*dPT/dPdrho-1.0d0)/rho/cp
        else
          h=e+RT
          call VIRB (t,x,b)
          call DBDT (t,x,dbt)
          hjt=(dbt*t-b)/cp
        end if
c  if any of the factors in speed of sound are negative (e.g. in two-
c  phase region) return 0.0
c       w=SQRT(1.0d3/wm*cp/cv*dPdrho)
        w2=cp/cv*dPdrho
        if (w2.gt.0.0d0) then
          w=SQRT(1.0d3/wmas(icomp)*w2)
        else
          w=0.0d0
        end if
c
      else
c  call general PHIK or PHIX routines for all other models
        call ISPURE (x,icomp)
        if (icomp.ne.0) then
c  pure fluid
          tau=tz(icomp)/t
          del=rho/rhoz(icomp)
          phi00=PHIK(icomp,0,0,tau,del)  !real-gas terms
          phi01=PHIK(icomp,0,1,tau,del)
          phi10=PHIK(icomp,1,0,tau,del)
          phi11=PHIK(icomp,1,1,tau,del)
          phi02=PHIK(icomp,0,2,tau,del)
          phi20=PHIK(icomp,2,0,tau,del)
        else
c  mixture
          call REDX (x,t0,rho0)
          tau=t0/t
          del=rho/rho0
          phi00=PHIX(0,0,tau,del,x)   !real-gas terms
          phi01=PHIX(0,1,tau,del,x)
          phi10=PHIX(1,0,tau,del,x)
          phi11=PHIX(1,1,tau,del,x)
          phi02=PHIX(0,2,tau,del,x)
          phi20=PHIX(2,0,tau,del,x)
        end if
c       write (*,1003) t,rho,phi00,phi01,phi10,phi11,phi02,phi20
c1003   format (1x,' THERM--t,rho,PHIs:   ',f8.2,f12.6,6d16.6)
c
        phig00=PHI0(0,0,t,rhos,x)      !ideal-gas terms
        phig10=PHI0(1,0,t,rho,x)
        phig20=PHI0(2,0,t,rho,x)
c       write (*,1005) (x(j),j=1,ncmax)
c1005   format (1x,' THERM--output x(i): ',5f14.8)
c       write (*,1024) phig00,phig10,phig20
c1024   format (1x,' THERM--phig-00/01/02:',20x,3d16.6)
        p=RT*rho*(1.0d0+phi01)
        e=RT*(phig10+phi10)
        if (icomp.ne.0) then
          e=e-href(icomp)
        else
          do i=1,nc
            e=e-x(i)*href(i)
          enddo
        endif
        h=e+RT*(1.0d0+phi01)
        s=R*(phig10+phi10-phig00-phi00)
c       write (*,*) ' THERM--t,rho,x,s,sref:  ',t,rho,x(1),s,sref(1)
        if (icomp.ne.0) then
          s=s-sref(icomp)
        else
          do i=1,nc
            s=s-x(i)*sref(i)
          enddo
        endif
        cv=-R*(phi20+phig20)
c       write (*,*) ' THERM--tau,del,Cv_resid:  ',tau,del,phi20
        cp=cv+R*(1.0d0+phi01-phi11)**2/(1.0d0+2.0d0*phi01+phi02)
        if (cv.gt.0.d0) w2=RT*cp/cv*(1.0d0+2.0d0*phi01+phi02)
c  if any of the factors in speed of sound are negative (e.g. in two-
c  phase region) return 0.0
        if (w2.gt.0.0d0) then
          w=SQRT(w2*1.0d3/WMOL(x))  !convert from molar to mass units
        else
          w=0.0d0
        end if
        if (rho.gt.1.0d-8) then
          hjt=-1.0d0/(cp*rho)*(phi01+phi02+phi11)/
     &        (1.0d0+2.0d0*phi01+phi02)
        else
          call VIRB (t,x,b)
          call DBDT (t,x,dbt)
          hjt=(dbt*t-b)/cp
        end if
      end if
c
      RETURN
      end                                              !subroutine THERM
c
c ======================================================================
c
      subroutine THERM2 (t,rho,x,p,e,h,s,cv,cp,w,Z,hjt,A,G,
     &                   xkappa,beta,dPdrho,d2PdD2,dPT,drhodT,drhodP,
     &                   d2PT2,d2PdTD,spare3,spare4)
c
c  compute thermal quantities as a function of temperature, density,
c  and compositions using core functions (Helmholtz free energy, ideal
c  gas heat capacity and various derivatives and integrals)
c
c  this routine is the same as THERM, except that additional properties
c  are calculated
c
c  inputs:
c        t--temperature [K]
c      rho--molar density [mol/L]
c        x--composition [array of mol frac]
c  outputs:
c        p--pressure [kPa]
c        e--internal energy [J/mol]
c        h--enthalpy [J/mol]
c        s--entropy [J/mol-K]
c       Cv--isochoric heat capacity [J/mol-K]
c       Cp--isobaric heat capacity [J/mol-K]
c        w--speed of sound [m/s]
c        Z--compressibility factor (= PV/RT) [dimensionless]
c      hjt--isenthalpic Joule-Thomson coefficient [K/kPa]
c        A--Helmholtz energy [J/mol]
c        G--Gibbs free energy [J/mol]
c   xkappa--isothermal compressibility (= -1/V dV/dP = 1/rho dD/dP) [1/kPa]
c     beta--volume expansivity (= 1/V dV/dT = -1/rho dD/dT) [1/K]
c   dPdrho--derivative dP/drho [kPa-L/mol]
c   d2PdD2--derivative d^2P/drho^2 [kPa-L^2/mol^2]
c      dPT--derivative dP/dT [kPa/K]
c   drhodT--derivative drho/dT [mol/(L-K)]
c   drhodP--derivative drho/dP [mol/(L-kPa)]
c    d2PT2--derivative d2P/dT2 [kPa/K^2]
c   d2PdTD--derivative d2P/dTd(rho) [J/mol-K]
c   sparei--2 space holders for possible future properties
c
c  written by M. McLinden, NIST Physical & Chem Properties Div, Boulder, CO
c  03-16-98  MM, original version; based on THERM
c  03-30-98 EWL, add Joule-Thomson coeff to MBWR case
c  12-01-98 EWL, add Reos and triple point pressure and density to /CCON/
c  12-02-98 EWL, remove compositional dependence for pure fluids
c  12-02-98 EWL, restructure to closely mimic THERM
c  12-02-98 EWL, add the reference states to the calculation of A and G
c  12-22-98 EWL, recalculate R for mixtures based on values for pure fluids
c  02-11-99 EWL, skip calculation of d2PdD2 if rho=0
c  04-27-01 EWL, change order of calculation of a and g in BWR section
c  04-27-01 DGF, change sign before sref in the calculation of a and g
c  09-05-02 EWL, add ideal gas isothermal compressibility and d2pdD2
c  09-05-02 EWL, change check on rho from 1.d-10 to 1.0d-8 to avoid
c                zero's coming back from core_feq at low rhos.
c  06-14-06 EWL, change dPdD to dPdrho, etc, to avoid compiler problems with subroutine dPdD, etc.
c  03-04-08 EWL, add checks for T=0
c  12-04-09 EWL, add d2P/dT2
c  03-26-10 EWL, add d2P/dTdrho
c  01-03-11 EWL, fixed d2P/dT2 calculation (divided by T)
c
cx DEC$ ATTRIBUTES DLLEXPORT :: THERM2
c
      include 'commons.for'
      dimension x(ncmax)
c
      call ISPURE (x,icomp)
      spare3=xnotc  !flag indicating not calculated
      spare4=xnotc
      p=0.d0
      e=0.d0
      h=0.d0
      s=0.d0
      cv=0.d0
      cp=0.d0
      w=0.d0
      hjt=0.d0
      Z=0.d0
      A=0.d0
      G=0.d0
      xkappa=0.d0
      beta=0.d0
      dPdrho=0.d0
      d2PdD2=0.d0
      dPT=0.d0
      drhodT=0.d0
      drhodP=0.d0
      d2PT2=0.d0
      d2PdTD=0.d0
      if (t.le.0.d0) return
c
      call RMIX (x)
      RT=R*t
      call DBDT (t,x,dbt)
      call VIRB (t,x,b)
      rhos=rho
c  entropy calc will crash if rho = 0
      if (rho.lt.1.0d-40) rhos=1.0d-20
      if (heos.eq.'BWR') then
c  pure fluid MBWR equation of state--call BWR-specific routines
        icomp=1
        p=PBWR(icomp,t,rho)
        ar=ABWR(icomp,t,rho)
        dadt=DABWR(icomp,t,rho)
        cpiint=CPI(t,x)
        cptint=CPT(t,x)
        dPdrho=DPDBWR(icomp,t,rho)
        dPT=DPTBWR(icomp,t,rho)
        e=ar-t*dadt
c    &    +cpiint-R*(t-tref(icomp))  ! R*tref is const, merge w/ href
     &    +cpiint-RT
     &    -href(icomp)
c  additional properties added to THERM2 not in THERM
        d2PdD2=D2PBWR(icomp,t,rho)
        drhodT=-dPT/dPdrho
        drhodP=1.0d0/dPdrho
c
        s=-dadt+R*log(rhoref(icomp)/rhos)+cptint-R*log(t/tref(icomp))
     &    -sref(icomp)
        cv=-t*D2ABWR(icomp,t,rho)+CP0(t,x)-R
        A=e-t*s
        if (rho.gt.1.0d-8) then
          G=A+p/rho
          beta=-drhodT/rho
          xkappa=drhodP/rho
        else
          G=A+R*t
          beta=1.0d0/t  !if rho = 0, then ideal-gas behavior
          xkappa=xnotc
          if (p.gt.0.d0) xkappa=1.d0/p
        end if
        if (rho.gt.1.0d-8) then
          cp=cv+t/rho**2*dPT**2/dPdrho
        else
          cp=CP0(t,x)
        end if
        if (rho.gt.1.0d-8) then
          h=e+p/rho
          hjt=(t/rho*DPTBWR(icomp,t,rho)/dPdrho-1.0d0)/rho/cp
        else
          h=e+RT
          hjt=(dbt*t-b)/cp
        end if
c  if any of the factors in speed of sound are negative (e.g. in two-
c  phase region) return 0.0
c       w=SQRT(1.0d3/wm*cp/cv*dPdrho)
        w2=cp/cv*dPdrho
        if (w2.gt.0.0d0) then
          w=SQRT(1.0d3/wmas(icomp)*w2)
        else
          w=0.0d0
        end if
c
      else
c  call general PHIK or PHIX routines for all other models
        if (icomp.ne.0) then
c  pure fluid
          tau=tz(icomp)/t
          del=rho/rhoz(icomp)
          phi00=PHIK(icomp,0,0,tau,del)  !real-gas terms
          phi01=PHIK(icomp,0,1,tau,del)
          phi10=PHIK(icomp,1,0,tau,del)
          phi11=PHIK(icomp,1,1,tau,del)
          phi12=PHIK(icomp,1,2,tau,del)
          phi21=PHIK(icomp,2,1,tau,del)
          phi02=PHIK(icomp,0,2,tau,del)
          phi20=PHIK(icomp,2,0,tau,del)
          phi03=PHIK(icomp,0,3,tau,del)
        else
c  mixture
          call REDX (x,t0,rho0)
          tau=t0/t
          del=rho/rho0
          phi00=PHIX(0,0,tau,del,x)   !real-gas terms
          phi01=PHIX(0,1,tau,del,x)
          phi10=PHIX(1,0,tau,del,x)
          phi11=PHIX(1,1,tau,del,x)
          phi12=PHIX(1,2,tau,del,x)
          phi21=PHIX(2,1,tau,del,x)
          phi02=PHIX(0,2,tau,del,x)
          phi20=PHIX(2,0,tau,del,x)
          phi03=PHIX(0,3,tau,del,x)
        end if
c       write (*,1003) t,rho,phi00,phi01,phi10,phi11,phi02,phi20
c1003   format (1x,' THERM--t,rho,PHIs:   ',f8.2,f12.6,6d16.6)
c
        phig00=PHI0(0,0,t,rhos,x)      !ideal-gas terms
        phig10=PHI0(1,0,t,rho,x)
        phig20=PHI0(2,0,t,rho,x)
c       write (*,1005) (x(j),j=1,ncmax)
c1005   format (1x,' THERM--output x(i): ',5f14.8)
c       write (*,1024) phig00,phig10,phig20
c1024   format (1x,' THERM--phig-00/01/02:',20x,3d16.6)
        p=RT*rho*(1.0d0+phi01)
        e=RT*(phig10+phi10)
        if (icomp.ne.0) then
          e=e-href(icomp)
        else
          do i=1,nc
            e=e-x(i)*href(i)
          enddo
        endif
        h=e+RT*(1.0d0+phi01)
        s=R*(phig10+phi10-phig00-phi00)
c       write (*,*) ' THERM--t,rho,x,s,sref:  ',t,rho,x(1),s,sref(1)
        if (icomp.ne.0) then
          s=s-sref(icomp)
        else
          do i=1,nc
            s=s-x(i)*sref(i)
          enddo
        endif
        cv=-R*(phi20+phig20)
c       write (*,*) ' THERM--tau,del,Cv_resid:  ',tau,del,phi20
        cp=cv+R*(1.0d0+phi01-phi11)**2/
     &     (1.0d0+2.0d0*phi01+phi02)
        w2=RT*cp/cv*(1.0d0+2.0d0*phi01+phi02)
c  if any of the factors in speed of sound are negative (e.g. in two-
c  phase region) return 0.0
        if (w2.gt.0.0d0) then
          w=SQRT(w2*1.0d3/WMOL(x))  !convert from molar to mass units
        else
          w=0.0d0
        end if
        if (rho.gt.1.0d-8) then
          hjt=-1.0d0/(cp*rho)*(phi01+phi02+phi11)/
     &        (1.0d0+2.0d0*phi01+phi02)
        else
          hjt=(dbt*t-b)/cp
        end if
c  additional properties added to THERM2 not in THERM
        A=RT*(phi00+phig00)
        G=A+RT*(1.0d0+phi01)
        if (icomp.ne.0) then
          a=a-href(icomp)+sref(icomp)*t
          g=g-href(icomp)+sref(icomp)*t
        else
          do i=1,nc
            a=a-x(i)*(href(i)-sref(i)*t)
            g=g-x(i)*(href(i)-sref(i)*t)
          enddo
        endif
        dPdrho=RT*(1.0d0+2.0d0*phi01+phi02)
        dPT=R*rho*(1.0d0+phi01-phi11)
        d2PT2=R*rho*phi21/T        !d2P/dT2=d3A/dT2dV=1/T*dCv/dV
        d2PdTD=R*(1.d0+2.d0*phi01+phi02-2.d0*phi11-phi12)
        drhodP=1.0d0/(RT*(1.0d0+2.0d0*phi01+phi02))
        drhodT=-rho*(1.0d0+phi01-phi11)/(t*(1.0d0+2.0d0*phi01+phi02))
        if (rho.gt.1.0d-8) then
          d2PdD2=RT/rho*(2.0d0*phi01+4.0d0*phi02+phi03)
          beta=-drhodT/rho
          xkappa=drhodP/rho
        else
          d2PdD2=2.d0*b*R*t
          beta=xnotc
          beta=1.0d0/t  !if rho = 0, then ideal-gas behavior
          xkappa=xnotc
          if (p.gt.0.d0) xkappa=1.d0/p
        end if
      end if
      if (rho.lt.1.0d-40) then
        Z=1.0d0       !if rho = 0, then ideal-gas behavior
      else
        Z=p/(RT*rho)
      end if
c
      RETURN
      end                                             !subroutine THERM2
c
c ======================================================================
c
      subroutine THERM0 (t,rho,x,p0,e0,h0,s0,cv0,cp00,w0,A0,G0)
c
c  compute ideal gas thermal quantities as a function of temperature, density,
c  and compositions using core functions
c
c  this routine is the same as THERM, except it only calculates ideal gas
c  properties (Z=1) at any temperature and density
c
c  inputs:
c        t--temperature [K]
c      rho--molar density [mol/L]
c        x--composition [array of mol frac]
c  outputs:
c       p0--pressure [kPa]
c       e0--internal energy [J/mol]
c       h0--enthalpy [J/mol]
c       s0--entropy [J/mol-K]
c      Cv0--isochoric heat capacity [J/mol-K]
c     Cp00--isobaric heat capacity [J/mol-K]
c       w0--speed of sound [m/s]
c       A0--Helmholtz energy [J/mol]
c       G0--Gibbs free energy [J/mol]
c
c  11-26-02 EWL, original version; based on THERM
c
cx DEC$ ATTRIBUTES DLLEXPORT :: THERM0
c
      include 'commons.for'
      dimension x(ncmax)
c
      p0=0.d0
      e0=0.d0
      h0=0.d0
      s0=0.d0
      cv0=0.d0
      cp00=0.d0
      w0=0.d0
      A0=0.d0
      G0=0.d0
      if (t.le.0.d0) return
      call RMIX (x)
      RT=R*t
      rhos=rho
c  entropy calc will crash if rho = 0
      if (rho.lt.1.0d-40) rhos=1.0d-20
      phig00=PHI0(0,0,t,rhos,x)      !ideal-gas terms
      phig10=PHI0(1,0,t,rho,x)
      phig20=PHI0(2,0,t,rho,x)
      p0=RT*rho
      e0=RT*phig10
      s0=R*(phig10-phig00)
      A0=RT*phig00
      call ISPURE (x,icomp)
      if (icomp.ne.0) then
        e0=e0-href(icomp)
        s0=s0-sref(icomp)
        a0=a0-href(icomp)+sref(icomp)*t
      else
        do i=1,nc
          e0=e0-x(i)*href(i)
          s0=s0-x(i)*sref(i)
          a0=a0-x(i)*(href(i)-sref(i)*t)
        enddo
      endif
      cv0=-R*phig20
      cp00=cv0+R
      h0=e0+RT
      G0=A0+RT
      w2=RT*cp00/cv0
      if (w2.gt.0.0d0) then
        w0=SQRT(w2*1.0d3/WMOL(x))
      else
        w0=0.0d0
      end if
c
      RETURN
      end                                             !subroutine THERM0
c
c ======================================================================
c
      subroutine RESIDUAL (t,rho,x,pr,er,hr,sr,cvr,cpr,Ar,Gr)
c
c  compute the residual quantities as a function of temperature, density,
c  and compositions (where the residual is the property minus the ideal
c  gas portion).
c
c  inputs:
c        t--temperature [K]
c      rho--molar density [mol/L]
c        x--composition [array of mol frac]
c  outputs:
c       pr--residual pressure [kPa]  (p-rho*R*T)
c       er--residual internal energy [J/mol]
c       hr--residual enthalpy [J/mol]
c       sr--residual entropy [J/mol-K]
c      Cvr--residual isochoric heat capacity [J/mol-K]
c      Cpr--residual isobaric heat capacity [J/mol-K]
c       Ar--residual Helmholtz energy [J/mol]
c       Gr--residual Gibbs free energy [J/mol]
c
c  written by E.W. Lemmon, NIST Physical & Chem Properties Div, Boulder, CO
c  07-07-10 EWL, original version; based on THERM2
c
cx DEC$ ATTRIBUTES DLLEXPORT :: RESIDUAL
c
      include 'commons.for'
      dimension x(ncmax)
c
      pr=0.d0
      er=0.d0
      hr=0.d0
      sr=0.d0
      cvr=0.d0
      cpr=0.d0
      Ar=0.d0
      Gr=0.d0
      if (t.le.0.d0) return
      call ISPURE (x,icomp)
      call RMIX (x)
      if (icomp.ne.0) then
c  pure fluid
        tau=tz(icomp)/t
        del=rho/rhoz(icomp)
        phi00=PHIK(icomp,0,0,tau,del)  !real-gas terms
        phi01=PHIK(icomp,0,1,tau,del)
        phi10=PHIK(icomp,1,0,tau,del)
        phi11=PHIK(icomp,1,1,tau,del)
        phi02=PHIK(icomp,0,2,tau,del)
        phi20=PHIK(icomp,2,0,tau,del)
      else
c  mixture
        call REDX (x,t0,rho0)
        tau=t0/t
        del=rho/rho0
        phi00=PHIX(0,0,tau,del,x)   !real-gas terms
        phi01=PHIX(0,1,tau,del,x)
        phi10=PHIX(1,0,tau,del,x)
        phi11=PHIX(1,1,tau,del,x)
        phi02=PHIX(0,2,tau,del,x)
        phi20=PHIX(2,0,tau,del,x)
      end if
c
      RT=R*T
      pr=RT*rho*phi01
      er=RT*phi10
      hr=er+RT*phi01
      sr=R*(phi10-phi00)
      cvr=-R*phi20
      cpr=cvr+R*(1.0d0+phi01-phi11)**2/(1.0d0+2.0d0*phi01+phi02)-R
      Ar=RT*phi00
      Gr=Ar+RT*phi01
c
      RETURN
      end                                           !subroutine RESIDUAL
c
c ======================================================================
c
      subroutine ENTRO (t,rho,x,s)
c
c  compute entropy as a function of temperature, density and composition
c  using core functions (temperature derivative of Helmholtz free energy
c  and ideal gas integrals)
c
c  based on derivations in Younglove & McLinden, JPCRD 23 #5, 1994,
c  equations A5, A19 - A26
c
c  inputs:
c        t--temperature [K]
c      rho--molar density [mol/L]
c        x--composition [array of mol frac]
c  output:
c        s--entropy [J/mol-K]
c
c  written by M. McLinden, NIST Thermophysics Division, Boulder, Colorado
c  10-05-94  MM, original version
c  10-03-95  MM, change /MODEL/--models specified by strings
c  10-10-95  MM, compute ideal gas pressure and pass to PHI0
c  11-03-95  MM, add calls to mixture Helmholtz (HMX) model
c  11-08-95  MM, convert calls to PHI0, CP0, CPI, CPT to mixture form
c  11-29-95  MM, variable lower limit on coefficient/constant arrays
c                to accommodate ECS reference fluid
c  01-19-96  MM, fix ref state for HMX: s = s - sum[x(i)*sref(i)]
c  02-27-96  MM, parameter n0=-ncmax to accommodate ECS-thermo model
c                replace calls to PHIHMX, PHIFEQ with general PHIX, PHIK
c  03-22-96  MM, replace /MODEL/ with /EOSMOD/
c  04-19-96  MM, change call to PHI0:  pass rho instead of pideal
c                calculate s using PHI0 rather than Cp0
c  07-19-96  MM, change general calls to PHI0 (same as THERM)
c  04-22-97  MM, lower bound on rho for s calc set to 1.0d-20
c  10-01-97  MM, add compiler switch to allow access by DLL
c  12-02-98 EWL, remove compositional dependence for pure fluids
c
cx DEC$ ATTRIBUTES DLLEXPORT :: ENTRO
c
      include 'commons.for'
      dimension x(ncmax)
c
      s=0.d0
      if (t.le.0.d0) return
      call RMIX (x)
      if (rho.lt.1.0d-40) then
c  entropy calc will crash if rho = 0
        rhos=1.0d-40
      else
        rhos=rho
      end if
      if (heos.eq.'BWR') then
c  pure fluid MBWR equation of state--call BWR-specific routines
        icomp=1
        s=-DABWR(icomp,t,rho)+R*log(rhoref(icomp)/rhos)+CPT(t,x)
     &    -R*log(t/tref(icomp))-sref(icomp)
      else
c  call general PHIK or PHIX routines for all other models
        call ISPURE (x,icomp)
        if (icomp.ne.0) then
c  pure fluid
          tau=tz(icomp)/t
          del=rho/rhoz(icomp)
          phi00=PHIK(icomp,0,0,tau,del)  !real-gas terms
          phi10=PHIK(icomp,1,0,tau,del)
        else
c  mixture
          call REDX (x,t0,rho0)
          tau=t0/t
          del=rho/rho0
          phi00=PHIX(0,0,tau,del,x)  !real-gas terms
          phi10=PHIX(1,0,tau,del,x)
        end if
c
        phig00=PHI0(0,0,t,rhos,x)      !ideal-gas terms
        phig10=PHI0(1,0,t,rho,x)
        s=R*(phig10+phi10-phig00-phi00)
        if (icomp.ne.0) then
          s=s-sref(icomp)
        else
          do i=1,nc
            s=s-x(i)*sref(i)
          enddo
        endif
      end if
c
      RETURN
      end                                              !subroutine ENTRO
c
c ======================================================================
c
      subroutine ENTHAL (t,rho,x,h)
c
c  compute enthalpy as a function of temperature, density, and
c  composition using core functions (Helmholtz free energy and ideal
c  gas integrals)
c
c  based on derivations in Younglove & McLinden, JPCRD 23 #5, 1994,
c  equations A7, A18, A19
c
c  inputs:
c        t--temperature [K]
c      rho--molar density [mol/L]
c        x--composition [array of mol frac]
c  output:
c        h--enthalpy [J/mol]
c
c  written by M. McLinden, NIST Thermophysics Division, Boulder, Colorado
c  10-06-94  MM, original version
c  10-03-95  MM, change /MODEL/--models specified by strings
c  10-10-95  MM, compute ideal gas pressure and pass to PHI0
c  11-03-95  MM, add calls to mixture Helmholtz (HMX) model
c  11-08-95  MM, convert calls to PHI0, CP0, CPI, CPT to mixture form
c  11-29-95  MM, variable lower limit on coefficient/constant arrays
c                to accommodate ECS reference fluid
c  01-19-96  MM, fix ref state for HMX: h = h - sum[x(i)*href(i)]
c  02-27-96  MM, parameter n0=-ncmax to accommodate ECS-thermo model
c                replace calls to PHIHMX, PHIFEQ with general PHIX, PHIK
c  03-22-96  MM, replace /MODEL/ with /EOSMOD/
c  07-19-96  MM, change general calls to PHI0 (same as THERM)
c  10-01-97  MM, add compiler switch to allow access by DLL
c  12-02-98 EWL, remove compositional dependence for pure fluids
c  04-05-00 EWL, check for rho=0 and avoid division by zero
c
cx DEC$ ATTRIBUTES DLLEXPORT :: ENTHAL
c
      include 'commons.for'
      dimension x(ncmax)
c
      h=0.d0
      if (t.le.0.d0) return
      call RMIX (x)
      if (heos.eq.'BWR') then
c  pure fluid MBWR equation of state--call BWR-specific routines
        icomp=1
        if (rho.lt.1.d-8) then
          h=ABWR(icomp,t,rho)-t*DABWR(icomp,t,rho)+CPI(t,x)-href(icomp)
        else
          h=ABWR(icomp,t,rho)-t*DABWR(icomp,t,rho)+
     &     PBWR(icomp,t,rho)/rho-R*t+CPI(t,x)-href(icomp)
        endif
c
      else
c  call general PHIK or PHIX routines for all other models
        call ISPURE (x,icomp)
        if (icomp.ne.0) then
c  pure fluid
          tau=tz(icomp)/t
          del=rho/rhoz(icomp)
          phi01=PHIK(icomp,0,1,tau,del)
          phi10=PHIK(icomp,1,0,tau,del)
        else
c  mixture
          call REDX (x,t0,rho0)
          tau=t0/t
          del=rho/rho0
          phi01=PHIX(0,1,tau,del,x)  !real-gas terms
          phi10=PHIX(1,0,tau,del,x)
        end if
c
        RT=R*t
        phig10=PHI0(1,0,t,rho,x)
        e=RT*(phig10+phi10)
        if (icomp.ne.0) then
          e=e-href(icomp)
        else
          do i=1,nc
            e=e-x(i)*href(i)
          enddo
        endif
        h=e+RT*(1.0d0+phi01)
      end if
c
      RETURN
      end                                             !subroutine ENTHAL
c
c ======================================================================
c
      subroutine ENERGY (t,rho,x,e)
c
c  compute energy as a function of temperature, density, and
c  composition using core functions (Helmholtz free energy and ideal
c  gas integrals)
c
c  based on derivations in Younglove & McLinden, JPCRD 23 #5, 1994
c
c  inputs:
c        t--temperature [K]
c      rho--molar density [mol/L]
c        x--composition [array of mol frac]
c  output:
c        e--energy [J/mol]
c
c  written by E.W. Lemmon, NIST Thermophysics Division, Boulder, Colorado
c  12-13-00 EWL, original version
c
cx DEC$ ATTRIBUTES DLLEXPORT :: ENERGY
c
      include 'commons.for'
      dimension x(ncmax)
c
      e=0.d0
      if (t.le.0.d0) return
      call RMIX (x)
      if (heos.eq.'BWR') then
c  pure fluid MBWR equation of state--call BWR-specific routines
        icomp=1
        e=ABWR(icomp,t,rho)-t*DABWR(icomp,t,rho)-R*t+CPI(t,x)
     &   -href(icomp)
c
      else
c  call general PHIK or PHIX routines for all other models
        call ISPURE (x,icomp)
        if (icomp.ne.0) then
c  pure fluid
          tau=tz(icomp)/t
          del=rho/rhoz(icomp)
          phi10=PHIK(icomp,1,0,tau,del)
        else
c  mixture
          call REDX (x,t0,rho0)
          tau=t0/t
          del=rho/rho0
          phi10=PHIX(1,0,tau,del,x)
        end if
c
        phig10=PHI0(1,0,t,rho,x)
        e=R*t*(phig10+phi10)
        if (icomp.ne.0) then
          e=e-href(icomp)
        else
          do i=1,nc
            e=e-x(i)*href(i)
          enddo
        endif
      end if
c
      RETURN
      end                                             !subroutine ENERGY
c
c ======================================================================
c
      subroutine CVCP (t,rho,x,cv,cp)
c
c  compute isochoric (constant volume) and isobaric (constant pressure)
c  heat capacity as functions of temperature, density, and composition
c  using core functions
c
c  based on derivations in Younglove & McLinden, JPCRD 23 #5, 1994,
c  equation A15, A16
c
c  inputs:
c        t--temperature [K]
c      rho--molar density [mol/L]
c        x--composition [array of mol frac]
c  outputs:
c       cv--isochoric heat capacity [J/mol-K]
c       cp--isobaric heat capacity [J/mol-K]
c
c  written by M. McLinden, NIST Thermophysics Division, Boulder, Colorado
c  10-06-94  MM, original version
c  10-03-95  MM, change /MODEL/--models specified by strings
c  10-10-95  MM, compute ideal gas pressure and pass to PHI0
c  11-03-95  MM, add calls to mixture Helmholtz (HMX) model
c  11-08-95  MM, convert calls to PHI0, CP0, CPI, CPT to mixture form
c  11-29-95  MM, variable lower limit on coefficient/constant arrays
c                to accommodate ECS reference fluid
c  02-27-96  MM, parameter n0=-ncmax to accommodate ECS-thermo model
c                replace calls to PHIHMX, PHIFEQ with general PHIX, PHIK
c  03-22-96  MM, replace /MODEL/ with /EOSMOD/
c  07-19-96  MM, change general calls to PHI0 (same as THERM)
c  10-01-97  MM, add compiler switch to allow access by DLL
c
cx DEC$ ATTRIBUTES DLLEXPORT :: CVCP
c
      include 'commons.for'
      dimension x(ncmax)
c
      cv=0.d0
      cp=0.d0
      if (t.le.0.d0) return
      call RMIX (x)
      if (heos.eq.'BWR') then
c  pure fluid MBWR equation of state--call BWR-specific routines
        icomp=1
        cv=-t*D2ABWR(icomp,t,rho)+CP0(t,x)-R
        if (rho.gt.1.0d-8) then
          cp=cv+t/rho**2*DPTBWR(icomp,t,rho)**2/DPDBWR(icomp,t,rho)
        else
          cp=cv+R
        end if
c
      else
c  call general PHIK or PHIX routines for all other models
        call ISPURE (x,icomp)
        if (icomp.ne.0) then
c  pure fluid
          tau=tz(icomp)/t
          del=rho/rhoz(icomp)
          phi01=PHIK(icomp,0,1,tau,del)  !real-gas terms
          phi02=PHIK(icomp,0,2,tau,del)
          phi11=PHIK(icomp,1,1,tau,del)
          phi20=PHIK(icomp,2,0,tau,del)
        else
c  mixture
          call REDX (x,t0,rho0)
          tau=t0/t
          del=rho/rho0
          phi01=PHIX(0,1,tau,del,x)  !real-gas terms
          phi02=PHIX(0,2,tau,del,x)
          phi11=PHIX(1,1,tau,del,x)
          phi20=PHIX(2,0,tau,del,x)
        end if
c
        phig20=PHI0(2,0,t,rho,x)         !ideal-gas term
        cv=-R*(phi20+phig20)
        cp=cv+R*(1.0d0+phi01-phi11)**2/
     &     (1.0d0+2.0d0*phi01+phi02)
      end if
c
      RETURN
      end                                               !subroutine CVCP
c
c ======================================================================
c
      subroutine CVCPK (icomp,t,rho,cv,cp)
c
c  compute isochoric (constant volume) and isobaric (constant pressure)
c  heat capacity as functions of temperature for a given component
c
c  analogous to CVCP, except for component icomp, this is used by transport
c  routines to calculate Cv & Cp for the reference fluid (component zero)
c
c  inputs:
c    icomp--component number in mixture (1..nc); 1 for pure fluid
c        t--temperature [K]
c      rho--molar density [mol/L]
c  outputs:
c       cv--isochoric heat capacity [J/mol-K]
c       cp--isobaric heat capacity [J/mol-K]
c
c  written by M. McLinden, NIST Physical & Chem Properties Div, Boulder, CO
c  06-16-97  MM, original version; based on CVCP
c  10-01-97  MM, add compiler switch to allow access by DLL
c  03-06-98  MM, check hmxeos, not heos, for 'BWR' (crash for icomp = 0)
c
cx DEC$ ATTRIBUTES DLLEXPORT :: CVCPK
c
      include 'commons.for'
c
      cv=0.d0
      cp=0.d0
      if (t.le.0.d0) return
      if (hmxeos(icomp).eq.'BWR') then
c  pure fluid MBWR equation of state--call BWR-specific routines
        if (rho.gt.1.0d-8) then
          cv=-t*D2ABWR(icomp,t,rho)+CP0K(icomp,t)-R
          cp=cv+t/rho**2*DPTBWR(icomp,t,rho)**2/DPDBWR(icomp,t,rho)
        else
          cp=CP0K(icomp,t)
          cv=cp-R
        end if
c
      else
c  call general PHIK or PHIX routines for all other models
        tau=tz(icomp)/t
        del=rho/rhoz(icomp)
        phi01=PHIK(icomp,0,1,tau,del)  !real-gas terms
        phi02=PHIK(icomp,0,2,tau,del)
        phi11=PHIK(icomp,1,1,tau,del)
        phi20=PHIK(icomp,2,0,tau,del)
c
        phig20=PHI0K(icomp,2,0,t,rho)  !ideal-gas term
        cv=-R*(phi20+phig20)
        cp=cv+R*(1.0d0+phi01-phi11)**2/(1.0d0+2.0d0*phi01+phi02)
      end if
c
      RETURN
      end                                              !subroutine CVCPK
c
c ======================================================================
c
      subroutine GIBBS (t,rho,x,Ar,Gr)
c
c  compute residual Helmholtz and Gibbs free energy as a function of
c  temperature, density, and composition using core functions
c
c  N.B.  The quantity calculated is
c
c        G(T,rho) - G0(T,P*) = G(T,rho) - G0(T,rho) + RTln(RTrho/P*)
c
c        where G0 is the ideal gas state and P* is a reference pressure
c        which is equal to the current pressure of interest.  Since Gr
c        is used only as a difference in phase equilibria calculations
c        where the temperature and pressure of the phases are equal, the
c        (RT/P*) part of the log term will cancel and is omitted.
c
c        "normal" (not residual) A and G are computed by subroutine AG
c
c  based on derivations in Younglove & McLinden, JPCRD 23 #5, 1994,
c  equations A8 - A12
c
c  inputs:
c        t--temperature [K]
c      rho--molar density [mol/L]
c        x--composition [array of mol frac]
c  outputs:
c       Ar--residual Helmholtz free energy [J/mol]
c       Gr--residual Gibbs free energy [J/mol]
c
c  written by M. McLinden, NIST Thermophysics Division, Boulder, Colorado
c  10-07-94  MM, original version
c  08-07-95  MM, add calls to Fundamental (Helmholtz) EOS
c  10-03-95  MM, change /MODEL/--models specified by strings
c  11-03-95  MM, add calls to mixture Helmholtz (HMX) model
c  11-29-95  MM, variable lower limit on coefficient/constant arrays
c                to accommodate ECS reference fluid
c  02-27-96  MM, parameter n0=-ncmax to accommodate ECS-thermo model
c                replace calls to PHIHMX, PHIFEQ with general PHIX, PHIK
c  03-22-96  MM, replace /MODEL/ with /EOSMOD/
c  10-01-97  MM, add compiler switch to allow access by DLL
c
cx DEC$ ATTRIBUTES DLLEXPORT :: GIBBS
c
      include 'commons.for'
      dimension x(ncmax)
c
      Ar=0.d0
      Gr=0.d0
      if (t.le.0.d0) return
      call RMIX (x)
      if (heos.eq.'BWR') then
c  pure fluid MBWR equation of state--call BWR-specific routines
        icomp=1
        Ar=ABWR(icomp,t,rho)
        Gr=Ar+PBWR(icomp,t,rho)/rho+R*t*(-1.0d0+log(rho))
c
      else
c  call general PHIK or PHIX routines for all other models
        call ISPURE (x,icomp)
        if (icomp.ne.0) then
c  pure fluid
          tau=tz(icomp)/t
          del=rho/rhoz(icomp)
          phi00=PHIK(icomp,0,0,tau,del)  !real-gas terms
          phi01=PHIK(icomp,0,1,tau,del)
        else
c  mixture
          call REDX (x,t0,rho0)
          tau=t0/t
          del=rho/rho0
          phi00=PHIX(0,0,tau,del,x)  !real-gas terms
          phi01=PHIX(0,1,tau,del,x)
        end if
c
        RT=R*t
        Ar=RT*phi00
        Gr=Ar+RT*(1.0d0+phi01)+RT*(-1.0d0+log(rho))
      end if
c
      RETURN
      end                                              !subroutine GIBBS
c
c ======================================================================
c
      subroutine AG (t,rho,x,a,g)
c
c  compute Helmholtz and Gibbs energies as a function of temperature,
c  density, and composition.
c
c  N.B.  These are not residual values (those are calculated by GIBBS).
c
c  inputs:
c        t--temperature [K]
c      rho--molar density [mol/L]
c        x--composition [array of mol frac]
c  outputs:
c        a--Helmholtz energy [J/mol]
c        g--Gibbs free energy [J/mol]
c
c  written by E.W. Lemmon, NIST Physical & Chem Properties Div, Boulder, CO
c   3-27-98 EWL, original version
c  12-02-98 EWL, reorganize code so to eliminate x(i) in pure fluid calculation
c
cx DEC$ ATTRIBUTES DLLEXPORT :: AG
c
      include 'commons.for'
      dimension x(ncmax)
c
      a=0.d0
      g=0.d0
      if (t.le.0.d0) return
      call RMIX (x)
      if (rho.lt.1.0d-40) then
c  calc will crash if rho = 0
        rhos=1.0d-40
      else
        rhos=rho
      end if
      if (heos.eq.'BWR') then
c  pure fluid MBWR equation of state--call BWR-specific routines
        icomp=1
        p=PBWR(icomp,t,rho)
        a=ABWR(icomp,t,rho)
        cpiint=CPI(t,x)
        cptint=CPT(t,x)
        a=a+cpiint-R*t-href(icomp)
     &   -t*(R*log(rhoref(icomp)/rhos)+cptint-R*log(t/tref(icomp))
     &    -sref(icomp))
        if (rho.gt.0.d0) then
          g=a+p/rho
        else
          g=a+R*t
        endif
c
      else
        RT=R*t
        phig00=PHI0(0,0,t,rhos,x)      !ideal-gas terms
c  call general PHIK or PHIX routines for all other models
        call ISPURE (x,icomp)
        if (icomp.ne.0) then
c  pure fluid
          tau=tz(icomp)/t
          del=rho/rhoz(icomp)
          phi00=PHIK(icomp,0,0,tau,del)  !real-gas terms
          phi01=PHIK(icomp,0,1,tau,del)
          a=RT*(phig00+phi00)-(href(icomp)-t*sref(icomp))
        else
c  mixture
          call REDX (x,t0,rho0)
          tau=t0/t
          del=rho/rho0
          phi00=PHIX(0,0,tau,del,x)   !real-gas terms
          phi01=PHIX(0,1,tau,del,x)
          a=RT*(phig00+phi00)
          do i=1,nc
            a=a-x(i)*(href(i)-t*sref(i))
          enddo
        end if
        g=a+RT*(1.0d0+phi01)
      end if
c
      RETURN
      end                                                 !subroutine AG
c
c ======================================================================
c
      subroutine PRESS (t,rho,x,p)
c
c  compute pressure as a function of temperature,
c  density, and composition using core functions
c
c  direct implementation of core function of corresponding model
c
c  inputs:
c        t--temperature [K]
c      rho--molar density [mol/L]
c        x--composition [array of mol frac]
c  output:
c        p--pressure [kPa]
c
c  written by M. McLinden, NIST Thermophysics Division, Boulder, Colorado
c  11-19-94  MM, original version
c  08-07-95  MM, add calls to Fundamental (Helmholtz) EOS
c  10-03-95  MM, change /MODEL/--models specified by strings
c  11-03-95  MM, add calls to mixture Helmholtz (HMX) model
c  11-29-95  MM, variable lower limit on coefficient/constant arrays
c                to accommodate ECS reference fluid
c  02-27-96  MM, parameter n0=-ncmax to accommodate ECS-thermo model
c                replace calls to PHIHMX, PHIFEQ with general PHIX, PHIK
c  03-22-96  MM, replace /MODEL/ with /EOSMOD/
c  10-01-97  MM, add compiler switch to allow access by DLL
c
cx DEC$ ATTRIBUTES DLLEXPORT :: PRESS
c
      include 'commons.for'
      dimension x(ncmax)
c
      p=0.d0
      if (t.le.0.d0) return
      call RMIX (x)
      if (heos.eq.'BWR') then
c  pure fluid MBWR equation of state--call BWR-specific routines
        icomp=1
        p=PBWR(icomp,t,rho)
c
      else
c  call general PHIK or PHIX routines for all other models
        call ISPURE (x,icomp)
        if (icomp.ne.0) then
c  pure fluid
          tau=tz(icomp)/t
          del=rho/rhoz(icomp)
          p=R*t*rho*(1.0d0+PHIK(icomp,0,1,tau,del))
        else
c  mixture
          call REDX (x,t0,rho0)
          tau=t0/t
          del=rho/rho0
          p=R*t*rho*(1.0d0+PHIX(0,1,tau,del,x))
        end if
      end if
c
      RETURN
      end                                              !subroutine PRESS
c
c ======================================================================
c
      subroutine DPDD (t,rho,x,dpdrho)
c
c  compute partial derivative of pressure w.r.t. density at constant
c  temperature as a function of temperature, density, and composition
c
c  inputs:
c        t--temperature [K]
c      rho--molar density [mol/L]
c        x--composition [array of mol frac]
c  output:
c   dpdrho--dP/drho [kPa-L/mol]
c
c  written by M. McLinden, NIST Thermophysics Division, Boulder, Colorado
c  04-23-95  MM, original version
c  08-07-95  MM, add calls to Fundamental (Helmholtz) EOS
c  10-03-95  MM, change /MODEL/--models specified by strings
c  11-03-95  MM, add calls to mixture Helmholtz (HMX) model
c  11-29-95  MM, variable lower limit on coefficient/constant arrays
c                to accommodate ECS reference fluid
c  02-27-96  MM, parameter n0=-ncmax to accommodate ECS-thermo model
c                replace calls to PHIHMX, PHIFEQ with general PHIX, PHIK
c  03-22-96  MM, replace /MODEL/ with /EOSMOD/
c  10-16-96  MM, change name from DPRHO to DPDD
c  10-01-97  MM, add compiler switch to allow access by DLL
c
cx DEC$ ATTRIBUTES DLLEXPORT :: DPDD
c
      include 'commons.for'
      dimension x(ncmax)
c
      dpdrho=0.d0
      if (t.le.0.d0) return
      call RMIX (x)
      if (heos.eq.'BWR') then
c  pure fluid MBWR equation of state--call BWR-specific routines
        icomp=1
        dpdrho=DPDBWR(icomp,t,rho)
c
      else
c  call general PHIK or PHIX routines for all other models
        call ISPURE (x,icomp)
        if (icomp.ne.0) then
c  pure fluid
          tau=tz(icomp)/t
          del=rho/rhoz(icomp)
          phi01=PHIK(icomp,0,1,tau,del)  !real-gas terms
          phi02=PHIK(icomp,0,2,tau,del)
        else
c  mixture
          call REDX (x,t0,rho0)
          tau=t0/t
          del=rho/rho0
          phi01=PHIX(0,1,tau,del,x)  !real-gas terms
          phi02=PHIX(0,2,tau,del,x)
        end if
        dpdrho=R*t*(1.0d0+2.0d0*phi01+phi02)
      end if
c
      RETURN
      end                                               !subroutine DPDD
c
c ======================================================================
c
      subroutine DPDDK (icomp,t,rho,dPdrho)
c
c  compute partial derivative of pressure w.r.t. density at constant
c  temperature as a function of temperature and density for a specified
c  component
c
c  analogous to DPDD, except for component icomp, this is used by transport
c  routines to calculate dP/dD for the reference fluid (component zero)
c
c  inputs:
c    icomp--component number in mixture (1..nc); 1 for pure fluid
c        t--temperature [K]
c      rho--molar density [mol/L]
c  output:
c   dPdrho--dP/drho [kPa-L/mol]
c
c  written by M. McLinden, NIST Physical & Chem Properties Div, Boulder, CO
c  06-16-97  MM, original version; based on DPDD
c  09-29-97  MM, if component uses MBWR, call DPDBWR
c  10-01-97  MM, add compiler switch to allow access by DLL
c
cx DEC$ ATTRIBUTES DLLEXPORT :: DPDDK
c
      include 'commons.for'
c
      dpdrho=0.d0
      if (t.le.0.d0) return
      if (hmxeos(icomp).eq.'BWR') then
c  pure fluid MBWR equation of state--call BWR-specific routines
        dpdrho=DPDBWR(icomp,t,rho)
c
      else
c  call general PHIK or PHIX routines for all other models
        tau=tz(icomp)/t
        del=rho/rhoz(icomp)
        phi01=PHIK(icomp,0,1,tau,del)  !real-gas terms
        phi02=PHIK(icomp,0,2,tau,del)
        dpdrho=R*t*(1.0d0+2.0d0*phi01+phi02)
      end if
c
      RETURN
      end                                              !subroutine DPDDK
c
c ======================================================================
c
      subroutine DPDD2 (t,rho,x,d2PdD2)
c
c  compute second partial derivative of pressure w.r.t. density at const
c  temperature as a function of temperature, density, and composition
c
c  inputs:
c        t--temperature [K]
c      rho--molar density [mol/L]
c        x--composition [array of mol frac]
c  output:
c   d2pdD2--d^2P/drho^2 [kPa-L^2/mol^2]
c
c  written by E.W. Lemmon, NIST Physical & Chem Properties Div, Boulder, CO
c  06-03-97 EWL, original version
c  10-01-97  MM, add compiler switch to allow access by DLL
c  02-11-99 EWL, skip calculation of d2PdD2 if rho=0
c  09-05-02 EWL, add ideal gas d2PdD2
c
cx DEC$ ATTRIBUTES DLLEXPORT :: DPDD2
c
      include 'commons.for'
      dimension x(ncmax)
c
      d2PdD2=0.d0
      if (t.le.0.d0) return
      call RMIX (x)
      if (heos.eq.'BWR') then
c  pure fluid MBWR equation of state--call BWR-specific routines
        icomp=1
        d2PdD2=D2PBWR(icomp,t,rho)
c
      else
c  call general PHIK or PHIX routines for all other models
        call ISPURE (x,icomp)
        if (icomp.ne.0) then
c  pure fluid
          tau=tz(icomp)/t
          del=rho/rhoz(icomp)
          phi01=PHIK(icomp,0,1,tau,del)  !real-gas terms
          phi02=PHIK(icomp,0,2,tau,del)
          phi03=PHIK(icomp,0,3,tau,del)
        else
c  mixture
          call REDX (x,t0,rho0)
          tau=t0/t
          del=rho/rho0
          phi01=PHIX(0,1,tau,del,x)  !real-gas terms
          phi02=PHIX(0,2,tau,del,x)
          phi03=PHIX(0,3,tau,del,x)
        end if
        if (rho.gt.1.0d-8) then
          d2PdD2=R*t/rho*(2.0d0*phi01+4.0d0*phi02+phi03)
        else
          call VIRB (t,x,b)
          d2PdD2=2.d0*b*R*t
        end if
      end if
c
      RETURN
      end                                              !subroutine DPDD2
c
c ======================================================================
c
      subroutine DPDT (t,rho,x,dpt)
c
c  compute partial derivative of pressure w.r.t. temperature at constant
c  density as a function of temperature, density, and composition
c
c  inputs:
c        t--temperature [K]
c      rho--molar density [mol/L]
c        x--composition [array of mol frac]
c  output:
c      dpt--dP/dT [kPa/K]
c
c  written by M. McLinden, NIST Thermophysics Division, Boulder, Colorado
c  10-16-96  MM, original version, based on DPDD
c  10-28-96  MM, insert missing rho into form using PHI's
c  10-01-97  MM, add compiler switch to allow access by DLL
c
cx DEC$ ATTRIBUTES DLLEXPORT :: DPDT
c
      include 'commons.for'
      dimension x(ncmax)
c
      dpt=0.d0
      if (t.le.0.d0) return
      call RMIX (x)
      if (heos.eq.'BWR') then
c  pure fluid MBWR equation of state--call BWR-specific routines
        icomp=1
        dpt=DPTBWR(icomp,t,rho)
c
      else
c  call general PHIK or PHIX routines for all other models
        call ISPURE (x,icomp)
        if (icomp.ne.0) then
c  pure fluid
          tau=tz(icomp)/t
          del=rho/rhoz(icomp)
          phi01=PHIK(icomp,0,1,tau,del)  !real-gas terms
          phi11=PHIK(icomp,1,1,tau,del)
        else
c  mixture
          call REDX (x,t0,rho0)
          tau=t0/t
          del=rho/rho0
          phi01=PHIX(0,1,tau,del,x)  !real-gas terms
          phi11=PHIX(1,1,tau,del,x)
        end if
        dpt=R*rho*(1.0d0+phi01-phi11)
      end if
c
      RETURN
      end                                               !subroutine DPDT
c
c ======================================================================
c
      subroutine DPDTK (icomp,t,rho,dpt)
c
c  compute partial derivative of pressure w.r.t. temperature at constant
c  density as a function of temperature and density for a specified component
c
c  analogous to DPDT, except for component icomp, this is used by transport
c  routines to calculate dP/dT
c
c  inputs:
c    icomp--component number in mixture (1..nc); 1 for pure fluid
c        t--temperature [K]
c      rho--molar density [mol/L]
c  output:
c      dpt--dP/dT [kPa/K]
c
c  written by E.W. Lemmon, NIST Thermophysics Division, Boulder, Colorado
c  07-07-98 EWL, original version, based on DPDT
c
cx DEC$ ATTRIBUTES DLLEXPORT :: DPDTK
c
      include 'commons.for'
c
      dpt=0.d0
      if (t.le.0.d0) return
      if (hmxeos(icomp).eq.'BWR') then
c  pure fluid MBWR equation of state--call BWR-specific routines
        dpt=DPTBWR(icomp,t,rho)
c
      else
c  call general PHIK or PHIX routines for all other models
        tau=tz(icomp)/t
        del=rho/rhoz(icomp)
        phi01=PHIK(icomp,0,1,tau,del)  !real-gas terms
        phi11=PHIK(icomp,1,1,tau,del)
        dpt=R*rho*(1.0d0+phi01-phi11)
      end if
c
      RETURN
      end                                              !subroutine DPDTK
c
c ======================================================================
c
      subroutine DDDP (t,rho,x,drhodp)
c
c  compute partial derivative of density w.r.t. pressure at constant
c  temperature as a function of temperature, density, and composition
c
c  inputs:
c        t--temperature [K]
c      rho--molar density [mol/L]
c        x--composition [array of mol frac]
c  output:
c   drhodp--drho/dP [mol/(L-kPa)]
c
c  written by M. McLinden, NIST Phys & Chem Properties Div, Boulder, CO
c  08-29-97  MM, original version, based on DPDD (just the inverse)
c  10-01-97  MM, add compiler switch to allow access by DLL
c
cx DEC$ ATTRIBUTES DLLEXPORT :: DDDP
c
      include 'commons.for'
      dimension x(ncmax)
c
      drhodp=0.d0
      if (t.le.0.d0) return
      call RMIX (x)
      if (heos.eq.'BWR') then
c  pure fluid MBWR equation of state--call BWR-specific routines
        icomp=1
        drhodp=1.0d0/DPDBWR(icomp,t,rho)
c
      else
c  call general PHIK or PHIX routines for all other models
        call ISPURE (x,icomp)
        if (icomp.ne.0) then
c  pure fluid
          tau=tz(icomp)/t
          del=rho/rhoz(icomp)
          phi01=PHIK(icomp,0,1,tau,del)  !real-gas terms
          phi02=PHIK(icomp,0,2,tau,del)
        else
c  mixture
          call REDX (x,t0,rho0)
          tau=t0/t
          del=rho/rho0
          phi01=PHIX(0,1,tau,del,x)  !real-gas terms
          phi02=PHIX(0,2,tau,del,x)
        end if
        drhodp=1.0d0/(R*t*(1.0d0+2.0d0*phi01+phi02))
      end if
c
      RETURN
      end                                               !subroutine DDDP
c
c ======================================================================
c
      subroutine DDDT (t,rho,x,drhodt)
c
c  compute partial derivative of density w.r.t. temperature at constant
c  pressure as a function of temperature, density, and composition
c
c  inputs:
c        t--temperature [K]
c      rho--molar density [mol/L]
c        x--composition [array of mol frac]
c  output:
c   drhodt--drho/dT [mol/(L-K)]
c
c   d(rho)/d(T) = -d(rho)/dP x dP/dT = -dP/dT / (dP/d(rho))
c
c  written by M. McLinden, NIST Phys & Chem Properties Div, Boulder, CO
c  08-29-97  MM, original version, based on DPDD and DPDT
c  10-01-97  MM, add compiler switch to allow access by DLL
c
cx DEC$ ATTRIBUTES DLLEXPORT :: DDDT
c
      include 'commons.for'
      dimension x(ncmax)
c
      drhodt=0.d0
      if (t.le.0.d0) return
      call RMIX (x)
      if (heos.eq.'BWR') then
c  pure fluid MBWR equation of state--call BWR-specific routines
        icomp=1
        drhodt=-DPTBWR(icomp,t,rho)/DPDBWR(icomp,t,rho)
c
      else
c  call general PHIK or PHIX routines for all other models
        call ISPURE (x,icomp)
        if (icomp.ne.0) then
c  pure fluid
          tau=tz(icomp)/t
          del=rho/rhoz(icomp)
          phi01=PHIK(icomp,0,1,tau,del)  !real-gas terms
          phi11=PHIK(icomp,1,1,tau,del)
          phi02=PHIK(icomp,0,2,tau,del)
        else
c  mixture
          call REDX (x,t0,rho0)
          tau=t0/t
          del=rho/rho0
          phi01=PHIX(0,1,tau,del,x)  !real-gas terms
          phi11=PHIX(1,1,tau,del,x)
          phi02=PHIX(0,2,tau,del,x)
        end if
        drhodt=-rho*(1.0d0+phi01-phi11)/(t*(1.0d0+2.0d0*phi01+phi02))
      end if
c
      RETURN
      end                                               !subroutine DDDT
c
c ======================================================================
c
      subroutine DERVPVT (t,rho,x,
     &                    dPdD,dPdT,d2PdD2,d2PdT2,d2PdTD,
     &                    dDdP,dDdT,d2DdP2,d2DdT2,d2DdPT,
     &                    dTdP,dTdD,d2TdP2,d2TdD2,d2TdPD)
c
c  compute derivatives of temperature, pressure, and density
c  using core functions for Helmholtz free energy equations only
c
c  inputs:
c        t--temperature [K]
c      rho--molar density [mol/L]
c        x--composition [array of mol frac]
c  outputs:
c     dPdD--derivative dP/drho [kPa-L/mol]
c     dPdT--derivative dP/dT [kPa/K]
c     dDdP--derivative drho/dP [mol/(L-kPa)]
c     dDdT--derivative drho/dT [mol/(L-K)]
c     dTdP--derivative dT/dP [K/kPa]
c     dTdD--derivative dT/drho [(L-K)/mol]
c   d2PdD2--derivative d^2P/drho^2 [kPa-L^2/mol^2]
c   d2PdT2--derivative d2P/dT2 [kPa/K^2]
c   d2PdTD--derivative d2P/dTd(rho) [J/mol-K]
c
c  written by E.W. Lemmon, NIST Physical & Chem Properties Div, Boulder, CO
c  08-21-12 EWL, original version; based on THERM2
c
cx DEC$ ATTRIBUTES DLLEXPORT :: DERVPVT
c
      include 'commons.for'
      dimension x(ncmax)
c
      if (t.le.0.d0) return
      call RMIX (x)
      RT=R*t
c
c  call general PHIX routines
      call REDX (x,t0,rho0)
      tau=t0/t
      del=rho/rho0
c     phi00=PHIX(0,0,tau,del,x)   !real-gas terms
      phi01=PHIX(0,1,tau,del,x)
c     phi10=PHIX(1,0,tau,del,x)
      phi11=PHIX(1,1,tau,del,x)
      phi12=PHIX(1,2,tau,del,x)
      phi21=PHIX(2,1,tau,del,x)
c     phi20=PHIX(2,0,tau,del,x)
      phi02=PHIX(0,2,tau,del,x)
      phi03=PHIX(0,3,tau,del,x)
c
      u    = 1.d0+phi01-phi11
      dut  = phi21
      dud  = phi01+phi02-phi11-phi12
c
      v    = 1.d0+2.d0*phi01+phi02
      dvt  =-2.d0*phi11-phi12
      dvd  = 2.d0*phi01+4.d0*phi02+phi03
c
      dPdD    = RT*v
      dPdT    = R*rho*u
      dDdT    =-rho*u/(t*v)
      dDdP    = 1.d0/dPdD
      d2PdT2  = R*rho*dut/t
      d2PdTD  = R*(v+dvt)
      d2DdPT  =-(v+dvt-u/v*dvd)/t/RT/v**2
      d2DdT2  = rho*u/v**2/t**2*(u+v-u/v*dvd+dvt+dud-v/u*dut)
c
      if (rho.gt.1.0d-8) then
        dTdP    = 1.d0/dPdT
        dTdD    = 1.d0/dDdT
        d2PdD2  = RT/rho*dvd
        d2DdP2  =-dvd/v**3/rho/RT**2
        d2TdP2  =-dut/(R*rho)**2/t/u**3
        d2TdD2  = t*v/rho**2/u**2*(u+v-u/v*dvd+dvt+dud-v/u*dut)
        d2TdPD  =-(u+dud-v/u*dut)/r/rho**2/u**2
      else
        call VIRB (t,x,b)
        d2PdD2 = 2.d0*b*R*t
        d2DdP2 =-2.d0*b/RT**2
        dTdP   = xinf
        dTdD   = xinf
        d2TdP2 = xinf
        d2TdD2 = xinf
        d2TdPD = xinf
      end if
c
      RETURN
      end                                            !subroutine DERVPVT
c
c ======================================================================
c
      subroutine DHD1(t,rho,x,dhdt_d,dhdt_p,dhdd_t,dhdd_p,dhdp_t,dhdp_d)
c
c  compute partial derivatives of enthalpy w.r.t. t, p, or rho at constant
c  t, p, or rho as a function of temperature, density, and composition
c
c  inputs:
c        t--temperature [K]
c      rho--molar density [mol/L]
c        x--composition [array of mol frac]
c  outputs:
c   dhdt_d--dH/dT at constant density [J/(mol-K)]
c   dhdt_p--dH/dT at constant pressure [J/(mol-K)]
c   dhdd_t--dH/drho at constant temperature [(J/mol)/(mol/L)]
c   dhdd_p--dH/drho at constant pressure [(J/mol)/(mol/L)]
c   dhdp_t--dH/dP at constant temperature [J/(mol-kPa)]
c   dhdp_d--dH/dP at constant density [J/(mol-kPa)]
c
c  written by E.W. Lemmon, NIST Thermophysics Division, Boulder, Colorado
c  10-02-00 EWL, original version
c  05-30-06 EWL, change subroutine name from DHDT to DHD1, and add other
c                derivates of h with respect to t, p, or rho
c
cx DEC$ ATTRIBUTES DLLEXPORT :: DHD1
c
      include 'commons.for'
      dimension x(ncmax)
c
      dhdt_d=0.d0
      dhdt_p=0.d0
      dhdd_t=0.d0
      dhdd_p=0.d0
      dhdp_t=0.d0
      dhdp_d=0.d0
      if (t.le.0.d0) return
      call RMIX (x)
      rhos=rho
      if (rho.lt.1.0d-10) rhos=1.0d-10
      if (heos.eq.'BWR') then
c  pure fluid MBWR equation of state--call BWR-specific routines
        icomp=1
        tau=tz(icomp)/t
        del=rho/rhoz(icomp)
        phi01=PHIBWR(icomp,0,1,tau,del)  !real-gas terms
        phi11=PHIBWR(icomp,1,1,tau,del)
        phi20=PHIBWR(icomp,2,0,tau,del)
        phi02=PHIBWR(icomp,0,2,tau,del)
c
      else
c  call general PHIK or PHIX routines for all other models
        call ISPURE (x,icomp)
        if (icomp.ne.0) then
c  pure fluid
          tau=tz(icomp)/t
          del=rho/rhoz(icomp)
          phi01=PHIK(icomp,0,1,tau,del)  !real-gas terms
          phi11=PHIK(icomp,1,1,tau,del)
          phi20=PHIK(icomp,2,0,tau,del)
          phi02=PHIK(icomp,0,2,tau,del)
        else
c  mixture
          call REDX (x,t0,rho0)
          tau=t0/t
          del=rho/rho0
          phi01=PHIX(0,1,tau,del,x)  !real-gas terms
          phi11=PHIX(1,1,tau,del,x)
          phi20=PHIX(2,0,tau,del,x)
          phi02=PHIX(0,2,tau,del,x)
        end if
      end if
      phig20=PHI0(2,0,t,rho,x)
      phig11=PHI0(1,1,t,rho,x)
      call THERM2 (t,rhos,x,p,e,h,s,cv,cp,w,Z,hjt,A,G,xkappa,beta,
     &      dPdrho,d2PdD2,dPT,drhodT,drhodP,d2PT2,d2PdTD,spare3,spare4)
      dhdt_p=cp
      dhdt_d=R*(-phig20-phi20+phi01-phi11+1.d0)
      if (rho.gt.1.0d-8) then
        dhdp_t=1.d0/rho+t*drhodT/rho**2
        dhdd_t=R*T/rho*(phig11+phi11+phi01+phi02)
        dhdp_d=dhdp_t+dhdt_p/dPT
        dhdd_p=dhdd_t+dhdt_d/drhodT
      else
        call VIRB (t,x,b)
        call DBDT (t,x,dbt)
        dhdp_t=1.d0/rhos+t*drhodT/rhos**2
        dhdd_t=-r*t**2*dbt+r*t*b
        dhdp_d=xinf
        dhdd_p=xinf
      endif
c
      RETURN
      end                                               !subroutine DHD1
c
c ======================================================================
c
      subroutine FGCTY2 (t,rho,x,f,ierr,herr)
c
c  compute fugacity for each of the nc components of a mixture by
c  analytical differentiation of the dimensionless residual Helmholtz energy
c
c  based on derivations in the GERG-2004 document for natural gas
c
c  inputs:
c        t--temperature [K]
c      rho--molar density [mol/L]
c        x--composition [array of mol frac]
c  outputs:
c        f--array (1..nc) of fugacities [kPa]
c
c  written by E.W. Lemmon, NIST Thermophysics Division, Boulder, Colorado
c  02-22-10 EWL, original version
c
cx DEC$ ATTRIBUTES DLLEXPORT :: FGCTY2
c
      include 'commons.for'
      dimension x(ncmax),f(ncmax)
      dimension dadn(ncmax),dnadn(ncmax)
      character*255 herr
c
      ierr=0
      herr=' '
      call ISPURE (x,icomp)
      call RMIX (x)
      do i=1,nc
        f(i)=0.0d0
      enddo
      if (t.le.0.d0 .or. rho.lt.1.0d-40) RETURN
      if (icomp.ne.0) goto 10  !Call old FGCTY routine for pure fluids
c
      RTrho=R*t*rho
      call PHIDERV (1,t,rho,x,dadn,dnadn,ierr,herr)
      if (ierr.ne.0) goto 10
      do i=1,nc
        f(i)=xerr
        if (ABS(dnadn(i)).lt.100.0d0) f(i)=x(i)*RTrho*exp(dnadn(i))
      enddo
      RETURN
c
 10   continue
      call FGCTY (t,rho,x,f)
      ierr=0
      herr=' '
      RETURN
      end                                             !subroutine FGCTY2
c
c ======================================================================
c
      subroutine PHIDERV (iderv,t,rho,x,dadn,dnadn,ierr,herr)
c
c  calculate various derivatives needed for VLE determination
c  based on derivations in the GERG-2004 document for natural gas
c
c  inputs:
c        iderv--set to 1 for first order derivatives only (dadn and dnadn)
c               set to 2 for full calculations
c        t--temperature (K)
c      rho--density (mol/L)
c        x--composition [array of mol frac]
c
c  outputs: (where n is mole number)
c           (the listed equation numbers are those in the GERG manuscript)
c    dnadn--partial(n*alphar)/partial(ni)                   Eq. 7.15
c     dadn--n*partial(alphar)/partial(ni)                   Eq. 7.16
c    daddn--del*n*par.(par.(alphar)/par.(del))/par.(ni)     Eq. 7.17
c     dvdn--n*[partial(Vred)/partial(ni)]/Vred              Eq. 7.18
c           (=-n*[partial(Dred)/partial(ni)]/Dred)
c     dtdn--n*[partial(Tred)/partial(ni)]/Tred              Eq. 7.19
c    dadxi--partial(alphar)/partial(xi)                     Eq. 7.21g
c   sdadxi--sum[xi*partial(alphar)/partial(xi)]             Eq. 7.21g
c   dadxij--partial^2(alphar)/partial(xi)/partial(xj)       Eq. 7.21i
c    daddx--del*partial^2(alphar)/partial(xi)/partial(del)  Eq. 7.21j
c    dadtx--tau*partial^2(alphar)/partial(xi)/partial(tau)  Eq. 7.21k
c   dphidT--par.(ln(phi))/par.(T) (constant p,n,x)          Eq. 7.29
c   dphidp--par.(ln(phi))/par.(p) (constant T,n,x)          Eq. 7.30
c  dphidnj--n*par.[ln(phi(i))]/par(nj) (constant T,p)       Eq. 7.31
c  dlnfinidT--par.[ln(fi/ni)]/par(T)                        Eq. 7.36
c  dlnfinidV--n*par.[ln(fi/ni)]/par(V)                      Eq. 7.37
c   d2adbn--    par.[par.(n*alphar)/par.(ni)]/par.(T)       Eq. 7.44
c   d2adnn--n*partial^2(n*alphar)/partial(ni)/partial(nj)   Eq. 7.46 and 7.47 (similar to 7.38)
c   d2addn--del*par.[n*par.(alphar)/par.(ni)]/par.(del)     Eq. 7.50
c   d2adtn--tau*par.[n*par.(alphar)/par.(ni)]/par.(tau)     Eq. 7.51
c   d2adxn--    par.[n*par.(alphar)/par.(ni)]/par.(xj)      Eq. 7.52
c   ddrdxn--par.[n*par.(Dred)/par.(ni)]/par.(xj)            Eq. 7.55
c   dtrdxn--par.[n*par.(Tred)/par.(ni)]/par.(xj)            Eq. 7.56
c     dpdn--n*partial(p)/partial(ni)                        Eq. 7.63 constant T,V,nj
c    dpdxi--partial(p)/partial(xi)                          constant T,V
c d2adxnTV--par.[n*par.(alphar)/par.(ni)]/par.(xj)          constant T,V
c  dadxiTV--partial(alphar)/partial(xi)                     constant T,V
c daddxiTV--del*partial^2(alphar)/partial(xi)/partial(del)  constant T,V
c  dphidxj--par.(ln(phi))/par.(xj)                          constant T,p,x
c    xlnfi--Log of modified fugacity
c
c  written by E.W. Lemmon, NIST Thermophysics Division, Boulder, Colorado
c  02-22-10 EWL, original version
c  12-09-12 EWL, fix equations for dlnfinidT and dlnfinidV
c
      include 'commons.for'
      dimension x(ncmax)
      character*255 herr
      dimension dadn(ncmax),dnadn(ncmax),
     &          aok(ncmax),aok01(ncmax),aok10(ncmax),
     &          sdadxi(ncmax),sdaddxi(ncmax),sdadtxi(ncmax),
     &          tr01(ncmax),dr01(ncmax),sdadxx(ncmax),
     &          phimxk(ncmax,ncmax),
     &          phimxk01(ncmax,ncmax),phimxk10(ncmax,ncmax),
     &          dr11(ncmax,ncmax),tr11(ncmax,ncmax)
c
      ierr=0
      herr=' '
      call RMIX (x)
      call REDX (x,t0,rho0)
      tau=t0/t
      del=rho/rho0
      Rt=R*t

      do i=1,nc
        dadn(i)=0.d0
        dnadn(i)=0.d0
        daddn(i)=0.d0
        d2addn(i)=0.d0
        d2adtn(i)=0.d0
        daddx(i)=0.d0
        dadtx(i)=0.d0
        dtdn(i)=0.d0
        dvdn(i)=0.d0
        dadxi(i)=0.d0
        aok(i)=0.d0
        aok01(i)=0.d0
        aok10(i)=0.d0
        sdadxi(i)=0.d0
        sdaddxi(i)=0.d0
        sdadtxi(i)=0.d0
        tr01(i)=0.d0
        dr01(i)=0.d0
        dpdn(i)=0.d0
        sdadxx(i)=0.d0
        do j=1,nc
          d2adnn(i,j)=0.d0
          ddrdxn(i,j)=0.d0
          dtrdxn(i,j)=0.d0
          d2adxn(i,j)=0.d0
          dadxij(i,j)=0.d0     !if i=j, derivative=0
        enddo
      enddo

      if (heos.eq.'PR') then
c       call FGCTY (t,rho,x,dnadn)
        dummy=PHIPRX (-1,0,tau,del,x)
        dnadn(1:nc)=daddn(1:nc)   !dnadn is temporarily stored in daddn
        daddn(1:nc)=0.d0
        ierr=0
        if (dummy.ne.-1.d0) ierr=1
        RETURN
      endif
c
c  get Helmholtz energy of pure fluid
      ar  =PHIX(0,0,tau,del,x)
      ar01=PHIX(0,1,tau,del,x)
      ar10=PHIX(1,0,tau,del,x)
      if (ar01.le.-1.d0) then
        ierr=1
        return
      endif

      do i=1,nc
        phimxk(i,i)=0.d0
        if (x(i).gt.0.d0) then
          call RDXHMX (1,i,0,x,tr01(i),dr01(i),ierr,herr)
          if (ierr.ne.0) RETURN
          aok(i)=PHIK(i,0,0,tau,del)
          if (i.ne.nc) then
            do j=i+1,nc
              if (x(j).gt.0.d0) then
                phimxk(i,j)=PHIMIX(i,j,0,0,tau,del,x)
                phimxk(j,i)=phimxk(i,j)
              endif
            enddo
          endif
        endif
      enddo
c
c  calculate first order derivatives only
      if (iderv.eq.1) then
        do i=1,nc
          if (x(i).gt.0.d0) then
          do j=1,nc
            if (x(j).gt.0.d0) then
c  get derivatives of reducing parameters
              dtdn(i)=dtdn(i)-x(j)*tr01(j)
              dvdn(i)=dvdn(i)-x(j)*dr01(j)
              sdadxi(i)=sdadxi(i)+x(j)*aok(j)
              if (i.eq.j) then
                dtdn(i)=dtdn(i)+tr01(j)
                dvdn(i)=dvdn(i)+dr01(j)
                dadxi(i)=dadxi(i)+aok(j)
              else
c  add excess Helmholtz energy of i-j interaction
                dadxi(i)=dadxi(i)+phimxk(i,j)/x(i)
              endif
              if (j.ne.nc) then
                do k=j+1,nc
c  subtract excess Helmholtz energy of i-j interaction twice (to include j-i)
                  if (x(k).ne.0.d0) sdadxi(i)=sdadxi(i)+phimxk(k,j)*2.d0
                enddo
              endif
            endif
          enddo
          endif
        enddo
c
c  *** do this only while testing numerical derivatives!!! ***
c       call RDXHMX (-1,0,0,x,t0,rho0,ierr,herr)

        do i=1,nc
          if (x(i).gt.0) then
            dtdn(i)=dtdn(i)/t0
            dvdn(i)=dvdn(i)*rho0
            dadn(i)=ar01*(1.d0+dvdn(i))+ar10*dtdn(i)+dadxi(i)-sdadxi(i)   !Eq. 7.16 in GERG
            dnadn(i)=ar+dadn(i)                                           !Eq. 7.15
          endif
        enddo
c
c  calculate first and second order derivatives
      else
        ar02=PHIX(0,2,tau,del,x)
        ar20=PHIX(2,0,tau,del,x)
        ar11=PHIX(1,1,tau,del,x)
        call PRESS (t,rho,x,p)
        call DPDT (t,rho,x,dPT)
        call DPDD (t,rho,x,dpdrho)
        call DDDT (t,rho,x,drhodt)  !Only needed for 7.66
        dPdV=-dpdrho*rho**2
        if (p.eq.0.d0) p=1.d-20
        if (dPdV.eq.0.d0) dPdV=1.d-20
        dVdT=0.d0
        if (rho.ne.0.d0) dVdT=-drhodt/rho**2
c       if (dpdrho.lt.0 .or. dPT.lt.0) then
c         ierr=1
c         return
c       endif

        do i=1,nc
          phimxk01(i,i)=0.d0
          phimxk10(i,i)=0.d0
          if (x(i).gt.0.d0) then
            aok01(i)=PHIK(i,0,1,tau,del)
            aok10(i)=PHIK(i,1,0,tau,del)
            if (i.ne.nc) then
              do j=i+1,nc
                if (x(j).gt.0.d0) then
                  phimxk01(i,j)=PHIMIX(i,j,0,1,tau,del,x)
                  phimxk10(i,j)=PHIMIX(i,j,1,0,tau,del,x)
                  phimxk01(j,i)=phimxk01(i,j)
                  phimxk10(j,i)=phimxk10(i,j)
                endif
              enddo
            endif
            do j=1,nc
              if (x(j).gt.0.d0) then
                ij=11
                if (i.eq.j) ij=2
                call RDXHMX (ij,i,j,x,tr11(i,j),dr11(i,j),ierr,herr)
                dr11(i,j)=2*rho0**3*dr01(j)*dr01(i)-rho0**2*dr11(i,j)
                if (ierr.ne.0) RETURN
              endif
            enddo
          endif
        enddo

        do j=1,nc
          if (x(j).gt.0.d0) then
            do i=1,nc
              if (x(i).gt.0.d0) then
                ddrdxn(i,j)= dr01(j)*rho0**2                              !Eq. 7.55
                dtrdxn(i,j)=-tr01(j)                                      !Eq. 7.56
                do k=1,nc
                  if (x(k).gt.0.d0) then
                    ddrdxn(i,j)=ddrdxn(i,j)-x(k)*dr11(k,j)
                    dtrdxn(i,j)=dtrdxn(i,j)-x(k)*tr11(k,j)
                    if (i.eq.k) then
                      ddrdxn(i,j)=ddrdxn(i,j)+dr11(k,j)
                      dtrdxn(i,j)=dtrdxn(i,j)+tr11(k,j)
                    endif
                  endif
                enddo
              endif
            enddo
          endif
        enddo

        do i=1,nc
        if (x(i).gt.0.d0) then
        do j=1,nc
          if (x(j).gt.0.d0) then
            dtdn(i)=dtdn(i)-x(j)*tr01(j)
            dvdn(i)=dvdn(i)-x(j)*dr01(j)
            sdadxi(i)=sdadxi(i)+x(j)*aok(j)
            sdaddxi(i)=sdaddxi(i)+x(j)*aok01(j)
            sdadtxi(i)=sdadtxi(i)+x(j)*aok10(j)
            if (i.eq.j) then
              daddx(i)=daddx(i)+aok01(j)
              dadtx(i)=dadtx(i)+aok10(j)
              dtdn(i)=dtdn(i)+tr01(j)
              dvdn(i)=dvdn(i)+dr01(j)
              dadxi(i)=dadxi(i)+aok(j)
            endif
c  add excess Helmholtz energy of i-j interaction
            dadxi(i)=dadxi(i)+phimxk(i,j)/x(i)
            daddx(i)=daddx(i)+phimxk01(i,j)/x(i)
            dadtx(i)=dadtx(i)+phimxk10(i,j)/x(i)
            if (j.ne.nc) then
              do k=j+1,nc
c  subtract excess Helmholtz energy of i-j interaction twice (to include j-i)
              if (x(k).gt.0.d0) then
                sdadxi(i) =sdadxi(i) +phimxk(k,j)*2.d0
                sdaddxi(i)=sdaddxi(i)+phimxk01(k,j)*2.d0
                sdadtxi(i)=sdadtxi(i)+phimxk10(k,j)*2.d0
              endif
              enddo
            endif
          endif
        enddo
        dtdn(i)=dtdn(i)/t0
        dvdn(i)=dvdn(i)*rho0
        endif
        enddo
c
        do i=1,nc
          if (x(i).gt.0.d0) then
            dvdn1=1.d0+dvdn(i)
            dadn(i)=ar01*dvdn1+ar10*dtdn(i)+dadxi(i)-sdadxi(i)            !Eq. 7.16 in GERG
            daddn(i)=ar02*dvdn1+ar11*dtdn(i)+daddx(i)-sdaddxi(i)          !Eq. 7.17
            dnadn(i)=ar+dadn(i)                                           !Eq. 7.15
            d2addn(i)=(ar01+ar02)*dvdn1+ar11*dtdn(i)+daddx(i)-sdaddxi(i)  !Eq. 7.50
            d2adtn(i)=ar11*dvdn1+(ar10+ar20)*dtdn(i)+dadtx(i)-sdadtxi(i)  !Eq. 7.51
            d2adbn(i)=-1.d0/T*(ar10+d2adtn(i))                            !Eq. 7.44
            xlnfi(i)=dlog(x(i)/(1.d0+ar01))+dnadn(i)                      !Log of modified fugacity
            dlnfinidT(i)=(1.d0-ar10-d2adtn(i))/T                          !Eq. 7.36 with use of 7.44
            dlnfinidV(i)=-rho*(1.d0+ar01+d2addn(i))                       !Eq. 7.37 with use of 7.45 (this is really n*Eq7.37)
          endif
        enddo

        do i=1,nc
          if (x(i).gt.0.d0) then
            daddnk=ar02*(1.d0+dvdn(i))+ar11*dtdn(i)+daddx(i)-sdaddxi(i)   !Eq. 7.17
            dpdn(i)=rho*Rt*(1.d0+ar01*(2.d0+dvdn(i))+daddnk)              !Eq. 7.63 in GERG
            dadxiTV(i)=ar01*rho0*dr01(i)+ar10/t0*tr01(i)+dadxi(i)         !par(ar)/par(xi) at constant T and V
            daddxiTV(i)=ar02*rho0*dr01(i)+ar11/t0*tr01(i)+daddx(i)        !par^2(ar)/par(xi)/par(del) at constant T and V
            dpdxi(i)=rho*Rt*(dr01(i)*rho0*ar01+daddxiTV(i))               !d(P)/d(xi) at constant T and V
            vrt=-dpdn(i)/dpdv/rt                                          !Eq. 7.32 divided by RT
            dphidT(i)=d2adbn(i)+1.d0/t-vrt*dpt                            !Eq. 7.29  d(ln(phi))/dT at constant p and x (or n)
            dphidp(i)=vrt-1.d0/p                                          !Eq. 7.30  d(ln(phi))/dP at constant T and x (or n)
            dmurdt(i)=r*dnadn(i)+rt*d2adbn(i)-dpdn(i)*dvdt                 !Eq. 7.66 without the ideal gas part
          endif
        enddo
        do j=1,nc
          if (x(j).gt.0.d0) then
            do i=1,nc
              if (x(i).gt.0.d0) then
                dadxij(i,j)=phimxk(i,j)/x(j)/x(i)
                sdadxx(j)=sdadxx(j)+x(i)*dadxij(i,j)
              endif
            enddo
          endif
        enddo
        do i=1,nc
          if (x(i).gt.0.d0) then
            do j=1,nc
              if (x(j).gt.0.d0) then
              d2adxn(i,j)=daddx(j)*(1.d0+dvdn(i))                         !Eq. 7.52
     &                 -ar01/rho0*(ddrdxn(i,j)-rho0**2*dr01(j)*dvdn(i))
     &                 +dadtx(j)*dtdn(i)
     &                 +ar10/t0*(dtrdxn(i,j)-tr01(j)*dtdn(i))
     &                 +dadxij(i,j)-dadxi(j)-sdadxx(j)
              d2adxnTV(j,i)=d2addn(i)*rho0*dr01(j)                        !d^2(n*ar)/dxj/dni at constant T and V
     &                 +d2adtn(i)/t0*tr01(j)+d2adxn(i,j)+dadxiTV(j)
              endif
            enddo
          endif
        enddo
        do i=1,nc
          if (x(i).gt.0.d0) then
          do j=1,nc
            if (x(j).gt.0.d0) then
              sd2adxn=0.d0
              do k=1,nc
                sd2adxn=sd2adxn+x(k)*d2adxn(i,k)
              enddo
              !Eq. 7.38 times n is the same as Eq. 7.46 (d2adnn)
              d2adnn(i,j)=dadn(j)+d2addn(i)*(1.d0+dvdn(j))                !Eq. 7.46
     &                   +d2adtn(i)*dtdn(j)+d2adxn(i,j)-sd2adxn
              dphidnj(i,j)=d2adnn(i,j)+1.d0+dpdn(j)*dpdn(i)/dpdv/Rt       !Eq. 7.31
              dlnphiidxj(i,j)=d2adxnTV(i,j)+dPdn(j)/Rt*dpdxi(i)/dpdV
              dphidxj(i,j)=dlnphiidxj(i,j)
              if (i.eq.j) dphidxj(i,j)=dphidxj(i,j)+1.d0/x(i)
            endif
          enddo
          endif
        enddo
      endif

      RETURN
      end                                            !subroutine PHIDERV
c
c ======================================================================
c
      subroutine FGCTY (t,rho,x,f)
c
c  old routine to compute fugacity for each of the nc components of a mixture
c  by numerical differentiation (using central differences) of the
c  dimensionless residual Helmholtz energy
c
c  based on derivations in E.W. Lemmon, MS Thesis, University of Idaho
c  (1991); section 3.2
c
c  inputs:
c        t--temperature [K]
c      rho--molar density [mol/L]
c        x--composition [array of mol frac]
c  outputs:
c        f--array (1..nc) of fugacities [kPa]
c
c  written by M. McLinden, NIST Thermophysics Division, Boulder, Colorado
c  12-15-95  MM, original version
c  12-18-95  MM, add pure component fugacity as a special case
c  01-08-96  MM, bug on call to PHIFEQ (wrong arguments)
c  02-27-96  MM, parameter n0=-ncmax to accommodate ECS-thermo model
c                add Zcrit to common /CCON/
c                replace calls to PHIHMX, PHIFEQ with general PHIX, PHIK
c  03-19-19  MM, add dipole moment to /CCON/
c  03-22-96  MM, replace /MODEL/ with /EOSMOD/
c  10-01-97  MM, add compiler switch to allow access by DLL
c  12-16-97  MM, add check for rho = 0; overflow on exponent (set to xerr)
c  12-01-98 EWL, add Reos and triple point pressure and density to /CCON/
c  12-22-98 EWL, recalculate R for mixtures based on values for pure fluids
c  05-08-06 EWL, modify how delp and deln are calculated for x>0.9999
c  01-25-07 EWL, change default f(i) from 0 to 1.  Skip calculation if x(i)=0
c  02-26-09 EWL, set f(icomp) equal to a very large number instead of xerr when the variable arg is huge
c  11-20-09 BFT, change deln to delmol in check for x(i).gt.1.0d0-delmol
c
cx DEC$ ATTRIBUTES DLLEXPORT :: FGCTY
c
      include 'commons.for'
      dimension x(ncmax),f(ncmax)
      dimension xplus(ncmax),xminus(ncmax)
c
      delmol=1.0d-4
      call ISPURE (x,icomp)
c
c  fill output fugacity array with zeros (final value for undefined
c  components and insurance against problems for others)
      do i=1,nc
        f(i)=0.0d0
      enddo
      if (t.le.0.d0) return
c
      call RMIX (x)
c  check for zero input density
      if (rho.lt.1.0d-40) RETURN
c
      RTrho=R*t*rho
      if (icomp.ne.0) then
c  pure component
        if (heos.eq.'BWR') then
c  pure fluid MBWR equation of state--use BWR-specific routines
          Ar=ABWR(icomp,t,rho)
          p=PBWR(icomp,t,rho)
          f(icomp)=RTrho*exp(Ar/(R*t)+p/RTrho-1.0d0)
        else
c  for other models, use general PHIK routines
          tau=tz(icomp)/t
          del=rho/rhoz(icomp)
          phi00=PHIK(icomp,0,0,tau,del)
          phi01=PHIK(icomp,0,1,tau,del)
c  check for potential under- or over-flow (can happen in 2-phase, but
c  the fugacity is meaningless there anyway)
          arg=phi00+phi01
          if (ABS(arg).lt.500.0d0) then
            f(icomp)=RTrho*exp(arg)
          else
            f(icomp)=1.d100
          end if
        end if
      else
c
c  mixture
        do i=1,nc
c  compute positive and negative increments to number of moles
c  general case:  deln < x(i) < 1 - deln
          delpp=delmol
          deln=-delmol
          if (x(i).gt.0.d0) then
          if (x(i).lt.delmol) then
c  special case--composition of component i is nearly zero
            deln=-x(i)/2.d0
            delpp=-deln
          else if (x(i).gt.1.0d0-delmol) then
c  special case--composition of component i is nearly one (pure fluid)
            delpp=(1.0d0-x(i))/2.d0
            deln=-delpp
          end if
          delp1=1.0d0/(1.0d0+delpp)
          deln1=1.0d0/(1.0d0+deln)
c  since total number of moles is now 1 + (delp or deln), all of the
c  compositions have changed
          do j=1,nc
            xplus(j)=x(j)*delp1
            xminus(j)=x(j)*deln1
          enddo
          xplus(i)=(x(i)+delpp)*delp1
          xminus(i)=(x(i)+deln)*deln1
c  derivative is at constant volume, so must adjust density
          Dplus=rho*(1.0d0+delpp)
          Dminus=rho*(1.0d0+deln)
c  compute residual Helmholtz at 'plus' and 'minus' density and composition
c  could call subroutine GIBBS here, but more efficient to directly call
c  the core routines (via PHIX)
          call REDX (xplus,t0,rho0)
          tau=t0/t
          del=Dplus/rho0
          Aplus=PHIX(0,0,tau,del,xplus)          !real-gas terms
          call REDX (xminus,t0,rho0)
          tau=t0/t
          del=Dminus/rho0
          Aminus=PHIX(0,0,tau,del,xminus)        !real-gas terms
          dnadn0=((1.0d0+delpp)*Aplus-(1.0d0+deln)*Aminus)/(delpp-deln)
c         write (*,*) ' FGCTY--delp,deln:  ',delp,deln
c         write (*,*) ' FGCTY--i,A+, A-, dAdN: ',i,Aplus,Aminus,dnadn0
c  check for potential under- or over-flow (can happen in 2-phase, but
c  the fugacity is meaningless there anyway)
          f(i)=xerr
          if (ABS(dnadn0).lt.100.0d0) f(i)=x(i)*RTrho*exp(dnadn0) !A is dimensionless
          end if
        enddo
      end if
c
      RETURN
      end                                              !subroutine FGCTY
c
c ======================================================================
c
      subroutine CHEMPOT (t,rho,x,u,ierr,herr)
c
c  compute the chemical potentials for each of the nc components of a
c  mixture
c
c  inputs:
c        t--temperature [K]
c      rho--molar density [mol/L]
c        x--composition [array of mol frac]
c  outputs:
c        u--array (1..nc) of the chemical potentials [J/mol]
c
c  written by E.W. Lemmon, NIST Thermophysics Division, Boulder, Colorado
c  03-18-10 EWL, original version
c
cx DEC$ ATTRIBUTES DLLEXPORT :: CHEMPOT
c
      include 'commons.for'
      dimension x(ncmax),u(ncmax)
      dimension dadn(ncmax),dnadn(ncmax)
      character*255 herr
c
      ierr=0
      herr=' '
      do i=1,nc
        u(i)=0.d0
      enddo
      if (t.le.0.d0) return
      if (rho.lt.1.0d-40) RETURN
c
      call RMIX (x)
      RT=R*t
      call ISPURE (x,icomp)
      if (icomp.ne.0) then
c  pure component
        call AG (t,rho,x,a,g)
        u(icomp)=g
      else
        call PHIDERV (1,t,rho,x,dadn,dnadn,ierr,herr)
        do i=1,nc
          da0dn=PHI0K(i,0,0,t,rho)     !ideal-gas terms  (Eq. 7.14 in GERG)
          da0dn=da0dn-href(i)/RT+sref(i)/R+1.D0+log(x(i))
          u(i)=(dnadn(i)+da0dn)*RT
        enddo
      end if
c
      RETURN
      end                                            !subroutine CHEMPOT
c
c ======================================================================
c
      subroutine FUGCOF (t,rho,x,phi,ierr,herr)
c
c  compute the fugacity coefficient for each of the nc components of a
c  mixture
c
c  inputs:
c        t--temperature [K]
c      rho--molar density [mol/L]
c        x--composition [array of mol frac]
c  outputs:
c      phi--array (1..nc) of the fugacity coefficients [-]
c
c  written by E.W. Lemmon, NIST Thermophysics Division, Boulder, Colorado
c  03-21-10 EWL, original version
c
cx DEC$ ATTRIBUTES DLLEXPORT :: FUGCOF
c
      include 'commons.for'
      dimension x(ncmax),phi(ncmax),f(ncmax)
      character*255 herr
c
      ierr=0
      herr=' '
      do i=1,nc
        phi(i)=0.d0
      enddo
      if (t.le.0.d0) return
      if (rho.lt.1.0d-40) RETURN
c
      call ISPURE (x,icomp)
      call FGCTY2 (t,rho,x,f,ierr,herr)
      call PRESS (t,rho,x,p)
      if (p.gt.0.d0) then
        if (icomp.ne.0) then
c  pure component
          phi(icomp)=f(icomp)/p
        else
          do i=1,nc
            if (x(i).gt.0.d0) phi(i)=f(i)/p/x(i)
          enddo
        endif
      endif
c
      RETURN
      end                                             !subroutine FUGCOF
c
c ======================================================================
c
      subroutine ACTVY (t,rho,x,actv,gamma,ierr,herr)
c
c  compute the activity and activity coefficient for each of the nc
c  components of a mixture
c
c  inputs:
c        t--temperature [K]
c      rho--molar density [mol/L]
c        x--composition [array of mol frac]
c  outputs:
c     actv--array (1..nc) of the activities
c    gamma--array (1..nc) of the activity coefficients
c
c  written by E.W. Lemmon, NIST Thermophysics Division, Boulder, Colorado
c  03-21-10 EWL, original version
c
cx DEC$ ATTRIBUTES DLLEXPORT :: ACTVY
c
      include 'commons.for'
      dimension x(ncmax),actv(ncmax),gamma(ncmax),f(ncmax),fp(ncmax)
      dimension xl(ncmax),xv(ncmax)
      character*255 herr
c
      ierr=0
      herr=' '
      do i=1,nc
        actv(i)=0.d0      !Pure fluid values
        gamma(i)=0.d0
      enddo
      if (t.le.0.d0) return
      if (rho.lt.1.0d-40) RETURN
c
      call ISPURE (x,icomp)
      if (icomp.eq.0) then
        call FGCTY2 (t,rho,x,f,ierr,herr)
        call PRESS (t,rho,x,p)
        ic2=icnc
        do i=1,nc
          icnc=i
          if (x(i).gt.0.d0) then
            call RMIX (x)
c           call TPRHO(t,p,x,2,0,dp,ierr,herr)
            call TPFLSH (t,p,x,dp,dl,dv,xl,xv,q,e,h,s,cv,cp,w,ierr,herr)
            call FGCTY2 (t,dp,x,fp,ierr,herr)
            if (fp(i).gt.0.d0) actv(i)=f(i)/fp(i)
            gamma(i)=actv(i)/x(i)
          endif
        enddo
        icnc=ic2
        call RMIX (x)
      endif
c
      RETURN
      end                                              !subroutine ACTVY
c
c ======================================================================
c
      subroutine VIRB (t,x,b)
c
c  compute second virial coefficient as a function of temperature
c  and composition.
c
c  inputs:
c        t--temperature [K]
c        x--composition [array of mol frac]
c  outputs:
c        b--second virial coefficient [L/mol]
c
c  written by E.W. Lemmon, NIST Physical & Chem Properties Div, Boulder, CO
c  03-27-98 EWL, original version
c  08-30-04 EWL, change rho to 0.00000001
c
cx DEC$ ATTRIBUTES DLLEXPORT :: VIRB
c
      include 'commons.for'
      dimension x(ncmax)
c
      b=0.d0
      if (t.le.0.d0) return
      call RMIX (x)
      rho=0.00000001d0
      if (heos.eq.'BWR') then
c  pure fluid MBWR equation of state--call BWR-specific routines
        icomp=1
        p=PBWR(icomp,t,rho)
        b=(p/rho/R/t-1.0d0)/rho
c
      else
c  call general PHIK or PHIX routines for all other models
        call ISPURE (x,icomp)
        if (icomp.ne.0) then
c  pure fluid
          tau=tz(icomp)/t
          del=rho/rhoz(icomp)
          phi01=PHIK(icomp,0,1,tau,del)
        else
c  mixture
          call REDX (x,t0,rho0)
          tau=t0/t
          del=rho/rho0
          phi01=PHIX(0,1,tau,del,x)
        end if
        b=phi01/rho
      end if
c
      RETURN
      end                                               !subroutine VIRB
c
c ======================================================================
c
      subroutine DBDT (t,x,dbt)
c
c  compute the 1st derivative of B (B is the second virial coefficient) with
c  respect to T as a function of temperature and composition.
c
c  inputs:
c        t--temperature [K]
c        x--composition [array of mol frac]
c  outputs:
c      dbt--1st derivative of B with respect to T [L/mol-K]
c
c  written by E.W. Lemmon, NIST Physical & Chem Properties Div, Boulder, CO
c  07-30-01 EWL, original version
c  08-30-04 EWL, change rho to 0.00000001
c
cx DEC$ ATTRIBUTES DLLEXPORT :: DBDT
c
      include 'commons.for'
      dimension x(ncmax)
c
      dbt=0.d0
      if (t.le.0.d0) return
      call RMIX (x)
      rho=0.00000001d0
      if (heos.eq.'BWR') then
c  pure fluid MBWR equation of state--call BWR-specific routines
        icomp=1
        p=PBWR(icomp,t,rho)
        dpt=DPTBWR(icomp,t,rho)
        dbt=(dpt - p/t)/rho**2/t/R
c
      else
c  call general PHIK or PHIX routines for all other models
        call ISPURE (x,icomp)
        if (icomp.ne.0) then
c  pure fluid
          tau=tz(icomp)/t
          del=rho/rhoz(icomp)
          phi11=PHIK(icomp,1,1,tau,del)
        else
c  mixture
          call REDX (x,t0,rho0)
          tau=t0/t
          del=rho/rho0
          phi11=PHIX(1,1,tau,del,x)
        end if
        dbt=-phi11/rho/t
      end if
c
      RETURN
      end                                               !subroutine DBDT
c
c ======================================================================
c
      subroutine DBDT2 (t,x,dbt2)
c
c  compute the 2nd derivative of B (B is the second virial coefficient) with
c  respect to T as a function of temperature and composition.
c
c  inputs:
c        t--temperature [K]
c        x--composition [array of mol frac]
c  outputs:
c      dbt2--2nd derivative of B with respect to T [L/mol-K^2]
c
c  written by E.W. Lemmon, NIST Physical & Chem Properties Div, Boulder, CO
c  10-29-07 EWL, original version
c
cx DEC$ ATTRIBUTES DLLEXPORT :: DBDT2
c
      include 'commons.for'
      dimension x(ncmax)
c
      dbt2=0.d0
      if (t.le.0.d0) return
      call RMIX (x)
      rho=0.00000001d0
      if (heos.eq.'BWR') then
c  pure fluid MBWR equation of state--call BWR-specific routines
        dbt2=0     !not yet implemented
c
      else
c  call general PHIK or PHIX routines for all other models
        call ISPURE (x,icomp)
        if (icomp.ne.0) then
c  pure fluid
          tau=tz(icomp)/t
          del=rho/rhoz(icomp)
          phi21=PHIK(icomp,2,1,tau,del)
          phi11=PHIK(icomp,1,1,tau,del)
        else
c  mixture
          call REDX (x,t0,rho0)
          tau=t0/t
          del=rho/rho0
          phi21=PHIX(2,1,tau,del,x)
          phi11=PHIX(1,1,tau,del,x)
        end if
        dbt2=(phi21+2.d0*phi11)/rho/t**2
      end if
c
      RETURN
      end                                              !subroutine DBDT2
c
c ======================================================================
c
      subroutine VIRC (t,x,c)
c
c  compute the third virial coefficient as a function of temperature
c  and composition.
c
c  inputs:
c        t--temperature [K]
c        x--composition [array of mol frac]
c  outputs:
c        c--third virial coefficient [(L/mol)^2]
c
c  written by E.W. Lemmon, NIST Physical & Chem Properties Div, Boulder, CO
c   3-27-98 EWL, original version
c  12-02-98 EWL, change rho to 0.0001 to avoid numerical problems in BWR calc.
c  08-30-04 EWL, change rho to 0.00000001
c  05-24-06 EWL, change rho to 0.000001 for the BWR
c  05-07-09 EWL, change rho to 0.0001 for the BWR
c
cx DEC$ ATTRIBUTES DLLEXPORT :: VIRC
c
      include 'commons.for'
      dimension x(ncmax)
c
      c=0.d0
      if (t.le.0.d0) return
      call RMIX (x)
      rho=0.000001d0
      if (heos.eq.'BWR') then
        rho=0.0001d0
c  pure fluid MBWR equation of state--call BWR-specific routines
        icomp=1
        p=PBWR(icomp,t,rho)
        dpd=DPDBWR(icomp,t,rho)
        c=((dpd-2.0d0*p/rho)/R/t+1.0d0)/rho**2
c
      else
c  call general PHIK or PHIX routines for all other models
        call ISPURE (x,icomp)
        if (icomp.ne.0) then
c  pure fluid
          tau=tz(icomp)/t
          del=rho/rhoz(icomp)
          phi02=PHIK(icomp,0,2,tau,del)
        else
c  mixture
          call REDX (x,t0,rho0)
          tau=t0/t
          del=rho/rho0
          phi02=PHIX(0,2,tau,del,x)
        end if
        c=phi02/rho**2
      end if
c
      RETURN
      end                                               !subroutine VIRC
c
c ======================================================================
c
      subroutine DCDT (t,x,dct)
c
c  compute the 1st derivative of C (C is the third virial coefficient) with
c  respect to T as a function of temperature and composition.
c
c  inputs:
c        t--temperature [K]
c        x--composition [array of mol frac]
c  outputs:
c      dct--1st derivative of C with respect to T [(L/mol)^2-K]
c
c  written by E.W. Lemmon, NIST Physical & Chem Properties Div, Boulder, CO
c  10-29-07 EWL, original version
c
cx DEC$ ATTRIBUTES DLLEXPORT :: DCDT
c
      include 'commons.for'
      dimension x(ncmax)
c
      dct=0.d0
      if (t.le.0.d0) return
      call RMIX (x)
      rho=0.00000001d0
      if (heos.eq.'BWR') then
c  pure fluid MBWR equation of state--call BWR-specific routines
        dct=0.d0      !not yet implemented
c
      else
c  call general PHIK or PHIX routines for all other models
        call ISPURE (x,icomp)
        if (icomp.ne.0) then
c  pure fluid
          tau=tz(icomp)/t
          del=rho/rhoz(icomp)
          phi12=PHIK(icomp,1,2,tau,del)
        else
c  mixture
          call REDX (x,t0,rho0)
          tau=t0/t
          del=rho/rho0
          phi12=PHIX(1,2,tau,del,x)
        end if
        dct=-phi12/rho**2/t
      end if
c
      RETURN
      end                                               !subroutine DCDT
c
c ======================================================================
c
      subroutine DCDT2 (t,x,dct2)
c
c  compute the 2nd derivative of C (C is the third virial coefficient) with
c  respect to T as a function of temperature and composition.
c
c  inputs:
c        t--temperature [K]
c        x--composition [array of mol frac]
c  outputs:
c      dct2--2nd derivative of C with respect to T [(L/mol-K)^2]
c
c  written by E.W. Lemmon, NIST Physical & Chem Properties Div, Boulder, CO
c  10-29-07 EWL, original version
c
cx DEC$ ATTRIBUTES DLLEXPORT :: DCDT2
c
      include 'commons.for'
      dimension x(ncmax)
c
      dct2=0.d0
      if (t.le.0.d0) return
      call RMIX (x)
      rho=0.00000001d0
      if (heos.eq.'BWR') then
c  pure fluid MBWR equation of state--call BWR-specific routines
        dct2=0     !not yet implemented
c
      else
c  call general PHIK or PHIX routines for all other models
        call ISPURE (x,icomp)
        if (icomp.ne.0) then
c  pure fluid
          tau=tz(icomp)/t
          del=rho/rhoz(icomp)
          phi22=PHIK(icomp,2,2,tau,del)
          phi12=PHIK(icomp,1,2,tau,del)
        else
c  mixture
          call REDX (x,t0,rho0)
          tau=t0/t
          del=rho/rho0
          phi22=PHIX(2,2,tau,del,x)
          phi12=PHIX(1,2,tau,del,x)
        end if
        dct2=(phi22+2.d0*phi12)/rho**2/t**2
      end if
c
      RETURN
      end                                              !subroutine DCDT2
c
c ======================================================================
c
      subroutine VIRD (t,x,d)
c
c  compute the fourth virial coefficient as a function of temperature
c  and composition.
c
c  inputs:
c        t--temperature [K]
c        x--composition [array of mol frac]
c  outputs:
c        d--fourth virial coefficient [(L/mol)^3]
c
c  written by E.W. Lemmon, NIST Physical & Chem Properties Div, Boulder, CO
c  11-26-01 EWL, original version
c  12-08-11 EWL, change rho to 1.d-4, was too small for d=1 Gaussian terms
c
      include 'commons.for'
      dimension x(ncmax)
c
      d=0.d0
      if (t.le.0.d0) return
      call RMIX (x)
c     rho=0.00000001d0
      rho=1.d-4
      if (heos.eq.'BWR') then
c  pure fluid MBWR equation of state--call BWR-specific routines
c       icomp=1
c       p=PBWR(icomp,t,rho)
c       dpd=DPDBWR(icomp,t,rho)
c  need to update with correct formula:
c       c=((dpd-2.0d0*p/rho)/R/t+1.0d0)/rho**2
        d=0
c
      else
c  call general PHIK or PHIX routines for all other models
        call ISPURE (x,icomp)
        if (icomp.ne.0) then
c  pure fluid
          tau=tz(icomp)/t
          del=rho/rhoz(icomp)
          phi03=PHIK(icomp,0,3,tau,del)
        else
c  mixture
          call REDX (x,t0,rho0)
          tau=t0/t
          del=rho/rho0
          phi03=PHIX(0,3,tau,del,x)
        end if
        d=phi03/rho**3
      end if
c
      RETURN
      end                                               !subroutine VIRD
c
c ======================================================================
c
      subroutine VIRBA (t,x,ba)
c
c  compute second acoustic virial coefficient as a function of temperature
c  and composition.
c
c  inputs:
c        t--temperature [K]
c        x--composition [array of mol frac]
c  outputs:
c        ba--second acoustic virial coefficient [L/mol]
c
c  written by E.W. Lemmon, NIST Physical & Chem Properties Div, Boulder, CO
c  10-29-07 EWL, original version
c
cx DEC$ ATTRIBUTES DLLEXPORT :: VIRBA
c
      include 'commons.for'
      dimension x(ncmax)
c
      ba=0.d0
      if (t.le.0.d0) return
      call VIRB (t,x,b)
      call DBDT (t,x,dbt)
      call DBDT2 (t,x,dbt2)
      cp00=CP0(t,x)
      gpg=cp00/(cp00-R)
c  Trusler and Zarari, J. Chem. Thermodyn., 28:329-335, 1996.
c  Gillis and Moldover, Int. J. Theromphys., 17(6):1305-1324, 1996.
      ba=2.d0*b+2.d0*(gpg-1.d0)*t*dbt+(gpg-1.d0)**2/gpg*t**2*dbt2
c
      RETURN
      end                                              !subroutine VIRBA
c
c ======================================================================
c
      subroutine VIRCA (t,x,ca)
c
c  compute third acoustic virial coefficient as a function of temperature
c  and composition.
c
c  inputs:
c        t--temperature [K]
c        x--composition [array of mol frac]
c  outputs:
c        ca--third acoustic virial coefficient [(L/mol)^2]
c
c  written by E.W. Lemmon, NIST Physical & Chem Properties Div, Boulder, CO
c  10-29-07 EWL, original version
c
cx DEC$ ATTRIBUTES DLLEXPORT :: VIRCA
c
      include 'commons.for'
      dimension x(ncmax)
c
      ca=0.d0
      if (t.le.0.d0) return
      call VIRB (t,x,b)
      call VIRBA (t,x,ba)
      call DBDT (t,x,dbt)
      call DBDT2 (t,x,dbt2)
      call VIRC (t,x,c)
      call DCDT (t,x,dct)
      call DCDT2 (t,x,dct2)
      cp00=CP0(t,x)
      gpg=cp00/(cp00-R)
c  Gillis and Moldover, Int. J. Theromphys., 17(6):1305, 1996.
c  Estela-Uribe and Trusler, Int.  J. Theromphys., 21(5):1033, 2000.
      q=b+(2.d0*gpg-1.d0)*t*dbt+(gpg-1.d0)*t**2*dbt2
      ca=(gpg-1.d0)*q**2+(2.d0*gpg+1.d0)*c
      ca=ca+(gpg**2-1.d0)*t*dct+(gpg-1.d0)**2/2.d0*t**2*dct2
      ca=ca/gpg
c  to convert to the pressure expansion form, use this:
c     ca=(el-ba*b)/R/t
c
      RETURN
      end                                              !subroutine VIRCA
c
c ======================================================================
c
      subroutine B12 (t,x,b)
c
c  compute b12 as a function of temperature and composition.
c
c  inputs:
c        t--temperature [K]
c        x--composition [array of mol frac]
c  outputs:
c        b--b12 [(L/mol)^2]
c
c  written by E.W. Lemmon, NIST Physical & Chem Properties Div, Boulder, CO
c  04-19-01 EWL, original version
c
      include 'commons.for'
      dimension x(ncmax),xb(ncmax)
c
      if (nc.ne.2 .or. x(1).le.0.d0 .or. x(itwo2).le.0.d0) then   !Only calculate b12 for a binary
        b=0
        RETURN
      endif
      call VIRB (t,x,bx)
c     ic2=icnc         !Do not change icnc because it affects parallel code while fitting
c     icnc=1
      xb(ione1)=1.d0
      xb(itwo2)=0.d0
      call VIRB (t,xb,b1)
c     icnc=2
      xb(ione1)=0.d0
      xb(itwo2)=1.d0
      call VIRB (t,xb,b2)
      b=(bx-x(1)**2*b1-x(itwo2)**2*b2)/2.d0/x(1)/x(itwo2)
c     icnc=ic2
      RETURN
      end                                                !subroutine B12
c
c ======================================================================
c
      subroutine EXCESS (t,p,x,kph,rho,vE,eE,hE,sE,aE,gE,ierr,herr)
c
c  compute excess properties as a function of temperature, pressure,
c  and composition.
c
c  inputs:
c        t--temperature [K]
c        p--pressure [kPa]
c        x--composition [array of mol frac]
c      kph--phase flag:  1 = liquid
c                        2 = vapor
c                        0 = stable phase
c  outputs:
c       rho--molar density [mol/L] (if input less than 0, used as initial guess)
c        vE--excess volume [L/mol]
c        eE--excess energy [J/mol]
c        hE--excess enthalpy [J/mol]
c        sE--excess entropy [J/mol-K]
c        aE--excess Helmholtz energy [J/mol]
c        gE--excess Gibbs energy [J/mol]
c      ierr--error flag:  0 = successful
c                        55 = T,p inputs in different phase for the pure fluids
c      herr--error string (character*255 variable if ierr<>0)
c
c  written by E.W. Lemmon, NIST Physical & Chem Properties Div, Boulder, CO
c  04-25-02 EWL, original version
c  11-04-08 EWL, add ierr and herr to argument list
c  11-26-08 EWL, add aE and gE to argument list
c  03-21-10 EWL, add log(x(i)) to sE, gE, and aE
c  08-24-11 EWL, replace use of 'ic2=ic' with z(i)=1 so that the fitter can parallelize the code
c  11-23-11 EWL, remove the checks for inputs in different phases
c
      include 'commons.for'
      dimension x(ncmax),xliq(ncmax),xvap(ncmax),z(ncmax)
      character*255 herr
c
      ierr=0
      herr=' '
      d=rho
      vE=0.d0
      eE=0.d0
      hE=0.d0
      sE=0.d0
      aE=0.d0
      gE=0.d0
      rho=0.d0
      call ISPURE (x,icomp)
      if (icomp.ne.0) RETURN
c
      kguess=0
      if (d.lt.0) kguess=1
      d=abs(d)
      if (kph.ne.0) then
       call TPRHO (t,p,x,kph,kguess,d,ierr,herr)
       if (ierr.ne.0) then
         d=d*2
         call TPRHO (t,p,x,kph,1,d,ierr,herr)
       endif
       if (ierr.ne.0)
     & call TPFLSH(t,p,x,d,dl,dv,xliq,xvap,q,eE,hE,sE,cv,cp,w,ierr,herr)
       call THERM (t,d,x,pp,eE,hE,sE,cv,cp,w,hjt)
       call AG (t,d,x,aE,gE)
      else
       call TPFLSH(t,p,x,d,dl,dv,xliq,xvap,q,eE,hE,sE,cv,cp,w,ierr,herr)
       call AG (t,d,x,aE,gE)
      endif
      if (ierr.ne.0) RETURN
      rho=d
      if (d.gt.0.d0) vE=1.d0/d
c
      call CRITP (x,tc2,pc2,Dc2,ierr,herr)
c     ic2=icnc
      do i=1,nc
        do j=1,nc
          z(j)=0.d0
        enddo
        z(i)=1.d0
c       icnc=i
c...Do not use kph or call TPRHO since the pure fluids could be in either phase
        call RMIX (z)
        RT=R*t
        call INFO (i,wmm,ttrp,tnbpt,tc,pc,dc,zc,acf,dip,rgas)
        call TPFLSH (t,p,z,d,dl,dv,xliq,xvap,q,e,h,s,cv,cp,w,ierr,herr)
c       if (d.gt.dc .and. rho.lt.Dc2 .and. t.lt.tc) goto 100
c       if (d.lt.dc .and. rho.gt.Dc2 .and. t.lt.tc) goto 100
        call AG (t,d,z,a,g)
        if (d.gt.0.d0) vE=vE-x(i)/d
        eE=eE-x(i)*e
        hE=hE-x(i)*h
        sE=sE-x(i)*(s- R*log(x(i)))
        aE=aE-x(i)*(a+RT*log(x(i)))
        gE=gE-x(i)*(g+RT*log(x(i)))
      enddo
c     icnc=ic2
      call RMIX (x)
      RETURN
c
c100  continue
c     vE=0.d0
c     eE=0.d0
c     hE=0.d0
c     sE=0.d0
c     aE=0.d0
c     gE=0.d0
c     ierr=55
c     herr='[EXCESS error] temperature and pressure inputs are in '//
c    &     'different phases for the pure fluids'//hnull
c     call ERRMSG (ierr,herr)
c     icnc=ic2
c     call RMIX (x)
c     RETURN
      end                                             !subroutine EXCESS
c
c ======================================================================
c
      subroutine FPV (t,rho,p,x,f)
c
c  Compute the supercompressibility factor, Fpv.
c
c  inputs:
c        t--temperature [K]
c        p--pressure [kPa]
c      rho--molar density [mol/L]
c        x--composition [array of mol frac]
c  outputs:
c        f--Fpv = sqrt[Z(60 F, 14.73 psia)/Z(T,P)]
c
c  written by E.W. Lemmon, NIST Physical & Chem Properties Div, Boulder, CO
c  11-07-02 EWL, original version
c
cx DEC$ ATTRIBUTES DLLEXPORT :: FPV
c
      include 'commons.for'
      dimension x(ncmax)
      character*255 herr
c
      tfpv = 288.705555555556d0    !60 F
      pfpv = 101.55977492837d0     !14.73 psia
      call TPRHO (tfpv,pfpv,x,2,0,dfpv,ierr,herr)
      if (p.gt.0.d0) then
        f=SQRT(pfpv/tfpv/dfpv*rho*t/p)
      else
        f=SQRT(pfpv/tfpv/dfpv/R)
      endif

      RETURN
      end                                                !subroutine FPV
Cc
Cc ======================================================================
Cc
C      subroutine SPECGR (t,rho,p,gr)
Cc
Cc  Compute the specific gravity (relative density).
Cc
Cc  inputs:
Cc        t--temperature [K]
Cc        p--pressure [kPa]
Cc      rho--molar density [mol/L]
Cc  outputs:
Cc       gr--specific gravity [dimensionless]
Cc
Cc  written by E.W. Lemmon, NIST Physical & Chem Properties Div, Boulder, CO
Cc  11-07-02 EWL, original version
Cc
C      include 'commons.for'
Cc
C      rhoair=1.d0      !Need to add formulation for air here
C      if (rhoair.gt.0.d0) then
C        gr=rho/rhoair
C      else
C        gr=1.d0
C      endif
C
C      RETURN
C      end                                             !subroutine SPECGR
c
c ======================================================================
c
      subroutine RMIX (x)
c
c  inputs:
c        x--composition [array of mol frac]
c
c  written by E.W. Lemmon, NIST Thermophysics Division, Boulder, Colorado
c  01-19-01 EWL, original version
c
      include 'commons.for'
      dimension x(ncmax)
c
      call ISPURE (x,icomp)
      if (icomp.ne.0) then
        R=Reos(icomp)
      else
        R=0.0d0
        do i=1,nc
          R=R+x(i)*Reos(i)
        enddo
      endif
      if (R.lt.1.d-10) R=8.314472d0  !Check for bad x(i)
      RETURN
      end                                               !subroutine RMIX
c
c ======================================================================
c
      subroutine RMIX2 (x,Rgas)
c
c  Return the gas "constant" as a combination of the gas constants for
c  the pure fluids
c
c  inputs:
c        x--composition [array of mol frac]
c  outputs:
c     Rgas--gas constant [J/mol-K]
c
c  written by E.W. Lemmon, NIST Thermophysics Division, Boulder, Colorado
c  03-21-10 EWL, original version
c
      include 'commons.for'
      dimension x(ncmax)
c
      call RMIX (x)
      Rgas=R
      RETURN
      end                                              !subroutine RMIX2
c
c ======================================================================
c
      subroutine THERM3 (t,rho,x,
     &           xkappa,beta,xisenk,xkt,betas,bs,xkkt,thrott,pi,spht)
c
c  Compute miscellaneous thermodynamic properties
c
c  inputs:
c        t--temperature [K]
c      rho--molar density [mol/L]
c        x--composition [array of mol frac]
c
c  outputs:
c   xkappa--Isothermal compressibility [1/kPa]
c     beta--Volume expansivity [1/K]
c   xisenk--Isentropic expansion coefficient [-]
c      xkt--Isothermal expansion coefficient [-]
c    betas--Adiabatic compressibility [1/kPa]
c       bs--Adiabatic bulk modulus [kPa]
c     xkkt--Isothermal bulk modulus [kPa]
c   thrott--Isothermal throttling coefficient [L/mol]
c       pi--Internal pressure [kPa]
c     spht--Specific heat input [J/mol]
c
c  written by E.W. Lemmon, NIST Physical & Chem Properties Div, Boulder, CO
c  06-16-06 EWL, original version
c
cx DEC$ ATTRIBUTES DLLEXPORT :: THERM3
c
      include 'commons.for'
      dimension x(ncmax)
c
      call THERM2 (t,rho,x,p,e,h,s,cv,cp,w,Z,hjt,A,G,xkappa,beta,
     &             dPdrho,d2PdD2,dPT,drhodT,drhodP,
     &             d2PT2,d2PdTD,spare3,spare4)
      wmm=WMOL(x)
      xisenk=0.d0
      if (p.le.0.d0) then
        xkt=1
        if (t.gt.0.d0) xisenk=w**2/R/T*wmm*0.001d0
      else
        xkt=rho/p*dPdrho               !Isothermal expansion coefficient
        xisenk=w**2*rho/p*wmm*0.001d0   !Isentropic expansion coefficient
      endif
      betas=xnotc
      if (rho.gt.0.d0 .and. w.gt.0.d0)
     &  betas=1.d0/rho/w**2/wmm*1000.d0 !Adiabatic compressibility
      bs=xisenk*p                      !Adiabatic bulk modulus
      xkkt=xkt*p                       !Isothermal bulk modulus
      thrott=-hjt*cp                   !Isothermal throttling coef.
      pi=t*dpt-p                       !Internal pressure
      if (abs(dpt).gt.1.d-20) then
        spht=rho*cp*dpdrho/dpt         !Specific heat input
      else
        spht=cp*t
      end If
      RETURN
      end                                             !subroutine THERM3
c
c ======================================================================
c
      subroutine VIRBCD (t,x,b,c,d)
c
c  Compute virial coefficients as a function of temperature
c  and composition.  The routine currently works only for pure fluids and
c  for the Helmholtz equation.
c  All values are computed exactly based on the terms in the eos, not
c  as done in VIRB by calculating properties at rho=1.d-8.
c
c  inputs:
c        t--temperature [K]
c        x--composition [array of mol frac]
c  outputs:
c        b--second virial coefficient [l/mol]
c        c-- third virial coefficient [(l/mol)^2]
c        d--fourth virial coefficient [(l/mol)^3]
c
c  written by E.W. Lemmon, NIST Physical & Chem Properties Div, Boulder, CO
c  01-01-10 EWL, original version
c  10-08-11 EWL, include Gaussian terms and change input parameters
c
      include 'commons.for'
      dimension x(ncmax),phisvv(n0:nx,mxtrm)
c
      b=0.d0
      c=0.d0
      d=0.d0
      call ISPURE (x,icomp)
      if (icomp.eq.0) RETURN
      if (t.le.0.0d0) RETURN
      if (hmxeos(icomp)(1:2).ne.'FE') RETURN
C
      tau=tz(icomp)/t
      elntau=log(tau)
      do k=1,ntermf(icomp)
        phisvv(icomp,k)=afeq(icomp,k)*EXP(tifeq(icomp,k)*elntau)
      enddo
      do i=1,ncrt(icomp)
        k=i+ntermf(icomp)
        da=-deltaf(icomp,i)
        ta=tau-gammaf(icomp,i)
        if (dlif(icomp,k).eq.2 .and. tlif(icomp,i).eq.2) then
          df=alphaf(icomp,i)*da**INT(dlif(icomp,k))
          tf= betaf(icomp,i)*ta**INT(tlif(icomp,i))
        else
          df=alphaf(icomp,i)*da**dlif(icomp,k)
          tf= betaf(icomp,i)*ta**tlif(icomp,i)
        endif
        if (eitf(icomp,i).ne.0.d0) then
          phisvv(icomp,k)=0.d0
        else
          phisvv(icomp,k)=afeq(icomp,k)*EXP(tifeq(icomp,k)*elntau+tf+df)
        endif
      enddo
c
c  second virial coefficient
      do k=1,ntermf(icomp)+ncrt(icomp)
        if (difeq(icomp,k).eq.1) then
          b=b+phisvv(icomp,k)
        endif
      enddo
      b=b/rhoz(icomp)
c
c  third virial coefficient
      do k=1,ntermf(icomp)
        if (difeq(icomp,k).eq.2) then
          c=c+2.d0*phisvv(icomp,k)
        elseif (difeq(icomp,k).eq.1 .and. dlif(icomp,k).eq.1) then
          c=c-2.d0*phisvv(icomp,k)
        endif
      enddo
      do i=1,ncrt(icomp)
        k=i+ntermf(icomp)
        if (difeq(icomp,k).eq.2) then
          c=c+2.d0*phisvv(icomp,k)
        elseif (difeq(icomp,k).eq.1) then
          c=c-4.d0*alphaf(icomp,i)*deltaf(icomp,i)*phisvv(icomp,k)
        endif
      enddo
      c=c/rhoz(icomp)**2
c
c  fourth virial coefficient
      do k=1,ntermf(icomp)
        if (difeq(icomp,k).eq.3) then
          d=d+6.d0*phisvv(icomp,k)
        elseif (difeq(icomp,k).eq.1 .and. dlif(icomp,k).eq.2) then
          d=d-6.d0*phisvv(icomp,k)
        elseif (difeq(icomp,k).eq.2 .and. dlif(icomp,k).eq.1) then
          d=d-6.d0*phisvv(icomp,k)
        elseif (difeq(icomp,k).eq.1 .and. dlif(icomp,k).eq.1) then
          d=d+3.d0*phisvv(icomp,k)
        endif
      enddo
      do i=1,ncrt(icomp)
        k=i+ntermf(icomp)
        if (difeq(icomp,k).eq.3) then
          d=d+6.d0*phisvv(icomp,k)
        elseif (difeq(icomp,k).eq.2) then
          d=d-12.d0*alphaf(icomp,i)*deltaf(icomp,i)*phisvv(icomp,k)
        elseif (difeq(icomp,k).eq.1) then
          d=d+phisvv(icomp,k)*(+6.d0*alphaf(icomp,i)
     &         +12.d0*(alphaf(icomp,i)*deltaf(icomp,i))**2)
        endif
      enddo
      d=d/rhoz(icomp)**3
c
      RETURN
      end                                             !subroutine VIRBCD
c
c ======================================================================
c
      subroutine HEAT (t,rho,x,hg,hn,ierr,herr)
c
c  Compute the ideal gas gross and net heating values.
c
c  inputs:
c        t--temperature [K]
c      rho--molar density [mol/L]
c        x--composition [array of mol frac]
c
c  outputs:
c       hg--gross (or superior) heating value [J/mol]
c       hn--net (or inferior) heating value [J/mol]
c     ierr--error flag:  0 = successful
c                        1 = error in chemical formula
c                        2 = not all heating values available
c     herr--error string (character*255 variable if ierr<>0)
c
c  written by E.W. Lemmon, NIST Physical & Chem Properties Div, Boulder, CO
c  01-09-08 EWL, original version
c
cx DEC$ ATTRIBUTES DLLEXPORT :: HEAT
c
      include 'commons.for'
      character*255 herr,hcf
      dimension x(ncmax),v(6)
c
      call ISPURE (x,icomp)
      hg=0.d0
      hn=0.d0
      do k=1,nc
        acrb=0.d0   !Number of carbon atoms
        ahyd=0.d0
        aoxy=0.d0
        anit=0.d0
        asul=0.d0
        hgk=0.d0
        hnk=0.d0
c
c  extract chemical formula from hsyn1, use the part in {} if available
        hcf=hsyn1(k)
        i=index(hcf,'{')
        if (i.eq.0) then
          i=index(hcf,'!')
          if (i.ne.0) hcf=hcf(1:i-1)
        else
          hcf=hcf(i+1:255)
          i=index(hcf,'}')
          if (i.ne.0) hcf=hcf(1:i-1)
        endif
c
c  extract the number of carbon, hydrogen, oxygen, ..., atoms from
c  the chemical formula
 10     continue
        if (hcf(2:2).lt.'a' .or. hcf(2:2).gt.'z')
     &      hcf=hcf(1:1)//' '//hcf(2:255)       !Add space in second slot
        do i=3,5
          if (hcf(i:i).lt.'0' .or. hcf(i:i).gt.'9')
     &        hcf=hcf(1:i-1)//' '//hcf(i:255)       !Add space in ith slot
        enddo
c
        read (hcf(3:5),'(i3)') j
        if (j.eq.0) j=1
        if (hcf(1:2).eq.'C ') then           !Carbon
          if (acrb.gt.0) goto 999
          acrb=real(j)
        elseif (hcf(1:2).eq.'H ') then       !Hydrogen
          if (ahyd.gt.0) goto 999
          ahyd=real(j)
        elseif (hcf(1:2).eq.'O ') then       !Oxygen
          if (aoxy.gt.0) goto 999
          aoxy=real(j)
        elseif (hcf(1:2).eq.'N ') then       !Nitrogen
          if (anit.gt.0) goto 999
          anit=real(j)
        elseif (hcf(1:2).eq.'S ') then       !Sulfur
          if (asul.gt.0) goto 999
          asul=real(j)
        endif
        hcf=hcf(6:255)
        if (hcf.ne.' ') goto 10
c
c       if (acrb+ahyd+aoxy+anit+asul.eq.0) goto 999   !Unknown substance
c
        if (abs(hcmbst(k)+1.d0).lt.1.d-12) goto 998
        hgk=hcmbst(k)*1000.d0
        v(1)=-ahyd/2.d0                        !Water produced
        v(2)=acrb+ahyd/4.d0-aoxy/2.d0+asul     !Oxygen needed
        v(3)=-acrb                             !CO2 produced
        v(4)=-anit/2.d0                        !Nitrogen
        v(5)=-asul                             !SO2
c
        t25=298.15d0
        rho0=0.d0
        call ENTHAL (t25,rho0,x,h25)
        call ENTHAL (t,rho0,x,h)
        hgk=hgk-(h25-h)
c
        call ENTHHC (0,t25,t,h)                !Liquid water
        hgk=hgk-v(1)*h
        do i=2,5
          call ENTHHC (i,t25,t,h)
          hgk=hgk-v(i)*h
        enddo
c
        call ENTHHC (0,t,-1.d0,h1)                !Liquid water
        call ENTHHC (1,t,-1.d0,h2)                !Ideal gas water
        hnk=hgk+v(1)*(h2-h1)
c
        if (k.eq.icomp) then
          hg=hgk
          hn=hnk
        else
          hg=hg+x(k)*hgk
          hn=hn+x(k)*hnk
        endif
      enddo
c
      ierr=0
      herr=' '
      RETURN
c
 998  ierr=2
      herr='[HEAT error 2] Heating values are not available for all '//
     &     'species in the mixture'//hnull
      hg=0.d0
      hn=0.d0
      RETURN
c
 999  ierr=1
      herr='[HEAT error 1] Error in chemical formula'//hnull
      hg=0.d0
      hn=0.d0
      RETURN
      end                                               !subroutine HEAT
c
c ======================================================================
c
      subroutine ENTHHC (icmb,t1,t2,h)
c
c  Compute the ideal gas enthalpy difference between temperatures t1 and
c  t2 for several combustion gases.  This is used in conjunction with the
c  heat of combustion subroutine so that the extra fluids do not have to be
c  loaded in memory.  If the EOS ever changes, then the coefficients
c  here must be updated.
c
c  inputs:
c       t1--temperature [K]
c       t2--temperature [K]
c           if t2 is less than zero, then absolute enthalpy calculated at t1
c     icmb--fluid identifier:
c           0-saturated liquid water
c           1-water
c           2-oxygen
c           3-CO2
c           4-nitrogen
c           5-SO2
c
c  outputs:
c        h--ideal gas enthalpy difference [J/mol]
c           (for i=0, then saturated liquid enthalpy difference of water)
c
c  written by E.W. Lemmon, NIST Physical & Chem Properties Div, Boulder, CO
c  01-09-08 EWL, original version
c  04-30-12 EWL, check for T>Tc(water)
c
      include 'commons.for'
      dimension xkhc(10),cpchc(10)
c
      h=0
      if (icmb.eq.0) then
        ntc=6
        cpchc(1)= 0.8943272d+5     !Enthalpy of saturated liquid water.
        cpchc(2)=-0.6138239d+5     !Fit by EWL on 1/9/2007
        cpchc(3)=-0.4415242d+5     !Matches Wagner & Pruss equation to within
        cpchc(4)=-0.1092092d+5     !0.02% over full saturation range.
        cpchc(5)= 0.6703065d+5     !Extrapolation to 200 K is smooth.
        cpchc(6)=-0.1763063d+6
        xkhc(1) = 0.032d0
        xkhc(2) = 0.078d0
        xkhc(3) = 0.825d0
        xkhc(4) = 4.d0
        xkhc(5) = 9.d0
        xkhc(6) =12.d0
        tcwater=647.096d0
        if (t1.gt.tcwater .or. t2.gt.tcwater) then
          h=0.d0
        else
          do i=1,ntc
                            h=h+cpchc(i)*(1.d0-t1/tcwater)**xkhc(i)
            if (t2.ge.0.d0) h=h-cpchc(i)*(1.d0-t2/tcwater)**xkhc(i)
          enddo
        endif
        RETURN
      elseif (icmb.eq.1) then
        ntc=1
        nte=5
        cpchc(1)=0.400632d+1             !Water
        cpchc(2)=0.124360d-1
        cpchc(3)=0.973150d+0
        cpchc(4)=0.127950d+1
        cpchc(5)=0.969560d+0
        cpchc(6)=0.248730d+0
        xkhc(1) =    0.d0
        xkhc(2) =  833.d0
        xkhc(3) = 2289.d0
        xkhc(4) = 5009.d0
        xkhc(5) = 5982.d0
        xkhc(6) =17800.d0
        R=8.314371357587d0
c                           value from above    value from refprop
c                           at 300 K            at 300 K
        if (t2.lt.0.d0) h=(-88471.35339670102d0+45964.71449803960d0)/r
      elseif (icmb.eq.2) then
        ntc=1
        nte=5
        cpchc(1)=3.51808732d0            !Oxygen
        cpchc(2)=0.102323928D+01
        cpchc(3)=0.784357918D+00
        cpchc(4)=0.337183363D-02
        cpchc(5)=-.170864084D-01
        cpchc(6)=0.463751562D-01
        xkhc(1) =0.d0
        xkhc(2) =0.224632440D+04
        xkhc(3) =0.112599763D+05
        xkhc(4) =0.120126209D+04
        xkhc(5) =0.690089445D+02
        xkhc(6) =0.532805445D+04
        R=8.31434d0
        if (t2.lt.0.d0) h=(-56058.60590328777d0+8734.35384436554d0)/r
      elseif (icmb.eq.3) then
        ntc=1
        nte=5
        cpchc(1)=0.35d+01                !CO2
        cpchc(2)=1.99427042d0
        cpchc(3)=0.621052475d0
        cpchc(4)=0.411952928d0
        cpchc(5)=1.04028922d0
        cpchc(6)=0.0832767753d0
        xkhc(1) =   0.d0
        xkhc(2) = 958.49956d0
        xkhc(3) =1858.80115d0
        xkhc(4) =2061.10114d0
        xkhc(5) =3443.89908d0
        xkhc(6) =8238.20035d0
        R=8.31451d0
        if (t2.lt.0.d0) h=(-43458.10456571817d0+22372.0720622156d0)/r
      elseif (icmb.eq.4) then
        ntc=4
        nte=1
        cpchc(1)= 3.5d0                  !Nitrogen
        cpchc(2)= 3.066469d-6
        cpchc(3)= 4.70124d-9
        cpchc(4)=-3.987984d-13
        cpchc(5)= 0.1012941d1
        xkhc(1) = 0.d0
        xkhc(2) = 1.d0
        xkhc(3) = 2.d0
        xkhc(4) = 3.d0
        xkhc(5) = 3364.011d0
        R=8.31451d0
        if (t2.lt.0.d0) h=(-22898.14229042497d0+8723.88255738888d0)/r
      elseif (icmb.eq.5) then
        ntc=2
        nte=2
        cpchc(1)= 4.0d0                  !SO2
        cpchc(2)= 0.72453d-4
        cpchc(3)= 1.0620d0
        cpchc(4)= 1.9401d0
        xkhc(1) =    0.d0
        xkhc(2) =    1.d0
        xkhc(3) =  775.d0
        xkhc(4) = 1851.d0
        R=8.314472d0
        if (t2.lt.0.d0) h=(-28976.84624561172d0+26659.0278471527d0)/r
      endif
c
      do i=1,ntc
        xkhci=xkhc(i)
        xkhc1=xkhci+1.0d0
                        h=h+cpchc(i)*t1**xkhc1/xkhc1
        if (t2.ge.0.d0) h=h-cpchc(i)*t2**xkhc1/xkhc1
      enddo
      do i=1,nte
        j=i+ntc
        expui1=EXP(xkhc(j)/t1)
        expui2=EXP(xkhc(j)/t2)
        if (t2.ge.0.d0)
     &  h=h-cpchc(j)*(-0.5d0*xkhc(j))*(1.0d0+expui2)/(1.0d0-expui2)
        h=h+cpchc(j)*(-0.5d0*xkhc(j))*(1.0d0+expui1)/(1.0d0-expui1)
      enddo
      h=h*R
      end                                             !subroutine ENTHHC
c
c ======================================================================
c
      subroutine ISPURE (x,icomp)
c
c  Determine if the user has requested the properties of a pure fluid.
c  This happens if 1) nc=1, 2) PUREFLD has been called, or 3) one of the
c  compositions in the x array is one.
c
c  inputs:
c        x--composition [array of mol frac]
c
c  outputs:
c    icomp--index set to the pure fluid, which is 1 for nc=1 or 0 for
c           a mixture.  If PUREFLD has been called, icomp=icnc.
c
c  written by E.W. Lemmon, NIST Thermophysics Division, Boulder, Colorado
c  05-01-08 EWL, original version
c
      include 'commons.for'
      dimension x(ncmax)
c
      icomp=0
      if (nc.eq.1) then
        icomp=1
      elseif (icnc.gt.0) then
        icomp=icnc
      else
        do i=1,nc
          if (ABS(x(i)-1.d0).lt.1.d-12) then
            icomp=i
            RETURN
          endif
        enddo
      endif
      RETURN
      end                                             !subroutine ISPURE
c
c ======================================================================
c
      subroutine RIEM (t,rho,x,riemc)
c
c  inputs:
c        t--temperature [K]
c      rho--molar density [mol/L]
c        x--composition [array of mol frac]
c
c  outputs:
c    riemc--RIEM is the thermodynamic curvature in cubic nanometers/molecule.
c    RIEM has magnitude of the correlation volume, is negative for attractive
c    interactions, and positive for repulsive interactions, except when its
c    magnitude gets smaller than the molecular volume.
c
c  written by E.W. Lemmon, NIST Thermophysics Division, Boulder, Colorado
c  08-01-11 EWL, original version
c
cx DEC$ ATTRIBUTES DLLEXPORT :: RIEM
      include 'commons.for'
      dimension x(ncmax)
c
      riemc=0.d0
      if (rho.lt.1.d-8) return
      call REDX (x,t0,rho0)
      tau=t0/t
      del=rho/rho0
      a10=(PHI0(0,1,t,rho,x)+PHIX(0,1,tau,del,x))/del
      a20=(PHI0(0,2,t,rho,x)+PHIX(0,2,tau,del,x))/del**2
      a30=(PHI0(0,3,t,rho,x)+PHIX(0,3,tau,del,x))/del**3
      a11=(PHI0(1,1,t,rho,x)+PHIX(1,1,tau,del,x))/tau/del
      a21=(PHI0(1,2,t,rho,x)+PHIX(1,2,tau,del,x))/tau/del**2
      a12=(PHI0(2,1,t,rho,x)+PHIX(2,1,tau,del,x))/tau**2/del
      a02=(PHI0(2,0,t,rho,x)+PHIX(2,0,tau,del,x))/tau**2
      a03=(PHI0(3,0,t,rho,x)+PHIX(3,0,tau,del,x))/tau**3
      sum=-2.d0*       a02**2*a10
     &    +4.d0*del*   a03*a10*a11 +4.d0*del   *a02*a11**2
     &    -4.d0*del*   a02*a10*a12 -2.d0*del**2*a10*a12**2
     &    -4.d0*del*   a02**2*a20  +2.d0*del**2*a03*a11*a20
     &    -5.d0*del**2*a02*a12*a20 -     del**3*a12**2*a20
     &    +2.d0*del**2*a03*a10*a21 +4.d0*del**2*a02*a11*a21
     &    +     del**3*a03*a20*a21 +     del**3*a02*a21**2
     &    -     del**2*a02**2*a30  -     del**3*a02*a12*a30
      xna=6.0221367d+23
      riemc=1.d0/(2.d0*xna*del**2*rho0*a02**2*(2.d0*a10+del*a20)**2)*sum

      RETURN
      end                                               !subroutine RIEM
c
c        1         2         3         4         5         6         7
c23456789012345678901234567890123456789012345678901234567890123456789012
c
c ======================================================================
c                                                    end file prop_sub.f
c ======================================================================
c  begin file realgas.f
c
c  This file contains the routines implementing the real-gas part of
c  the thermodynamic functions.  They call the corresponding "core"
c  routines for the specified component or mixture.
c
c  contained here are:
c     function PHIK (icomp,itau,idel,tau,del)
c     function PHIX (itau,idel,tau,del,x)
c     subroutine REDK (icomp,tred,Dred)
c     subroutine REDX (x,tred,Dred)
c
c ======================================================================
c ======================================================================
c
      function PHIK (icomp,itau,idel,tau,del)
c
c  compute reduced Helmholtz energy or a derivative as functions
c  of dimensionless temperature and density; calls the appropriate
c  core function
c
c  inputs:
c    icomp--pointer specifying component (1..nc)
c     itau--flag specifying order of temperature derivative to calc
c     idel--flag specifying order of density derivative to calculate
c           when itau = 0 and idel = 0, compute A/RT
c           when itau = 0 and idel = 1, compute 1st density derivative
c           when itau = 1 and idel = 1, compute cross derivative
c           etc.
c      tau--dimensionless temperature (To/T)
c      del--dimensionless density (D/Do)
c  output (as function value):
c      phi--residual (real-gas) part of the Helmholtz energy, or one
c           of its derivatives (as specified by itau and idel),
c           in reduced form (A/RT)
c
c        The Helmholtz energy consists of ideal and residual (real-gas)
c        terms; this routine calculates only the residual part.
c
c        This function computes pure component properties only.
c
c  written by M. McLinden, NIST Thermophysics Division, Boulder, Colorado
c  02-07-96  MM, original version
c  02-27-96  MM, parameter n0=-ncmax to accommodate ECS-thermo model
c  03-22-96  MM, replace /MODEL/ with /EOSMOD/
c  03-05-98  MM, do not check mix model (heos) on branch
c  07-21-03 EWL, add Peng-Robinson check
c
      include 'commons.for'
c
      if (del.le.1.0d-10) then    !trivial solution at zero density
        phik=0.0d0                !for any and all derivatives
        RETURN
      end if
c
      if (hmxeos(icomp)(1:2).eq.'FE') then
        phik=PHIFEQ (icomp,itau,idel,tau,del)
      else if (hmxeos(icomp).eq.'QUI') then
        phik=PHIQUI (icomp,itau,idel,tau,del)
      else if (hmxeos(icomp).eq.'BWR') then
        phik=PHIBWR (icomp,itau,idel,tau,del)
      else if (hmxeos(icomp).eq.'ECS') then
        phik=PHIECS (icomp,itau,idel,tau,del)
      else if (hmxeos(icomp).eq.'PR') then
        phik=PHIPR (icomp,itau,idel,tau,del)
      else
c  model not found, but no way to return an error from here
c       write (*,*) ' PHIK--model not found: ',heos,' ',hmxeos(icomp)
        phik=-9.99d99
      end if
c      RETURN
      end                                                 !function PHIK
c
c ======================================================================
c
      function PHIX (itau,idel,tau,del,x)
c
c  compute reduced Helmholtz energy or a derivative as functions
c  of dimensionless temperature and density by calling the appropriate
c  mixture model
c
c  inputs:
c     itau--flag specifying order of temperature derivative to calc
c     idel--flag specifying order of density derivative to calculate
c           when itau = 0 and idel = 0, compute A/RT
c           when itau = 0 and idel = 1, compute 1st density derivative
c           when itau = 1 and idel = 1, compute cross derivative
c           etc.
c      tau--dimensionless temperature (To/T)
c      del--dimensionless density (D/Do)
c        x--composition array (mol frac)
c  output (as function value):
c      phi--residual (real-gas) part of the Helmholtz energy, or one
c           of its derivatives (as specified by itau and idel),
c           in reduced form (A/RT)
c
c  N.B.  The reducing parameters To and Do are often, but not
c        necessarily, equal to the critical temperature and density.
c
c        The Helmholtz energy consists of ideal gas and residual (real-
c        gas) terms.  The residual term consists of ideal-solution and
c        mixing terms.  This routine calculates only the residual term.
c
c  written by M. McLinden, NIST Thermophysics Division, Boulder, Colorado
c  02-07-96  MM, original version
c  02-27-96  MM, parameter n0=-ncmax to accommodate ECS-thermo model
c  03-22-96  MM, replace /MODEL/ with /EOSMOD/
c  10-10-96  MM, if (nc = 1) call PHIK, rather than model-specific PHIxxx
c  10-30-02 EWL, add AGA8 mixture model
c  07-21-03 EWL, add Peng-Robinson check
c
      include 'commons.for'
      dimension x(ncmax)
c
      phix=0.0d0
      if (del.le.1.0d-10) RETURN  !trivial solution at zero density
c
      call ISPURE (x,icomp)
      if (icomp.ne.0) then
        phix=PHIK(icomp,itau,idel,tau,del)
      else
c  call HMX model
        if (heos.eq.'HMX') then
          phix=PHIHMX(itau,idel,tau,del,x)
c  call AGA8 model
        elseif (heos.eq.'AGA') then
          phix=PHIAGA(itau,idel,tau,del,x)
c  call Peng-Robinson model
        elseif (heos.eq.'PR') then
          phix=PHIPRX(itau,idel,tau,del,x)
        end if
      end if
c
      RETURN
      end                                                 !function PHIX
c
c ======================================================================
c
      subroutine REDK (icomp,tred,Dred)
c
c  returns reducing parameters associated with a pure fluid EOS;
c  used to calculate the 'tau' and 'del' which are the independent
c  variables in the EOS
c
c  N.B.  The reducing parameters are often, but not always, equal
c        to the critical temperature and density.
c
c  input:
c    icomp--component number in mixture (1..nc); 1 for pure fluid
c  outputs:
c     tred--reducing temperature [K]
c     Dred--reducing molar density [mol/L]
c
c  written by M. McLinden, NIST Thermophysics Division, Boulder, Colorado
c  02-27-96  MM, original version, adapted from REDFEQ and PHIK
c  03-22-96  MM, replace /MODEL/ with /EOSMOD/
c  03-05-98  MM, do not check mix model (heos) on branch
c
      include 'commons.for'
c
      if (hmxeos(icomp)(1:2).eq.'FE') then
        call REDFEQ (icomp,tred,Dred)
c       write (*,1001) icomp,tred,Dred
      else if (hmxeos(icomp).eq.'QUI') then
        call REDQUI (icomp,tred,Dred)
c       write (*,1001) icomp,tred,Dred
      else if (hmxeos(icomp).eq.'BWR') then
        call CRTBWR (icomp,tred,pc,Dred)
c       write (*,1001) icomp,tred,Dred
c1001   format (1x,' REDK--icomp,tred,Dred: ',i2,2e14.6)
      else if (hmxeos(icomp).eq.'ECS') then
        call CRTECS (icomp,tred,pc,Dred)
      else if (hmxeos(icomp).eq.'PR') then
        call CRTPR (icomp,tred,pc,Dred)
      else
c  model not found, but no way to return an error from here
c       write (*,1100) icomp,hmxeos(icomp)
c1100   format (1x,' REDK--model not found for icomp = ',i3,':  ',a3)
        tred=9.99d99
        Dred=9.99d99
      end if
c
      RETURN
      end                                               !subroutine REDK
c
c ======================================================================
c
      subroutine REDX (x,tred,Dred)
c
c  returns reducing parameters associated with mixture EOS;
c  used to calculate the 'tau' and 'del' which are the independent
c  variables in the EOS
c
c  input:
c        x--composition array [mol frac]
c  outputs:
c     tred--reducing temperature [K]
c     Dred--reducing molar density [mol/L]
c
c  written by M. McLinden, NIST Thermophysics Division, Boulder, Colorado
c  02-27-96  MM, original version; adapted from REDHMX and PHIX
c  03-11-96  MM, parameter n0=-ncmax to accommodate ECS-thermo model
c                (missed in original version)
c  03-22-96  MM, replace /MODEL/ with /EOSMOD/
c  10-10-96  MM, if (nc = 1) call REDK, rather than model-specific routine
c
      include 'commons.for'
      dimension x(ncmax)
c
      call ISPURE (x,icomp)
      if (icomp.ne.0) then
        call REDK (icomp,tred,Dred)
      else
        if (heos.eq.'HMX') then
          call REDHMX (x,tred,Dred)
        elseif (heos.eq.'AGA') then
          call REDHMX (x,tred,Dred)
        elseif (heos.eq.'PR') then
          call REDPR (x,tred,Dred)
        end if
      end if
c
      RETURN
      end                                               !subroutine REDX
c
c
c        1         2         3         4         5         6         7
c23456789012345678901234567890123456789012345678901234567890123456789012
c
c ======================================================================
c                                                     end file realgas.f
c ======================================================================
c  begin file sat_sub.f
c
c  This file contains routines for saturation properties
c
c  contained here are:
c     subroutine SATT (t,x,kph,p,rhol,rhov,xliq,xvap,ierr,herr)
c     subroutine SATP (p,x,kph,t,rhol,rhov,xliq,xvap,ierr,herr)
c     subroutine SATD (rho,x,kph,kr,t,p,rhol,rhov,xliq,xvap,ierr,herr)
c     subroutine SATH (h,x,kph,nroot,k1,t1,p1,d1,k2,t2,p2,d2,ierr,herr)
c     subroutine SATE (e,x,kph,nroot,k1,t1,p1,d1,k2,t2,p2,d2,ierr,herr)
c     subroutine SATS (s,x,kph,nroot,k1,t1,p1,d1,k2,t2,p2,d2,
c    &                 k3,t3,p3,d3,ierr,herr)
c     subroutine MAXWELL (icomp,ts,ps,dl,dv,ierr,herr)
c     subroutine EHMAXX (x,ieflag,ehmax,tehmax,ierr,herr)
c     subroutine SMAXX (x,smx,tsmx,smn,tsmn,smmin,tsmmin,ierr,herr)
c     subroutine CSATK (icomp,t,kph,p,rho,csat,ierr,herr)
c     subroutine CV2PK (icomp,t,rho,cv2p,csat,ierr,herr)
c     subroutine DPTSATK (icomp,t,kph,p,rho,csat,dpt,ierr,herr)
c     subroutine TPRHOB (t,p,rho1,rho2,x,rho,ierr,herr)
c     subroutine DLDV (t,p,rhol,rhov,xl,xv,ierr,herr)
c     subroutine LIQSPNDL (t,x,rhol,ierr,herr)
c     subroutine VAPSPNDL (t,x,rhov,ierr,herr)
c     subroutine SETVSPNDL (icomp,ierr,herr)
c     subroutine SETLSPNDL (icomp,ierr,herr)
c     subroutine FNCRPT (x,d,p,t,ierr,herr)
c     function CRTDEN (x,t,d)
c     subroutine SATTEST (t,x,kph,p,x2,ierr,herr)
c     subroutine SATPEST (p,x,kph,t,x2,ierr,herr)
c     subroutine PTEST (inp,t,p,alpha,x,tc2,pc2,acf2,calc,xout,ierr,herr)
c     subroutine SATTP (t,p,x,iFlsh,iGuess,d,Dl,Dv,xliq,xvap,q,ierr,herr)
c     subroutine SATEST (iFlash,t,p,x,xliq,xvap,ierr,herr)
c     subroutine SAT0EST (t,p,x,xliq,xvap,ierr,herr)
c     subroutine GETXY (z,vf,philn,phi,x,y)
c     subroutine LGPHI (iderv,iphase,t,rho,p,x,philn,dpt,dpdrho,ddt,cp,
c    &                  ierr,herr)
c     subroutine CRTPNT (z,tc,pc,rhoc,ierr,herr)
c     subroutine SATGV (t,p,z,vf,b,ipv,ityp,isp,rhox,rhoy,x,y,ierr,herr)
c     subroutine SATSPLN (z,ierr,herr)
c
c ======================================================================
c ======================================================================
c
      subroutine SATT (t,x,kph,p,rhol,rhov,xliq,xvap,ierr,herr)
c
c  iterate for saturated liquid and vapor states given temperature
c  and the composition of one phase
c
c  inputs:
c        t--temperature [K]
c                       if t is negative, then use other variables as
c                       initial guesses at abs(t)
c        x--composition [array of mol frac] (phase specified by kph)
c      kph--phase flag: 1 = input x is liquid composition (bubble point)
c                       2 = input x is vapor composition (dew point)
c                       3 = input x is liquid composition (freezing point)
c                       4 = input x is vapor composition (sublimation point)
c  outputs:
c        p--pressure [kPa]
c     rhol--molar density [mol/L] of saturated liquid
c     rhov--molar density [mol/L] of saturated vapor
c           For a pseudo pure fluid, the density of the equilibrium phase
c           is not returned.  Call SATT twice, once with kph=1 to get
c           pliq and rhol, and once with kph=2 to get pvap and rhov.
c     xliq--liquid phase composition [array of mol frac]
c     xvap--vapor phase composition [array of mol frac]
c     ierr--error flag:   0 = successful
c                         1 = T < Tmin
c                         8 = x out of range
c                         9 = T and x out of range
c                       120 = CRITP did not converge
c                       121 = T > Tcrit
c                       122 = TPRHO-liquid did not converge (pure fluid)
c                       123 = TPRHO-vapor did not converge (pure fluid)
c                       124 = pure fluid iteration did not converge
c           following 3 error codes are advisory--iteration will either
c           converge on later guess or error out (ierr = 128)
c                      -125 = TPRHO did not converge for parent ph (mix)
c                      -126 = TPRHO did not converge for incipient (mix)
c                      -127 = composition iteration did not converge
c                       128 = mixture iteration did not converge
c     herr--error string (character*255 variable if ierr<>0)
c
c  written by M. McLinden, NIST Thermophysics Division, Boulder, Colorado
c  07-11-95  MM, original version
c  09-11-95  MM, add error string to argument list
c  09-25-95  MM, rearrange argument list (outputs in order p, rho, x)
c  10-06-95  MM, use stored acentric factor for pure fluids
c  10-11-95  MM, RETURN if any error detected
c  11-26-95  MM, Raoult's law as first guess for mixture
c  11-29-95  MM, variable lower limit on coefficient/constant arrays
c                to accommodate ECS reference fluid
c  12-18-95  MM, fill xliq, xvap with zeros for undefined components
c  12-19-20  MM, add full mixture iteration using fugacity
c  12-27-95  MM, pratio for new pressure if no converge for TPRHO for mix
c  01-09-96  MM, move check for supercritical outside nc = 1 block
c  02-27-96  MM, parameter n0=-ncmax to accommodate ECS-thermo model
c                add Zcrit to common /CCON/
c  03-06-96  MM, reset warning from TPRHO if loop eventually converges
c  03-19-96  MM, add dipole moment to /CCON/
c  04-05-96  MM, test for supercritical '.ge. tc' rather than '.gt. tc'
c  05-30-96  MM, check input temperature against limits
c  06-03-96  MM, add 'EOS' to calling list for LIMITX
c  06-05-96  MM, refine error numbers and messages;
c                also ensure that all outputs are set on error condition
c  11-14-96  MM, adjust pratio, etc to get closer to critical
c   2-07-96 EWL, add pressure increment/decrement when TPRHO does not converge
c   2-13-96 EWL, add initial guess for densities near the critical point
c                return critical point values if within delta of Tc
c   6-06-96 EWL, return critical point values for failure to converge if
c                Tc - T < 10 mK
c  10-01-97  MM, add compiler switch to allow access by DLL
c  11-13-97 EWL, initialize fpit(j); potential bomb if no value when writing error message
c  11-14-97 EWL, add line following 500 to improve critical region convergence
c  02-09-98  MM, limit delp step, change delp if TPRHO does not converge
c  02-11-98  MM, check that new guess for mix pressure is < p_crit
c  03-24-98 EWL, use critical region initial guesses when converge fails
c                due to liquid and vapor roots being equal
c  04-06-98 EWL, call subroutine AG to get Gibbs energy
c  07-30-98  MM, check for f1=0 in phase 2 iteration; separate kguess for each phase
c  08-03-98 EWL, check for fpit(2)-fpit(1)<>0 before calculation of pit(3)
c  12-01-98 EWL, add Reos and triple point pressure and density to /CCON/
c  12-22-98 EWL, zero out all elements of xliq and xvap
c  12-22-98 EWL, use pure fluid algorithm when called with a mixture but x(i)=1
c  02-04-99 EWL, increase tolerance if number of iterations hits 8 or 12
c  02-04-99 EWL, if fugacity is zero, don't restart, just change x2
c  02-04-99 EWL, add check for equal densities
c  02-04-99 EWL, allow pressure to be greater than critical pressure
c  02-04-99 EWL, do not allow outer loop to converge if inner loop has not
c  02-04-99 EWL, if TPRHO fails, set x2 to original values before restarting
c  08-23-99 EWL, change khpsav to kphsav
c  11-16-99 EWL, do not modify x2new(i) after the check for fugacity=0
c                when x2(i)=x1(i)=0 (composition was set to zero by user)
c  02-23-00 EWL, add kph=3,4 as inputs and call melting or sublimation lines
c  03-14-00 MLH, change 'do 100 i=1,ncmax' from ncmax to nc
c  12-18-00 EWL, use different pratio for dew and bubble sides
c  02-27-01 EWL, don't allow too large of jumps on first mixture iteration for p
c  07-16-01 EWL, add calls to ancillary equations to get better estimates
c  07-16-01 EWL, call THERM one last time on the liquid side once converged
c  11-08-01 EWL, add alternative method that converges near the critical point
c  11-20-01 EWL, check for ierr=-16 (t<ttrp)
c  02-25-02 EWL, allow initial guesses to be passed in by negating the pressure
c  05-28-02 EWL, check for bad root in two phase
c  09-19-02 EWL, add ancillary check for liquid pressure
c  09-19-02 EWL, exit after calculating ancillaries for pseudo-pure fluids
c  07-28-03 EWL, add check to keep x2 from bouncing around
c  11-30-04 EWL, add checks to remove crashes (p>1.d5, rhol-rhov<.1)
c  11-16-05 EWL, add check for negative temperature for use in getting initial values
c  07-21-08 EWL, add missing parenthesis in check for delp-delp2
c  02-18-08 EWL, add check for icomp<>old icomp (icsav)
c  04-12-10 EWL, add check for dp/dT negative
c  04-22-10 EWL, rename variables in TSTSAV
c  09-15-11  MK, add call to Maxwell subroutine
c
cx DEC$ ATTRIBUTES DLLEXPORT :: SATT
c
      include 'commons.for'
      character*255 herr,herr2,herr3
      dimension x(ncmax),xliq(ncmax),xvap(ncmax),x2org(ncmax),xs(ncmax)
      dimension x2(ncmax),f1(ncmax),f2(ncmax),x2new(ncmax)
      dimension pit(3),fpit(2)
c
      iaga=0
      call ISPURE (x,icomp)
      herr2=hnull
      if (lsatt) then
        if (ABS(t-tsavt).lt.1.0d-9 .and. kph.eq.kphsvt) then
          lsame=.true.
          if (icomp.ne.icsavt) lsame=.false.
          if (icomp.eq.0) then
            do i=1,nc
              if (ABS(x(i)-xsavt(i)).gt.1.0d-9) lsame=.false.
            enddo
          endif
          if (lsame) then
            p=psavt
            rhol=dlsavt
            rhov=dvsavt
            do i=1,nc
              xliq(i)=xlsavt(i)
              xvap(i)=xvsavt(i)
            enddo
            ierr=0
            herr=' '
            RETURN
          endif
        endif
      endif
c  set tolerance and maximum number of iterations
      tolr=1.0d-6
      itmax=25
c     write (*,*) ' SATT--entering with t,kph = ',t,kph
      ierr=0
      iflag=0        !flag for equal densities close to critical
      herr=' '
      delp2=1.d6
      fpit(1)=0.0d0
      fpit(2)=0.0d0
      initflg=0
c  make the temperature negative to use the other parameters in the call
c  statement as initial guesses
      if (t.lt.0.d0) then
        initflg=1
        t=abs(t)
      else
        p=0.0d0
        rhol=0.0d0
        rhov=0.0d0
        if (icomp.eq.0) then
          do i=1,nc
            xliq(i)=x(i)
            xvap(i)=x(i)
          enddo
        else
          do i=1,nc
            xliq(i)=0.d0
            xvap(i)=0.d0
          enddo
          xliq(icomp)=1.d0
          xvap(icomp)=1.d0
        endif
      endif
c
c  check if melting or sublimation line requested and call appropriate routines.
      if (kph.eq.3) then      !liquid/solid
        call MELTT (t,x,p,ierr2,herr2)
        rhol=dtpn(1)
        if (p.gt.1.d-15) call TPRHO (t,p,x,1,1,rhol,ierr,herr)
        if (ierr.eq.0) then
          ierr=ierr2
          herr=herr2
        endif
        goto 900
      else if (kph.eq.4) then      !vapor/solid
        call SUBLT (t,x,p,ierr2,herr2)
        if (t.gt.0.d0) rhov=p/(R*t)
        if (rhov.lt.1.d10) call TPRHO (t,p,x,2,1,rhov,ierr,herr)
        if (ierr.eq.0) then
          ierr=ierr2
          herr=herr2
        endif
        goto 900
      end if
c
c  check that input conditions (in this case t and x) are within limits
c
      Ddum=0.0d0
      pdum=0.0d0
      call LIMITX ('EOS',t,Ddum,pdum,x,tmin,tmax,rhomax,pmax,ierr,herr2)
      if (ierr.gt.0 .or. ierr.eq.-16) then
        if (ierr.eq.1 .and. t.lt.tmin .and. icomp.ne.0) then      !vapor/solid
          ierr2=ierr
          call SUBLT (t,x,p,ierr,herr)
          if (t.gt.0.d0 .and. p.gt.0.d0) then
            rhov=p/(R*t)
            if (rhov.lt.1.d10) call TPRHO (t,p,x,2,1,rhov,ierr3,herr3)
            goto 900
          endif
          ierr=ierr2
        endif
        ierr=abs(ierr)
c  T and/or x are out of bounds, set error flag and return
        write (herr,1000) ierr,herr2(1:238),hnull
 1000   format ('[SATT error',i3,'] ',a238,a1)
        call ERRMSG (ierr,herr)
        RETURN
      end if
c
      call CRITP (x,tc,pc,rhoc,ierr,herr2)
      if (ierr.gt.0) then
c  error condition--set outputs, issue warning, and return
        ierr=120
        p=0.0d0
        rhol=0.0d0
        rhov=0.0d0
        do i=1,nc
          xliq(i)=x(i)
          xvap(i)=x(i)
        enddo
        write (herr,1120) herr2(1:237),hnull
 1120   format ('[SATT error 120] ',a237,a1)
        call ERRMSG (ierr,herr)
        RETURN
      end if
c
      acf=0.d0
      if (icomp.eq.0) then
        do i=1,nc
          acf=acf+x(i)*accen(i)
        enddo
      endif
c
      if (icomp.ne.0) acf=accen(icomp)
      if (t.gt.tc-1.0d-8 .and. icomp.ne.0) then
c  input temperature is equal to or greater than critical,
c  return critical parameters for output pressure and densities
        p=pc
        rhol=rhoc
        rhov=rhoc
        do i=1,nc
          xliq(i)=x(i)
          xvap(i)=x(i)
        enddo
        if (t.gt.tc+1.0d-8) then
c  supercritical temperature as input, set error flag and return
c  critical parameters for output pressure and densities
          ierr=121
          write (herr,1121) t,tc,hnull
          call ERRMSG (ierr,herr)
 1121     format ('[SATT error 121] ',
     &            'temperature input to saturation routine is ',
     &            'greater than critical temperature; T =',g12.5,
     &            ' K, Tcrit =',g12.5,' K.',a1)
        end if
        RETURN
      end if
c
c  generate initial guess for pressure using acentric factor
c
      if (initflg.eq.0) then
        p=pc*10.d0**(-2.333333d0*(1.d0+acf)*(tc/t-1.d0))
      endif
c  for near-critical states, generate initial guesses for density;
c  using correlation developed by E.W. Lemmon, NIST
      theta=(ABS(1.0d0-t/tc))**(1.0d0/3.0d0)*(1.5d0+acf)
      rholi=rhoc*(1.0d0+1.113614d0*theta+0.080400d0*theta**2)
      rhovi=rhoc*(1.0d0-1.078683d0*theta+5.014057d-2*theta**2)
      if (rhovi.lt.0.d0) rhovi=1.d-6
c
      if (heos.eq.'AGA') then
        heos='HMX'
        iaga=1
      endif
c
      if (icomp.eq.0 .and. iSatFlg.eq.0) then
        call SATTP (t,p,x,kph,0,d,rhol,rhov,xliq,xvap,q,ierr,herr)
        if (ierr.eq.0 .and. kph.eq.2 .and. rhol.lt.rhov*0.8d0) then
          call SATGV (t,p,x,1.d0,d,1,1,1,rhol,rhov,xliq,xvap,ierr,herr)
        endif
        if (ierr.eq.0) goto 900
      endif
c
c  pure fluid iteration
      if (icomp.ne.0) then
        do i=1,nc
          xliq(i)=0.d0
          xvap(i)=0.d0
        enddo
        xliq(icomp)=1.d0
        xvap(icomp)=1.d0
c
c  Iterate for saturated liquid and vapor states given temperature using
c  a simple successive substitution method.  The independent variable
c  in the iteration is the vapor pressure.  The convergence criteria
c  is equality of Gibbs free energy in both phases.
c
        if ((t.gt.0.99d0*tc .or. iflag.eq.1) .and. ianc(icomp).eq.0)then
          goto 300
        else
c  assume nothing about densities on initial calls to TPRHO
          kguess=0
        endif

        rhol=rholi
        rhov=rhovi
        if (hpsk(icomp).ne.' ' .and. hpsk(icomp).ne.'NBS') then
          call PSATK (icomp,t,p,ierr,herr)
        endif
        if (hplk(icomp).ne.' ' .and. hplk(icomp).ne.'NBS'
     &                         .and. kph.eq.1) then
          call PLSATK (icomp,t,p,ierr,herr)!Get liquid pressure for mixtures
        endif
        if (hdlk(icomp).ne.' ' .and. hdlk(icomp).ne.'NBS') then
          call DLSATK (icomp,t,rhol,ierr,herr)
          if (ierr.gt.0) rhol=rholi
          if (ierr.le.0) kguess=1
        endif
        if (hdvk(icomp).ne.' ' .and. hdvk(icomp).ne.'NBS') then
          call DVSATK (icomp,t,rhov,ierr,herr)
          if (ierr.gt.0) rhov=rhovi
          if (ierr.le.0) kguess=1
        endif
        if (ianc(icomp).eq.1 .and. kph.eq.2) then
          call TPRHO (t,p,x,2,kguess,rhov,ierr,herr) !find vapor density
          rhol=rhov   !Don't return liquid density for equilibrium phase
          goto 900    !For pseudo-pure fluid, stop here
        elseif (ianc(icomp).eq.1) then
          call TPRHO (t,p,x,1,kguess,rhol,ierr,herr)!find liquid density
          rhov=rhol   !Don't return vapor density for equilibrium phase
          goto 900    !For pseudo-pure fluid, stop here
        endif

c  call new Maxwell routine of Matthias Kunick
c       call MAXWELL (icomp,t,p,rhol,rhov,ierr,herr)
c       if (ierr.eq.0) return

        do 200 it=1,itmax
c       write (*,*) 'SATT--t,p input to TPRHO: ',t,p
        call TPRHO (t,p,x,1,kguess,rhol,ierr,herr2) !find liquid density
        if (ierr.ne.0 .or. rhol.le.0.d0) then
          kguess=0
          p=p*1.005d0
          goto 200
        end if
        call TPRHO (t,p,x,2,kguess,rhov,ierr,herr2) !find vapor density
        if (ierr.ne.0 .or. rhov.le.0.d0) then
          p=p*0.95d0
          goto 200
        end if
c  use previous densities as initial guesses for calls to TPRHO after
c  first iteration
        kguess=1
c
        call AG (t,rhol,x,Aliq,Gliq)
        call AG (t,rhov,x,Avap,Gvap)
        ZG=Gliq-Gvap
c       write (*,1014) it,t,rhol,rhov,p,Gliq,Gvap,ZG
c1014   format (1x,'SATT:  it,t,rhol,rhov,p,Gliq,Gvap,ZG: ',
c    &              i4,f8.3,2f12.8,e14.6,2f12.4,e14.6)
c
c  check convergence
c
c  check that liquid and vapor densities are different
        if (ABS(rhol-rhov).lt.1.0d-8 .or.
     &     (ABS(1.d0/rhol-1.d0/rhov).lt.0.1d0 .and. t.lt.tc-1.d0)) then
          ierr=124
          herr='[SATT error 124] density roots equal'
          call ERRMSG (ierr,herr)
          goto 300
        end if
        delpp=ZG/(1.d0/rhol-1.d0/rhov)
c  the delp-delp2 check is only important for very low pressures on the
c  liquid surface (propane or R124).  See comments in TPRHO.
        if (abs(delpp/p).lt.tolr .or.
     &       abs((delpp-delp2)/delp2).lt.1.d-11) then
          p=p-delpp
          call TPRHO (t,p,x,2,kguess,rhov,ierr,herr2) !find vap density
          if (ierr.ne.0 .or. p.gt.pc .or. rhov.gt.rhoc) then
            ierr=123
            write (herr,1123) it,herr2(1:147),hnull
 1123       format ('[SATT error 123] vapor density iteration in ',
     &            'saturation routine did not converge for pressure ',
     &            'iteration',i3,'; ',a147,a1)
            call ERRMSG (ierr,herr)
c  return critical parameters if not converged and very close to Tc
            goto 300
          end if
          call TPRHO (t,p,x,1,kguess,rhol,ierr,herr2) !find liq density
c  call THERM again to get exact p at T and rhol.  This is only important
c  for very low pressures.
c...(12-13-06 EWL)  Call THERM with RHOV if p < 1 kPa.  This was put in place
c                   because some of the pressures were coming back erratic
c                   from the PR model (for example, butane at T<160 K)
          if (p.gt.1.d0) then
            call THERM (t,rhol,x,p,e,h,s,cv,cp,w,hjt)
          else
            call THERM (t,rhov,x,p,e,h,s,cv,cp,w,hjt)
          endif
          if (ierr.ne.0 .or. p.gt.pc .or. rhol.lt.rhoc) then
            ierr=122
            write (herr,1122) it,herr2(1:146),hnull
 1122       format ('[SATT error 122] liquid density iteration in ',
     &            'saturation routine did not converge for pressure ',
     &            'iteration',i3,'; ',a146,a1)
c  return critical parameters if not converged and very close to Tc
            goto 300
          end if
c  !debug--next six lines for debug only
c         call GIBBS (t,rhol,x,Aliq,Gliq)
c         call GIBBS (t,rhov,x,Avap,Gvap)
c         ZG=Gliq-Gvap
c         write (*,1015) it,t,rhol,rhov,p,Gliq,Gvap,ZG
c1015   format (1x,'SATT:  it,t,rhol,rhov,p,Gliq,Gvap,ZG: ',
c    &              i4,f8.3,2f12.8,e14.6,2f12.4,e14.6)
          ierr=0
          herr=' '
          goto 900         !normal termination for pure fluid
        end if
        delp2=delpp
c
c  continue iteration, define next guess (check that delp
c  will not result in negative [or very small] pressure)
c  02-09-98 MM:  limit step size
        if (ABS(delpp).gt.0.4d0*p) then
          do jj=1,10
c           write (*,1198) p,delp
c1198       format(1x,'% SATT advisory; delp gives p<0; p,delp:',2e12.4)
            delpp=0.5*delpp
            if (ABS(delpp).lt.0.4d0*p) goto 110
          enddo
        end if
 110    continue
        p=p-delpp
        if (p.gt.1.d5) goto 210   !prevent overflow
c
 200    continue
c  iteration has not converged
 210    continue
        ierr=124
        write (herr,1124) t,hnull
 1124   format ('[SATT error 124] ',
     &          'iteration for saturation state did not converge; ',
     &          'T =',g12.5,' K.',a1)
        call ERRMSG (ierr,herr)
c  return critical parameters if not converged and very close to Tc
        if (t.gt.0.999975*tc) then
          p=pc
          rhol=rhoc
          rhov=rhoc
        end if
c
c  Alternative method for finding saturation boundaries.  The routines works
c  best near critical by finding the spinodal points on the vapor and liquid
c  sides, and uses these points to bound the iteration.
 300    continue
        if (rholi.gt.0.d0 .and. rhovi.gt.0.d0) then
          call LIQSPNDL (t,x,rholi,ierr,herr)
          call VAPSPNDL (t,x,rhovi,ierr,herr)
          if (ierr.gt.0) goto 390
c
c  Get the pressures at the spinodals and find the densities in the opposite
c  phase at the spinodal pressures.  The liquid pressure could be negative.
c  These new densities will then bound the iteration, i.e., the liquid density
c  will be between rholi and rholj, and likewise for the vapor density.
          call PRESS (t,rholi,x,pl)
          call PRESS (t,rhovi,x,pv)
          CALL TPRHOB (t,pv,rholi,rholi*2.d0,x,rholj,ierr,herr)
          if (pl.le.0.d0) then
            rhovj=0.d0
          else
            CALL TPRHOB (t,pl,0.d0,rhovi,x,rhovj,ierr,herr)
          endif

c  Find the saturation condition.  Use the midpoint of the spinodal pressures
c  for the initial guess.  Call TPRHOB to get both densities, and call AG to
c  get Gibbs energy.  The difference in G is used to get the next pressure.
          it=0
          p=(pl+pv)/2.d0
          if (p.lt.0.d0) p=pv/2.d0
 370      continue
          CALL TPRHOB (t,p,rhovi,rhovj,x,rhov,ierr,herr)
          if (ierr.ne.0) then
            p=p*1.001d0
            goto 380
          endif
          CALL TPRHOB (t,p,rholi,rholj,x,rhol,ierr,herr)
          if (ierr.ne.0) then
            p=p*0.999d0
            goto 380
          endif
          call AG (t,rhol,x,Aliq,Gliq)
          call AG (t,rhov,x,Avap,Gvap)
          ZG=Gliq-Gvap
          delpp=ZG/(1.d0/rhol-1.d0/rhov)
          if (p-delpp.lt.0.d0) then
            p=p/2.d0
          else
            p=p-delpp
          endif
          if (abs(delpp/p)*100.lt.tolr) goto 900   !Exit when solved
 380      continue
          it=it+1
          if (it.lt.20) goto 370
 390      continue
          ierr=124
          write (herr,1124) t,hnull
          call ERRMSG (ierr,herr)
          p=pc
          rhol=rhoc
          rhov=rhoc
        endif
c
c  end of pure fluid iteration
c
      else
c
c  begin mixture iteration
c
c  Iterate for the pressure and the composition of the incipient phase
c  (vapor phase for a bubble point calculation, liquid for dew point)
c  given temperature and the composition of the parent phase.  Iteration
c  is generally based on the algorithm given by Smith & Van Ness (Intro
c  to Chem Engr Thermo, McGraw-Hill, 1975); convergence criteria is the
c  equality of fugacity for each component in both phases.
c
        x2sum=0.d0
        tolr=1.d-8
        call SATTEST (t,x,kph,psum,x2,ierr,herr)
        if (psum.gt.pc) psum=0.99d0*pc  !helps critical region conv.
c
c  variable kph2 specifies the state of the incipient phase (x2):
c     1 = liq,  2 = vap
c  it is used in calls to TPRHO
c  pratio is multiplier for pressure to use when TPRHO does not converge
c  different values for liquid and vapor phases, such that new guess for
c  pressure is further into corresponding single-phase region
        if (kph.eq.1) then
          kph2=2
          prtio1=1.05d0          !Choose different pratio for the dew
          prtio2=1.02d0          !and bubble sides to avoid loops
          if (initflg.ne.0) then
            do i=1,nc
              x2(i)=xvap(i)
            enddo
            psum=p
          endif
        else
          kph2=1
          prtio1=0.95d0
          prtio2=0.98d0
          if (initflg.ne.0) then
            do i=1,nc
              x2(i)=xliq(i)
            enddo
            psum=p
          endif
        end if
c
c  begin main mixture iteration--outer loop for pressure,
c  using Raoult's Law result from above as first guess
c
        p=psum
        do i=1,nc
          if (kph.eq.1) then
            xvap(i)=x2(i)
          else
            xliq(i)=x2(i)
          endif
        enddo
c
        kgues1=0              !for first calls to TPRHO
        kgues2=0              !kguess flags for parent & incipient phase
        lppos=.false.         !flags for reguli-falsi iteration
        lpneg=.false.
        pneg=0.0d0
        ppos=0.0d0
        fpneg=0.0d0
        fppos=0.0d0
        if (initflg.eq.0) then
          rho1=0.0d0
          rho2=0.0d0
        else
          kgues1=1
          kgues2=1
          if (kph.eq.1) then
            rho1=rhol
            rho2=rhov
          else
            rho1=rhov
            rho2=rhol
          endif
        endif
        tbad2=0.0d0
        ibad1=0
        ibad2=0
        j=1
        do ii=1,nc
          x2org(ii)=x2(ii)
        enddo
        pit(1)=psum           !first guess for pressure = sum (x1*Pi)
c
c
c
c       write (*,*) ' SATT--begin outer iteration loop for pressure'
        do 400 itpp=1,itmax
c  increase tolerance to account for errors in numerical derivatives in FGCTY2
        if (itpp.eq.8) tolr=tolr*10
        if (itpp.eq.12) tolr=tolr*10
        if (itpp.eq.15) tolr=tolr*10
        p=pit(j)
c       write (*,*) ' SATT--pressure iteration',itpp,' w/ p =',pit(j)
        lx2con=.false.        !flag for convergence of inner loop
c  compute density and fugacities for parent phase
        i=iprnterr
        iprnterr=0
        call TPRHO (t,p,x,-kph,kgues1,rho1,ierr,herr2)   !parent phase
        iprnterr=i
        kgues1=1
        if (kph.eq.1) then
          if (rho1.lt.rhoc/2.d0) ierr=1
          if (rho1.lt.rhoc*1.2d0 .and.itpp.eq.1 .and.initflg.eq.0)ierr=1
        endif
        if (ierr.gt.0) then
          ibad1=ibad1+1
          if (ibad1.lt.6) then
            if (kph.eq.1) then
              call DLDV (t,p,rho1,rho2,x,x2,ierr,herr2)
            else
              call DLDV (t,p,rho2,rho1,x2,x,ierr,herr2)
            endif
            pit(j)=p
          endif
          if (ierr.ne.0) then
            ierr=-125
            write (herr,1125) itpp,herr2(1:149),hnull
 1125       format ('[SATT advisory -125] density iteration in ',
     &              'saturation routine did not converge for pressure ',
     &              'iteration',i3,'; ',a149,a1)
            kgues1=0              !do not reuse faulty density as guess
            pit(j)=pit(j)*prtio1 !try another pressure and use up one
            goto 400              !iteration (to prevent infinite loop)
          else
            kgues2=1
          endif
        end if
        call FGCTY2 (t,rho1,x,f1,ierr,herr)
c       write (*,1082) itpp,t,p,rho1,(x(i),i=1,2),(f1(i),i=1,2)
c1082   format (1x,' SATT--phase 1:  ',i3,f8.2,2e14.6,2e16.8,2e18.10)
c
c  begin inner iteration loop for composition of phase 2
c
c       write (*,*) 'SATT--begin inner loop for composition of phase 2'
c
        sumdl2=2.0d0
        do itx=1,itmax*2
        do i=1,nc
        xs(i)=x2(i)
        enddo
c  compute density and fugacities for phase 2
        i=iprnterr
        iprnterr=0
        call TPRHO (t,p,x2,-kph2,kgues2,rho2,ierr,herr2)!incipient phase
        if (itx.ne.1) then
          if (ABS(rho2-rhoc).lt.1 .and. ABS(rho1-rhoc).gt.10) then
            rho2o=rho2
c  jump away from critical point when a bad root was found
            rho2=rho2*.5d0
            ierr2=ierr
            call TPRHO (t,p,x2,-kph2,kgues2,rho2,ierr,herr3)
            if (ierr.ne.0 .or. ABS(rho1-rho2).lt.0.1d0) then
              herr2=herr3
              ierr=ierr2
              rho2=rho2o
            endif
          endif
        endif
        iprnterr=i
        kgues2=1
        itx1=0
 420    continue
        if (ierr.gt.0 .or. ABS(rho1-rho2).lt.0.1d0) then
          ibad2=ibad2+1
          if (ibad2.lt.15) then
            if (ABS(rho1-rho2).lt.0.1d0 .and.
     &      ABS(tcrit(1)-tcrit(izero0+2)).gt.100.d0) then  !Use izero0+2 to trick the compiler to ignore an error for element 2 when ncmax=1
              do i=1,nc
                x2(i)=(tbad2*x(i)+x2org(i))/(1.d0+tbad2)
              enddo
              tbad2=tbad2+0.2d0
            endif
            if (kph.eq.1) then
              call DLDV (t,p,rho1,rho2,x,x2,ierr,herr2)
            else
              call DLDV (t,p,rho2,rho1,x2,x,ierr,herr2)
            endif
            call FGCTY2 (t,rho1,x,f1,ierr,herr)
            pit(j)=p
          endif
          if (ABS(f1(1)).gt.1.d10) goto 810
          if (ierr.ne.0 .or. ABS(rho1-rho2).lt.0.1d0) then
            ierr=-126
            write (herr,1126) itx,herr2(1:146),hnull
 1126       format ('[SATT advisory -126] density iteration in ',
     &            'saturation routine did not converge for composition',
     &            ' iteration',i3,'; ',a146,a1)
            do ii=1,nc
              x2(ii)=x2org(ii)
            enddo
            kgues2=0              !do not reuse faulty density as guess
            pit(j)=pit(j)/prtio2 !try another pressure and use up one
            goto 400              !iteration (to prevent infinite loop)
          endif
        endif
        call FGCTY2 (t,rho2,x2,f2,ierr,herr)
c       write (*,1086) itx,rho2,(x2(i),i=1,2),(f2(i),i=1,2)
c1086   format (1x,'       phase 2:  ',i3,22x,e14.6,2e16.8,2e18.10)
c  calculate new x2's by ratio of fugacities; inner loop has converged
c  when x2's change by less than a convergence tolerance
        x2sum=0.0d0
        do i=1,nc
          if (f2(i).gt.1.0d-20 .and. f1(i).gt.0.0d0) then
            x2new(i)=x2(i)*f1(i)/f2(i)
          else
c  in case fugacity is zero; e.g., if x(i)=0, then slightly modify x2(i)
            if (x(i).gt.0.d0) then
              rho2=rho1
              itx1=itx1+1
              if (itx1.lt.10) goto 420
            endif
            x2new(i)=0
c           if (x2(i).gt.0) x2new(i)=x2(i)+0.01d0
c           if (x2new(i).gt.1.0d0) x2new(i)=x2(i)-0.01d0
          end if
          x2sum=x2sum+x2new(i)
        enddo
        if (x2sum.le.0.d0 .or. x2sum.gt.1.d6) goto 810
c  normalize the x2 compositions; this yields next guess for x2 and
c  ensures that the x2 always sum to one
        sumdel=0.0d0
        do i=1,nc
          x2new(i)=x2new(i)/x2sum
          sumdel=sumdel+abs(x2(i)-x2new(i))  !change in compositions
          x2(i)=x2new(i)
        enddo
c       write (*,1560) (x2(i),i=1,nc)
c1560   format (1x,'SATT:  new compositions in inner loop:  ',5f10.5)
        if (sumdel.lt.tolr .or. abs(sumdel-sumdl2).lt.tolr*100.d0) then
c  inner iteration loop has converged
          lx2con=.true.
          ierr=0
          goto 700
        end if
        sumdl2=sumdel
c  if not, continue inner iteration loop
        if (int(itx/10)*10.eq.itx) then
c  occasionally average out the compositions on two successive iterations.
c  sometimes x2 bounces back and forth between two values.
          do i=1,nc
            x2(i)=(x2(i)+xs(i))/2.d0
          enddo
        endif
        enddo
c
c  inner iteration loop has not converged
        ierr=-127
        write (herr,1127) t,sumdel,hnull
 1127   format ('[SATT advisory -127] ',
     &          'iteration for composition in saturation routine ',
     &          'did not converge; T =',g12.5,
     &          ' K; deltaX =',g12.5,' mol frac.',a1)
        call ERRMSG (ierr,herr)
c
c  end of inner (x2) iteration loop
c
 700    continue
        fpit(j)=1.0d0-x2sum
c  outer (pressure) loop has converged when the x2's sum to one, i.e.,
c  when the fugacities of each component in each phase are equal
c       write (*,*) ' SATT--check conv, p, fp: ',pit(j),fpit(j)
        call DPDT (t,rho2,x2,dpt2)
        if (dpt2.le.0.d0) goto 810  !dp/dT should never be negative
        if (ABS(fpit(j)).lt.tolr .and. lx2con) then
          ierr=0
          herr=' '
          goto 850
        else
c  provided that the inner loop has converged, update positive and
c  negative bounds on pressure for possible use in reguli-falsi iteration
          if (lx2con) then
            if (fpit(j).lt.0.0d0) then
              lpneg=.true.
              pneg=pit(j)
              fpneg=fpit(j)
            else
              lppos=.true.
              ppos=pit(j)
              fppos=fpit(j)
            end if
          end if
        end if
c
c  compute new guess for saturation pressure
c
        if (j.eq.1) then
c  for first iteration, new pressure is ratio of old
          if (x2sum.gt.5) x2sum=5
          j=2
          if (kph.eq.1) then
c  bubble point
            pit(2)=pit(1)*x2sum
          else
c  dew point
            pit(2)=pit(1)/x2sum
          end if
        else
c  subsequent iterations--use secant method
          if (ABS(fpit(2)-fpit(1)).gt.1.0d-12)
     &    pit(3)=pit(2)-fpit(2)*(pit(2)-pit(1))/(fpit(2)-fpit(1))
c  check that new pressure is not outside bounds, if so use reguli-falsi
          if (lpneg .and. lppos .and. (pit(3).gt.1.001d0*MAX(ppos,pneg)
     &        .or. pit(3).lt.0.990d0*MIN(ppos,pneg))) then
            pit(3)=ppos-fppos*(ppos-pneg)/(fppos-fpneg)
          end if
c  discard oldest iteration
          pit(1)=pit(2)
          pit(2)=pit(3)
          fpit(1)=fpit(2)
        end if
c       write (*,1799) itpp,j,pit(1),pit(2),fpit(2)
c1799   format (1x,' SATT--itpp,j,p1,p2,fp2:  ',2i4,3e14.6)
 400    continue
c  outer iteration loop has not converged
 810    continue
        ierr=128
        write (herr,1128) t,hnull
 1128   format ('[SATT error 128] ',
     &          'iteration for saturation state did not converge; T =',
     &          g12.5,' K.',a1)
        call ERRMSG (ierr,herr)
        p=pc
        rho1=rhoc
        rho2=rhoc
c
c  end of outer (pressure) iteration loop
c
 850    continue
c
c  assign final compositions and densities for parent and incipient
c  phases (x and x2, rho1 and rho2, respectively) to outputs
c
        if (kph.eq.1) then
c  bubble point
          rhol=rho1
          rhov=rho2
          do i=1,nc
            xliq(i)=x(i)
            xvap(i)=x2(i)
          enddo
        else
c  dew point
          rhol=rho2
          rhov=rho1
          do i=1,nc
            xliq(i)=x2(i)
            xvap(i)=x(i)
          enddo
        end if
c  call new routine SATTP if ierr>0 and attempt to get convergence
c       if (ierr.gt.0 .and. icomp.eq.0 .and. iSatFlg.eq.0) then
c         call SATTP(t,p,x,kph,0,d,rhol,rhov,xliq,xvap,q,ierr,herr)
c       endif
        if (rhov.gt.rhol*0.99d0) then
          if (ABS(xliq(1)-xvap(1)).lt.0.1d0) then
            p=pc
            rhov=rhoc
            rhol=rhoc
            if (t.lt.tc) then
              ierr=128
              write (herr,1128) t,hnull
              call ERRMSG (ierr,herr)
            else
              ierr=121
              write (herr,1121) t,tc,hnull
              call ERRMSG (ierr,herr)
            endif
          endif
        endif
c  end of mixture iteration
      end if
c
c  save results
 900  continue
      if (ierr.eq.0) then
        if (p.lt.0.00001d0 .and. icomp.ne.0) p=rhov*r*t
        tsavt=t
        psavt=p
        icsavt=icomp
        kphsvt=kph
        dlsavt=rhol
        dvsavt=rhov
        if (icomp.eq.0) then
          do i=1,nc
            xsavt(i)=x(i)
            xlsavt(i)=xliq(i)
            xvsavt(i)=xvap(i)
          enddo
        else
          do i=1,nc
            xsavt(icomp)=0.d0
            xlsavt(icomp)=0.d0
            xvsavt(icomp)=0.d0
          enddo
          xsavt(icomp)=1.d0
          xlsavt(icomp)=1.d0
          xvsavt(icomp)=1.d0
        endif
        lsatt=.true.
      endif
      if (iaga.eq.1) then
        heos='AGA'
        if (ierr.eq.0) call TPRHO (t,p,xvap,2,1,rhov,ierr,herr)
      endif
      RETURN
c
      end                                               !subroutine SATT
c
c ======================================================================
c
      subroutine SATTEST (t,x,kph,p,x2,ierr,herr)
c
c  estimate initial values for saturation states given temperature
c  and the composition of one phase
c
c  inputs:
c        t--temperature [K]
c        x--composition [array of mol frac] (phase specified by kph)
c      kph--phase flag: 1 = input x is liquid composition (bubble point)
c                       2 = input x is vapor composition (dew point)
c  outputs:
c        p--estimated pressure [kPa]
c       x2--estimated composition of unknown phase [array of mol frac]
c
c  written by E.W. Lemmon, NIST Thermophysics Division, Boulder, Colorado
c  08-06-09 EWL, original version, taken from code in SATT
c
cx DEC$ ATTRIBUTES DLLEXPORT :: SATTEST
c
      include 'commons.for'
      dimension x(ncmax),x2(ncmax),pcomp(ncmax)
      character*255 herr
c
c  generate initial guesses for mixture pressure and compositions
c  using Raoult's law
c
c  estimates for vapor pressures of pure components
      ierr=0
      herr=' '
      do i=1,nc
        pcomp(i)=pcrit(i)
     &        *10.d0**(-2.333333d0*(1.d0+accen(i))*(tcrit(i)/t-1.d0))
      enddo
c
      p=0.d0
      if (kph.eq.1) then
c  bubble point
        do i=1,nc
          p=p+x(i)*pcomp(i)
        enddo
        do i=1,nc
          x2(i)=x(i)*pcomp(i)/p
        enddo
      else
c  dew point
        ysum=0.d0
        do i=1,nc
          ysum=ysum+x(i)/pcomp(i)
        enddo
        do i=1,nc
          x2(i)=x(i)/pcomp(i)/ysum
          p=p+x2(i)*pcomp(i)
        enddo
      end if
      RETURN
c
      end                                            !subroutine SATTEST
c
c ======================================================================
c
      subroutine SATP (p,x,kph,t,rhol,rhov,xliq,xvap,ierr,herr)
c
c  iterate for saturated liquid and vapor states given pressure
c  and the composition of one phase
c
c  inputs:
c        p--pressure [kPa]
c        x--composition [array of mol frac] (phase specified by kph)
c      kph--phase flag:  1 = input x is liquid composition
c                        2 = input x is vapor composition
c                        3 = input x is liquid composition (freezing point)
c                        4 = input x is vapor composition (sublimation point)
c
c  outputs:
c        t--temperature [K]
c     rhol--molar density [mol/L] of saturated liquid
c     rhov--molar density [mol/L] of saturated vapor
c           For a pseudo pure fluid, the density of the equilibrium phase
c           is not returned.  Call SATP twice, once with kph=1 to get
c           tliq and rhol, and once with kph=2 to get tvap and rhov.
c     xliq--liquid phase composition [array of mol frac]
c     xvap--vapor phase composition [array of mol frac]
c     ierr--error flag:  0 = successful
c                        2 = P < Ptp
c                        4 = P < 0
c                        8 = x out of range
c                       12 = P and x out of range
c                      140 = CRITP did not converge
c                      141 = P > Pcrit
c                      142 = TPRHO-liquid did not converge (pure fluid)
c                      143 = TPRHO-vapor did not converge (pure fluid)
c                      144 = pure fluid iteration did not converge
c           following 3 error codes are advisory--iteration will either
c           converge on later guess or error out (ierr = 148)
c                     -144 = Raoult's law (mixture initial guess) did
c                            not converge
c                     -145 = TPRHO did not converge for parent ph (mix)
c                     -146 = TPRHO did not converge for incipient (mix)
c                     -147 = composition iteration did not converge
c                      148 = mixture iteration did not converge
c     herr--error string if ierr<>0 (character*255)
c
c  written by M. McLinden, NIST Thermophysics Division, Boulder, Colorado
c  07-13-95  MM, original version
c  09-11-95  MM, add error string to argument list
c  09-25-95  MM, rearrange argument list (outputs in order t, rho, x)
c  10-11-95  MM, RETURN if any error detected
c  11-29-95  MM, variable lower limit on coefficient/constant arrays
c                to accommodate ECS reference fluid
c  12-11-95  MM, Raoult's law as first guess for mixture
c  12-18-95  MM, fill xliq, xvap with zeros for undefined components
c  12-27-95  MM, add full mixture iteration using fugacity, based on SATT
c  02-27-96  MM, parameter n0=-ncmax to accommodate ECS-thermo model
c                add Zcrit to common /CCON/
c  03-19-96  MM, add dipole moment to /CCON/
c  04-05-96  MM, test for supercritical '.ge. pc' rather than '.gt. pc'
c  11-14-96  MM, adjust initial guesses, tratio, etc to get closer to critical
c  02-12-96 EWL, special initial guess for temperature near the critical point
c  07-15-97  MM, add errors/warnings to parallel SATT
c  10-01-97  MM, add compiler switch to allow access by DLL
c  11-13-97 EWL, initialize ft(j); potential bomb if no value when writing error message
c  12-05-97  MM, check that TPRHO gives density within bounds
c                if Raoult's law iteration D.N.C., revert to initial guess
c  02-10-98  MM, add reguli-falsi, quadratic interpolation and bisection
c                to Raoult's law iteration
c  04-06-98 EWL, call subroutine AG to get Gibbs energy
c  07-30-98  MM, check for f1=0 in phase 2 iteration; separate kguess for each phase
c  11-30-98 EWL, change kguess to kgues2 in call to TPRHO in vapor search.
c  12-01-98 EWL, add Reos and triple point pressure and density to /CCON/
c  12-01-98 EWL, add Reos and triple point pressure and density to /CCON/
c  12-01-98 EWL, add Reos and triple point pressure and density to /CCON/
c  12-22-98 EWL, zero out all elements of xliq and xvap
c  12-22-98 EWL, use pure fluid algorithm when called with a mixture but x(i)=1
c  12-23-98 EWL, modify step size for T when TPRHO fails
c  12-23-98 EWL, replace rhov with rhoc/2 when TPRHO finds liquid root
c  08-03-99 EWL, if TPRHO fails, set x2 to original values before restarting
c  08-03-99 EWL, if dpdrho>1d6, then return an error message
c  01-11-00 EWL, remove ierr from lines where 'i3' was not in format statement
c  02-23-00 EWL, add kph=3,4 as inputs and call melting or sublimation lines
c  12-17-01 EWL, call SATT if iteration fails
c  05-28-02 EWL, check for bad root in two phase
c  08-14-02 EWL, add logic if ammonia/water in use
c  09-19-02 EWL, add checks for ancillary routines and exit for pseudo-pures
c  03-24-05 EWL, add check for small rho in liquid phase. (for mixtures, inner loop)
c  09-21-06 EWL, increase itmax, check for ierr=-147, add small value to keep x2sum<>1,
c                add check for nh3+h2o, split tratio into trtio1 and trtio2
c  03-07-07 EWL, add check for very low pcomp(i)
c  02-18-08 EWL, add check for icomp<>old icomp (icsav)
c  04-22-10 EWL, rename variables in PSTSAV
c  11-29-12 EWL, in inner loop, if density from TPRHO is out range, exit after 10 iterations
c
cx DEC$ ATTRIBUTES DLLEXPORT :: SATP
c
      include 'commons.for'
      character*255 herr,herr2,herr3
      dimension x(ncmax),xliq(ncmax),xvap(ncmax),x2org(ncmax)
      dimension x2(ncmax),f1(ncmax),f2(ncmax),x2new(ncmax)
      dimension tk(4),ft(3)                  !used for T iteration
c
      iaga=0
      call ISPURE (x,icomp)
      ierr=0
      rho1=0
      rho2=0
      herr=' '
      herr2=hnull
      if (lsatp) then
        if (ABS(p-psavp).lt.1.d-9 .and. kph.eq.kphsvp
     &          .and. p.gt.1.d-7) then
          lsame=.true.
          if (icomp.ne.icsavp) lsame=.false.
          if (icomp.eq.0) then
            do i=1,nc
              if (ABS(x(i)-xsavp(i)).gt.1.0d-9) lsame=.false.
            enddo
          endif
          if (lsame) then
            t=tsavp
            rhol=dlsavp
            rhov=dvsavp
            do i=1,nc
              xliq(i)=xlsavp(i)
              xvap(i)=xvsavp(i)
            enddo
            RETURN
          endif
        endif
      endif
c  set tolerance and maximum number of iterations
      tolr=1.0d-6
      itmax=100
      ft(1)=0.0d0  !initialize to avoid potential problem
      ft(2)=0.0d0  !when writing error message to GUI
c
c  initialize outputs in event of failure of routines
      t=300.0d0
      rhol=0.0d0
      rhov=0.0d0
      if (icomp.eq.0) then
        do i=1,nc
          xliq(i)=x(i)
          xvap(i)=x(i)
        enddo
      else
        do i=1,nc
          xliq(i)=0.d0
          xvap(i)=0.d0
        enddo
        xliq(icomp)=1.d0
        xvap(icomp)=1.d0
      endif
c
c  check if melting or sublimation line requested and call appropriate routines.
      if (kph.eq.3) then      !liquid/solid
        call MELTP (p,x,t,ierr2,herr2)
        rhol=dtpn(1)
        if (t.gt.0.d0) call TPRHO (t,p,x,1,1,rhol,ierr,herr)
        if (ierr.eq.0) then
          ierr=ierr2
          herr=herr2
        endif
        goto 900
      else if (kph.eq.4) then      !vapor/solid
        call SUBLP (p,x,t,ierr2,herr2)
        if (t.gt.0.d0) then
          rhov=p/(R*t)
          if (rhov.lt.1.d10) call TPRHO (t,p,x,2,1,rhov,ierr,herr)
        endif
        if (ierr.eq.0) then
          ierr=ierr2
          herr=herr2
        endif
        goto 900
      end if
c
      call CRITP (x,tc,pc,rhoc,ierr,herr2)
      if (ierr.gt.0) then
c  error condition--set outputs, issue warning, and return
        ierr=140
        write (herr,1140) herr2(1:237),hnull
 1140   format ('[SATP error 140] ',a237,a1)
        call ERRMSG (ierr,herr2)
        RETURN
      end if
c
c  check that input conditions (in this case p and x) are within limits
c
      Ddum=0.0d0
      tdum=0.8d0*tc
      call LIMITX ('EOS',tdum,Ddum,p,x,tmin,tmax,rhomax,pmax,ierr,herr2)
c     write (*,*) ' SATP--density limit:  ',rhomax
      if (ierr.gt.1) then     !ignore ierr = 1 (t out of range)
c  p and/or x are out of bounds, set error flag and return
        t=0.8d0*tc
        write (herr,1000) ierr,herr2(1:238),hnull
 1000   format ('[SATP error',i3,'] ',a238,a1)
        call ERRMSG (ierr,herr)
        RETURN
      end if
c
      if (icomp.ne.0) then
        if (p.lt.ptpn(icomp)) then
          call SUBLP (p,x,t,ierr,herr)        !vapor/solid
          if (t.gt.0.d0) then
            rhov=p/(R*t)
            if (rhov.lt.1.d10) call TPRHO (t,p,x,2,1,rhov,ierr3,herr3)
            goto 900
          endif
          ierr=2
          t=ttpn(icomp)
          write (herr,1149) p/1000.0d0,ptpn(icomp)/1000.0d0,hnull
          call ERRMSG (ierr,herr)
 1149     format ('[SATP error 2] ',
     &            'pressure less than triple point pressure; P =',
     &          g12.5,' MPa, Ptp =',g12.5,' MPa.',a1)
          RETURN
        endif
      endif
c
      if (p/pc.ge.0.99999999d0 .and. icomp.ne.0) then
c  input pressure is equal to or greater than critical point value,
c  return critical parameters for output temperature and densities
c  output compositions initialized above
        t=tc
        rhol=rhoc
        rhov=rhoc
        if (p/pc.gt.1.000001d0) then
c  supercritical pressure as input, set error flag and return
c  critical parameters for output pressure and densities
          ierr=141
          write (herr,1141) p/1000.0d0,pc/1000.0d0,hnull
          call ERRMSG (ierr,herr)
 1141     format ('[SATP error 141] ',
     &            'pressure input to saturation routine is ',
     &            'greater than critical pressure; P =',g12.5,
     &            ' MPa, Pcrit =',g12.5,' MPa.',a1)
        end if
        RETURN
      end if
c
      if (heos.eq.'AGA') then
        heos='HMX'
        iaga=1
      endif
C
      if (icomp.eq.0 .and. iSatFlg.eq.0) then
        iGue=0
        call SATTP (t,p,x,kph+2,iGue,d,rhol,rhov,xliq,xvap,q,ierr,herr)
        if (ierr.eq.0) goto 900
      endif
c
      if (icomp.ne.0) then
c
c  pure fluid iteration
        do i=1,nc
          xliq(i)=0.d0
          xvap(i)=0.d0
        enddo
        xliq(icomp)=1.d0
        xvap(icomp)=1.d0
c
c  Iterate for saturated liquid and vapor states given pressure using
c  a simple successive substitution method.  The independent variable
c  in the iteration is the temperature.  The convergence criteria is
c  equality of Gibbs free energy in both phases.
c
c  generate initial guess using acentric factor
c
        t=tc/(1.0-0.428571*log10(p/pc)/(1.0+accen(icomp)))
c       write (*,*) 'SATP:  T(0): ',t
c
c  assume nothing about densities on initial calls to TPRHO
        kguess=0
        if (p.gt.0.98*pc) then
c  for near-critical states, generate initial guesses for density;
c  using correlation developed by E.W. Lemmon, NIST
          theta=(1-p/pc)*(1.6d0-accen(icomp))
          t=tc*(1.0d0-0.103947d0*theta-4.108265d-2*theta**2)
          theta=(1-p/pc)**(1.0d0/3.0d0)*(3.0d0+accen(icomp))
          rhov=rhoc*(1.0d0-0.290039d0*theta-7.120197d-3*theta**2)
          rhol=rhoc*(1.0d0+0.298544d0*theta+1.870808d-2*theta**2)
          kguess = 1
        endif
        if (hpsk(icomp).ne.' ' .and. hpsk(icomp).ne.'NBS') then
          call TSATP (p,x,tt,ierr,herr)
          if (tt.gt.0.) t=tt
        endif
        if (hplk(icomp).ne.' ' .and. hplk(icomp).ne.'NBS'
     &                         .and. kph.eq.1) then
          call TSATPL (p,x,tt,ierr,herr)!Get liquid pressure for mixtures
          if (tt.gt.0.) t=tt
        endif
        if (hdlk(icomp).ne.' ' .and. hdlk(icomp).ne.'NBS') then
          kguess=1
          call DLSATK (icomp,t,rhol,ierr,herr)
        endif
        if (hdvk(icomp).ne.' ' .and. hdvk(icomp).ne.'NBS') then
          kguess=1
          call DVSATK (icomp,t,rhov,ierr,herr)
        endif
        stp=1.0002d0
        if (ianc(icomp).eq.1 .and. kph.eq.2) then
          call TPRHO (t,p,x,2,kguess,rhov,ierr,herr) !find vapor density
          rhol=rhov   !Don't return liquid density for equilibrium phase
          goto 900    !For pseudo-pure fluid, stop here
        elseif (ianc(icomp).eq.1) then
          call TPRHO (t,p,x,1,kguess,rhol,ierr,herr)!find liquid density
          rhov=rhol   !Don't return vapor density for equilibrium phase
          goto 900    !For pseudo-pure fluid, stop here
        endif
        do 200 it=1,itmax
        call TPRHO (t,p,x,1,kguess,rhol,ierr,herr2) !find liquid density
        if (ierr.ne.0 .or. rhol.lt.rhoc) then
          t=t/stp
          stp=1.0d0+(stp-1.0d0)/1.2d0
          goto 200
c         herr=' ERROR from SATP:  '//herr2
c         call ERRMSG (ierr,herr)
c         RETURN
        end if
        call TPRHO (t,p,x,2,kguess,rhov,ierr,herr2)  !find vapor density
        if (ierr.ne.0 .or. rhov.gt.rhoc) then
          t=t*1.001d0
          if (t.gt.tc) t=t/1.001d0*1.00005d0
          if (rhov.gt.rhoc) rhov=rhoc/2.0d0
          goto 200
c         herr=' ERROR from SATP:  '//herr2
c         call ERRMSG (ierr,herr)
c         RETURN
        end if
c  use previous densities as initial guesses for calls to TPRHO after
c  first iteration
        kguess=1
c       call GIBBS (t,rhol,x,Aliq,Gliq)
c       call GIBBS (t,rhov,x,Avap,Gvap)
        call AG (t,rhol,x,Aliq,Gliq)
        call AG (t,rhov,x,Avap,Gvap)
        call ENTRO (t,rhol,x,sliq)
        call ENTRO (t,rhov,x,svap)
        ZG=Gliq-Gvap
c       write (*,1014) it,p,rhol,rhov,t,Gliq,Gvap,ZG
c1014   format (1x,'SATP:',i4,e14.6,2f12.8,f10.5,2f12.4,e14.6)
c
c  check convergence
c
        delt=ZG/(sliq-svap)
        if (abs(delt).lt.tolr) then
c  pure component iteration is done (make use of current delt)
          t=t+delt
          call TPRHO (t,p,x,1,kguess,rhol,ierr,herr2) !find liq density
          if (ierr.ne.0 .or. t.gt.tc .or. rhol.lt.rhoc) then
            ierr=142
            write (herr,1142) it,herr2(1:142),hnull
 1142       format ('[SATP error 142] liquid density iteration in ',
     &            'saturation routine did not converge for temperature',
     &            ' iteration',i3,'; ',a142,a1)
            call ERRMSG (ierr,herr)
c  return critical parameters if not converged and very close to Pc
            if (p.gt.0.9999*pc) then
              t=tc
              rhol=rhoc
              rhov=rhoc
            end if
            goto 300
c           RETURN
          end if
          call TPRHO (t,p,x,2,kguess,rhov,ierr,herr2) !find vap density
          if (ierr.ne.0 .or. p.gt.pc .or. rhov.gt.rhoc) then
            ierr=143
            write (herr,1143) it,herr2(1:143),hnull
 1143       format ('[SATP error 143] vapor density iteration in ',
     &            'saturation routine did not converge for temperature',
     &            ' iteration',i3,'; ',a143,a1)
            call ERRMSG (ierr,herr)
c  return critical parameters if not converged and very close to Pc
            if (p.gt.0.9999*pc) then
              t=tc
              rhol=rhoc
              rhov=rhoc
            end if
            goto 300
c           RETURN
          end if
c  !debug--next four lines for debug only
c         call GIBBS (t,rhol,x,Aliq,Gliq)
c         call GIBBS (t,rhov,x,Avap,Gvap)
c         ZG=Gliq-Gvap
c         write (*,1015) it,p,rhol,rhov,t,Gliq,Gvap,ZG
c1015   format (1x,'SATP:',i4,e14.6,2f12.8,f10.5,2f12.4,e14.6)
          ierr=0
          herr=' '
          goto 900         !normal termination for pure fluid
        end if
c
c  continue iteration, define next guess (check that delt
c  will not result in too large a change in temperature)
        if (delt.gt.0.5*t) then
          do j=1,100
c           write (*,1198) t,delt
c1198       format (1x,'% SATP advisory; delt > 0.5*t; t,delt:',2f12.6)
            delt=0.25*delt
            if (delt.lt.0.5*t) goto 110
          enddo
        end if
 110    continue
        t=t+delt
c
 200    continue
c
c  In case of failure, try calling SATT iteratively to find the saturated
c  temperature.  This takes advantage of the alternate method in SATT used
c  at temperatures very close to the critical point.
 300    continue
        i=0
        t1=tc*.999d0
        call SATT (t1,x,kph,p1,rhol,rhov,xliq,xvap,ierr,herr)
        t2=tc*.9995d0
 310    continue
        call SATT (t2,x,kph,p2,rhol,rhov,xliq,xvap,ierr,herr)
        t=t2
        if (ABS(p2-p).lt.tolr .and. ierr.eq.0) goto 900  !Convergence
        i=i+1
        if (ABS(p2-p1).lt.1.d-12) goto 320
        if (i.gt.20) goto 320
        t=t1-(p1-p)/(p2-p1)*(t2-t1)
        if (t.gt.tc .and. t2.gt.t1) t=(t2+tc)/2.d0
        if (t.gt.tc .and. t1.gt.t2) t=(t1+tc)/2.d0
        t1=t2
        p1=p2
        t2=t
        goto 310
c
c  iteration has not converged
 320    continue
        ierr=144
        write (herr,1144) p/1000.0d0,hnull
 1144   format ('[SATP error 144] ',
     &          'iteration for saturation state did not converge; ',
     &          'P =',g12.5,' MPa.',a1)
        call ERRMSG (ierr,herr)
c  return critical parameters if not converged and very close to Tc
        if (p.gt.0.9999*pc) then
          t=tc
          rhol=rhoc
          rhov=rhoc
        end if
        goto 900
c
c  end of pure fluid iteration
c
      else
c
c  begin mixture iteration
c
c  Iterate for the temperature and the composition of the incipient
c  phase (vapor phase for a bubble point calculation, liquid for dew
c  point) given pressure and the composition of the parent phase.
c  Iteration is generally based on the algorithm given by Van Ness
c  & Abbott (Classical Thermodynamics of Nonelectrolyte Solutions with
c  Applications to Phase Equilibria, McGraw-Hill, 1982); convergence
c  criteria is the equality of fugacity for each component in both
c  phases.
c
        call SATPEST (p,x,kph,t,x2,ierr,herr)
        j=2
        tk(j)=t
        if (kph.eq.1) then
c  bubble point
c  variable kph2 specifies the state of the incipient phase (x2): 1=liq, 2=vap
c  trtio is temperature multiplier to use when TPRHO does not converge;
c  different values for liquid and vapor phases, such that new guess
c  is further into corresponding single-phase region
          kph2=2
          trtio1=0.995d0
          trtio2=0.998d0
        else
c  dew point
          kph2=1
          trtio1=1.005d0
          trtio2=1.002d0
        end if
c
c  initial temperature (satisfying Raoult's law) has been found,
c  check that this temperature is not above critical
        tmax=0.998d0*tc
        if (tk(j).gt.tmax .or. tk(j).le.0) tk(j)=tmax
c
c  the following line adjusts the initial guess for ammonia/water mixtures
c  allowing the saturation routines to work substantially better, especially in
c  the critical region.  It may work for other mixtures as well.
        if (iamwat.ne.0) tk(j)=tk(j)*1.05d0
c
c  generate initial guesses for densities & incipient phase composition;
c  the do loop allows for the possibility that TPRHO does not converge,
c  it should normally exit with just one pass
c
        do it=1,itmax
          t=tk(j)
c  first guess for densities (separate flags for each phase)
          kgues1=0
          kgues2=0
          call TPRHO (t,p,x,kph,kgues1,rho1,ierr,herr2)     !parent phase
          kgues1=1
          if (ierr.gt.0) then
            kgues1=0             !do not reuse faulty density as guess
            ierr=-145
            write (herr,1145) herr2(1:146),hnull
 1145       format ('[SATP advisory -145] density iteration in ',
     &            'saturation routine did not converge for the parent',
     &            ' phase; ',a146,a1)
            call ERRMSG (ierr,herr)
            if (t.gt.0.8*tc .and. kph.eq.1) then
c   non-convergence probably because too close to critical
              tnew=0.995*t
            else
              tnew=1.005*t
            end if
            tk(j)=tnew
          else
            call TPRHO (t,p,x2,kph2,kgues2,rho2,ierr,herr2) !incipient ph
            kgues2=1
            if (ierr.gt.0) then
              kgues2=0             !do not reuse faulty density as guess
              ierr=-144
              write (herr,1146) herr2(1:146),hnull
 1146         format ('[SATP advisory -146] density iteration in ',
     &              'saturation routine did not converge for the ',
     &              'incipient phase; ',a146,a1)
              call ERRMSG (ierr,herr)
              if (t.gt.0.8*tc .and. kph2.eq.1) then
c   non-convergence probably because too close to critical
                tnew=0.995*t
              else
                tnew=1.005*t
              end if
              tk(j)=tnew
            else
              goto 550   !both parent and incipient phases have converged
            end if
          end if
        enddo

c
c  main outer iteration loop for mixtures
c  loop for temperature, using Raoult's Law result (above) as first guess
c
 550    continue
c
        t=tk(j)
        do i=1,nc
          if (kph.eq.1) then
            xvap(i)=x2(i)
          else
            xliq(i)=x2(i)
          endif
        enddo
c
        x2sum=0.0d0
        ltpos=.false.         !flags for reguli-falsi iteration
        ltneg=.false.
        tneg=0.0d0
        tpos=0.0d0
        ftneg=0.0d0
        ftpos=0.0d0
        do ii=1,nc
          x2org(ii)=x2(ii)
        enddo
c       write (*,*) ' SATP--start main iteration; j,tk(j):  ',j,tk(j)
        tk(1)=tk(j)           !first guess for temperature from above
        j=1                   !reset iteration flag
        kguess=0              !for first calls to TPRHO
        do 400 itt=1,itmax
        if (int(itt/10)*10.eq.itt .and. itt.gt.30) then
          trtio1=trtio1**2
          trtio2=trtio2**2
        endif
        t=tk(j)
        lx2con=.false.        !flag for convergence of inner loop
c  compute density and fugacities for parent phase
c       write (*,*) ' SATP call TPRHO (parent) for it,T = ',itt,t
        call TPRHO (t,p,x,kph,kguess,rho1,ierr,herr2)   !parent phase
        if (itt.ne.1) then
          if (ABS(rho1-rhoc).lt.1 .and. ABS(rho2-rhoc).gt.4) then
c  jump away from critical point when a bad root was found
            rho1=rho1*1.5d0
            call TPRHO (t,p,x,kph,kguess,rho1,ierr,herr2)
          endif
        endif
        kgues1=1
        if (ierr.gt.0) then
          kgues1=0             !do not reuse faulty density as guess
          ierr=-145
          write (herr,1245) itt,herr2(1:146),hnull
 1245     format ('[SATP advisory -145] density iteration in ',
     &            'saturation routine did not converge for temperature',
     &            ' iteration',i3,'; ',a146,a1)
          tk(j)=tk(j)*trtio1  !try another temperature and use up one
          goto 400             !iteration (to prevent infinite loop)
        else if (rho1.gt.1.1d0*rhomax) then
c  density from TPRHO is out of range, reset
          rho1=rhomax
          ierr=-145
          write (herr,1245) itt,herr2(1:146),hnull
        end if
        call FGCTY2 (t,rho1,x,f1,ierr,herr)
c       write (*,1082) itt,t,p,rho1,(x(i),i=1,2),(f1(i),i=1,2)
c1082   format (1x,' SATP--phase 1:  ',i3,f11.5,2e14.6,2e16.8,2e18.10)
c
c  begin inner iteration loop for composition of phase 2
c
        do itx=1,itmax*2
c  compute density and fugacities for phase 2
          call TPRHO (t,p,x2,kph2,kguess,rho2,ierr,herr2) !incipient phase
          kgues2=1
          if (ierr.gt.0 .or. ABS(rho2-rho1).lt.0.01d0 .or.
     &       (rho2.lt..01d0 .and. kph2.eq.1)) then
            kgues2=0             !do not reuse faulty density as guess
            ierr=-146
            write (herr,1246) itx,herr2(1:146),hnull
 1246       format ('[SATP advisory -146] density iteration in ',
     &            'saturation routine did not converge for composition',
     &            ' iteration',i3,'; ',a146,a1)
            do ii=1,nc
              x2(ii)=x2org(ii)
            enddo
            kguess=0
            tk(j)=tk(j)/trtio2   !try another pressure and use up one
            goto 400             !iteration (to prevent infinite loop)
          else if (rho2.gt.1.2*rhomax) then
c  density from TPRHO is out of range, reset
            rho2=rhomax
            ierr=-146
            write (herr,1246) itt,herr2(1:146),hnull
            if (itx.gt.10) goto 700
          end if
          call FGCTY2 (t,rho2,x2,f2,ierr,herr)
c       write (*,1086) itx,rho2,(x2(i),i=1,2),(f2(i),i=1,2)
c1086   format (1x,'       phase 2:  ',i3,25x,e14.6,2e16.8,2e18.10)
c  calculate new x2's by ratio of fugacities; inner loop has converged
c  when x2's change by less than a convergence tolerance
          x2sum=0.0d0
          do i=1,nc
            if (x2(i).gt.0.d0) then
            if (f2(i).gt.1.0d-20 .and. f1(i).gt.0.0d0) then
              x2new(i)=x2(i)*f1(i)/f2(i)
            else
c  in case fugacity is zero; e.g., if x(i)=0 x2(i) does not change
              x2new(i)=x2(i)+0.0001d0 !add a little to keep x2sum<>1
            end if
            x2sum=x2sum+x2new(i)
            endif
          enddo
c  normalize the x2 compositions; this yields next guess for x2 and
c  ensures that the x2 always sum to one
          sumdel=0.0d0
          do i=1,nc
            if (x2(i).gt.0.d0) then
            x2new(i)=x2new(i)/x2sum
            sumdel=sumdel+abs(x2(i)-x2new(i))  !change in compositions
            x2(i)=x2new(i)
            endif
          enddo
          if (sumdel.lt.tolr) then
c  inner iteration loop has converged
            lx2con=.true.
            goto 700
          end if
c  if not, continue inner iteration loop
        enddo
c  inner iteration loop has not converged
        ierr=-147
        write (herr,1147) p/1000.0d0,sumdel,hnull
 1147   format ('[SATP advisory -147] ',
     &          'iteration for composition in saturation routine ',
     &          'did not converge; P =',g12.5,
     &          ' MPa; deltaX =',g12.5,' mol frac.',a1)
        call ERRMSG (ierr,herr)
c
c  end of inner (x2) iteration loop
c
 700    continue
        ft(j)=1.0d0-x2sum
c  outer (temperature) loop has converged when the x2's sum to one, i.e.,
c  when the fugacities of each component in each phase are equal
        if (abs(ft(j)).lt.tolr .and. ierr.ne.-147) then
          goto 850
        else
c  provided that the inner loop has converged, update positive and
c  negative bounds on pressure for possible use in reguli-falsi iteration
          if (lx2con) then
            if (ft(j).lt.0.0d0) then
              ltneg=.true.
              tneg=tk(j)
              ftneg=ft(j)
            else
              ltpos=.true.
              tpos=tk(j)
              ftpos=ft(j)
            end if
          end if
        end if
c
c  compute new guess for saturation temperature
c
        if (j.eq.1) then
c  for first iteration, new temperature is ratio of old
          j=2
          kguess=1    !use previous density as initial guess to TPRHO
c  ratio for next guess of temperature; the 0.10d0 is adjustable
          tnew=1.0d0+0.10d0*(x2sum-1.0d0)
c         write (*,*) ' PSAT--x2sum,tnew:  ',x2sum,tnew
          if (kph.eq.1) then
c  bubble point
            tk(2)=tk(1)/tnew
          else
c  dew point
            tk(2)=tk(1)*tnew
          end if
        else
c  subsequent iterations--use secant method, check for divide by zero
          if (ABS(ft(2)-ft(1)).lt.1.0d-10) then
            tk(3)=0.5*(tk(1)+tk(2))
          else
            tk(3)=tk(2)-ft(2)*(tk(2)-tk(1))/(ft(2)-ft(1))
          end if
c  check that new temperature is not outside bounds, if so use reguli-falsi
          if (ltneg .and. ltpos .and. (tk(3).gt.MAX(tpos,tneg)
     &        .or. tk(3).lt.MIN(tpos,tneg))) then
            tk(3)=tpos-ftpos*(tpos-tneg)/(ftpos-ftneg)
          end if
          if (tk(3).lt.0) tk(3)=tk(2)*.95d0
          if (tk(3).gt.tc*1.5d0) tk(3)=tk(2)*1.05d0
c         write (*,1137) tk(1),tk(2),tk(3),yyyyy,ft(2)
c1137     format (1x,' SATP--tguess_1,2,3; ft_1,2:  ',5e14.6)
c  discard oldest iteration
          tk(1)=tk(2)
          tk(2)=tk(3)
          ft(1)=ft(2)
        end if
 400    continue
c  outer iteration loop has not converged
        ierr=148
        write (herr,1148) p/1000.0d0,hnull
 1148   format ('[SATP error 148] ',
     &          'iteration for saturation state did not converge; P =',
     &          g12.5,' MPa.',a1)
        call ERRMSG (ierr,herr)
c
c  end of outer (temperature) iteration loop
c
 850    continue
c
c  assign final compositions and densities for parent and incipient
c  phases (x and x2, rho1 and rho2, respectively) to outputs
c
        t=tk(j)
        if (kph.eq.1) then
c  bubble point
          rhol=rho1
          rhov=rho2
          do i=1,nc
            xliq(i)=x(i)
            xvap(i)=x2(i)
          enddo
        else
c  dew point
          rhol=rho2
          rhov=rho1
          do i=1,nc
            xliq(i)=x2(i)
            xvap(i)=x(i)
          enddo
        end if
        call DPDD (t,rhol,xliq,dpdrh1)
        call DPDD (t,rhov,xvap,dpdrh2)
        if (dpdrh1.gt.1.0d6 .or. dpdrh2.gt.1.0d6) then
          ierr=148
          write (herr,1148) p/1000.d0,hnull
          call ERRMSG (ierr,herr)
        endif
        if ((rhol.gt.rhoc .and. rhov.gt.rhoc) .or.
     &      (rhol.lt.rhoc .and. rhov.lt.rhoc)) then
c  for some mixtures, both rhol and rhov can be greater than rhoc, so
c  check for p close to pc first before returning error
          if (p.lt.0.95d0*pc .or. icomp.ne.0 .or. kph.eq.2) then
            ierr=148
            write (herr,1148) p/1000.d0,hnull
            call ERRMSG (ierr,herr)
          endif
        endif
c  call new routine SATTP if ierr>0 and attempt to get convergence
c       if (ierr.gt.0 .and. icomp.eq.0 .and. iSatFlg.eq.0) then
c         call SATTP(t,p,x,kph+2,0,d,rhol,rhov,xliq,xvap,q,ierr,herr)
c       endif
c
c  end of mixture iteration
      end if
c
c  save results
 900  continue
      if (ierr.eq.0) then
        tsavp=t
        psavp=p
        icsavp=icomp
        kphsvp=kph
        dlsavp=rhol
        dvsavp=rhov
        if (icomp.eq.0) then
          do i=1,nc
            xsavp(i)=x(i)
            xlsavp(i)=xliq(i)
            xvsavp(i)=xvap(i)
          enddo
        else
          do i=1,nc
            xsavp(i)=0.d0
            xlsavp(i)=0.d0
            xvsavp(i)=0.d0
          enddo
          xsavp(icomp)=1.d0
          xlsavp(icomp)=1.d0
          xvsavp(icomp)=1.d0
        endif
        lsatp=.true.
      endif
      if (iaga.eq.1) then
        heos='AGA'
        if (ierr.eq.0) call TPRHO (t,p,xvap,2,1,rhov,ierr,herr)
      endif
      RETURN
c
      end                                               !subroutine SATP
c
c ======================================================================
c
      subroutine SATPEST (p,x,kph,t,x2,ierr,herr)
c
c  estimate initial values for saturation states given pressure
c  and the composition of one phase
c
c  inputs:
c        p--pressure [kPa]
c        x--composition [array of mol frac] (phase specified by kph)
c      kph--phase flag: 1 = input x is liquid composition (bubble point)
c                       2 = input x is vapor composition (dew point)
c  outputs:
c        t--estimated temperature [K]
c       x2--estimated composition of unknown phase [array of mol frac]
c
c  written by E.W. Lemmon, NIST Thermophysics Division, Boulder, Colorado
c  08-06-09 EWL, original version, taken from code in SATP
c  08-06-09 EWL, remove the check on pcomp(i)<10.  The impact of this may not be good for all situations.
c
cx DEC$ ATTRIBUTES DLLEXPORT :: SATPEST
c
      include 'commons.for'
      dimension x(ncmax),x2(ncmax),pcomp(ncmax)
      dimension tk(4),ft(3)                  !used for T iteration
      character*255 herr
c
      ltpos=.false. !flags for reguli-falsi iteration
      ltneg=.false.
      tneg=0.d0
      tpos=0.d0
      ftneg=0.d0
      ftpos=0.d0
      tolr=1.0d-6
      itmax=100
      j=1                     !flag for first iteration
c
c  generate initial guess using Raoult's law,
c  first generate initial guess for temperature by simple ratio of
c  pure component saturation temperatures
      tk(1)=0.d0
      acf=0.d0              !average acentric factor
      do i=1,nc
        ti=tcrit(i)/(1.0-0.428571*log10(p/pcrit(i))/(1.0+accen(i)))
c         write (*,*) ' SATP:  tsat-guess for component ',i,ti
        tk(1)=tk(1)+x(i)*ti
        acf=acf+x(i)*accen(i)
      enddo
      tzero=tk(1)  !save in case Raoult iteration does not converge
c
c  secant method iteration to find t which satisfies Raoult's law
c
      do it=1,itmax
c  approximate pure component vapor pressures with acentric factor
      do i=1,nc
        pxp=-2.333333*(1.0+accen(i))*(tcrit(i)/tk(j)-1.0)
        if (ABS(pxp).lt.50) pcomp(i)=pcrit(i)*10.0**pxp
c       if (pcomp(i).lt.10.) pcomp(i)=10.d0
      enddo
c
      if (kph.eq.1) then
c  bubble point
        psum=0.d0
        do i=1,nc
          psum=psum+x(i)*pcomp(i)
        enddo
        ft(j)=1.d0-p/psum
        if (abs(ft(j)).lt.tolr) goto 500  !iteration has converged
c  update + & - bounds on temperature for possible use in reguli-falsi
        if (ft(j).lt.0.d0) then
          ltneg=.true.
          tneg=tk(j)
          ftneg=ft(j)
        else
          ltpos=.true.
          tpos=tk(j)
          ftpos=ft(j)
        end if
c  generate next guess
        if (it.eq.1) then
          tratio=1.d0-0.42857d0*log10(psum/p)/(1.d0+acf)
          tk(2)=tk(1)*tratio
          j=2
        else if (it.ge.itmax/3 .and. ltpos .and. ltneg) then
c  if iteration has not converged after many iterations, use bisection
c  (provided that guesses bounding the root are available)
          tk(2)=0.5d0*(tpos+tneg)
          tk(1)=tk(2)
          ft(1)=ft(j)
          j=2
        else
c  use secant method
          if (ABS(ft(2)-ft(1)).gt.1.0d-10) then
            tk(3)=tk(2)-ft(2)*(tk(2)-tk(1))/(ft(2)-ft(1))
          else
            tk(3)=0.5d0*(tk(1)+tk(2))
          end if
c  check that new temperature is not outside bounds, if so use reguli-falsi
          if (ltneg .and. ltpos .and. (tk(j+1).gt.MAX(tpos,tneg)
     &        .or. tk(j+1).lt.MIN(tpos,tneg))) then
            tk(j+1)=tpos-ftpos*(tpos-tneg)/(ftpos-ftneg)
          end if
          tk(1)=tk(2)
          tk(2)=tk(3)
          ft(1)=ft(2)
        end if
      else
c  dew point
        xdamp=1.d0     !damping ratio for secant method
        ypsum=0.d0
        do i=1,nc
          ypsum=ypsum+x(i)*p/pcomp(i)
          ft(j)=1.0-ypsum
        enddo
        if (ABS(ft(j)).lt.1.0d3*tolr) goto 500  !iteration has converged
c  update + & - bounds on pressure for possible use in reguli-falsi
        if (ft(j).lt.0.d0) then
          ltneg=.true.
          tneg=tk(j)
          ftneg=ft(j)
        else
          ltpos=.true.
          tpos=tk(j)
          ftpos=ft(j)
        end if
        if (it.eq.1) then
          tratio=1.d0/(1.0-0.42857*log10(ypsum)/(1.d0+acf))
          tk(2)=tk(1)*tratio
          j=2
        else if (it.eq.2) then
c  secant method for 2nd guess
            if (ABS(ft(2)-ft(1)).gt.1.0d-10) then
              tk(3)=tk(2)-xdamp*ft(2)*(tk(2)-tk(1))/(ft(2)-ft(1))
            else
              tk(3)=0.5d0*(tk(1)+tk(2))
            end if
c  check that new temperature is not outside bounds, if so use reguli-falsi
            if (ltneg .and. ltpos .and. (tk(j+1).gt.MAX(tpos,tneg)
     &          .or. tk(j+1).lt.MIN(tpos,tneg))) then
              tk(j+1)=tpos-ftpos*(tpos-tneg)/(ftpos-ftneg)
            end if
            j=3
        else if (it.le.itmax/3 .or. .not.(ltpos.and.ltneg)) then
c  2nd order secant (inverse quadratic interpolation) for subsequent guesses
c  see Numerical Recipes, p 252
          rr=ft(3)/ft(2)  !these are the R,S,T used in Num. Rec.
          rs=ft(3)/ft(1)
          rt=ft(1)/ft(2)
          rrst=(rt-1.d0)*(rr-1.d0)*(rs-1.d0)
          if (abs(rrst).gt.1.d-20) then
            tk(4)=tk(3)
     &       +rs*(rt*(rr-rt)*(tk(2)-tk(3))-(1.d0-rr)*(tk(3)-tk(1)))/rrst
          else
            tk(j+1)=-1.d0    !Fix so that reguli-falsi will kick in
          endif
c  check that new temperature is not outside bounds, if so use reguli-falsi
          if (ltneg .and. ltpos .and. (tk(j+1).gt.MAX(tpos,tneg)
     &        .or. tk(j+1).lt.MIN(tpos,tneg))) then
            tk(j+1)=tpos-ftpos*(tpos-tneg)/(ftpos-ftneg)
          end if
c  discard oldest iteration
          tk(1)=tk(2)
          tk(2)=tk(3)
          tk(3)=tk(4)
          ft(1)=ft(2)
          ft(2)=ft(3)
        else
c  if iteration has not converged by now, use bisection
          tk(2)=0.5d0*(tpos+tneg)
          tk(1)=tk(2)
          ft(1)=ft(j)
          j=2
        end if
      end if
c       write (*,1006) it,j,tk(j-1),tk(j),ft(j-1)
c1006   format (1x,' SATP Raoult''s: it,j,t1,t2,ft:',2i4,2f12.4,e16.7)
      enddo                                     !next trial for t
c
c  iteration has not converged, issue warning and proceed
      ierr=-144
      herr='[SATP advisory -144] Raoult''s law iteration (to '//
     &     'generate mixture initial guess) has not converged.'//
     &     hnull
      call ERRMSG (ierr,herr)
      if (ABS(ft(j)).lt.1.0d4*tolr .or. ABS(tk(j)-tk(j-1)).lt.1.d0) then
      else
c  if current guess is not even close go back to initial guess
        tk(j)=tzero
      end if
c
 500  continue

      psum=0.d0
      if (kph.eq.1) then
c  bubble point
        do i=1,nc
          psum=psum+x(i)*pcomp(i)
        enddo
        do i=1,nc
          x2(i)=x(i)*pcomp(i)/psum
        enddo
      else
c  dew point
        ysum=0.d0
        do i=1,nc
          ysum=ysum+x(i)/pcomp(i)
        enddo
        do i=1,nc
          x2(i)=x(i)/pcomp(i)/ysum
          psum=psum+x2(i)*pcomp(i)
        enddo
      end if
      t=tk(j)
      RETURN
c
      end                                            !subroutine SATPEST
c
c ======================================================================
c
      subroutine SATD (rho,x,kph,kr,t,p,rhol,rhov,xliq,xvap,ierr,herr)
c
c  iterate for temperature and pressure given a density along the
c  saturation boundary and the composition
c
c  inputs:
c      rho--molar density [mol/L]
c        x--composition [array of mol frac]
c      kph--flag specifying desired root for multi-valued inputs
c           has meaning only for water at temperatures close to its triple point
c          -1 = return middle root (between 0 and 4 C)
c           1 = return highest temperature root (above 4 C)
c           3 = return lowest temperature root (along freezing line)
c  outputs:
c        t--temperature [K]
c        p--pressure [kPa]
c     rhol--molar density [mol/L] of saturated liquid
c     rhov--molar density [mol/L] of saturated vapor
c     xliq--liquid phase composition [array of mol frac]
c     xvap--vapor phase composition [array of mol frac]
c       kr--phase flag: 1 = input state is liquid
c                       2 = input state is vapor in equilibrium with liq
c                       3 = input state is liquid in equilibrium with solid
c                       4 = input state is vapor in equilibrium with solid
c     ierr--error flag:   0 = successful
c                         2 = D > Dmax
c                         8 = x out of range
c                        10 = D and x out of range
c                       160 = CRITP did not converge
c                       161 = SATD did not converge
c     herr--error string (character*255 variable if ierr<>0)
c
c  N.B. kr = 3,4 presently working only for pure components
c
c  either (rhol,xliq) or (rhov,xvap) will correspond to the input state
c  with the other pair corresponding to the other phase in equilibrium
c  with the input state
c
c  written by M. McLinden, NIST Phys & Chem Properties Div, Boulder, CO
c  11-22-99  MM, original version
c  02-08-00 EWL, add pure fluid version using Maxwell criteria
c  02-28-00 EWL, add checks for water
c  08-13-02 EWL, add check for ierr<>0 in mixture routine
c  07-28-11 EWL, calculate rhov at Tc in vapor phase for mixtures to get ft(1)
c
cx DEC$ ATTRIBUTES DLLEXPORT :: SATD
c
      include 'commons.for'
      character*255 herr,herr1
      dimension x(ncmax),xliq(ncmax),xvap(ncmax)
      dimension tt(3),ft(2)
c
      iaga=0
      call ISPURE (x,icomp)
      ierr=0
      herr=' '
      t0=300.0d0
      p0=100.0d0
      call LIMITX ('EOS',t0,rho,p0,x,tmin,tmax,Dmax,pmax,ierr,herr1)
c  [don't care if t0 or p0 are out of bounds, only rho and x]
      if (ierr.ge.8 .or. rho.gt.Dmax .or. rho.le.0.0d0) then
        write (herr,1001) ierr,herr1(1:235),hnull
 1001   format ('[SATD error',i3,'] ',a235,a1)
        call ERRMSG (ierr,herr)
        RETURN
      end if
      call CRITP (x,tc,pc,rhoc,ierr,herr1)
      t=tc
      p=pc
      rhol=rhoc
      rhov=rhoc
      if (ierr.gt.0) then
c  error condition--set outputs, issue warning, and return
        ierr=160
        write (herr,1160) herr1(1:237),hnull
 1160   format ('[SATD error 160] ',a237,a1)
        call ERRMSG (ierr,herr1)
        RETURN
      end if
      if (ABS(rhoc-rho).lt.0.001d0 .and. icomp.ne.0) then
        kr=1
        RETURN
      endif
c  calculate density at triple point if not set
      if (icomp.ne.0 .and. dtpv(icomp).lt.1.d-15) THEN
        call SATT (ttpn(icomp),x,2,p1,rhol,rhov,xliq,xvap,ierr,herr)
        if (ierr.gt.0 .and. ttpn(icomp).lt.10.d0) then
          ierr=0   !Ignore for eos testing (ttp<10 K)
          rhov=1.d-10
        endif
        dtpv(icomp)=rhov
      endif
c  check if pure water
      iw=0
      rhow=55.504316185d0  !maximum liquid density from Pruss Eq.
      if (hcas(icomp).eq.'7732-18-5' .and. icomp.ne.0) then
        iw=1
        if (rho.lt.dtpn(icomp) .and. (kph.eq.-1 .or. kph.eq.3)) goto 210
        if (rho.gt.rhow .and. (kph.eq.-1 .or. kph.eq.1)) goto 210
      endif
c  determine region
      if (rho.lt.dtpv(icomp) .and. icomp.ne.0) then
        kr=4                         !vapor/solid
      elseif (rho.lt.rhoc) then
        kr=2                         !vapor
      elseif (iw.eq.1 .and. rho.lt.rhow .and. kph.ne.3) then   !water
        kr=1
      elseif (rho.gt.dtpn(icomp) .and. abs(dtpn(icomp)).gt.1.d-20
     &       .and. icomp.ne.0) then
        kr=3                         !liquid/solid
      else
        kr=1                         !liquid
      end if
c     write (*,*) 'SATD--initial phase:  ',kr
c
      if (heos.eq.'AGA') then
        heos='HMX'
        iaga=1
      endif
c
c  pure fluid VLE iteration
      if (icomp.ne.0 .and. kr.le.2 .and. kph.ne.-1
     &               .and. ianc(icomp).eq.0) then
        tol=1.0d-6
        itmax=20
c  estimate liquid density for any fluid
        if (d72l.lt.1.d-8) then
          t=0.72d0*tc
          call SATT (t,x,1,p,rhol,rhov,xliq,xvap,ierr,herr)
          d72l=rhol
          if (ianc(icomp).eq.1)
     &      call SATT (t,x,2,p,rhol,rhov,xliq,xvap,ierr,herr)
          d72v=rhov
        endif
        if (kr.eq.1) then
          d=rho/rhoc+(1.2d0-d72l/rhoc)*(rho-rhoc)/(d72l-rhoc)-1.d0
          t=9.272d0*LOG(d+1.0d0)-5.195d0*d
          t=tc*(1.0d0-t**(1.d0/0.337d0))
        elseif (kr.eq.2) then
          t=tc
          if (d72v.gt.0) then
            dx=LOG(d72v/rhoc)
            del=LOG(rho/rhoc)
            d=(3.5d0+dx)*(del/dx)**1.3d0-del
            t=0.5d0*LOG(d+1.0d0)-0.026d0*d**0.5D0
          endif
          if (t.lt.0) t=0
          t=tc/(1.d0+t**(1.d0/0.37d0))
        endif
c
        d1=0.001d0
        t2=t+0.00001d0
        stp1=1.00001d0
        stp2=1.00001d0
        do it=1,itmax
c  calculate pressure, if less than zero, increase t and try again
          call PRESS (t,rho,x,p)
          if (p.lt.0) then
            t=t*stp1
            stp1=1.0d0+(stp1-1.0d0)*1.5d0
            goto 140
          endif
          iii=iprnterr
          iprnterr=0
          call TPRHO (t,p,x,3-kr,0,rho2,ierr,herr)
          iprnterr=iii
c  calculate pressure, if error, decrease t and try again
          if (ierr.ne.0) then
            t=t/stp2
            stp2=1.0d0+(stp2-1.0d0)*2d0
            goto 140
          endif
          stp1=1.00001d0
          stp2=1.00001d0
c  use Maxwell criterion to generate next guess for t
          if (ABS(rho-rho2).gt.1d-11) then
            if (kr.eq.1) then
              rhol=rho
              rhov=rho2
            else
              rhol=rho2
              rhov=rho
            endif
            call AG (t,rho,x,a,g1)
            call AG (t,rho2,x,a,g2)
            call ENTRO (t,rho,x,s1)
            call ENTRO (t,rho2,x,s2)
            d2=d1
            if (ABS(s1-s2).gt.1d-11) d1=(g1-g2)/(s1-s2)
            if (ABS(d1-d2).gt.1d-11) f=-(t2-t)/(d2-d1)
            t2=t
            if (ABS(d1).le.tol) goto 900
            if (t+f*d1.le.0) then
              t=t*0.95d0
            else
              t=t+f*d1
            endif
          else
            t=t/stp1
          endif
        enddo
 140    continue
c  method failed (generally at very low temperatures in the liquid), try
c  alternate method:
c       write (*,*) 'Maxwell solution failed'
      endif
c
c  iterate for temperature using a combination of Newton's method
c  and reguli-falsi
c
      if (icomp.ne.0) then
        if (hmeltk(icomp).eq.'NBS' .and. rho.gt.dtpn(icomp)) then !no melt line
          ierr=2
          write (herr,1002) ierr,rho,dtpn(icomp),hnull
 1002     format('[SATD error',i3,'] density above triple-point density'
     &          ,'; D =',g12.5,' mol/L; Dtp =',g12.5,' mol/L',a1)
          call ERRMSG (ierr,herr)
          goto 900
        endif
        if (hsublk(icomp).eq.'NBS' .and. rho.lt.dtpv(icomp)) then !no subl line
          ierr=2
          write (herr,1003) ierr,rho,dtpv(icomp),hnull
 1003     format('[SATD error',i3,'] density below triple-point density'
     &          ,'; D =',g12.5,' mol/L; Dtp =',g12.5,' mol/L',a1)
          call ERRMSG (ierr,herr)
          goto 900
        endif
      end if
c
      tol=1.0d-7
      itmax=20
      rhowm=rhol
      if (kr.eq.3) then
        tt(1)=ttpn(icomp)
        rhol=dtpn(icomp)
        if (iw.eq.1) then !check for water
c  calculate p and d at slightly higher than the lowest possible temperature
          tt(1)=251.1650000001d0
          call MLTH2O (tt(1),p,p2)
        else
c  Call melting routine in case dtpn(1) is not exactly eq. to rho(ttrp)
          call MELTT (tt(1),x,p,ierr,herr)
        endif
        call TPRHO (tt(1),p,x,1,1,rhol,ierr,herr)
        ft(1)=log(rho/rhol)
      elseif (kr.eq.4) then
        tt(1)=ttpn(icomp)
        ft(1)=log(rho/dtpv(icomp))
      else
        tt(1)=tc
        ft(1)=log(rho/rhoc)
        if (kr.eq.2 .and. nc.gt.1) then  !For mixtures at Tc in the vapor phase, the value of rhoc is not correct
          call SATT (tc,x,kr,p,rhol,rhov,xliq,xvap,ierr,herr)
          if (ierr.eq.0 .and. rhov.gt.0) ft(1)=log(rho/rhov)
        endif
        if (iw.eq.1) then
          if (rho.ge.dtpn(icomp) .and. kph.eq.-1) then
            tt(1)=ttpn(icomp)
            ft(1)=log(dtpn(icomp)/rhoc)
          endif
        endif
      endif
c
c  generate second guess for temperature
c
      if (kr.eq.1) then
        tt(2)=0.85*tc
        if (iw.eq.1 .and. kph.eq.-1 .and. rho.ge.dtpn(icomp)) tt(2)=275
      else if (kr.eq.2) then
        tt(2)=0.75*tc
      else if (kr.eq.3) then
        tt(2)=0.85*tc
        if (iw.eq.1) tt(2)=273.16d0
      else if (kr.eq.4) then
        tt(2)=0.95*ttpn(icomp)
      end if
c
c  initialize iteration flags
c
      lneg=.false.
      lpos=.false.
      ltp=.false.      !flag indicating if SATT called at triple point
      tneg=0.0d0
      tpos=0.0d0
c  store variables for reguli-falsi
      if (ft(1).lt.0.0) then
        lneg=.true.
        tneg=tt(1)
      else
        lpos=.true.
        tpos=tt(1)
      end if
      jt=2
c
      do 200 it=1,itmax
      ierr=0
      if (kr.eq.1) then           !liquid
        call SATT (tt(jt),x,1,p,rhol,rhov,xliq,xvap,ierr,herr)
        if (rhol.gt.0.0d0) ft(jt)=log(rho/rhol)
      else if (kr.eq.2 .or. kr.eq.4) then      !vapor
        call SATT (tt(jt),x,kr,p,rhol,rhov,xliq,xvap,ierr,herr)
        if (rhov.gt.0) ft(jt)=log(rho/rhov)
      else if (kr.eq.3) then      !liquid/solid
        if (iw.eq.1) then !check for water
          call MLTH2O (tt(jt),p,p2)
          if (rho.lt.rhowm) p=p2
        else
          call MELTT (tt(jt),x,p,ierr,herr)
        endif
        kguess=1
        rhol=dtpn(icomp)
        call TPRHO (tt(jt),p,x,1,kguess,rhol,ierr,herr)
        if (rhol.gt.0) ft(jt)=log(rho/rhol)
      end if
      if (ierr.ne.0) then
        tt(jt)=0.999d0*tt(jt)
        goto 200
      endif
c     write (*,1999) it,jt,tt(jt),ft(jt)
c1999 format (1x,'% it,jt,t,ft: ',2i4,f9.4,f16.10)
c  check for convergence
      t=tt(jt)
      if (abs(ft(jt)).lt.tol) goto 900
c  store variables for reguli-falsi
      if (ft(jt).lt.0.0) then
        lneg=.true.
        tneg=tt(jt)
      else
        lpos=.true.
        tpos=tt(jt)
      end if
c  compute next guess for temperature
      if (jt.le.1) then
        jt=2
      else
        if (abs(ft(2)-ft(1)).gt.1.d-20)
     &  tt(3)=tt(2)-ft(2)*(tt(2)-tt(1))/(ft(2)-ft(1))
c  check if new guess is outside of bounds of previous guesses,
c  if so (and if upper and lower bounds are available) use
c  reguli-falsi
        if (lpos .and. lneg .and.
     &     (tt(3).gt.max(tpos,tneg) .or. tt(3).lt.min(tpos,tneg)))then
           tt(3)=0.5*(tpos+tneg)
c  check against triple point
        elseif (tt(3).lt.ttpn(icomp).and.icomp.ne.0 .and. iw.eq.0) then
          if (.not.ltp) then
            ltp=.true.
            tt(3)=ttpn(icomp)
          else if (tt(3).le.0.0d0) then
            tt(3)=0.5d0*tt(2)
          end if
        end if
        tt(1)=tt(2)
        tt(2)=tt(3)
        ft(1)=ft(2)
      end if
 200  continue
 210  continue
      p=pc
      t=tc
      rhol=rhoc
      rhov=rhoc
      ierr=161
      write (herr,1161) rho,hnull
 1161 format ('[SATD error 161] ',
     &        'iteration for saturation state given density did not ',
     &        'converge for D =',g12.5,' mol/L',a1)
      call ERRMSG (ierr,herr)
 900  continue
      if (iaga.eq.1) then
        heos='AGA'
        if (ierr.eq.0) call TPRHO (t,p,xvap,2,1,rhov,ierr,herr)
      endif
      RETURN
c
      end                                               !subroutine SATD
c
c ======================================================================
c
      subroutine SATH (h,x,kph,nroot,k1,t1,p1,d1,k2,t2,p2,d2,ierr,herr)
c
c  iterate for temperature, pressure, and density given enthalpy along
c  the saturation boundary and the composition
c
c  inputs:
c        h--molar enthalpy [J/mol]
c        x--composition [array of mol frac]
c      kph--flag specifying desired root
c           0 = return all roots along the liquid-vapor line
c           1 = return only liquid VLE root
c           2 = return only vapor VLE roots
c           3 = return liquid SLE root (melting line)
c           4 = return vapor SVE root (sublimation line)
c  outputs:
c    nroot--number of roots.  Value is set to one for kph=1,3,4 if ierr=0
c       k1--phase of first root (1-liquid, 2-vapor, 3-melt, 4-subl)
c       t1--temperature of first root [K]
c       p1--pressure of first root [kPa]
c       d1--molar density of first root [mol/L]
c       k2--phase of second root (1-liquid, 2-vapor, 3-melt, 4-subl)
c       t2--temperature of second root [K]
c       p2--pressure of second root [kPa]
c       d2--molar density of second root [mol/L]
c     ierr--error flag:   0 = successful
c                         2 = h < hmin
c                         4 = h > hmax
c                         8 = h > htrp (for subl input)
c                       160 = CRITP did not converge
c                       161 = SATH did not converge for one root
c                       162 = SATH did not converge for both roots
c     herr--error string (character*255 variable if ierr<>0)
c
c  The second root is always set as the root in the vapor at temperatures
c  below the maximum enthalpy on the vapor saturation line.  If kph is
c  set to 2, and only one root is found in the vapor (this occurs when h<hcrit)
c  the state point will be placed in k2,t2,p2,d2.  If kph=0 and this situation
c  occurred, the first root (k1,t1,p1,d1) would be in the liquid (k1=1, k2=2).
c
c  N.B. kph = 3,4 presently working only for pure components
c
c  written by E.W. Lemmon, NIST Phys & Chem Properties Div, Boulder, CO
c  02-22-00 EWL, original version
c  05-08-08 EWL, add iteration count to avoid endless loop
c  09-04-08 EWL, add check for water and adjust tmin to 273.16 K
c  01-04-11 EWL, add txmax=thmax to set txmax if hmax has already been found
c  03-07-11 EWL, increase tol when not converging (such as CO2 very near critical)
c  03-15-11 EWL, add check for h1>h2>h3 when determining hmax
c
cx DEC$ ATTRIBUTES DLLEXPORT :: SATH
c
      include 'commons.for'
      character*255 herr,herr1
      dimension x(ncmax),xliq(ncmax),xvap(ncmax)
      dimension tt(3),ft(2)
c
      call ISPURE (x,icomp)
      ierr=0
      ierr1=0
      iflag=0
      herr=' '
      k1=0
      t1=0
      p1=0
      d1=0
      k2=0
      t2=0
      p2=0
      d2=0
      nroot=0
      call MAXT (x,tmaxt,tmaxp,tmaxd,ierr,herr1)
      call CRITP (x,tc,pc,rhoc,ierr,herr1)
      if (ierr.gt.0) then
c  error condition--set outputs, issue warning, and return
        ierr=160
        write (herr,1160) herr1(1:237),hnull
 1160   format ('[SATH error 160] ',a237,a1)
        call ERRMSG (ierr,herr1)
        RETURN
      end if
c
c  calculate enthalpy at triple point if not set
      call LIMITS ('EOS',x,tmin,tmax,Dmax,pmax)
      if (ABS(htpl).lt.1.d-15) THEN
c  check for water
        if (hcas(icomp).eq.'7732-18-5' .and. icomp.ne.0) tmin=273.16d0
        t=tmin
        call SATT (t,x,1,p,rhol,rhov,xliq,xvap,ierr,herr)
        call ENTHAL (t,rhol,x,htpl)
        call ENERGY (t,rhol,x,etpl)
        if (icomp.eq.0 .or. ianc(icomp).eq.1) then
 100      continue
          call SATT (t,x,2,p,rhol,rhov,xliq,xvap,ierr,herr)
          if (ierr.gt.0 .and. t.lt.tc) then
            t=t+5
            goto 100
          endif
        endif
        call ENTHAL (t,rhov,x,htpv)
        call ENERGY (t,rhov,x,etpv)
      endif
      xtpl=htpl
      xtpv=htpv
      call ENTHAL (tc,rhoc,x,xc)
      if (ieflg.eq.1) then
        xtpl=etpl
        xtpv=etpv
        call ENERGY (tc,rhoc,x,xc)
      endif
c
c  find maximum enthalpy (or energy) along the saturated vapor dome
      xmax=hmax
      if (ieflg.eq.1) xmax=emax
      if (ABS(xmax).lt.1.d-15) THEN
        call EHMAXX (x,ieflg,xmax,tmax,ierr,herr)
      endif
      txmax=thmax
      if (ieflg.eq.1) txmax=temax
c
c  determine region
      if (kph.eq.3 .and. icomp.ne.0) then
        kphs=3                         !liquid/solid
      else if (kph.eq.4 .and. icomp.ne.0) then
        kphs=4                         !vapor/solid
      else
        if (h.lt.xc) then
          kphs=1                         !liquid
        else
          kphs=2                         !vapor
        end if
      endif
c     write (*,*) 'SATH--initial phase:  ',kphs
c
      if (h.gt.xtpv .and. kphs.eq.4) then
        ierr=8
        write (herr,1008) ierr,h,xtpv,hnull
 1008   format('[SATH error',i3,'] enthalpy greater than triple point'
     &     ,' value; h =',g12.5,' J/mol, max =',g12.5,' J/mol',a1)
        call ERRMSG (ierr,herr)
        RETURN
      endif
      if (h.lt.xtpl .and. kphs.ne.4) then
        ierr=2
        write (herr,1002) ierr,h,xtpl,hnull
 1002   format('[SATH error',i3,'] enthalpy below triple-point '
     &      ,'value; h =',g12.5,' J/mol, min =',g12.5,' J/mol',a1)
        call ERRMSG (ierr,herr)
        RETURN
      endif
      if (h.gt.xmax .and. kphs.ne.3) then
        ierr=4
        write (herr,1004) ierr,h,xmax,hnull
 1004   format('[SATH error',i3,'] enthalpy greater than maximum '
     &      ,'value; h =',g12.5,' J/mol, max =',g12.5,' J/mol',a1)
        call ERRMSG (ierr,herr)
        RETURN
      endif
c
c  iterate for temperature using a combination of Newton's method
c  and reguli-falsi
c
      tol=1.0d-6
      itmax=20
      if (kphs.eq.3) then
        tt(1)=tmin
        ft(1)=xtpl-h
      elseif (kphs.eq.4) then
        tt(1)=tmin
        ft(1)=xtpv-h
      else
        tt(1)=tc
        ft(1)=xc-h
c  Use values from Splines if set up by call to SATSPLN, should return the root with the higher temperature
        if (iSpline.ne.0 .and. ieflg.eq.0) then
          d=rhoc
          call SPLNROOT (nc+4,0,h,d,ierr,herr)
          call SPLNVAL (nc+1,0,d,t,ierr,herr)
          iflsh=1
          if (d.lt.rhoc) iflsh=2
          if (d.lt.rhoc .and. d.gt.tmaxd .and. tmaxd.ne.0) iflsh=-2
          call SATTP (t,p,x,iflsh,0,d,rhol,rhov,xliq,xvap,q,ierr,herr)
          call ENTHAL (t,d,x,hc)
          tt(1)=t
          ft(1)=hc-h
          if (iflsh.lt.0) kphs=iflsh
        endif
      endif
c
c  initialize iteration flags
c
 130  continue
      lneg=.false.
      lpos=.false.
      tpos=0
      tneg=0
c  store variables for reguli-falsi
      if (ft(1).lt.0.0) then
        lneg=.true.
        tneg=tt(1)
        if (abs(kphs).eq.2) then
          lpos=.true.
          tpos=txmax
        endif
      else
        lpos=.true.
        tpos=tt(1)
        if (abs(kphs).eq.2) then
          lneg=.true.
          tneg=txmax
        endif
      end if
c
c  generate second guess for temperature
c
      if (iSpline.ne.0) then
        tt(2)=tt(1)-0.1d0
      elseif (kphs.eq.1) then
        tt(2)=0.95*tc
      else if (abs(kphs).eq.2) then
        tt(2)=(tneg+tpos)/2.0d0
      else if (kphs.eq.3) then
        tt(2)=0.85*tc
      else if (kphs.eq.4) then
        tt(2)=0.95*tmin
      end if
      jt=2
c
      do it=1,itmax
      call SATT (tt(jt),x,kphs,p,rho,rhov,xliq,xvap,ierr,herr)
      if (abs(kphs).eq.2 .or. kphs.eq.4) rho=rhov
      call ENTHAL (tt(jt),rho,x,h1)
      if (ieflg.eq.1) call ENERGY (tt(jt),rho,x,h1)
      ft(jt)=h1-h
c     write (*,1999) it,jt,tt(jt),ft(jt)
c1999 format (1x,'% it,jt,t,ft: ',2i4,f9.4,f16.10)
c  check for convergence
      if (it.eq.10) tol=tol*10
      if (it.eq.15) tol=tol*10
      if (it.eq.18) tol=tol*10
      if (abs(ft(jt)).lt.tol) goto 160
c  store variables for reguli-falsi
      if (ft(jt).lt.0.0) then
        lneg=.true.
        tneg=tt(jt)
      else
        lpos=.true.
        tpos=tt(jt)
      end if
c  compute next guess for temperature
      if (abs(ft(2)-ft(1)).gt.1.d-20)
     &  tt(3)=tt(2)-ft(2)*(tt(2)-tt(1))/(ft(2)-ft(1))
c  check if new guess is outside of bounds of previous guesses,
c  if so (and if upper and lower bounds are available) use
c  reguli-falsi
      if (lpos .and. lneg .and.
     &  (tt(3).gt.max(tpos,tneg) .or. tt(3).lt.min(tpos,tneg))) then
        tt(3)=0.5*(tpos+tneg)
      elseif (tt(3).lt.tmin .and. kphs.ne.4) then
        tt(3)=tmin
      elseif (tt(3).le.tmin/10.0d0 .and. icomp.ne.0) then !subl check
        if (it.eq.1 .and. kphs.eq.4) then
          tt(3)=0.d0
        else
          goto 150
        endif
      endif
      tt(1)=tt(2)
      tt(2)=tt(3)
      ft(1)=ft(2)
      enddo
 150  continue
      if (ierr1.ne.161) then
        ierr=161
        ierr1=161
        write (herr,1161) h,nroot+1,hnull
 1161   format ('[SATH error 161] ',
     &         'iteration for saturation state did not ',
     &         'converge for h =',g12.5,' J/mol; root = ',i1,a1)
        herr1=herr
      else
        ierr=162
        write (herr,1162) h,hnull
 1162   format ('[SATH error 162] ',
     &         'iteration for saturation state did not ',
     &         'converge for both roots; h =',g12.5,' J/mol',a1)
      endif
      call ERRMSG (ierr,herr)
      tt(jt)=0
      p=0
      rho=0
 160  continue
      t=tt(jt)
      if (abs(kphs).eq.kph .or. kph.eq.0) then
        nroot=nroot+1
        if (iflag.eq.0) then
c  first root found, save values
          t1=t
          p1=p
          d1=rho
          k1=abs(kphs)
        else
c  second root found, save values
          t2=t
          p2=p
          d2=rho
          k2=abs(kphs)
          if (ierr.eq.0 .and. ierr1.ne.0) then
            ierr=ierr1
            herr=herr1
          endif
        endif
      endif
c  check if second root might exist
      if (h.gt.xtpv .and. h.lt.xmax .and. iflag.eq.0) then
c  only calculate second root if requested
        if (kph.eq.0 .or. kph.eq.2) then
          tt(1)=tmin
          ft(1)=xtpv-h
          kphs=2
          iflag=1
          if (iSpline.ne.0 .and. ieflg.eq.0) then
            d=0.01d0
            call SPLNROOT (nc+4,0,h,d,ierr,herr)
            call SPLNVAL (nc+1,0,d,t,ierr,herr)
            t=t+0.05d0  !Decrease slightly to bound root
            call SATTP (t,p,x,kphs,0,d,rhol,rhov,xliq,xvap,q,ierr,herr)
            call ENTHAL (t,d,x,hc)
            if (ieflg.eq.1) call ENERGY (t,d,x,hc)
            tt(1)=t
            ft(1)=hc-h
          endif
          goto 130
        endif
      endif
      RETURN
c
      end                                               !subroutine SATH
c
c ======================================================================
c
      subroutine MAXWELL (icomp,ts,ps,dl,dv,ierr,herr)
c
c  iterate for saturated liquid and vapor states of a pure fluid given temperature
c
c  inputs:
c    icomp--number of component
c       ts--temperature [K]
c       dl--initial guess for molar density [mol/L] of saturated liquid
c       dv--initial guess molar density [mol/L] of saturated vapor
c
c  outputs:
c       ps--saturation pressure [kPa]
c       dl--molar density [mol/L] of saturated liquid
c       dv--molar density [mol/L] of saturated vapor
c
c     ierr--error flag:   0 = successful
c                         1 = no convergence after kmax iterations
c     herr--error string (character*255 variable if ierr<>0)
c
c  written by Matthias Kunick, NIST Thermophysics Division, Boulder, Colorado
c  09-15-11  MK, original version
c
      include 'commons.for'
      dimension x(ncmax)
      character herr*255
      parameter (eps=1.d-4)
      parameter (kmax=50)
c
      ierr=0
      herr=' '
      dlsp=-1.d0
      dvsp=-1.d0
c
      if (tminfeq(icomp).lt.ttpn(icomp)) then
        tt=ttpn(icomp)
      else
        tt=tminfeq(icomp)
      endif
      tc  =tcfeq(icomp)
      rhoc=rhocfeq(icomp)
      qt=(ts-tt)/(tc-tt)
      vc=1.d0/rhoc
      dtl=dtpn(icomp)
      dtg=ptpn(icomp)/r/ttpn(icomp)
      vtl=1.d0/dtl*0.95d0   !<= vtr'
      vtg=1.d0/dtg*1.2d0    !>= vtr"
c
c --- start values for v1 and v2 -------------------------------------------
      v1=1.d0/dl
      v2=1.d0/dv
      v1ini=v1
      v2ini=v2
      if (v1ini.lt.vtl) vtl=v1ini*0.95D0
      if (v2ini.gt.vtg) vtg=v2ini*1.05D0
      k=0
c
c *** iteration algorithm ******************************************************
      do
        k=k+1
        dl=1.d0/v1
        dv=1.d0/v2
        call PRESS (ts,dl,x,p1)
        call AG    (ts,dl,x,a1,g)
        call DPDD  (ts,dl,x,alpha1)
        call PRESS (ts,dv,x,p2)
        call AG    (ts,dv,x,a2,g)
        call DPDD  (ts,dv,x,alpha2)
        alpha1=-alpha1*dl*dl
        alpha2=-alpha2*dv*dv
c
        is=0
        ierr1=0
        if (alpha1.gt.0.d0 .and. dlsp.lt.0.d0)
     &     call LIQSPNDL (t,x,dlsp,ierr1,herr)
        do while (alpha1.gt.0.d0) !Maxwell loop (liquid)
          is=is+1
          if (is.gt.10) goto 999
          if (ierr1.eq.0) then
            v1=1.d0/dlsp*0.995d0
          else
            v1=(vtl+v1)*0.5d0
          endif
          dl=1.d0/v1
          call DPDD (ts,dl,x,alpha1)
          alpha1=-alpha1*dl*dl
          if (alpha1.lt.0.d0) then
            call PRESS (ts,dl,x,p1)
            call AG (ts,dl,x,a1,g)
          end if
        end do
        is=0
        if (alpha2.gt.0.d0 .and. dvsp.lt.0.d0)
     &     call VAPSPNDL (t,x,dvsp,ierr1,herr)
        do while (alpha2.gt.0.d0) !Maxwell loop (vapor)
          is=is+1
          if (ierr1.eq.0) then
            v2=1.d0/dvsp*1.005d0
          else
            if (qt.gt.0.9d0) then
              v2=v2*1.005d0
              if (v2.gt.v2ini) v2=v2ini
            else
              v2=v2*1.2d0
            endif
            if (is.gt.10) v2=v2ini
          endif
          if (is.gt.20) goto 999
          dv=1.d0/v2
          call DPDD (ts,dv,x,alpha2)
          alpha2=-alpha2*dv*dv
          if (alpha2.lt.0.d0) then
            call PRESS (ts,dv,x,p2)
            call AG (ts,dv,x,a2,g)
          end if
        end do
c
        vdif=v2-v1
        pm=(a1-a2)/vdif
        if (dabs(vdif).lt.1.d-12 .or. k.gt.kmax) goto 999
        if (dabs(p1-p2)/p2.lt.eps) goto 998
c
        a=0.5d0*alpha1*(alpha1-alpha2)
        b=alpha1*(p1-p2-alpha2*(v1-v2))
        c=alpha2*(v1-v2)*(pm-p1)+0.5d0*(p1-p2)*(p1-p2)
        e=0.25d0*b*b/(a*a)-c/a
        if (e.le.1.d-10) then
          es=e*1.d12
          delv1=-0.5d0*b/a+
     &           dsign(1.d-6*dsqrt(dabs(es)),(alpha1-alpha2)/alpha2)
        else
          delv1=-0.5d0*b/a+dsign(dsqrt(dabs(e)),(alpha1-alpha2)/alpha2)
        end if
        delv2=(p1-p2+alpha1*delv1)/alpha2
c
c --- calculate new values for v1 and v2 -----------------------------------
        v1=v1+delv1
        v2=v2+delv2
        if (v1.gt.vc)  v1=0.9999d0*vc
        if (v1.lt.vtl) v1=vtl
        if (v2.lt.vc)  v2=1.0001d0*vc
        if (v2.ge.vtg) v2=vtg
        if (qt.lt.0.9d0 .and. v1.gt.v1ini*1.2d0) v1=(vtl+v1ini)*0.5d0
      end do

 998  ps=pm
      RETURN

 999  continue
      ps=-1.d0
      dl=-1.d0
      dv=-1.d0
      ierr=1
      write (herr,1)
    1 format('[MAXWELL error] no convergence')
c
      end                                            !subroutine MAXWELL
c
c ======================================================================
c
      subroutine EHMAXX (x,ieflag,ehmax,tehmax,ierr,herr)
c
c  find maximum enthalpy or energy on saturated vapor line.
c
c  inputs:
c        x--composition [array of mol frac]
c    ieflag--set to 0 for enthalpy, 1 for energy
c  outputs:
c    ehmax--maximum enthalpy or energy [J/mol]
c   tehmax--temperature at maximum enthalpy or energy [K]
c     ierr--error flag:   0 = successful
c     herr--error string (character*255 variable if ierr<>0)
c
c  written by E.W. Lemmon, NIST Phys & Chem Properties Div, Boulder, CO
c  06-15-11 EWL, original version, remove piece from SATH and place here
c  11-27-12 EWL, use values from Splines if available
c
      include 'commons.for'
      character*255 herr,herr1
      dimension x(ncmax),xliq(ncmax),xvap(ncmax)
      call MAXT (x,tmaxt,tmaxp,tmaxd,ierr,herr1)
      call CRITP (x,tc,pc,rhoc,ierr,herr1)
      call LIMITS ('EOS',x,tmin,tmax,Dmax,pmax)

c  Use values from Splines if set up by call to SATSPLN
      tinc=tc/10.d0
      if (iSpline.ne.0) then
        d=rhoc
        call SPLNROOT (nc+4,1,0.d0,d,ierr,herr)
        call SPLNVAL (nc+1,0,d,tt1,ierr,herr)
        tinc=1.d0
        tt1=tt1+tinc
      else
        tt1=tc-tinc
      endif
      ifirst=1
  10  continue
c  set up initial three points
      call SATT (tt1,x,2,p,rhol,rhov,xliq,xvap,ierr,herr)
      call ENTHAL (tt1,rhov,x,h1)
      if (ieflag.eq.1) call ENERGY (tt1,rhov,x,h1)
      tt2=tt1-tinc
      call SATT (tt2,x,2,p,rhol,rhov,xliq,xvap,ierr,herr)
      call ENTHAL (tt2,rhov,x,h2)
      if (ieflag.eq.1) call ENERGY (tt2,rhov,x,h2)
      tt3=tt2-tinc
      call SATT (tt3,x,2,p,rhol,rhov,xliq,xvap,ierr,herr)
      call ENTHAL (tt3,rhov,x,h3)
      if (ieflag.eq.1) call ENERGY (tt3,rhov,x,h3)
      it=0
      if (h1.gt.h2 .and. h2.gt.h3 .and. ifirst.eq.1) then
        tt1=tc-tc/100.d0
        ifirst=2
        goto 10
      endif
c  use quadratic solution to find next guess for Tmax
 140  continue
      it=it+1
      b1=(h2-h1)/(tt2-tt1)
      b2=((h3-h2)/(tt3-tt2)-(h2-h1)/(tt2-tt1))/(tt3-tt1)
      b3=b1-b2*tt1-b2*tt2
      tehmax=-b3/2.0d0/b2
      if (nc.eq.1 .or. tmaxd.eq.0.d0) then
        if (tehmax.gt.tc) tehmax=(tc+tt1)/2.0d0
      else
        if (tehmax.gt.tmaxt) tehmax=(tmaxt+tt1)/2.0d0
      endif
      if (tehmax.lt.tmin) tehmax=(tmin+tt1)/2.0d0
      call SATT (tehmax,x,2,p,rhol,rhov,xliq,xvap,ierr,herr)
      if (ieflag.ne.1) then
        call ENTHAL (tehmax,rhov,x,ehmax)
        thmax=tehmax
        hmax=ehmax
      else
        call ENERGY (tehmax,rhov,x,ehmax)
        temax=tehmax
        emax=ehmax
      endif
c  discard a point and load in the new one
      if (tehmax.lt.tt3) then
        tt1=tt2
        tt2=tt3
        tt3=tehmax
        h1=h2
        h2=h3
        h3=ehmax
      elseif (tehmax.gt.tt1) then
        tt3=tt2
        tt2=tt1
        tt1=tehmax
        h3=h2
        h2=h1
        h1=ehmax
      elseif (tehmax.gt.tt2) then
        tt1=tehmax
        h1=ehmax
      else
        tt3=tehmax
        h3=ehmax
      endif
      hdiff=hold-ehmax
      hold=ehmax
      if (ABS(hdiff).gt.1.d-9 .and. it.lt.50) goto 140  !check for convergence
      RETURN
      end                                               !subroutine HMAX
c
c ======================================================================
c
      subroutine SATE (e,x,kph,nroot,k1,t1,p1,d1,k2,t2,p2,d2,ierr,herr)
c
c  iterate for temperature, pressure, and density given energy along
c  the saturation boundary and the composition
c
c  inputs:
c        e--molar energy [J/mol]
c        x--composition [array of mol frac]
c      kph--flag specifying desired root
c           0 = return all roots along the liquid-vapor line
c           1 = return only liquid VLE root
c           2 = return only vapor VLE roots
c           3 = return liquid SLE root (melting line)
c           4 = return vapor SVE root (sublimation line)
c  outputs:
c    see SATH for description of outputs
c
c  written by E.W. Lemmon, NIST Phys & Chem Properties Div, Boulder, CO
c  05-16-05 EWL, original version
c
cx DEC$ ATTRIBUTES DLLEXPORT :: SATE
c
      include 'commons.for'
      character*255 herr
      dimension x(ncmax)
c
      ieflg=1
      call SATH (e,x,kph,nroot,k1,t1,p1,d1,k2,t2,p2,d2,ierr,herr)
      ieflg=0
      if (ierr.ne.0) then
        i=index(herr,'SATH')
        if (i.gt.0) herr=herr(1:i+2)//'E'//herr(i+4:255)
        i=index(herr,'h =')
        if (i.gt.0) herr=herr(1:i-1)//'e'//herr(i+1:255)
        i=index(herr,'enthalpy')
        if (i.gt.0) herr=herr(1:i-1)//'energy'//herr(i+8:255)
      endif
      RETURN
c
      end                                               !subroutine SATE
c
c ======================================================================
c
      subroutine SATS (s,x,kph,nroot,k1,t1,p1,d1,k2,t2,p2,d2,
     &                 k3,t3,p3,d3,ierr,herr)
c
c  iterate for temperature, pressure, and density given an entropy along
c  the saturation boundary and the composition
c
c  inputs:
c        s--molar entropy [J/mol-K]
c        x--composition [array of mol frac]
c      kph--flag specifying desired root
c           0 = return all roots along the liquid-vapor line
c           1 = return only liquid VLE root
c           2 = return only vapor VLE roots
c           3 = return liquid SLE root (melting line)
c           4 = return vapor SVE root (sublimation line)
c  outputs:
c    nroot--number of roots.  Set to one for kph=1,3,4 if ierr=0
c       k1--phase of first root (1-liquid, 2-vapor, 3-melt, 4-subl)
c       t1--temperature of first root [K]
c       p1--pressure of first root [kPa]
c       dl--molar density of first root [mol/L]
c       k2--phase of second root (1-liquid, 2-vapor, 3-melt, 4-subl)
c       t2--temperature of second root [K]
c       p2--pressure of second root [kPa]
c       d2--molar density of second root [mol/L]
c       k3--phase of third root (1-liquid, 2-vapor, 3-melt, 4-subl)
c       t3--temperature of third root [K]
c       p3--pressure of third root [kPa]
c       d3--molar density of third root [mol/L]
c     ierr--error flag:   0 = successful
c                         1 = no roots found for specified input phase
c                         2 = s < smin
c                         4 = s > smax
c                         8 = s > strp (for subl input)
c                       160 = CRITP did not converge
c                       161 = SATS did not converge for one root
c                       162 = SATS did not converge for two roots
c                       163 = SATS did not converge for all roots
c     herr--error string (character*255 variable if ierr<>0)
c
c  The second root is always set as the root in the vapor at temperatures
c  below the maximum entropy on the vapor saturation line.  If kph is
c  set to 2, and only one root is found in the vapor (this occurs when s<scrit)
c  the state point will be placed in k2,t2,p2,d2.  If kph=0 and this situation
c  occurred, the first root (k1,t1,p1,d1) would be in the liquid (k1=1, k2=2).
c
c  The third root is the root with the lowest temperature.  For fluids
c  with multiple roots:  When only one root is found in the vapor phase
c  (this happens only at very low temperatures past the region where three
c  roots are located), the value of the root is still placed in
c  k3,t3,p3,d3.  For fluids that never have more than one root (when there
c  is no maximum entropy along the saturated vapor line), the value of the
c  root is always placed in k1,t1,p1,d1.
c
c  N.B. kph = 3,4 presently working only for pure components
c
c  written by E.W. Lemmon, NIST Phys & Chem Properties Div, Boulder, CO
c  02-24-00 EWL, original version
c  04-18-07 EWL, add check for SATT failure on the vapor side when finding stpv
c  03-04-10 EWL, add error message 1001 for root not found in specified phase
c  03-04-10 EWL, check for cases where melting line is not available
c  03-31-11 EWL, add check for p>pmax along melting line
c
cx DEC$ ATTRIBUTES DLLEXPORT :: SATS
c
      include 'commons.for'
      character*255 herr,herr1
      dimension x(ncmax),xliq(ncmax),xvap(ncmax)
      dimension tt(3),ft(2)
c
      call ISPURE (x,icomp)
      herr=' '
      ierr=0
      ierr1=0
      iflag=0
      nroot=0
      k1=0
      t1=0.d0
      p1=0.d0
      d1=0.d0
      k2=0
      t2=0.d0
      p2=0.d0
      d2=0.d0
      k3=0
      t3=0.d0
      p3=0.d0
      d3=0.d0
      call MAXT (x,tmaxt,tmaxp,tmaxd,ierr,herr1)
      call CRITP (x,tc,pc,rhoc,ierr,herr1)
      call ENTRO (tc,rhoc,x,sc)      !entropy at critical point
      if (ierr.gt.0) then
c  error condition--set outputs, issue warning, and return
        ierr=160
        write (herr,1160) herr1(1:237),hnull
 1160   format ('[SATS error 160] ',a237,a1)
        call ERRMSG (ierr,herr1)
        RETURN
      end if
c
c  calculate entropy at triple point if not set
      call LIMITS ('EOS',x,tmin,tmax,Dmax,pmax)
      if (ABS(stpl).lt.1.d-15) THEN
        if (icomp.ne.0) then
          call INFO (icomp,wmm,ttrp,tnbpt,tq,pq,Dq,Zc,ac1,dip,Rg1)
          if (tmin.lt.ttrp) tmin=ttrp  !Check for water
        endif
        t=tmin
        call SATT (t,x,1,p,rhol,rhov,xliq,xvap,ierr,herr)
        call ENTRO (t,rhol,x,stpl)
        if (icomp.eq.0 .or. ianc(icomp).eq.1) then
 100      continue
          call SATT (t,x,2,p,rhol,rhov,xliq,xvap,ierr,herr)
          if (ierr.gt.0 .and. t.lt.tc) then
            t=t+5
            goto 100
          endif
        endif
        call ENTRO (t,rhov,x,stpv)
      endif
c
c  find maximum and minimum entropy along the saturated vapor dome, and
c  the minimum entropy along the melting line
      if (ABS(tsmax).lt.1.d-15) THEN
        call SMAXX (x,smax,tsmax,smin,tsmin,sminm,tsminm,ierr,herr)
      endif
c
c  determine region
      if (kph.eq.3 .and. icomp.ne.0) then
        kphs=3                         !liquid/solid
      else if (kph.eq.4 .and. icomp.ne.0) then
        kphs=4                         !vapor/solid
      else
        if (s.lt.sc) then
          kphs=1                         !liquid
        else
          kphs=2                         !vapor
        end if
      endif
c     write (*,*) 'SATS--initial phase:  ',kphs
c
      if (s.lt.stpv .and. kphs.eq.4) then
        ierr=8
        write (herr,1008) ierr,s,stpv,hnull
 1008   format('[SATS error',i3,'] entropy less than triple point'
     &    ,' entropy; s =',g12.5,' J/mol-K, smin =',g12.5,' J/mol-K',a1)
        call ERRMSG (ierr,herr)
        RETURN
      endif
      if (s.lt.stpl .and. (s.lt.sminm .or. kphs.ne.3)) then
        ierr=2
        smx=stpl
        if (sminm.lt.stpl .and. kphs.eq.3) smx=sminm
        write (herr,1002) ierr,s,smx,hnull
 1002   format('[SATS error',i3,'] entropy below minimum '
     &     ,'entropy; s =',g12.5,' J/mol-K, smin =',g12.5,' J/mol-K',a1)
        call ERRMSG (ierr,herr)
        RETURN
      endif
      if (s.gt.smax .and. s.gt.stpv .and. kphs.le.2) then
        ierr=4
        smx=smax
        if (stpv.gt.smax) smx=stpv
        write (herr,1004) ierr,s,smx,hnull
 1004   format('[SATS error',i3,'] entropy greater than maximum '
     &     ,'entropy; s =',g12.5,' J/mol-K, smax =',g12.5,' J/mol-K',a1)
        call ERRMSG (ierr,herr)
        RETURN
      endif
c
c  iterate for temperature using a combination of Newton's method
c  and reguli-falsi
c
      tol=1.0d-6
      itmax=20
      if (kphs.eq.3) then
        tt(1)=tmin
        ft(1)=stpl-s
        if (tsminm.gt.0) then
          tt(1)=tsminm
          ft(1)=sminm-s
        endif
      elseif (kphs.eq.4) then
        tt(1)=tmin
        ft(1)=stpv-s
      else
        tt(1)=tc
        ft(1)=sc-s
c  Check for situations where three roots exists in the vapor, but the current
c  input is beyond the three root region, and only one root exists.
        if (s.gt.smax .and. tsmax.gt.0) then
          tt(1)=tmin
          ft(1)=stpv-s
          iflag=2
          kphs=2
        endif
c  Use values from Splines if set up by call to SATSPLN, should return the root with the lowest entropy
        if (iSpline.ne.0) then
          d=rhoc
          if (tsmax.gt.0 .and. s.gt.smax) d=0.01d0
          call SPLNROOT (nc+5,0,s,d,ierr,herr)
          call SPLNVAL (nc+1,0,d,t,ierr,herr)
          iflsh=1
          if (d.lt.rhoc) iflsh=2
          if (d.lt.rhoc .and. d.gt.tmaxd .and. tmaxd.ne.0) iflsh=-2
          call SATTP (t,p,x,iflsh,0,d,rhol,rhov,xliq,xvap,q,ierr,herr)
          call ENTRO (t,d,x,sc)
          tt(1)=t
          ft(1)=sc-s
          if (iflsh.lt.0) kphs=iflsh
        endif
      endif
c
c  initialize iteration flags
c
 130  continue
      lneg=.false.
      lpos=.false.
      tpos=0
      tneg=0
c  store variables for reguli-falsi
      if (ft(1).lt.0.0) then
        lneg=.true.
        tneg=tt(1)
        if (abs(kphs).eq.2 .and. tsmax.gt.0) then
          lpos=.true.
          tpos=tsmax
          if (iflag.eq.2) tpos=tsmin
        endif
        if (kphs.eq.3 .and. iflag.eq.1) then
          lpos=.true.
          tpos=tsminm
        endif
      else
        lpos=.true.
        tpos=tt(1)
        if (abs(kphs).eq.2 .and. tsmax.gt.0) then
          lneg=.true.
          tneg=tsmax
          if (iflag.eq.2) tneg=tsmin
        endif
        if (kphs.eq.3 .and. iflag.eq.1) then
          lneg=.true.
          tneg=tsminm
        endif
      end if
c
c  generate second guess for temperature
c
      if (iSpline.ne.0) then
        tt(2)=tt(1)-0.1d0
      elseif (kphs.eq.1) then
        tt(2)=0.95*tc
      else if (abs(kphs).eq.2 .and. tneg.gt.0 .and. tpos.gt.0) then
        tt(2)=(tneg+tpos)/2.0d0
      else if (abs(kphs).eq.2) then
        tt(2)=0.85*tc
      else if (kphs.eq.3 .and. tneg.gt.0 .and. tpos.gt.0) then
        tt(2)=(tneg+tpos)/2.0d0
      else if (kphs.eq.3 .and. tsminm.gt.0) then
        tt(2)=1.05*tsminm
      else if (kphs.eq.3) then
        tt(2)=1.05*tmin
      else if (kphs.eq.4) then
        tt(2)=0.95*tmin
      end if
      jt=2
c
      do it=1,itmax
      if (it.eq.10) tol=tol*10.d0
      if (kphs.gt.0) then
        call SATT (tt(jt),x,kphs,p,rho,rhov,xliq,xvap,ierr,herr)
      else
        call SATTP (tt(jt),p,x,kphs,0,d,rho,rhov,xliq,xvap,q,ierr,herr)
      endif
      if (p.le.0.d0 .and. ierr.eq.0) goto 200
      if (abs(kphs).eq.2 .or. kphs.eq.4) rho=rhov
      call ENTRO (tt(jt),rho,x,s1)
      ft(jt)=s1-s
c     write (*,1999) it,jt,tt(jt),ft(jt)
c1999 format (1x,'% it,jt,t,ft: ',2i4,f9.4,f16.10)
c  check for convergence
      if (abs(ft(jt)).lt.tol) goto 160
c  store variables for reguli-falsi
      if (ft(jt).lt.0.0) then
        lneg=.true.
        tneg=tt(jt)
      else
        lpos=.true.
        tpos=tt(jt)
      end if
c  compute next guess for temperature
      if (abs(ft(2)-ft(1)).gt.1.d-20)
     &  tt(3)=tt(2)-ft(2)*(tt(2)-tt(1))/(ft(2)-ft(1))
c  check if new guess is outside of bounds of previous guesses,
c  if so (and if upper and lower bounds are available) use
c  reguli-falsi

      if (lpos .and. lneg .and. abs(ft(2)).gt.tol*1.d4 .and.
     &  (tt(3).gt.max(tpos,tneg) .or. tt(3).lt.min(tpos,tneg))) then
        tt(3)=0.5*(tpos+tneg)
      elseif (tt(3).lt.tmin .and. kphs.ne.4) then
        tt(3)=tmin
      else if (tt(3).le.tmin/10.0d0 .and. icomp.ne.0) then !subl check
        goto 150
      endif
      tt(1)=tt(2)
      tt(2)=tt(3)
      ft(1)=ft(2)
      enddo
 150  continue
      if (ierr1.ne.161 .and. ierr1.ne.162) then
        ierr=161
        ierr1=161
        write (herr,1161) s,nroot+1,hnull
 1161   format ('[SATS error 161] ',
     &         'iteration for saturation state given entropy did not ',
     &         'converge for s =',g12.5,' J/mol-K; root = ',i1,a1)
        herr1=herr
      elseif (ierr1.ne.162) then
        ierr=162
        write (herr,1162) s,hnull
 1162   format ('[SATS error 162] ',
     &         'iteration for saturation state given entropy did not ',
     &         'converge for two of the roots; s =',g12.5,' J/mol-K',a1)
      else
        ierr=163
        write (herr,1163) s,hnull
 1163   format ('[SATS error 163] ',
     &         'iteration for saturation state given entropy did not ',
     &         'converge for all roots; s =',g12.5,' J/mol-K',a1)
      endif
      call ERRMSG (ierr,herr)
      tt(jt)=0
      p=0
      rho=0
 160  continue
      t=tt(jt)
      if (abs(kphs).eq.kph .or. kph.eq.0) then
        nroot=nroot+1
        if (iflag.eq.0) then
c  first root found, save values
          t1=t
          p1=p
          d1=rho
          k1=abs(kphs)
        elseif (iflag.eq.1) then
c  second root found, save values
          t2=t
          p2=p
          d2=rho
          k2=abs(kphs)
        elseif (iflag.eq.2) then
c  third root found, save values
          t3=t
          p3=p
          d3=rho
          k3=abs(kphs)
        endif
        if (ierr.eq.0 .and. ierr1.ne.0) then
          ierr=ierr1
          herr=herr1
        endif
      endif
c  check if second root might exist
c  only calculate second root if requested
      if ((kph.eq.0 .or. kph.eq.2) .and. tsmax.gt.0) then
        if (s.gt.smin .and. s.lt.smax .and. iflag.eq.0) then
          kphs=2
          iflag=iflag+1
          tt(1)=tsmin
          ft(1)=smin-s
          goto 130
        elseif (s.gt.smin .and. s.lt.smax .and. s.lt.stpv
     &         .and. iflag.eq.1) then
          kphs=2
          iflag=iflag+1
          tt(1)=tmin
          ft(1)=stpv-s
          goto 130
        endif
      endif
      if (kph.eq.3 .and. tsminm.gt.0) then
        if (s.gt.sminm .and. s.lt.stpl .and. iflag.eq.0) then
          iflag=iflag+1
          tt(1)=tmin
          ft(1)=smin-s
          goto 130
        endif
      endif
 200  if (k1.eq.0 .and. k2.eq.0 .and. k3.eq.0 .and. ierr.eq.0) then
        ierr=1
        write (herr,1001) ierr,s,hnull
 1001   format('[SATS error',i3,'] no roots found for specified phase;'
     &    ,' s =',g12.5,' J/mol-K', a1)
        call ERRMSG (ierr,herr)
      endif
c  check for p>pmax along the melting line
      if (kph.eq.3 .and. nroot.eq.1 .and. ierr.eq.0) then
        call LIMITX ('EOS',t1,d1,p1,x,tmin,tmax,rhomax,pmax,ierr,herr)
      endif
      RETURN
c
      end                                               !subroutine SATS
c
c ======================================================================
c
      subroutine SMAXX (x,smx,tsmx,smn,tsmn,smmin,tsmmin,ierr,herr)
c
c  find maximum and minimum entropy along the saturated vapor dome, and
c  the minimum entropy along the melting line
c
c  inputs:
c        x--composition [array of mol frac]
c  outputs:
c      smx--maximum entropy [J/mol-K]
c     tsmx--temperature at maximum entropy [K]
c      smn--minimim entropy [J/mol-K]
c     tsmn--temperature at minimum entropy [K]
c    smmin--minimim entropy along melting line [J/mol-K]
c   tsmmin--temperature at minimum entropy along melting line [K]
c     ierr--error flag:   0 = successful
c     herr--error string (character*255 variable if ierr<>0)
c
c  written by E.W. Lemmon, NIST Phys & Chem Properties Div, Boulder, CO
c  06-15-11 EWL, original version, remove piece from SATS and place here
c
c
      include 'commons.for'
      character*255 herr,herr1
      dimension x(ncmax),xliq(ncmax),xvap(ncmax)
      call CRITP (x,tc,pc,rhoc,ierr,herr1)
      call LIMITS ('EOS',x,tmin,tmax,Dmax,pmax)
      call ENTRO (tc,rhoc,x,sc)      !entropy at critical point
      sold=0.d0
      istart=1
      tsmmin=-1
      smmin=stpl
      tsmn=-1
      smn=sc
      if (stpv.lt.sc) smn=stpv
      tsmx=-1
      smx=stpv
c  check first to see if melting line is double valued
      p=0.d0
      call SATT (tmin,x,3,p,rhol,rhov,xliq,xvap,ierr,herr)
      if (ABS(p).gt.1.d-15) then
        call ENTRO (tmin,rhol,x,s1)
        call SATT (tmin+1.0d0,x,3,p,rhol,rhov,xliq,xvap,ierr,herr)
        call ENTRO (tmin+1.0d0,rhol,x,s2)
        if (s2.lt.s1) istart=0      !melting line is doubled valued if s2<s1
      endif
c  set up initial three points
      j=0
      do i=istart,2
        if (i.eq.1) then
          tt1=tc-tc/20.d0
          tt2=tt1-tc/20.d0
          tt3=tt2-tc/20.d0
        else
          tt3=tmin+tmin/20.d0
          tt2=tt3+tmin/20.d0
          tt1=tt2+tmin/20.d0
        endif
        k=2
        if (i.eq.0) k=3
        call SATT (tt1,x,k,p,rhol,rho,xliq,xvap,ierr,herr)
        if (i.eq.0) rho=rhol
        call ENTRO (tt1,rho,x,s1)
        call SATT (tt2,x,k,p,rhol,rho,xliq,xvap,ierr,herr)
        if (i.eq.0) rho=rhol
        call ENTRO (tt2,rho,x,s2)
        call SATT (tt3,x,k,p,rhol,rho,xliq,xvap,ierr,herr)
        if (i.eq.0) rho=rhol
        call ENTRO (tt3,rho,x,s3)
c  use quadratic solution to find next guess for Tsm
 140    continue
        b1=(s2-s1)/(tt2-tt1)
        b2=((s3-s2)/(tt3-tt2)-(s2-s1)/(tt2-tt1))/(tt3-tt1)
        b3=b1-b2*tt1-b2*tt2
        tsm=-b3/2.0d0/b2
        j=j+1
        if (tsm.lt.tmin .or. j.gt.100) then
          if (i.eq.0) goto 110
          RETURN           !no solution (VLE line is not double valued)
        endif
        if (tsm.gt.tc) tsm=(tc+tt1)/2.0d0
        call SATT (tsm,x,k,p,rhol,rho,xliq,xvap,ierr,herr)
        if (i.eq.0) rho=rhol
        call ENTRO (tsm,rho,x,sm)
c  discard a point and load in the new one
        if (tsm.lt.tt3) then
          tt1=tt2
          tt2=tt3
          tt3=tsm
          s1=s2
          s2=s3
          s3=sm
        elseif (tsm.gt.tt1) then
          tt3=tt2
          tt2=tt1
          tt1=tsm
          s3=s2
          s2=s1
          s1=sm
        elseif (tsm.gt.tt2) then
          tt1=tsm
          s1=sm
        else
          tt3=tsm
          s3=sm
        endif
        sdiff=sold-sm
        sold=sm
        if (ABS(sdiff).gt.1.d-9) goto 140  !check for convergence
c  load appropriate fixed points with the max/min value.
        if (i.eq.1) then
          smx=sm
          tsmx=tsm
        elseif (i.eq.2) then
          smn=sm
          tsmn=tsm
        elseif (i.eq.0) then
          smmin=sm
          tsmmin=tsm
        endif
 110    continue
      enddo
      RETURN
      end                                               !subroutine SMAX
c
c ======================================================================
c
      subroutine CSATK (icomp,t,kph,p,rho,csat,ierr,herr)
c
c  compute the heat capacity along the saturation line as a function of
c  temperature for a given component
c
c  csat can be calculated two different ways:
c     Csat = Cp - T(DvDT)(DPDTsat)
c     Csat = Cp - beta/rho*hvap/(vliq - vvap)
c     where beta is the volume expansivity
c
c  inputs:
c    icomp--component number in mixture (1..nc); 1 for pure fluid
c        t--temperature [K]
c      kph--phase flag: 1 = liquid calculation
c                       2 = vapor calculation
c  outputs:
c        p--saturation pressure [kPa]
c      rho--saturation molar density [mol/L]
c     csat--saturation heat capacity [J/mol-K]
c
c  written by E.W. Lemmon, NIST Physical & Chem Properties Div, Boulder, CO
c  09-30-98 EWL, original version
c
cx DEC$ ATTRIBUTES DLLEXPORT :: CSATK
c
      include 'commons.for'
      character*255 herr
      dimension x(ncmax),xliq(ncmax),xvap(ncmax)
c
      ic2=icnc
      icnc=icomp
      csat=0.d0
      call SATT (t,x,kph,p,rhol,rhov,xliq,xvap,ierr,herr)
      if (ierr.gt.0 .or. rhol.le.0.d0) then
        icnc=ic2
        if (ierr.eq.0) ierr=1
        p=0.d0
        rho=0.d0
        RETURN
      end if
      rho=rhol
      if (kph.eq.2) rho=rhov
      call DPDT (t,rho,x,dpt)
      call DPDD (t,rho,x,dpdrho)
      call CVCPK (icomp,t,rho,cv,cp)
      call ENTHAL (t,rhol,x,hl)
      call ENTHAL (t,rhov,x,hv)
      beta=dpt/dpdrho/rho
      csat=cp-beta/rho*(hl-hv)/(1.d0/rhol-1.d0/rhov)
      icnc=ic2
c
      RETURN
      end                                              !subroutine CSATK
c
c ======================================================================
c
      subroutine DPTSATK (icomp,t,kph,p,rho,csat,dpt,ierr,herr)
c
c  compute the heat capacity and dP/dT along the saturation line as a
c  function of temperature for a given component.  See also subroutine CSATK.
c
c  inputs:
c    icomp--component number in mixture (1..nc); 1 for pure fluid
c        t--temperature [K]
c      kph--phase flag: 1 = liquid calculation
c                       2 = vapor calculation
c  outputs:
c        p--saturation pressure [kPa]
c      rho--saturation molar density [mol/L]
c     csat--saturation heat capacity [J/mol-K] (same as that called from CSATK)
c      dpt--dP/dT along the saturation line [kPa/K]
c           (this is not dP/dT "at" the saturation line for the single phase
c            state, but the change in saturated vapor pressure as the
c            saturation temperature changes.)
c
c  written by E.W. Lemmon, NIST Physical & Chem Properties Div, Boulder, CO
c  09-25-06 EWL, original version
c
cx DEC$ ATTRIBUTES DLLEXPORT :: DPTSATK
c
      include 'commons.for'
      character*255 herr
      dimension x(ncmax),xliq(ncmax),xvap(ncmax)
c
      ic2=icnc
      icnc=icomp
      csat=0.d0
      dpt=0.d0
      call SATT (t,x,kph,p,rhol,rhov,xliq,xvap,ierr,herr)
      if (ierr.gt.0 .or. rhol.le.0.d0) then
        icnc=ic2
        if (ierr.eq.0) ierr=1
        p=0.d0
        rho=0.d0
        RETURN
      end if
      rho=rhol
      if (kph.eq.2) rho=rhov
      call DPDT (t,rho,x,dpt)
      call DPDD (t,rho,x,dpdrho)
      call CVCPK (icomp,t,rho,cv,cp)
      call ENTHAL (t,rhol,x,hl)
      call ENTHAL (t,rhov,x,hv)
      beta=dpt/dpdrho/rho
      csat=cp-beta/rho*(hl-hv)/(1.d0/rhol-1.d0/rhov)
      dpt=             (hl-hv)/(1.d0/rhol-1.d0/rhov)/T
      icnc=ic2
c
      RETURN
      end                                            !subroutine DPTSATK
c
c ======================================================================
c
      subroutine CV2PK (icomp,t,rho,cv2p,csat,ierr,herr)
c
c  compute the isochoric heat capacity in the two phase (liquid+vapor)
c  region
c
c  inputs:
c    icomp--component number in mixture (1..nc); 1 for pure fluid
c        t--temperature [K]
c      rho--density [mol/l] if known
c           If rho=0, then a saturated liquid state is assumed.
c
c  outputs:
c     cv2p--isochoric two-phase heat capacity [J/mol-K]
c     csat--saturation heat capacity [J/mol-K]
c           (Although there is already a csat routine in REFPROP,
c            it is also returned here.  However, the calculation
c            speed is slower than csat.)
c
c  written by E.W. Lemmon, NIST Physical & Chem Properties Div, Boulder, CO
c  03-30-05 EWL, original version
c
cx DEC$ ATTRIBUTES DLLEXPORT :: CV2PK
c
      include 'commons.for'
      character*255 herr,herr1,herr2
      dimension x(ncmax),xliq(ncmax),xvap(ncmax)
c
      ierr=0
      herr=' '
      ic2=icnc
      icnc=icomp
      cv2p=0.d0
      dt=0.01d0
      i=1
      t1=t+dt
      t2=t-dt
      call SATT (t ,x,i,p ,dl ,dv ,xliq,xvap,ierr ,herr)
      call SATT (t1,x,i,p1,dl1,dv1,xliq,xvap,ierr1,herr1)
      call SATT (t2,x,i,p2,dl2,dv2,xliq,xvap,ierr2,herr2)
      if (rho.le.0.d0) rho=dl
      if (ierr.gt.0 .or. ierr1.gt.0 .or. ierr2.gt.0 .or. dl.le.0.d0)then
        if (ierr.eq.0 .and. ierr1.ne.0) then
          ierr=ierr1
          herr=herr1
        endif
        if (ierr.eq.0 .and. ierr2.ne.0) then
          ierr=ierr2
          herr=herr2
        endif
        if (ierr.eq.0 .and. dl.le.0.d0) ierr=1
        icnc=ic2
        RETURN
      endif
c
      call DPDT (t,dl,x,dpt)
      call DPDD (t,dl,x,dpdrho)
      call CVCPK (icomp,t,dl,cv,cp)
      call ENTHAL (t,dl,x,hl)
      call ENTHAL (t,dv,x,hv)
      beta=dpt/dpdrho/dl
      dpdtsat=(hv-hl)/t/(1.d0/dv-1.d0/dl)     ! d(p)/d(T) at sat. liq.
      dddtsat=(dl1-dl2)/2.d0/dt               ! d(rho)/d(T) at sat. liq.
      d2pdtsat=(p2+p1-2.d0*p)/dt**2           ! d^2(p)/d(T)^2 at sat. liq.
      csat=cp-beta/dl*dpdtsat*t
      cv2p=csat+t/dl**2*dddtsat*dpdtsat+t*(1.d0/rho-1.d0/dl)*d2pdtsat
      icnc=ic2
c
      RETURN
      end                                              !subroutine CV2PK
c
c ======================================================================
c
      subroutine TPRHOB (t,p,rho1,rho2,x,rho,ierr,herr)
c
c  iterate for density given temperature, pressure and an upper and lower
c  bound for the density.  This routine is only meant to replace TPRHO
c  in special cases near the critical point.  (And is only used by SATT.)
c
c  inputs:
c        t--temperature [K]
c        p--pressure [kPa]
c     rho1--first bound on density [mol/L]
c     rho2--second bound on density [mol/L]
c        x--composition [array of mol frac]
c  outputs:
c      rho--molar density [mol/L]
c     ierr--error flag:   0 = successful
c                         1 = failed to converge
c     herr--error string (character*255 variable if ierr<>0)
c
c  written by E.W. Lemmon, NIST Thermophysics Division, Boulder, Colorado
c  11-08-01 EWL, original version
c
      include 'commons.for'
      character*255 herr
      dimension x(ncmax)

      ierr=0
      herr=' '
      tolr=1.d-9
      d1=rho1
      d2=rho2
      if (d1.gt.d2) then
        d1=rho2
        d2=rho1
      endif
      it=1
      rho=(d1+d2)/2.d0
 140  continue
      call PRESS (t,rho,x,p1)
      call DPDD (t,rho,x,dpd)
      rho0=rho
c  use false position to get next root
      if (abs(dpd).gt.1.d-20) rho=rho+(p-p1)/dpd
c  keep within bounds
      if (rho.lt.d1) rho=(rho0+d1)/2.d0
      if (rho.gt.d2) rho=(rho0+d2)/2.d0
      if (ABS(p1-p).lt.tolr) RETURN
      it=it+1
      if (it.eq.10) tolr=tolr*100
      if (it.eq.15) tolr=tolr*100
      if (it.lt.25) goto 140

      ierr=1
      RETURN
      end                                             !subroutine TPRHOB
c
c ======================================================================
c
      subroutine DLDV (t,p,rhol,rhov,xl,xv,ierr,herr)
      include 'commons.for'
      character*255 herr
      dimension xl(ncmax),xv(ncmax)

      tolr=1.0d-6
      deld=1.d0
      call CRITP (xl,tc,pc,rhoc,ierr,herr)
      rhol=rhoc*1.1d0
      rhov=rhoc
      it=0
 140  continue
      it=it+1

      it2=0
 110  continue
      call DPDD2 (t,rhol,xl,dpdl2)
      call DPDD (t,rhol,xl,dpdl)
      call PRESS (t,rhol,xl,pl)
      if (abs(rhol).gt.1.d6) then
        ierr=1
        herr=' '
        RETURN
      endif
      if (dpdl2.lt.0.d0 .or. dpdl.lt.0.d0 .or. pl.lt.0.d0) then
        rhol=rhol*1.05d0
        it2=it2+1
        if (it2.lt.100) goto 110
      endif
      if (dpdl.gt.1.d4) then
        if (ABS(pl).gt.pc*1.5d0 .and. rhol-rhoc.lt.5) then
          rhol=rhol*1.5d0
          it2=it2+1
          if (it2.lt.100) goto 110
        endif
      endif


      it2=0
 120  continue
      call DPDD2 (t,rhov,xv,dpdv2)
      call DPDD (t,rhov,xv,dpdv)
      call PRESS (t,rhov,xv,pv)
      if (ABS(dpdv).gt.1.d5) then
        if (ABS(pv).gt.pc*1.5d0) then
          rhov=rhov*0.5d0
          it2=it2+1
          if (it2.lt.100) goto 120
        endif
      endif
      if (dpdv2.gt.0.d0 .or. dpdv.lt.0.d0) then
        rhov=rhov*.95d0
        it2=it2+1
        if (it2.lt.100) goto 120
      endif
      if (it.eq.1) then
        rhov=rhov*.95d0
        call DPDD2 (t,rhov,xv,dpdv2)
        call DPDD (t,rhov,xv,dpdv)
        call PRESS (t,rhov,xv,pv)
      endif



      p=(pl+pv)/2.d0

      if (abs(pv-p).gt.1.d-10 .and. abs(dpdv).gt.1.d-10) then
        deld=1.d0/(-dpdv/(pv-p)+dpdv2/2.d0/dpdv)
      else
        deld=deld/2.d0
      endif
 860  continue
      if (ABS(deld/rhov).gt.0.5d0) then
        deld=deld/10.d0
        goto 860
      endif
      rhov=rhov+deld

      if (abs(pl-p).gt.1.d-10 .and. abs(dpdl).gt.1.d-10) then
        deld=1.d0/(-dpdl/(pl-p)+dpdl2/2.d0/dpdl)
      else
        deld=deld/2.d0
      endif
 870  continue
      if (ABS(deld/rhol).gt.1.d0) then
        deld=deld/10.d0
        goto 870
      endif
      rhol=rhol+deld
      if (it.lt.50 .and. ABS(pl-pv).gt.tolr) goto 140

      ierr=0
      herr=' '
      RETURN
      end                                               !subroutine DLDV
c
c ======================================================================
c
      subroutine LIQSPNDL (t,x,rhol,ierr,herr)
c
c  Find the liquid spinodal density for a given temperature.
c  An estimate (rhol) can be provided otherwise it will be calulated from an
c  auxiliary spline function (which was prepared during SETUP).
c
c  inputs:
c        t--temperature [K]
c        x--composition [array of mol frac]
c     rhol--density at liquid spinodal [mol/L] (initial guess)
c           for negative inputs the corresponding spline function will be evaluated
c  outputs:
c     rhol--liquid spinodal [mol/L] (initial guess can be provided)
c     ierr--error flag:   0 = successful
c                       124 = failed to converge
c     herr--error string (character*255 variable if ierr<>0)
c
c  written by E.W. Lemmon, NIST Thermophysics Division, Boulder, Colorado
c  11-28-06 EWL, original version taken from code in SATT
c  09-15-11  MK, split subroutine SPNDL into liquid and vapor routines
c
      include 'commons.for'
      character*255 herr
      character*255 herr2
      dimension x(ncmax)
c
      ierr=0
      herr=' '
c
      call CRITP (x,tc,pc,rhoc,ierr,herr)
      call ISPURE (x,icomp)
c
      if (t.gt.tc+1.0d-8 .and. icomp.ne.0) then
        ierr=121
        write (herr,1121) t,tc,hnull
        call ERRMSG (ierr,herr)
 1121   format ('[LIQSPNDL error 121] ',
     &          'temperature input to spinodal routine is ',
     &          'greater than critical temperature; T =',g12.5,
     &          ' K, Tcrit =',g12.5,' K.',a1)
        RETURN
      end if
c
      if (rhol.le.0.d0) then
        call CSPLNVAL (ispndl_l,tspndl_l,dspndl_l,cspndl_l,
     &                        t,rhol,ierr2,herr2)
        if (ierr2.ne.0) rhol=dtpn(icomp)
      endif
c
      it=0
      tolr=1.d-8
c  find the liquid spinodal (point where dpdrho=0)
 310  continue
      call DPDD (t,rhol,x,dpd)
      call DPDD2 (t,rhol,x,dpd2)
      d1=rhol
      dp1=dpd
      if (abs(dpd2).gt.1.d-20) rhol=rhol-dpd/dpd2
      it=it+1
      if (it.eq.10) tolr=tolr*100.d0
      if (it.eq.15) tolr=tolr*100.d0
      if (it.gt.30 .or. rhol.lt.rhoc) then
c  in case of failure, use the false position method:
c  (when the nonanalytical terms are used, this may be caused due to the
c   uncalculated dpdd2 part)
        d2=rhol
        call DPDD (t,d2,x,dp2)
c  check for good bounds; if bad, find new ones:
        if (rhol.lt.rhoc .or. dp1*dp2.ge.0.d0) then
          it=0
          d1=rhoc
          d2=rhoc
          call DPDD (t,d1,x,dp1)
 320      continue
          d2=d2*1.02d0
          call DPDD (t,d2,x,dp2)
          it=it+1
          if (it.gt.100) goto 390
          if (dp1*dp2.gt.0) goto 320
        endif
        it=0
        tolr=1.d-8
 330    continue
        if (abs(dp2-dp1).gt.1.d-20) rhol=d1-dp1*(d2-d1)/(dp2-dp1)
        call DPDD (t,rhol,x,dpd)
        if (dpd*dp1.lt.0.d0) then
          d2=rhol
          dp2=dpd
        else
          d1=rhol
          dp1=dpd
        endif
        it=it+1
        if (it.gt.100) goto 390
        if (abs(dpd).gt.tolr) goto 330
      endif
      if (abs(dpd).gt.tolr) goto 310
      RETURN
C
 390  continue
      ierr=124
      write (herr,1124) t,hnull
      call ERRMSG (ierr,herr)
      rhol=rhoc
 1124 format ('[LIQSPNDL error 124] ',
     &        'iteration for spinodals did not converge; ',
     &        'T =',g12.5,' K.',a1)
      RETURN
      end                                           !subroutine LIQSPNDL
c
c ======================================================================
c
      subroutine VAPSPNDL (t,x,rhov,ierr,herr)
c
c  Find the vapor spinodal density for a given temperature.
c  An estimate (rhov) can be provided otherwise it will be calulated from an
c  auxiliary spline function (which was prepared during SETUP).
c
c  inputs:
c        t--temperature [K]
c        x--composition [array of mol frac]
c     rhov--density at vapor spinodal [mol/L] (initial guess)
c           for negative inputs the corresponding spline function will be evaluated
c  outputs:
c     rhov--density at vapor spinodal [mol/L]
c     ierr--error flag:   0 = successful
c                       124 = failed to converge
c     herr--error string (character*255 variable if ierr<>0)
c
c  written by E.W. Lemmon, NIST Thermophysics Division, Boulder, Colorado
c  11-28-06 EWL, original version taken from code in SATT
c  09-15-11  MK, split subroutine SPNDL into liquid and vapor routines
c
      include 'commons.for'
      character*255 herr
      character*255 herr2
      dimension x(ncmax)
c
      ierr=0
      herr=' '
c
      call CRITP (x,tc,pc,rhoc,ierr,herr)
      call ISPURE (x,icomp)
c
      if (t.gt.tc+1.0d-8 .and. icomp.ne.0) then
        ierr=121
        write (herr,1121) t,tc,hnull
        call ERRMSG (ierr,herr)
 1121   format ('[VAPSPNDL error 121] ',
     &          'temperature input to spinodal routine is ',
     &          'greater than critical temperature; T =',g12.5,
     &          ' K, Tcrit =',g12.5,' K.',a1)
        RETURN
      end if
c
      if (rhov.le.0.d0) then
        call CSPLNVAL (ispndl_v,tspndl_v,dspndl_v,cspndl_v,
     &                        t,rhov,ierr2,herr2)
        if (ierr2.ne.0) rhov=0.1d0
      endif
c
      it=0
      tolr=1.d-8
 340  continue
      call DPDD (t,rhov,x,dpd)
      call DPDD2 (t,rhov,x,dpd2)
      d1=rhov
      dp1=dpd
      if (abs(dpd2).gt.1.d-20) rhov=rhov-dpd/dpd2
      it=it+1
      if (it.eq.10) tolr=tolr*100.d0
      if (it.eq.15) tolr=tolr*100.d0
      if (it.gt.30 .or. rhov.gt.rhoc) then
c  false position method:
        d2=rhov
        call DPDD (t,d2,x,dp2)
c  check for good bounds; if bad, find new ones:
        if (d1.gt.rhoc .or. d2.gt.rhoc .or. dp1*dp2.ge.0.d0) then
          it=0
          d1=rhoc
          d2=rhoc
          call DPDD (t,d1,x,dp1)
 350      continue
          d2=d2/1.02d0
          call DPDD (t,d2,x,dp2)
          it=it+1
          if (it.gt.100) goto 390
          if (dp1*dp2.gt.0) goto 350
        endif
        it=0
        tolr=1.d-8
 360    continue
        if (abs(dp2-dp1).gt.1.d-20) rhov=d1-dp1*(d2-d1)/(dp2-dp1)
        call DPDD (t,rhov,x,dpd)
        if (dpd*dp1.lt.0.d0) then
          d2=rhov
          dp2=dpd
        else
          d1=rhov
          dp1=dpd
        endif
        it=it+1
        if (it.gt.100) goto 390
        if (abs(dpd).gt.tolr) goto 360
      endif
      if (abs(dpd).gt.tolr) goto 340
      RETURN
C
 390  continue
      ierr=124
      write (herr,1124) t,hnull
      call ERRMSG (ierr,herr)
      rhov=rhoc
 1124 format ('[VAPSPNDL error 124] ',
     &        'iteration for spinodals did not converge; ',
     &        'T =',g12.5,' K.',a1)
      RETURN
c
      end                                           !subroutine VAPSPNDL
c
c ======================================================================
c
      subroutine SETLSPNDL (icomp,ierr,herr)
c
c  Prepares a cubic spline interpolating the liquid spinodal.
c
c  inputs:
c    icomp--pure fluid number for which spinodals will be calculated
c  outputs:
c     ierr--error flag:   0 = successful
c                         1 = called with a mixture composition (pure fluids only)
c                         2 = convergence porblems in LIQSPNDL
c     herr--error string (character*255 variable if ierr<>0)
c
c  written by Matthias Kunick, NIST Thermophysics Division, Boulder, Colorado
c  09-15-11  MK, original version
c
c
      include 'commons.for'
      character*255 herr
      dimension x(ncmax)
c
      parameter (qcritreg=0.85d0)
      parameter (icritreg=10)
c
      ierr=0
      herr=' '
c
      if (icomp.eq.0) then
        ierr=1
        write (herr,1001)
        call ERRMSG (ierr,herr)
 1001   format ('[SETLSPNDL error 1] ',
     &          'SETLSPNDL can handle pure fluids only')
        RETURN
      endif
c
      call INFO (icomp,wmm,tt,tb,tc,pc,dc,zc,acf,dip,rgas)
      call CRITP (x,tc,pc,rhoc,ierr,herr)
c
      t=tt
      pt=pc*10.d0**(-2.333333d0*(1.d0+accen(icomp))*(tc/tt-1.d0))
      call TPRHO (tt,pt,x,1,0,rhol,ierr,herr)
      dt=(tc-tt)*qcritreg/(iptmax-icritreg-1)
      j=0
      rhol=dtpn(icomp)
      do i=1,iptmax-icritreg
        call LIQSPNDL (t,x,rhol,ierr,herr)
        if (ierr.eq.0) then
          j=j+1
          dspndl_l(j)=rhol
          tspndl_l(j)=t
        endif
        t=t+dt
      enddo
c
      dt=(tc-t)/(icritreg-1)
      do i=1,icritreg
        call LIQSPNDL (t,x,rhol,ierr,herr)
        if (ierr.eq.0) then
          j=j+1
          dspndl_l(j)=rhol
          tspndl_l(j)=t
        endif
        t=t+dt
      enddo
c
      if (j.lt.5) then
        ierr=2
        write (herr,1002)
        call ERRMSG (ierr,herr)
 1002   format ('[SETLSPNDL error 2] ',
     &          'Less then 5 points converged in LIQSPNDL')
        RETURN
      endif
c
      ispndl_l=j
      call CSPLINE (ispndl_l-1, tspndl_l, dspndl_l, cspndl_l)
c
      end                                          !subroutine SETLSPNDL
c
c ======================================================================
c
      subroutine SETVSPNDL (icomp,ierr,herr)
c
c  Prepares a cubic spline interpolating the vapor spinodal.
c
c  inputs:
c    icomp--pure fluid number for which spinodals will be calculated
c  outputs:
c     ierr--error flag:   0 = successful
c                         1 = called with a mixture composition (pure fluids only)
c                         2 = convergence problems in LIQSPNDL
c     herr--error string (character*255 variable if ierr<>0)
c
c  written by Matthias Kunick, NIST Thermophysics Division, Boulder, Colorado
c  09-15-11  MK, original version
c
      include 'commons.for'
      character*255 herr
      dimension x(ncmax)
      dimension dspndl_v_save(iptmax)
      dimension tspndl_v_save(iptmax)
c
      parameter (qcritreg=0.85d0)
      parameter (qlowtreg=0.75d0)
      parameter (icritreg=10)
      parameter (ilowtreg=10)
c
      ierr=0
      herr=' '
c
      if (icomp.eq.0) then
        ierr=1
        write (herr,1001)
        call ERRMSG (ierr,herr)
 1001   format ('[SETVSPNDL error 1] ',
     &          'SETVSPNDL can handle pure fluids only')
        RETURN
      endif
c
      call INFO (icomp,wmm,tt,tb,tc,pc,dc,zc,acf,dip,rgas)
      call CRITP (x,tc,pc,rhoc,ierr,herr)
c
      t=tt
      pt=pc*10.d0**(-2.333333d0*(1.d0+accen(icomp))*(tc/tt-1.d0))
      call TPRHO (tt,pt,x,2,0,rhov,ierr,herr)
      tlow=tt*qlowtreg
      dt=(tlow-tt)/(ilowtreg-1)
      j=0
      rhov=ptpn(icomp)/r/ttpn(icomp)
      if (rhov.gt.200) rhov=1.d-10  !Check for fitted fld file with t<1
      do i=1,ilowtreg
        call VAPSPNDL (t,x,rhov,ierr,herr)
        if (ierr.eq.0) then
          j=j+1
          dspndl_v(j)=rhov
          tspndl_v(j)=t
        endif
        t=t+dt
      enddo
c
      !re-order points
      do k=1,j
        dspndl_v_save(k)=dspndl_v(k)
        tspndl_v_save(k)=tspndl_v(k)
      enddo
      do k=1,j
        dspndl_v(k)=dspndl_v_save(j-k+1)
        tspndl_v(k)=tspndl_v_save(j-k+1)
      enddo
c
      t=tspndl_v(j)-dt
      dt=(tc-t)*qcritreg/(iptmax-icritreg-ilowtreg-1)
      rhov=dspndl_v(j)
      do i=1,iptmax-icritreg-ilowtreg
        call VAPSPNDL (t,x,rhov,ierr,herr)
        if (ierr.eq.0) then
          j=j+1
          dspndl_v(j)=rhov
          tspndl_v(j)=t
        endif
        t=t+dt
      enddo
c
      dt=(tc-t)/(icritreg-1)
      do i=1,icritreg
        call VAPSPNDL (t,x,rhov,ierr,herr)
        if (ierr.eq.0) then
          j=j+1
          dspndl_v(j)=rhov
          tspndl_v(j)=t
        endif
        t=t+dt
      enddo
c
      if (j.lt.5) then
        ierr=2
        write (herr,1002)
        call ERRMSG (ierr,herr)
 1002   format ('[SETVSPNDL error 2] ',
     &          'Less then 5 points converged in VAPSPNDL')
        RETURN
      endif
c
      ispndl_v=j
      call CSPLINE (ispndl_v-1, tspndl_v, dspndl_v, cspndl_v)
c
      end                                          !subroutine SETVSPNDL
c
c ======================================================================
c
      subroutine FNCRPT (x,d,p,t,ierr,herr)
c
c  Find the critical point of a pure fluid based on the EOS.
c  This is currently only for pure fluids!
c
c  inputs:
c        x--composition [array of mol frac]
c  outputs:
c        t--temperature [K]
c        p--pressure [kPa]
c        d--density [mol/L]
c     ierr--error flag:   0 = successful
c     herr--error string (character*255 variable if ierr<>0)
c
c  written by E.W. Lemmon, NIST Thermophysics Division, Boulder, Colorado
c  01-01-96 EWL, original version taken from code in SATT
c
c
      include 'commons.for'
      character*255 herr
      dimension x(ncmax)
c
      call CRITP (x,t,pc2,d,ierr,herr)
      iter=0
      ac=1.d-10
c     ac=1.d-8
c  get first point
      told=t+.1d0
      d=crtden(x,told,d)
      if (d.le.0) goto 30
      call DPDD (told,d,x,fold)
      fold=fold/1000.d0
 20   d=crtden(x,t,d)
      if (d.le.0) goto 30
      call DPDD (t,d,x,f)
      f=f/1000.d0
      iter=iter+1
      if (iter.gt.20) goto 30
      if(ABS(f).lt.ac)then
        call PRESS (t,d,x,p)
        RETURN
      endif
c  get next point by using the slope of the previous two points.
      if (fold.eq.f) goto 30
      t1=t-f*(told-t)/(fold-f)
      told=t
      fold=f
      t=t1
      if (t.gt.0) goto 20
 30   continue
c     write (*,*) ' *** Fncrpt: No convergence ***'
      end                                             !subroutine FNCRPT
      function CRTDEN (x,t,d)
      include 'commons.for'
      dimension x(ncmax)
      iter=0
 10   iter=iter+1
      call DPDD2 (t,d,x,df0)
      crtden=d
      if(ABS(df0).lt.1.d-12) RETURN
c     if(ABS(df0).lt.1.d-10) return
      if (iter.gt.30) then
c       write (*,*) 'Crtden: No convergence'
        RETURN
      endif
      call DPDD2 (t,d+0.0001d0,x,df1)
      call DPDD2 (t,d-0.0001d0,x,df2)
      fp=(df1-df2)/0.0002d0
      fpp=(df1+df2-2.d0*df0)/0.00000001d0
      d=d+1.d0/(-fp/df0+fpp/2.d0/fp)
      if (d.le.0) RETURN
      goto 10
      end                                               !function CRTDEN
c
c ======================================================================
c
      subroutine SATEST (iFlash,t,p,x,xliq,xvap,ierr,herr)
c
c  Estimate temperature, pressure, and compositions to be used
c  as initial guesses to SATTP.
c
c  inputs:
c   iFlash--see inputs to SATTP
c        t--temperature [K] (input or output)
c        p--pressure [MPa] (input or output)
c        x--composition [array of mol frac]
c  outputs:
c     xliq--liquid phase composition [array of mol frac]
c     xvap--vapor phase composition [array of mol frac]
c     ierr--error flag:   0 = successful
c                         1 = unsuccessful
c     herr--error string (character*255 variable if ierr<>0)
c
c  written by Diego Ortiz, NIST Thermophysics Division, Boulder, Colorado
c  07-01-10 DOO, original version
c
      include 'commons.for'
      dimension x(ncmax),xliq(ncmax),xvap(ncmax)
      character herr*255
c     dimension tini,ti,Tol,told,fnold
c     dimension i,j,k,dummy
c     dimension amag,fn,fnprime,tmp2
c     dimension tmp3,tmp4,taux1,taux2,taux3
c     dimension fnaux1,fnaux2,fnaux3,fnini
c     dimension tx,alpha
      dimension pc2(ncmax),tc2(ncmax),acf2(ncmax),wmm2(ncmax)
c     dimension wmm,ttrp,tnbpt,tc,pc,dc,zc,acf,dip,Rgas
c
      ierr=0
      do i=1,nc
        Call INFO (i,wmm2(i),ttrp,tnbpt,tc2(i),pc2(i),dc,zc,acf2(i),dip,
     & Rgas)
        xliq(i)=x(i)
        xvap(i)=x(i)
      enddo
      alpha=1

      If (t.eq.0 .or. iFlash.eq.3 .or. iFlash.eq.4) Then
        If (p.le.0) Then
          ierr=1
          RETURN
        endif
        tini=0
        do i=1,nc
          tini=tini+x(i)*tc2(i)/(1-
     & 0.428571*(Log(p/pc2(i))/Log(10D0))/(1+acf2(i)))
        enddo
      Else
        tini=t
      End If
      Tol=0.00000001

C     Do not remove parenthesis around p on the calls to PTEST.  It needs to send the value, not the memory location.
      If (iFlash.eq.1) Then
        Call PTEST (1,t,(p),alpha,x,tc2,pc2,acf2,p,xvap,ierr,herr)
        Call PTEST (5,t,(p),alpha,x,tc2,pc2,acf2,p,xvap,ierr,herr)

      ElseIf (iFlash.eq.2) Then
        Call PTEST (2,t,(p),alpha,x,tc2,pc2,acf2,p,xliq,ierr,herr)
        Call PTEST (6,t,(p),alpha,x,tc2,pc2,acf2,p,xliq,ierr,herr)

      ElseIf (iFlash.eq.3 .or. iFlash.eq.4) Then
        do j=1,7
          dummy=0.7d0+(1.d0-j)/10.d0
          Call PTEST(iFlash,tini,p,alpha,x,tc2,pc2,acf2,fnini,xvap,ierr,
     & herr)
          taux1=dummy*tini
          Call PTEST (iFlash,taux1,p,alpha,x,tc2,pc2,acf2,fnaux1,xvap,
     & ierr,herr)
          taux2=tini/dummy
          Call PTEST (iFlash,taux2,p,alpha,x,tc2,pc2,acf2,fnaux2,xvap,
     & ierr,herr)
          If (fnini*fnaux1.lt.0 .or. fnini*fnaux2.lt.0) GoTo 10
        enddo
 10   continue
        If (fnini*fnaux1.lt.0) Then
          taux2=(tini+taux1)/2
          Call PTEST (iFlash,taux2,p,alpha,x,tc2,pc2,acf2,fnaux2,xvap,
     & ierr,herr)
          If (fnaux2*fnini.lt.0) Then
            taux1=(taux2+tini)/2
            Call PTEST (iFlash,taux1,p,alpha,x,tc2,pc2,acf2,fnaux1,xvap,
     & ierr,herr)
            t=(taux1+taux2)/2
            If (fnaux1*fnini.lt.0) t=(taux1+tini)/2
          Else
            taux3=(taux2+taux1)/2
            Call PTEST (iFlash,taux3,p,alpha,x,tc2,pc2,acf2,fnaux3,xvap,
     & ierr,herr)
            t=(taux3+taux1)/2
            If (fnaux3*fnaux2.lt.0) t=(taux3+taux2)/2
          End If
        ElseIf (fnini*fnaux2.lt.0) Then
          taux1=(tini+taux2)/2
          Call PTEST (iFlash,taux1,p,alpha,x,tc2,pc2,acf2,fnaux1,xvap,
     & ierr,herr)
          If (iFlash.eq.3) Then
            t=(taux1+taux2)/2
            If (fnaux1*fnini.lt.0) t=(taux1+tini)/2
          ElseIf (iFlash.eq.4) Then
            If (fnaux1*fnini.lt.0) Then
              taux2=(taux1+tini)/2
              Call PTEST (iFlash,taux2,p,alpha,x,tc2,pc2,acf2,fnaux2,
     & xvap,ierr,herr)
              t=(taux2+taux1)/2
              If (fnaux2*fnini.lt.0) t=(taux2+tini)/2
            Else
              taux3=(taux1+taux2)/2
              Call PTEST (iFlash,taux3,p,alpha,x,tc2,pc2,acf2,fnaux3,
     & xvap,ierr,herr)
              t=(taux3+taux2)/2
              If (fnaux3*fnaux1.lt.0) t=(taux3+taux1)/2
            End If
          End If
        End If
        amag=2*Tol
        tmp3=100
        tmp4=100
        j=0
 30   continue
        If (amag.gt.Tol .or. tmp3.gt.1 .or. tmp4.gt.1) Then
          j=j+1
          If (j.gt.100) Then
            ierr=1
            RETURN
          endif
          Call PTEST (iFlash,t,p,alpha,x,tc2,pc2,acf2,fn,xvap,ierr,herr)
          tmp2=0
          do i=1,nc
            tx=5.373*tc2(i)
            If (iFlash.eq.3) tmp2=tmp2+(Exp((-tx*acf2(i)-tx)/t+
     &          5.373*acf2(i)))*(tx*pc2(i)*acf2(i)*x(i)+tx*pc2(i)*x(i))
            If (iFlash.eq.4) tmp2=tmp2+(Exp((tx*acf2(i)+tx)/t-
     &          5.373*acf2(i)))*((-tx*acf2(i)*x(i))/pc2(i)-
     &          (tx*x(i))/pc2(i))
          enddo
          fnprime=215.508424158*tmp2*((fn-1)/t)**2/p
          If (iFlash.eq.4) fnprime=-0.004640189839*p*tmp2/(t**2)
          told=t
          If (fnprime.ne.0) t=told-(fn/fnprime)
          fnold=fn
          Call PTEST (iFlash,t,p,alpha,x,tc2,pc2,acf2,fn,xvap,ierr,herr)
          amag=Abs(fn)
          tmp3=(Abs(told-t)/told)*100
          tmp4=(Abs(fnold-fn)/fnold)*100
          GoTo 30
        End If
        If (iFlash.eq.3) Call PTEST(5,t,p,alpha,x,tc2,pc2,acf2,fn,xvap,
     &      ierr,herr)
        If (iFlash.eq.4) Call PTEST(6,t,p,alpha,x,tc2,pc2,acf2,fn,xliq,
     &      ierr,herr)
      End If
      end                                             !subroutine SATEST
c
c ======================================================================
c
      subroutine SAT0EST (t,p,x,xliq,xvap,ierr,herr)
c
c  Estimate compositions for 2-phase states to be used
c  as initial guesses to SATTP.
c
c  inputs:
c   iFlash--see inputs to SATTP
c        t--temperature [K] (input or output)
c        p--pressure [MPa] (input or output)
c        x--composition [array of mol frac]
c  outputs:
c     xliq--liquid phase composition [array of mol frac]
c     xvap--vapor phase composition [array of mol frac]
c     ierr--error flag:   0 = successful
c                         1 = unsuccessful
c     herr--error string (character*255 variable if ierr<>0)
c
c  written by Diego Ortiz, NIST Thermophysics Division, Boulder, Colorado
c  07-01-10 DOO, original version
c
      include 'commons.for'
      dimension x(ncmax),xliq(ncmax),xvap(ncmax)
      character herr*255
c     dimension alphaini,ti,Tol,alphaold,fnold
c     dimension i,j,k,dummy,Pb,Tb,Pd,Td
c     dimension temp1,amag,fn,fnprime,temp2
c     dimension temp3,temp4,alpha1,alpha2,alpha3,alpha
c     dimension fnaux1,fnaux2,fnaux3,fnini
      dimension pc2(ncmax),tc2(ncmax),acf2(ncmax),wmm2(ncmax)
c     dimension wmm,ttrp,tnbpt,tc,pc,dc,zc,acf,dip,Rgas
c
      ierr=0
      do i=1,nc
        Call INFO (i,wmm2(i),ttrp,tnbpt,tc2(i),pc2(i),dc,zc,acf2(i),dip,
     & Rgas)
      enddo

C     Check if (T,P) is in the two-phase region
      Tb=0.d0
      Td=0.d0
      Call SATEST (1,t,Pb,x,xliq,xvap,ierr,herr)
      Call SATEST (2,t,Pd,x,xliq,xvap,ierr,herr)
      Call SATEST (3,Tb,p,x,xliq,xvap,ierr,herr)
      Call SATEST (4,Td,p,x,xliq,xvap,ierr,herr)
      If ((t-Td)*(t-Tb).gt.0 .or. (p-Pb)*(p-Pd).gt.0) Then
        do i=1,nc
        xvap(i)=x(i)/2
        xliq(i)=x(i)
        enddo
        RETURN
      End If

      alphaini=0.5
      alpha1=0.000000001
      alpha2=0.999999999
      Call PTEST (4,t,p,alphaini,x,tc2,pc2,acf2,fnini,xvap,ierr,herr)
      Call PTEST (4,t,p,alpha1,x,tc2,pc2,acf2,fnaux1,xvap,ierr,herr)
      Call PTEST (4,t,p,alpha2,x,tc2,pc2,acf2,fnaux2,xvap,ierr,herr)

      If (fnini*fnaux1.lt.0) Then
        alpha2=(alphaini+alpha1)/2
        Call PTEST (4,t,p,alpha2,x,tc2,pc2,acf2,fnaux2,xvap,ierr,herr)
        If (fnaux2*fnini.lt.0) Then
          alpha1=(alpha2+alphaini)/2
          Call PTEST (4,t,p,alpha1,x,tc2,pc2,acf2,fnaux1,xvap,ierr,herr)
          alpha=(alpha1+alpha2)/2
          If (fnaux1*fnini.lt.0) alpha=(alpha1+alphaini)/2
        Else
          alpha3=(alpha2+alpha1)/2
          Call PTEST (4,t,p,alpha3,x,tc2,pc2,acf2,fnaux3,xvap,ierr,herr)
          alpha=(alpha3+alpha1)/2
          If (fnaux3*fnaux2.lt.0) alpha=(alpha3+alpha2)/2
        End If
      ElseIf (fnini*fnaux2.lt.0) Then
        alpha1=(alphaini+alpha2)/2
        Call PTEST (4,t,p,alpha1,x,tc2,pc2,acf2,fnaux1,xvap,ierr,herr)
        If (fnaux1*fnini.lt.0) Then
          alpha2=(alpha1+alphaini)/2
          Call PTEST (4,t,p,alpha2,x,tc2,pc2,acf2,fnaux2,xvap,ierr,herr)
          alpha=(alpha2+alpha1)/2
          If (fnaux2*fnini.lt.0) alpha=(alpha2+alphaini)/2
        Else
          alpha3=(alpha1+alpha2)/2
          Call PTEST (4,t,p,alpha3,x,tc2,pc2,acf2,fnaux3,xvap,ierr,herr)
          alpha=(alpha3+alpha2)/2
          If (fnaux3*fnaux1.lt.0) alpha=(alpha3+alpha1)/2
        End If
      End If

      Tol=0.00001d0
      amag=2*Tol
      temp3=100
      temp4=100
      j=0
 30   continue
      If (amag.gt.Tol .or. temp3.gt.1 .or. temp4.gt.1) Then
        j=j+1
        Call PTEST (4,t,p,alpha,x,tc2,pc2,acf2,fn,xvap,ierr,herr)
        temp1=0
        do i=1,nc
          temp2=Exp((5.373d0*tc2(i)*acf2(i)+5.373*tc2(i))/t)
          temp3=pc2(i)*215.508424158d0**(1+acf2(i))
          temp1=temp1-(x(i)*0.004640189839d0*temp2*(p*temp2-
     & temp3))/((alpha*(p*temp2-temp3)-p*temp2)**2)
        enddo
        fnprime=p*temp1*215.508424158d0
        alphaold=alpha
        alpha=alphaold-(fn/fnprime)
        if (alpha.gt.1.d0) alpha=(1.d0+alphaold)/2.d0
        If (alpha.gt.1E+20 .or. j.gt.100) Then
          ierr=1
          RETURN
        endif
        fnold=fn
        Call PTEST (4,t,p,alpha,x,tc2,pc2,acf2,fn,xvap,ierr,herr)
        amag=Abs(fn)
        temp3=(Abs(alphaold-alpha)/alphaold)*100
        temp4=(Abs(fnold-fn)/fnold)*100
        GoTo 30
      End If

      Call PTEST (6,t,p,alpha,x,tc2,pc2,acf2,fn,xliq,ierr,herr)
      do i=1,nc
        xvap(i)=(x(i)-xliq(i)*(1-alpha))/alpha
      enddo
      end                                            !subroutine SAT0EST
c
c ======================================================================
c
      subroutine PTEST(inp,t,p,alpha,x,tc2,pc2,acf2,calc,xout,ierr,herr)
c
c  Part of the SATEST routines
c
c  inputs:
c  outputs:
c     ierr--error flag:   0 = successful
c     herr--error string (character*255 variable if ierr<>0)
c
c  written by Diego Ortiz, NIST Thermophysics Division, Boulder, Colorado
c  07-01-10 DOO, original version
c
      include 'commons.for'
      dimension x(ncmax),xout(ncmax),pc2(ncmax),tc2(ncmax),acf2(ncmax)
      character herr*255
c     dimension i
c     dimension sum
      dimension ptemp(ncmax)
c
      ierr=0
      herr=' '

      If (t.le.0) RETURN
      do i=1,nc
        ptemp(i)=pc2(i)*Exp(5.373*(1+acf2(i))*(1-tc2(i)/t))
        If (ptemp(i).gt.pc2(i)) ptemp(i)=pc2(i)+1*(ptemp(i)-pc2(i))
      enddo
      sum=0
      If (inp.eq.1) Then
        do i=1,nc
          sum=sum+x(i)*ptemp(i)
        enddo
        calc=sum
      ElseIf (inp.eq.2) Then
        do i=1,nc
          sum=sum+x(i)/ptemp(i)
        enddo
        calc=1/sum
      ElseIf (inp.eq.3) Then
        do i=1,nc
          sum=sum+x(i)*ptemp(i)
        enddo
        calc=1-p/sum
      ElseIf (inp.eq.4) Then
        do i=1,nc
          divs=(1-alpha+alpha*ptemp(i)/p)
          if (divs.gt.0.d0) sum=sum+x(i)/divs
        enddo
        calc=1-sum
      ElseIf (inp.eq.5) Then
        do i=1,nc
          xout(i)=x(i)/p*ptemp(i)
          If (xout(i).lt.0.000001 .and. x(i).gt.0.d0) xout(i)=0.000001
          If (xout(i).gt.0.999999) xout(i)=0.999999
          sum=sum+xout(i)
        enddo
        do i=1,nc
          xout(i)=xout(i)/sum
        enddo
      ElseIf (inp.eq.6) Then
        do i=1,nc
          xout(i)=x(i)/(1-alpha+alpha*ptemp(i)/p)
          If (xout(i).lt.0.000001 .and. x(i).gt.0.d0) xout(i)=0.000001
          If (xout(i).gt.0.999999) xout(i)=0.999999
          sum=sum+xout(i)
        enddo
        do i=1,nc
          xout(i)=xout(i)/sum
        enddo
      Else
      End If
      end                                              !subroutine PTEST
c
c ======================================================================
c
      subroutine SATTP (t,p,x,iFlsh,iGuess,d,Dl,Dv,xliq,xvap,q,ierr,
     & herr)
c
c  Estimate temperature, pressure, and compositions to be used
c  as initial guesses to SATTP
c
c  inputs:
c   iFlsh--Phase flag:    0 - Flash calculation (T and P known)
c                         1 - T and xliq known, P and xvap returned
c                         2 - T and xvap known, P and xliq returned
c                         3 - P and xliq known, T and xvap returned
c                         4 - P and xvap known, T and xliq returned
c                         if this value is negative, the retrograde point will be returned
c        t--temperature [K] (input or output)
c        p--pressure [MPa] (input or output)
c        x--composition [array of mol frac]
c   iGuess--if set to 1, all inputs are used as initial guesses for the calculation
c  outputs:
c        d--overall molar density [mol/L]
c       Dl--molar density [mol/L] of saturated liquid
c       Dv--molar density [mol/L] of saturated vapor
c     xliq--liquid phase composition [array of mol frac]
c     xvap--vapor phase composition [array of mol frac]
c        q--quality
c     ierr--error flag:   0 = successful
c                         1 = unsuccessful
c     herr--error string (character*255 variable if ierr<>0)
c
c  written by Andreas Jaeger, Johannes Gernert, Diego Ortiz, and Eric Lemmon
c  06-20-11 EWL, original version
c
      include 'commons.for'
      dimension x(ncmax),xliq(ncmax),xvap(ncmax),ix(ncmax),ij(ncmax)
      character herr*255
      dimension dadn(ncmax),dnadn(ncmax)
      dimension xvap_new(ncmax),xliq_new(ncmax)
      dimension xJacMatrix(50,50),Delta_X(50),GibbsEQN(50)
      dimension xlnfiliq(ncmax),xlnfivap(ncmax),
     &          dphidxjliq(ncmax,ncmax),dphidxjvap(ncmax,ncmax),
     &          dphidTliq(ncmax),dphidPliq(ncmax),
     &          dphidTvap(ncmax),dphidPvap(ncmax)

c  Set up pointer array ix to sort the components by largest first, removing
c  any that are zero.
      iGues=iGuess
      nc2=nc
      do i=1,nc
        ij(i)=1
      enddo
      do i=1,nc
        if (x(i).le.0.d0) nc2=nc2-1
        k=1
        do j=1,nc
          if (ij(k).eq.0) k=j
          if (x(j).gt.x(k) .and. ij(j).eq.1) k=j
        enddo
        ij(k)=0
        if (x(k).gt.0.d0) ix(i)=k
      enddo

      call ISPURE (x,icomp)
      call CRITP (x,tc,pc,rhoc,ierr,herr)
      iSatFlg=0
      irdxerr=0
      eMax=0
      iretrog=0
      if (iFlsh.lt.0) iretrog=1
      iFlash=abs(iFlsh)

      if (iSpline.ne.0 .and. iFlash.gt.0) then
        call MAXT (x,tmaxt,tmaxp,tmaxd,ierr,herr)
        call MAXP (x,pmaxt,pmaxp,pmaxd,ierr,herr)
        d=rhoc*2.d0
        if (iFlash.eq.2 .or. iFlash.eq.4) d=rhoc/10.d0
        if (iretrog.eq.1 .and. tmaxd.gt.0.d0) d=(tmaxd+rhoc)/2.d0
        if (iFlash.eq.1 .or. iFlash.eq.2) then
          call SPLNROOT (nc+1,0,t,d,ierr,herr)
          if (ierr.gt.0) then
            d=d*0.75d0
            if (d.lt.1.d-5) d=rhoc*0.75d0
            call SPLNROOT (nc+1,0,t,d,ierr,herr)
          endif
          if (ierr.gt.0) d=rhoc*2.d0
          call SPLNVAL (nc+1,1,d,dydd,ierr,herr)
          if (iFlash.eq.1 .and. dydd.gt.0) goto 10  !Exit if d(T)/d(rho) is positive (vapor surface)
        else
          call SPLNROOT (nc+2,0,p,d,ierr,herr)
          call SPLNVAL (nc+2,1,d,dydd,ierr,herr)
          if (iFlash.eq.3 .and. dydd.gt.0) goto 10  !Exit if d(P)/d(rho) is positive (vapor surface)
        endif
        Dl=d
        Dv=d

        do j=1,nc+3
          call SPLNVAL (j,0,d,y,ierr,herr)
          y=abs(y)
          if (j.le.nc) then
            if (iFlash.eq.1 .or. iFlash.eq.3) then
              xvap(j)=abs(y)
              xliq(j)=x(j)
            else
              xliq(j)=abs(y)
              xvap(j)=x(j)
            endif
          elseif (j.eq.nc+1) then
            if (iFlash.eq.3 .or. iFlash.eq.4) t=y
          elseif (j.eq.nc+2) then
            if (iFlash.eq.1 .or. iFlash.eq.2) p=y
          elseif (j.eq.nc+3) then
            if (iFlash.eq.1 .or. iFlash.eq.3) Dv=y
            if (iFlash.eq.2 .or. iFlash.eq.4) Dl=y
          endif
        enddo
        sumx=sum(xliq(1:nc))
        sumy=sum(xvap(1:nc))
        xliq(1:nc)=xliq(1:nc)/sumx
        xvap(1:nc)=xvap(1:nc)/sumy
        iGues=1
      endif

 10   continue
c  PR does not have derivatives needed for SATTP, must use SATT
      if (icomp.ne.0 .or. irdxerr.ne.0 .or .heos.eq.'PR') then
        iSatFlg=1
        if (iFlash.eq.1 .or. iFlash.eq.2) then
          call SATT (t,x,iFlash,p,Dl,Dv,xliq,xvap,ierr,herr)
        elseif (iFlash.eq.3 .or. iFlash.eq.4) then
          call SATP (p,x,iFlash-2,t,Dl,Dv,xliq,xvap,ierr,herr)
        else
          call TPFLSH(t,p,x,d,Dl,Dv,xliq,xvap,q,e,h,s,cv,cp,w,ierr,herr)
        endif
        if (iFlash.eq.1 .or. iFlash.eq.3) then
          q=0
          d=Dl
        elseif (iFlash.eq.2 .or. iFlash.eq.4) then
          q=1
          d=Dv
        endif
        iSatFlg=0
        if (ierr.eq.0) then
          if (abs(dl-dv).lt.0.1d0 .and. abs(dl-rhoc).gt.0.1d0) ierr=1
          if (dl+dv.lt.rhoc) ierr=1
        endif
        RETURN
      endif

      If (iGues.eq.0) Then
        dv=rhoc
        dl=rhoc
        If (iFlash.eq.3 .or. iFlash.eq.4) t=300
        If (iFlash.ne.0) Call SATEST (iFlash,t,p,x,xliq,xvap,ierr,herr)
        If (iFlash.eq.0) Call SAT0EST (t,p,x,xliq,xvap,ierr,herr)
      End If

      tol1=1.d-12
      tol2=1.d-10
      ierr=0
      herr=' '
      dvap=dv
      dliq=dl
      ieqn=nc2
      if (iFlash.eq.0) ieqn=2*(nc2-1)

      do il=1,30
        GibbsEQN=0.d0
c...Vapor
        call TPRHO (t,p,xvap,2,iGues,dvap,ierr,herr)
        if (ierr.ne.0) then
          call TPRHO (t,p,xvap,1,0,dvap,ierr,herr)
          if (ierr.ne.0) goto 1000
        endif
        call PHIDERV (2,t,dvap,xvap,dadn,dnadn,ierr,herr)
        if (ierr.eq.191) then !Derivatives of the Helmholtz equation are not available, use SATT or SATP
          irdxerr=ierr
          goto 10
        endif
        if (ierr.ne.0) goto 1000
        do j=1,nc2
          xlnfivap(j)=xlnfi(ix(j))
          dphidtvap(j)=dphidt(ix(j))
          dphidpvap(j)=dphidp(ix(j))
          do k=1,nc2
          dphidxjvap(j,k)=dphidxj(ix(j),ix(k))-dlnphiidxj(ix(nc2),ix(k))
          enddo
          dphidxjvap(j,nc2)=dphidxjvap(j,nc2)-1.d0/xvap(ix(nc2))
        end do

c...Liquid
        call TPRHO (t,p,xliq,1,iGues,dliq,ierr,herr)
        if (ierr.ne.0 .and. iFlash.eq.3) then
          t=t-5.d0
          call TPRHO (t,p,xliq,1,iGues,dliq,ierr,herr)
          if (ierr.ne.0) then
            t=t-5.d0
            call TPRHO (t,p,xliq,1,iGues,dliq,ierr,herr)
          endif
          if (ierr.ne.0) t=t+10.d0
        endif
        if (ierr.ne.0 .and. iFlash.eq.1) then
          p0=p
          p=p*1.2d0
          call TPRHO (t,p,xliq,1,iGues,dliq,ierr,herr)
          if (ierr.ne.0) then
            p=p*1.5d0
            call TPRHO (t,p,xliq,1,iGues,dliq,ierr,herr)
          endif
          if (ierr.ne.0) then
            p=p*1.5d0
            call TPRHO (t,p,xliq,1,iGues,dliq,ierr,herr)
          endif
          if (ierr.ne.0) p=p0
        endif
        if (ierr.ne.0) then
          call TPRHO (t,p,xliq,2,0,dliq,ierr,herr)
          if (ierr.ne.0) goto 1000
        endif
        call PHIDERV (2,t,dliq,xliq,dadn,dnadn,ierr,herr)
        if (ierr.ne.0) goto 1000
        do j=1,nc2
          xlnfiliq(j)=xlnfi(ix(j))
          dphidtliq(j)=dphidt(ix(j))
          dphidpliq(j)=dphidp(ix(j))
          do k=1,nc2
          dphidxjliq(j,k)=dphidxj(ix(j),ix(k))-dlnphiidxj(ix(nc2),ix(k))
          enddo
          dphidxjliq(j,nc2)=dphidxjliq(j,nc2)-1.d0/xliq(ix(nc2))
        end do

        do j=1,nc2
          GibbsEQN(j)=xlnfivap(j)-xlnfiliq(j)
        end do
        if (iFlash.eq.0) then
          do j=1,nc2-2
            dxkdxj_vap=(xvap(ix(nc2-1))-x(ix(nc2-1)))/
     &                 (xvap(ix(j))-x(ix(j)))
            dxkdxj_liq=(xliq(ix(nc2-1))-x(ix(nc2-1)))/
     &                 (xliq(ix(j))-x(ix(j)))
            GibbsEQN(nc2+j)=dxkdxj_vap-dxkdxj_liq
          end do
        end if

        if (il.eq. 8) tol1=tol1*10
        if (il.eq.12) tol1=tol1*10
        if (il.eq.16) tol1=tol1*10
        if (il.eq.20) tol1=tol1*10
        if (il.eq. 8) tol2=tol2*10
        if (il.eq.12) tol2=tol2*10
        if (il.eq.16) tol2=tol2*10
        if (il.eq.20) tol2=tol2*10
        eMax=maxval(dabs(GibbsEQN))
        if (eMax.lt.tol1) goto 1000

c..Set up Jacobian matrix
        xJacMatrix(1:ieqn,1:ieqn)=0.d0
        if (iFlash.eq.0) then
          do j=1,nc2-1
            do k=1,nc2
              xJacMatrix(k,j)=dphidxjvap(j,k)
              xJacMatrix(k,nc2-1+j)=-dphidxjliq(j,k)
            end do
          end do
          do j=1,nc2-2
            xJacMatrix(nc2+j,j)=
     &               -(xvap(ix(nc2-1))-x(ix(nc2-1)))/
     &               ((xvap(ix(j))-x(ix(j)))**2)
            xJacMatrix(nc2+j,nc2-1)=1.d0/(xvap(ix(j))-x(ix(j)))
            xJacMatrix(nc2+j,nc2-1+j)=
     &                (xliq(ix(nc2-1))-x(ix(nc2-1)))/
     &               ((xliq(ix(j))-x(ix(j)))**2)
            xJacMatrix(nc2+j,2*(nc2-1))=-1.d0/(xliq(ix(j))-x(ix(j)))
          end do
        else
          do k=1,nc2
            do j=1,nc2-1
              if (iFlash.eq.1 .or. iFlash.eq.3) then
                xJacMatrix(k,j)=dphidxjvap(j,k)
              elseif (iFlash.eq.2 .or. iFlash.eq.4) then
                xJacMatrix(k,j)=-dphidxjliq(j,k)
              endif
            end do
            if (iFlash.eq.1 .or. iFlash.eq.2) then
              xJacMatrix(k,nc2)=dphidpvap(k)-dphidpliq(k)
            elseif (iFlash.eq.3 .or. iFlash.eq.4) then
              xJacMatrix(k,nc2)=dphidtvap(k)-dphidtliq(k)
            endif
          end do
        endif
c..Solve Jacobian matrix
        Delta_X=-GibbsEQN
        call LUdecomp (ieqn,50,xJacMatrix,Delta_X,ierr,herr)
        eMax=maxval(dabs(Delta_X))
        if (eMax.lt.tol2) goto 1000

 100    continue
        jj=0
        if (iFlash.eq.0) jj=nc2-1
        t_new=0.d0
        p_new=0.d0
        sum_liq=0.d0
        sum_vap=0.d0
        sum_vsmall=0.d0

        do j=1,nc2
          if (x(ix(j)).gt.0.d0) then
            if (j.lt.nc2) then
              xvap_new(ix(j))=xvap(ix(j))+Delta_X(j)
              xliq_new(ix(j))=xliq(ix(j))+Delta_X(j+jj)
            else
              xvap_new(ix(nc2))=1.d0-sum_vap-sum_vsmall
              xliq_new(ix(nc2))=1.d0-sum_liq
              t_new=t+Delta_X(j)
              p_new=p+Delta_X(j)
            end if
            sum_vap=sum_vap+xvap_new(ix(j))
            sum_liq=sum_liq+xliq_new(ix(j))
            if (xvap_new(ix(j)).lt.1.d-10)
     &        sum_vsmall=sum_vsmall+xvap_new(ix(j))
            k=0
            if (iFlash.eq.1 .or. iFlash.eq.3) then
              if (xvap_new(ix(j)).le.0.d0.or.xvap_new(ix(j)).ge.1.d0)k=1
              if (p_new.lt.0) k=1
            elseif (iFlash.eq.2 .or. iFlash.eq.4) then
              if (xliq_new(ix(j)).le.0.d0.or.xliq_new(ix(j)).ge.1.d0)k=1
            else
              if (((xvap_new(ix(j))-x(ix(j)))
     &            *(xliq_new(ix(j))-x(ix(j))).gt.0.d0)
     &         .or.(xliq_new(ix(j))*xvap_new(ix(j)).lt.0.d0)) k=1
            endif
            if (k.eq.1) then
              Delta_X=Delta_X/2.d0
              if (maxval(dabs(Delta_X)).lt.1.d-10) goto 999
              goto 100
            end if
          endif
        end do

        Dl=dliq
        Dv=dvap
        if (iFlash.eq.1) then
          q=0
          xvap(ix(1:nc2))=xvap_new(ix(1:nc2))
          p=p_new
          d=dliq
        elseif (iFlash.eq.2) then
          q=1
          xliq(ix(1:nc2))=xliq_new(ix(1:nc2))
          p=p_new
          d=dvap
        elseif (iFlash.eq.3) then
          q=0
          xvap(ix(1:nc2))=xvap_new(ix(1:nc2))
          t=t_new
          d=dliq
        elseif (iFlash.eq.4) then
          q=1
          xliq(ix(1:nc2))=xliq_new(ix(1:nc2))
          t=t_new
          d=dvap
        elseif (iFlash.eq.0) then
          q=(x(ix(1))-xliq(ix(1)))/(xvap(ix(1))-xliq(ix(1)))
          xvap(ix(1:nc2))=xvap_new(ix(1:nc2))
          xliq(ix(1:nc2))=xliq_new(ix(1:nc2))
          d=1.d0/((1.0d0-q)/dliq+q/dvap)
        else
          stop
        endif
        if (p.le.0.d0) goto 1000
      enddo

 999  ierr=3
      herr='SATTP:  Error in iteration'
      if (il.gt.30) then
        ierr=2
        herr='SATTP:  Maximum number of iterations exceeded'
      endif
1000  continue
      if (dv.lt.0) ierr=1
      if (dl.lt.0) ierr=1
      if (abs(dl-dv).lt.0.1d0 .and. abs(dl-rhoc).gt.0.1d0) ierr=1
c     if (dv.gt.dl*1.1d0) ierr=1
      if (p.gt.pc*10) ierr=1
      if (p.le.0) ierr=1
      if (ierr.ne.0 .and. herr(1:1).eq.' ') then
        herr='SATTP:  Iteration failed'
      endif
      if (ierr.gt.0 .and. iSatFlg2.eq.0) then
        irdxerr=ierr
        goto 10
      endif
      RETURN
      end                                              !subroutine SATTP
c
c ======================================================================
c
      subroutine SATSPLN (z,ierr,herr)
c
c  calculates the phase boundary of a mixture at a given composition,
c  and the critical point, cricondentherm, and cricondenbar.
c
c  inputs:
c        z--composition [array of mol frac]
c  outputs:
c     ierr--error flag:   0 = successful
c     herr--error string (character*255 variable if ierr<>0)
c
c  written by E.W. Lemmon, NIST Thermophysics Division, Boulder, Colorado
c  09-20-11 EWL, original version
c  12-01-12 EWL, change to density marching method
c
      include 'commons.for'
      dimension xPnts(1000),yPnts(1000),coefs(1000)
      dimension x(ncmax),y(ncmax),z(ncmax),slp(20)
      character herr*255
      common /GVtemp/itersgv

      ierr=0
      herr=' '
c     if (iSpline.ne.0) then
c       lsame2=.true.
c       do i=1,nc
c         if (abs(z(i)-xspln(i)).gt.1.d-6) lsame2=.false.
c       enddo
c       if (lsame2) goto 999
c     end if

      iSpline=0
      slp=0.d0
      call ISPURE (z,icomp)
      if (icomp.ne.0) goto 999
      call CRITP (z,tc,pc,rhoc,ierr,herr)
      call LIMITS ('EOS',z,tmin,tmax,Dmax,pmax)
      p=0.001d0
      t=300
      rho=0.d0

c  call RDXHMX to make sure that analytical derivatives are available
c  for the mixture
      call RDXHMX (1,1,0,Z,tr01,dr01,ierr,herr)
      if (ierr.gt.0 .and. heos.ne.'PR') goto 999


 5    continue
      call SATTP (t,p,z,4,0,d,rhox,rhoy,x,y,q,ierr,herr)
      if (ierr.gt.0 .or. t.lt.tmin*0.95d0) then
        p=p*10.d0
        if (p.lt.pmax) goto 5
        ierr=1
        herr='[SATSPLN error 1] saturation routine failed in '//
     &       'calculating initial state'
        goto 999
      endif

      if (tmin.gt.t) tmin=t
      iSatFlg2=1
      vf=1
      d=rhoy
      n=0
      isame=0
      dinc=0.1d0
      d0=1.d-12
 10   continue
        call THERM (t,rhoy,y,pp,e,h,s,cv,cp,w,hjt)
        n=n+1
        do i=1,nc
          xarr(i,n)=-500.d0
          if (x(i).gt.0.d0) xarr(i,n)=log(x(i))
        enddo
        xarr(   0,n)=log(rhoy)
        xarr(nc+1,n)=log(t)
        xarr(nc+2,n)=log(p)
        xarr(nc+3,n)=log(rhox)
        xarr(nc+4,n)=h
        xarr(nc+5,n)=s
        if (n.le.5) then
c  add several very low density states to spline arrays to catch low densities
          d0=d0*100.d0
          if (rhoy.gt.d0) then
            xarr(   0,n)=log(d0)
            xarr(nc+2,n)=log(d0*r*t)
            goto 10
          endif
        endif
        rhoyo=rhoy
        rhoxo=rhox
        iex=0
        slp(2:20)=slp(1:19)

 20     continue
        if (d.lt.dinc/10.d0) then
          d=d*10.d0
        else
          d=d+dinc
        endif
        if (d.lt.0.d0) goto 30

        rhoy=d
        if (n.gt.3) then
            xval=log(d)
            xPnts(1:3)=xarr(0,n-2-iex:n-iex)
            yPnts(1:3)=xarr(nc+3,n-2-iex:n-iex)
            call POLYN (3,xPnts,yPnts,xval,yval,ierr,herr)
          rhox=exp(yval)
            yPnts(1:3)=xarr(nc+1,n-2-iex:n-iex)
            call POLYN (3,xPnts,yPnts,xval,yval,ierr,herr)
          t=exp(yval)
            yPnts(1:3)=xarr(nc+2,n-2-iex:n-iex)
            call POLYN (3,xPnts,yPnts,xval,yval,ierr,herr)
          p=exp(yval)
c           yPnts(1:3)=xarr(nc+5,n-2-iex:n-iex)
c           call POLYN (3,xPnts,yPnts,xval,yval,ierr,herr)
c         s=yval
          do i=1,nc
            yPnts(1:3)=xarr(i,n-2-iex:n-iex)
            call POLYN (3,xPnts,yPnts,xval,yval,ierr,herr)
            xi=exp(yval)
            if (xi.gt.0) x(i)=xi
          enddo
          sumx=sum(x(1:nc))
          if (abs(sumx).gt.1.d-10) then
            x(1:nc)=x(1:nc)/sumx
          else
            x(1:nc)=y(1:nc)
          endif
        endif

c  density marching algorithm
        call SATGV (t,p,z,vf,d,1,6,0,rhox,rhoy,x,y,ierr,herr)
        if (ierr.ne.0) then
          call SATGV (t,p,z,vf,d,2,6,0,rhox,rhoy,x,y,ierr,herr)
          if (ierr.ne.0 .and. d.lt.1) then
            p=p*10.d0
            call SATTP (t,p,z,4,0,dd,rhox,rhoy,x,y,q,ierr,herr)
            if (ierr.eq.0) d=dd
          endif
        endif

        if (ierr.le.0) then
          if (rhoyo.ne.rhoy) s1=(rhoxo-rhox)/(rhoyo-rhoy)
          slp(1)=s1
          if (n.gt.10 .and. abs(s1).gt.0.1d0) then
            if (rhoy.lt.rhoc*1.3d0 .and. rhoy.gt.rhoc*0.7d0) then
              sa=SUM(slp(2:10))/9.d0  !Average of last several points
              if (s1*sa.gt.0 .and. abs(s1).lt.abs(sa)) then
                !Both points same sign, and new slope less than average
              elseif (abs(slp(2)).le.0.1d0) then
              elseif (abs((s1-slp(2))/slp(2)).gt.5d0) then
                ierr=1
              endif
            endif
          endif
        endif

c       if (ierr.eq.0) then
c         if (abs(rhox-rhoxo)/rhox.gt.0.2d0) then
c           if (rhox.lt.rhoc*2.d0 .and. rhox.gt.rhoc/2.d0) ierr=1
c         endif
c       endif

        if (abs(rhox-rhoy)/rhox.lt.0.01d0) then
          isame=isame+1
          if (isame.gt.3 .and. ierr.eq.0) ierr=1
        else
          isame=0
        endif

        if (ierr.gt.0) then
          if (iex.lt.15 .and. n.gt.20) then
            iex=iex+1
          else
            iex=0
          endif
          if (d.gt.rhoc*4.d0) goto 30
          if (t.gt.tmin*0.999d0 .and. n.lt.narm) goto 20
        endif
      if (t.gt.tmin*0.999d0 .and. n.lt.narm) goto 10



 30   continue
      narr=n
      if (narr.lt.20) then
        ierr=2
        herr='[SATSPLN error 2] saturation routine failed'
        narr=0
        goto 999
      endif


c  Create splines
      xPnts(1:narr)=xarr(0,1:narr)
      do k=1,nc+5
        yPnts(1:narr)=xarr(k,1:narr)
        call CSPLINE (narr-1,xPnts,yPnts,coefs)
        carr(k,1:narr)=coefs(1:narr)
      enddo
      iSpline=1
      xspln(1:nc)=z(1:nc)

c  cricondentherm (search for dtdx=0)
      dtdx=0.d0
      d=rhoc/4.d0
      call SPLNROOT (nc+1,1,dtdx,d,ierr,herr)
      call SPLNVAL  (nc+1,0,d,tmxt,ierr1,herr)
      call SPLNVAL  (nc+2,0,d,tmxp,ierr1,herr)
      tmxd=d
      ierrtmx=0
      if (ierr.gt.0) then
        ierrtmx=1
        tmxt=300
        tmxp=0
        tmxd=0
      endif

c  cricondenbar (search for dpdx=0)
      dpdx=0.d0
      d=rhoc
      call SPLNROOT (nc+2,1,dpdx,d,ierr,herr)
      if (ierr.gt.0) then
        d=rhoc/2.d0
        call SPLNROOT (nc+2,1,dpdx,d,ierr,herr)
      endif
      call SPLNVAL  (nc+1,0,d,pmxt,ierr1,herr)
      call SPLNVAL  (nc+2,0,d,pmxp,ierr1,herr)
      pmxd=d
      ierrpmx=0
      if (ierr.gt.0) then
        ierrpmx=1
        pmxt=300
        pmxp=0
        pmxd=0
      endif

c  critical point [the point at which x(i)=y(i) where i is the fluid with max x]
      i=1
      do j=1,nc
        if (z(j).gt.z(i)) i=j
      enddo
      y1=z(i)
      d=rhoc
      call SPLNROOT (   i,0,y1,d,ierr,herr)
      if (ierr.gt.0) then
        d=rhoc/2.d0
        call SPLNROOT (   i,0,y1,d,ierr,herr)
      endif
      call SPLNVAL  (nc+1,0,d,crtt,ierr1,herr)
      call SPLNVAL  (nc+2,0,d,crtp,ierr1,herr)
      crtd=d
      ierrcrt=0
      if (ierr.gt.0 .or. crtp.gt.50000) then
        ierrcrt=1
        crtt=tc
        crtp=pc
        crtd=rhoc
      endif

      ierr=0
      herr=' '
 999  continue
      iSatFlg2=0
      RETURN
      end                                            !subroutine SATSPLN
c
c ======================================================================
c
      subroutine GETXY (z,vf,philn,phi,x,y)
c
c  calculate the liquid and vapor compositions with the known values
c  of the overall composition, the vapor fraction, and the log of the
c  fugacity coefficients.
c
c  inputs:
c         z--overall composition [array of mol frac]
c        vf--vapor fraction (0>=vf>=1)
c            set vf=0 for liquid and vf=1 for vapor
c     philn--natural log of the fugacity coefficients [-]
c
c  outputs:
c       phi--fugacity coefficients [-]
c         x--liquid composition [array of mol frac]
c         y--vapor composition [array of mol frac]
c
c  written by G. Venkatarathnam, Indian Institute of Technology Madras
c  00-00-12  GV, original version
c  10-29-12 EWL, adapt code for use in REFPROP
c
      include 'commons.for'
      dimension z(ncmax),x(ncmax),y(ncmax),philn(ncmax+3),phi(ncmax)
      do i=1,nc
        phi(i)=EXP(philn(i))
        x(i)=z(i)
        xdiv=1.d0-vf+vf*phi(i)
        if (ABS(xdiv).gt.1.d-10 .and. xdiv.lt.1.d+10) x(i)=z(i)/xdiv
        y(i)=x(i)*phi(i)
      enddo
      sumx=SUM(x(1:nc))
      sumy=SUM(y(1:nc))
      if (ABS(sumx).gt.1.d-10) x(1:nc)=x(1:nc)/sumx
      if (ABS(sumy).gt.1.d-10) y(1:nc)=y(1:nc)/sumy
      RETURN
      end                                              !subroutine GETXY
c
c ======================================================================
c
      subroutine LGPHI (iderv,iphase,t,rho,p,x,philn,dpt,dpdrho,ddt,cp,
     &                  ierr,herr)
c
c  inputs:
c     iderv--set to 1 for calculation of fugacity coefficient (philn) only
c            set to 2 for full calculations (when calling PHIDERV) for use in other places
c            set to 3 to calculate p as function of t and rho,
c                     and for full calculations of everything else
c         t--temperature [K]
c       rho--density [mol/l] (if iderv=3)
c         p--pressure [kPa] (if iderv<>3)
c         x--composition [array of mol frac]
c    iphase--input phase, 1: liquid, 2: vapor,
c                         0: phase with minimum gibbs energy
c
c  outputs:
c    iphase--correct phase, computed using GV's pi criteria [2:vap,1:liq]
c       rho--density [mol/l] (input value should be an initial guess)
c         p--pressure [kPa] (if iderv=3)
c     philn--ln of fugacity coefficient [-]
c      ierr--error flag
c      herr--error string (character*255 variable if ierr<>0)
c
c  written by G. Venkatarathnam, Indian Institute of Technology Madras
c  00-00-12  GV, original version
c  10-29-12 EWL, adapt code for use in REFPROP
c
      include 'commons.for'
      dimension x(ncmax),philn(ncmax),phi(ncmax)
      dimension dadn(ncmax),dnadn(ncmax)
      character herr*255

      call CRITP (x,tc,pc,rhoc,ierr,herr)
      if (iderv.eq.3) then
        call PRESS (t,rho,x,p)
      else
        if (iphase.ne.0) then
          call TPRHO (t,p,x,iphase,1,rho,ierr,herr)
          if (ierr.ne.0) call TPRHO (t,p,x,3-iphase,0,rho,ierr,herr)
          if (rho.eq.0.d0) rho=1.d-20
        else  ! phase with minimum gibbs energy
          grv=1.d36  !no convergence
          grl=1.d36
          call TPRHO (t,p,x,1,0,rhol,ierr,herr)
          if (ierr.le.0) call GIBBS (t,rhol,x,arl,grl)
          call TPRHO (t,p,x,2,0,rhov,ierr,herr)
          if (ierr.le.0) call GIBBS (t,rhov,x,arv,grv)
          rho=rhol
          if (grv.le.grl) rho=rhov
          if (rho.eq.0.d0) rho=1.d-20
        endif
      endif
      if (rho.lt.0.d0) rho=rhoc+1.d-20

      call THERM2 (t,rho,x,pp,e,h,s,cv,cp,w,z,hjt,a,g,
     &                   xkappa,beta,dpdrho,d2pdd2,dpt,ddt,drhodp,
     &                   d2pt2,d2pdtd,spare3,spare4)
      if (iderv.eq.1) then
        call FUGCOF (t,rho,x,phi,ierr,herr)
        philn(1:nc)=log(phi(1:nc))
      else
        call PHIDERV (iderv,t,rho,x,dadn,dnadn,ierr,herr)
        if (ierr.gt.0) RETURN
        RTrho=R*t*rho
        do i=1,nc
          phi(i)=1.d0
          if (ABS(dnadn(i)).lt.100.0d0) then
c  Correct calculation of log(phi) is:
c           if (p.gt.0) philn(i)=DLOG(RTrho/p)+dnadn(i)
c  but use this instead since p can be negative, and in the solution
c  of VLE the p's must be equal, so they cancel out.  The 1.d3 keeps the
c  value of RTrho on the same scale as dnadn (and also cancels out),
            philn(i)=DLOG(RTrho/1.d3)+dnadn(i)
          endif
        enddo
      endif
      if (dpt.ne.0.d0 .and. dpdrho.ne.0.d0)
     &    pifactor=2.d0-rho*(d2pdtd/dpt-d2pdd2/dpdrho)
      iphase=2
      if (pifactor.gt.1.d0) iphase=1
      if (rho.gt.rhoc*2.d0) iphase=1  !Special case for mixtures with water where pifactor<0 in the liquid
      RETURN
      end                                              !subroutine LGPHI
c
c ======================================================================
c
      subroutine CRTPNT (z,tc,pc,rhoc,ierr,herr)
c
c     Subroutine for the determination of true critical point of a
c     mixture using the Method of Michelsen (1984)
c
c     The routine requires good initial guess values of pc and tc.
c     On convergence, the values of bb and cc should be close to zero
c     and dd > 0 for a two-phase critical point.
c     bb=0, cc=0 and dd <= 0 for an unstable critical point.
c
c  inputs:
c         z--composition [array of mol frac]
c
c  outputs:
c        tc--critical temperature [K]
c        pc--critical pressure [kPa]
c      rhoc--critical density [mol/l]
c      ierr--error flag
c      herr--error string (character*255 variable if ierr<>0)
c
c  written by G. Venkatarathnam, Indian Institute of Technology Madras
c  10-15-11  GV, original version
c  01-07-13 EWL, adapt code for use in REFPROP
c
      include 'commons.for'
      dimension z(ncmax),y(ncmax),yn(ncmax),v(ncmax),g(ncmax),u(ncmax)
      dimension a(ncmax,ncmax),dfds(2),dpht(ncmax),dphp(ncmax)
      dimension phy(ncmax),phz(ncmax),dft2(2),dfp2(2)
      character*255 herr

      ierr=0
      herr=' '
      eps=1.d-4        ! Numerical perturbation of z
      call ISPURE (z,icomp)
      if (icomp.ne.0) then
        call CRITP (z,tc,pc,rhoc,ierr,herr)
        RETURN
      endif

 10   continue
      v(1:nc)=DSQRT(z(1:nc))
      pc=abs(pc)
      tol=1.d-8
      iz=1
      do k=1,20
        call LGPHI (2,iz,tc,rhoc,pc,z,phz,a1,a2,a3,a4,ierr,herr)
        if (ierr.gt.0) RETURN
        if (k.gt.1 .and. ABS(bb)+abs(cc).lt.tol) then
c  convergence obtained, return
c           write (*,*) k
          RETURN
        endif

        do i=1,nc
          do j=i,nc
            a(i,j)=v(i)*v(j)*dphidnj(i,j)
            a(j,i)=a(i,j)
          enddo
          a(i,i)=a(i,i)+1.d0
        enddo
        xlamda=0.d0
        call MINEIGEN (nc,a,u,xlamda,ierr,herr)

        if (k.eq.10) tol=tol*100
        dpht(1:nc)=dphidt(1:nc)
        dphp(1:nc)=dphidp(1:nc)
        do j=1,2
          rhoy=rhoc
          s=eps
          if (j.eq.1) s=-s
          y(1:nc)=ABS(s*u(1:nc)*v(1:nc)+z(1:nc))
          sumy=SUM(y(1:nc))
          if (ABS(sumy).gt.1.d-10) yn(1:nc)=y(1:nc)/sumy
          call LGPHI (2,iz,tc,rhoy,pc,yn,phy,a1,a2,a3,a4,ierr,herr)
          g(1:nc)=DLOG(y(1:nc)/z(1:nc))+phy(1:nc)-phz(1:nc)
          dfds(j)=SUM(v(1:nc)*u(1:nc)*g(1:nc))
          dft2(j)=SUM(v(1:nc)*u(1:nc)*(dpht(1:nc)-dphidt(1:nc)))
          dfp2(j)=SUM(v(1:nc)*u(1:nc)*(dphp(1:nc)-dphidp(1:nc)))
        enddo

        bb=xlamda/2.d0
        bp=(dfp2(2)-dfp2(1))/eps/4.d0
        bt=(dft2(2)-dft2(1))/eps/4.d0
        cc=(dfds(2)+dfds(1))/eps**2/6.d0
        cp=(dfp2(2)+dfp2(1))/eps**2/6.d0
        ct=(dft2(2)+dft2(1))/eps**2/6.d0

        denom=(bp*ct-bt*cp)
        if (abs(denom).lt.1.d-20) then
          ierr=1
          herr='dp, dt -> infinity. Provide better p, t guess values'
          RETURN
        endif
        dp=(cc*bt-bb*ct)/denom
        dt=(cp*bb-cc*bp)/denom
c       write (*,*) dt,dp
c       write (*,*) bb,cc
        do i=1,25
          if (ABS(dt).gt.2 .or. ABS(dp).gt.1000) then
            dt=dt/10.d0
            dp=dp/2.d0
          else
            EXIT
          endif
        enddo
        tc=tc-dt
        pc=pc-dp
        if (k.ge.20 .or. pc.lt.0.d0 .or. tc.lt.0.d0 .or.
     &      pc.gt.100.d3 .or. tc.gt.1.d3) then
          if (eps.lt.0.099d0) then
            call CRITP (z,tc,pc,rhoc,ierr,herr)
            eps=eps*10.d0
c           write (*,*) eps
            goto 10
          endif
          ierr=1
          herr='No convergence. Provide better p, t guess values'
          RETURN
        endif
      enddo
      end                                             !subroutine CRTPNT
c
c ======================================================================
c
      subroutine SATGV (t,p,z,vf,b,ipv,ityp,isp,rhox,rhoy,x,y,ierr,herr)
c
c  Calculates the bubble or dew point state using the entropy or density method
c  of GV.  The caculation method is similar to the volume based algorithm of GERG.
c  The cricondenbar and cricondentherm are estimated using the method in:  M.L.
c  Michelsen, Saturation point calculations, Fluid Phase Equilibria, 23:181, 1985.
c
c  inputs:
c         t--temperature [K]
c         p--pressure [kPa]
c         z--overall composition [array of mol frac]
c        vf--vapor fraction (0>=vf>=1)
c            set vf=0 for liquid and vf=1 for vapor
c            for ityp=6, vf=1 assumes x is liquid and y is vapor,
c                    and vf=0 assumes y is liquid and x is vapor
c         b--input value, either entropy [J/mol-K] or density [mol/l]
c       ipv--pressure or volume based algorithm
c            1 -> pressure based
c            2 -> volume based
c      ityp--input values
c            0 -> given p, calculate t
c            1 -> given t, calculate p
c            2 -> cricondentherm condition, calculate t,p (ipv=1 only)
c            3 -> cricondenbar condition, calculate t,p (ipv=1 only)
c            5 -> given entropy, calculate t,p
c            6 -> given density, calculate t,p
c       isp--use values from Splines as initial guesses if set to 1
c
c  outputs: (initial guesses must be sent in all variables (unless isp=1))
c         t--temperature [K]
c         p--pressure [kPa]
c      rhox--density of x phase [mol/l]
c      rhoy--density of y phase [mol/l]
c         x--composition of x array [array of mol frac]
c         y--composition of y array [array of mol frac]
c      ierr--error flag:  0 = successful
c                         1 = LUdecomp failed
c                         2 = derivatives are not available in RDXHMX
c                        71 = no convergence
c                        72 = log values too large
c                        73 = p or T out of range
c                        74 = trival solution
c                        75 = unacceptable F
c                        76 = False roots
c                        77 = density out of range
c                        80 = vf < 0 or vf > 1
c                        81 = sum(z)<>1
c                        82 = input rho<=0
c      herr--error string (character*255 variable if ierr<>0)
c
c
c  equations to be solved simultaneously are:
c  --pressure based:
c      f(1:n)=log(y/x)-log((fxi/nxi)/(fyi/nyi))=0
c      f(n+1)=sum(y(i)-x(i))=0
c      f(n+2)=b/binput-1=0, where b = p, t, d, or s
c
c  --volume based:
c      f(1:n) - log(y/x)-log((fxi/nxi)/(fyi/nyi))=0
c      f(n+1) - sum(y(i)-x(i))=0
c      f(n+2) - py=px
c      f(n+3) - b/binput-1=0, where b = p, t, d, or s
c
c  variables:
c     1 to nc - log(k(i))
c     nc+1    - log(t)
c     nc+2    - log(p) or log(rhox)
c     nc+3    -           log(rhoy)
c
c  written by G. Venkatarathnam, Indian Institute of Technology Madras
c  00-00-12  GV, original version
c  10-29-12 EWL, adapt code for use in REFPROP
c
      include 'commons.for'
      character*255 herr,hr
      dimension xjacob(50,50),f(50)
      dimension phx(ncmax),phy(ncmax),phz(ncmax),vrb(ncmax+3)
      dimension x(ncmax),y(ncmax),z(ncmax),phi(ncmax),vrb0(ncmax+3)
      dimension xo(ncmax),yo(ncmax)
      dimension dfxdp(ncmax),dfxdt(ncmax),dfxdnj(ncmax,ncmax)
      dimension dfydp(ncmax),dfydt(ncmax),dfydnj(ncmax,ncmax)
      dimension dfxdv(ncmax),dfydv(ncmax)

c     dimension x2(ncmax),y2(ncmax),tjcb(10,10)
c     dimension xincr(ncmax+3),phz1(ncmax),phx1(ncmax),phy1(ncmax)

      common /GVcom/ ixp,iyp,izp
      common /GVtemp/iters


      ierr=0
      herr=' '
      xo(1:nc)=x(1:nc)
      yo(1:nc)=y(1:nc)
      nvars=nc+2                ! Number of variables
      il=2
      if (ipv.eq.2) then
        il=3
        nvars=nc+3
      endif
      cf=1.d0-vf
      error2=1.d-12
      p1=1.d0
!c  use less strict convergence tolerance for cricondenbar and cricondentherm calculations
!      if (ityp.eq.2) error2=1.d-12
!      if (ityp.eq.2) error3=1.d-5
!c  cricondenbar can occur very close to critical point. Lower convergence criteria is therefore used.
!      if (ityp.eq.3) error2=1.d-12
!      if (ityp.eq.3) error3=1.d-4

c  get values from splines if already set up
      if (iSpline.ne.0 .and. isp.ne.0) then
        rhoin=0.1d0
        if (vf.eq.0) then
          call SPLNVAL(0,-2,t,rhoin,ierr,herr)
          rhoin=rhoin*0.9d0
        endif
        if (ityp.eq.0) call SPLNROOT (nc+2,0,p,rhoin,ierr,herr)
        if (ityp.eq.1) call SPLNROOT (nc+1,0,t,rhoin,ierr,herr)
        if (ityp.eq.5) call SPLNROOT (nc+5,0,b,rhoin,ierr,herr)
        if (ityp.eq.6) rhoin=b
        if (vf.eq.1) y(1:nc)=z(1:nc)
        if (vf.eq.0) x(1:nc)=z(1:nc)
        if (vf.eq.1) rhoy=rhoin
        if (vf.eq.0) rhox=rhoin
        do j=1,nc+3
          call SPLNVAL (j,0,rhoin,vout,ierr,herr)
          if (ierr.eq.0) then
            vout=abs(vout)
            if (j.le.nc) then
              if (vout.lt.1.d-100) vout=0.d0
              if (vf.eq.1) x(j)=vout
              if (vf.eq.0) y(j)=vout
            elseif (j.eq.nc+1) then
              if (ityp.ne.1) t=vout
            elseif (j.eq.nc+2) then
              if (ityp.ne.0) p=vout
            elseif (j.eq.nc+3) then
              if (vf.eq.1) rhox=vout
              if (vf.eq.0) rhoy=vout
            endif
          endif
        enddo
        sumx=sum(x(1:nc))
        sumy=sum(y(1:nc))
        if (abs(sumx).gt.1.d-10) then
          x(1:nc)=x(1:nc)/sumx
        else
          x=y
        endif
        if (abs(sumy).gt.1.d-10) then
          y(1:nc)=y(1:nc)/sumy
        else
          y=x
        endif
      endif

c  check input for errors
      sumz=sum(z(1:nc))
      if (vf.gt.1.d0 .or. vf.lt.0.d0) then
        ierr=80
        herr='[SATGV error 80] vf greater than 1 or less than 0'
      elseif (dabs(sumz-1.d0).ge.1.d-8) then
        ierr=81
        herr='[SATGV error 81] Sum of feed composition not equal to 1.0'
      elseif (rhox.le.0.d0 .or. rhoy.le.0.d0) then
        ierr=82
        herr='[SATGV error 82] Input density less than or equal to 0.0'
      endif
      if (ierr.gt.0) goto 999

c  use values for ixyzphase from previous call, unless rho is >2*rhoc or <rhoc/10
      call CRITP (y,tc,pc,rhoc,ierr,herr)
      if (vf.eq.0) call CRITP (x,tc,pc,rhoc,ierr,herr)
      rho=vf*rhoy+cf*rhox
      if (rhox.gt.rhoc*2.d0 .or. rhoy.lt.0.1d0)  ixp=1
      if (rhoy.gt.rhoc*2.d0 .or. rhox.lt.0.1d0)  iyp=1
      if (rho .gt.rhoc*2.d0) izp=1
      if (rho .lt.rhoc/5.d0) izp=2
      if (rhox.lt.rhoc/5.d0) ixp=2
      if (rhoy.lt.rhoc/5.d0) iyp=2

c  set up variables in equations to be solved
c  calculate initial log of K values from input x and y
      do i=1,nc
        vrb(i)=1.d0
        if (x(i).gt.0.d0 .and. y(i).gt.0.d0) vrb(i)=log(y(i)/x(i))
      enddo
      vrb(nc+1)=log(t)
      vrb(nc+2)=log(p)
      rhox1=rhox
      rhoy1=rhoy
      if (ipv.eq.2) then
        vrb(nc+2)=log(rhox1)
        vrb(nc+3)=log(rhoy1)
      endif
      if (ityp.eq.0) s=log(p)   !log(P)
      if (ityp.eq.0 .and. ipv.eq.2) s=p    !P
      if (ityp.eq.1) s=log(t)   !log(T)
      if (ityp.eq.5) s=b        !entropy
      if (ityp.eq.6) s=log(b)   !log(rho)

      iters=0
      do while (iters.lt.20)
        iters=iters+1
        t1=exp(vrb(nc+1))
        if (ipv.ne.2) then
          p1=exp(vrb(nc+2))
        elseif (ipv.eq.2) then
          rhox1=exp(vrb(nc+2))
          rhoy1=exp(vrb(nc+3))
        endif

c  check if the guess values for the next iteration are reasonable
        do i=1,nc
          if (dabs(vrb(i)).gt.100) then
            ierr=72
            write (herr,1072) ierr,i,vrb(i)
          endif
        enddo
        if (t1.gt.2000 .or. t1.lt.2) then !Temperature
          ierr=73
          write (herr,1073) ierr,p1,t1
        elseif (p1.gt.500000 .and. ipv.eq.1) then  !Pressure
          ierr=73
          write (herr,1073) ierr,p1,t1
        elseif (rhox1.gt.100 .and. ipv.eq.2) then  !Density
          ierr=77
          write (herr,1077) ierr,rhox1,t1
        elseif (rhoy1.gt.100 .and. ipv.eq.2) then  !Density
          ierr=77
          write (herr,1077) ierr,rhoy1,t1
        endif
        if (ierr.gt.0) goto 999

c  call routine to analytically get all derivatives (including A with respect to n and x)
        call GETXY (z,vf,vrb,phi,x,y)
        call LGPHI(il,ixp,t1,rhox1,p1,x,phx,dpxt,dpxd,dtx,cpx,ierr,herr)
        if (ierr.gt.0) RETURN
        if (ipv.ne.2) then
          dfxdnj(1:nc,1:nc)=dphidnj(1:nc,1:nc)
          dfxdt(1:nc)=t1*dphidt(1:nc)
          dfxdp(1:nc)=p1*dphidp(1:nc)
        else
          if (heos.eq.'PR') then
            ierr=99
            herr='Derivatives not yet available for PR'
            RETURN
          endif
          dfxdnj(1:nc,1:nc)=d2adnn(1:nc,1:nc)
          dfxdt(1:nc)=t1*dlnfinidt(1:nc)
          dfxdv(1:nc)=   dlnfinidv(1:nc)
          px1=p1
        endif
        call LGPHI (il,iyp,t1,rhoy1,p1,y,phy,dpyt,dpyd,dty,cpy,i,herr)
        if (ipv.ne.2) then
          dfydnj(1:nc,1:nc)=dphidnj(1:nc,1:nc)
          dfydt(1:nc)=t1*dphidt(1:nc)
          dfydp(1:nc)=p1*dphidp(1:nc)
        else
          dfydnj(1:nc,1:nc)=d2adnn(1:nc,1:nc)
          dfydt(1:nc)=t1*dlnfinidt(1:nc)
          dfydv(1:nc)=   dlnfinidv(1:nc)
          py1=p1
        endif

c  set up f matrix with variables in equations to be solved
        f(1:nc)=phy(1:nc)-phx(1:nc)+vrb(1:nc)                          !ln(fugacity coefficients)=log(y/x) [which equals: ln(x*phix/(y*phiy))=0]
        f(nc+1)=sum(z(1:nc)*(phi(1:nc)-1.d0)/(cf+vf*phi(1:nc)))            !sum(y-x)=0
        if (ipv.eq.2) f(nc+2)=(px1-py1)/1000.d0
        if (ityp.eq.0) then      !pressure input
          if (p1.gt.0.) f(nvars)=log(p1)/s-1.d0       !****works with vf=0,1 for volume based?
          if (ipv.eq.2) f(nvars)=s-(vf*px1+cf*py1)
        elseif (ityp.eq.1) then  !temperature input
          f(nvars)=log(t1)/s-1.d0
        elseif (ityp.eq.5) then  !entropy input
          call ENTRO (t1,rhox1,x,sx)
          call ENTRO (t1,rhoy1,y,sy)
          f(nvars)=(vf*sy+cf*sx)/s-1.d0
        elseif (ityp.eq.6) then  !density input
          s1=vf*rhoy1+cf*rhox1
          f(nvars)=log(s1)/s-1.d0
!        elseif (ityp.eq.2 .or. ityp.eq.3) then  !cricondentherm/bar input
!          izp=0
!          call LGPHI (2,izp,t1,rhoz1,p1,z,phz,d1,d2,d3,d4,ierr,herr)
!          term1=0.d0
!          term2=0.d0
!          do i=1,nc
!            if (ityp.eq.2) then
!              term1=term1+x(i)*(dfxdp(i)/p1-dphidP(i))
!              term2=term2+y(i)*(dfydp(i)/p1-dphidP(i))
!            else
!              term1=term1+x(i)*(dfxdt(i)/t1-dphidT(i))
!              term2=term2+y(i)*(dfydt(i)/t1-dphidT(i))
!            endif
!          enddo
!          f(nvars)=cf*term2+vf*term1
        endif

c  Determine Jacobian of funtions f(1) to f(n+3) using analytical derivatives
        xjacob(1:nvars,1:nvars)=0.d0
        if (ipv.eq.2) then
          xjacob(nc+2,nc+1)=t1*(dpxt-dpyt)/1000.d0
          xjacob(nc+2,nc+2)= rhox1*dpxd/1000.d0
          xjacob(nc+2,nc+3)=-rhoy1*dpyd/1000.d0
        endif
        do i=1,nc
          zeta=z(i)*phi(i)/(cf+vf*phi(i))**2                             !=y(i) for vf=0 and x(i) for vf=1
          xjacob(nc+1,i)=zeta                                          !d(sum(y-x))/d(ln(Ki))
          xjacob(1:nc,i)=zeta*(cf*dfydnj(1:nc,i)+vf*dfxdnj(1:nc,i))    !d(ln(fy/fx))/d(ln(Ki))
          xjacob(i,i)   =1.d0+xjacob(i,i)
          xjacob(i,nc+1)=dfydt(i)-dfxdt(i)                     !d(ln(fy/fx))/d(ln(T))
          if (ipv.ne.2) xjacob(i,nc+2)=dfydp(i)-dfxdp(i)                     !d(ln(fy/fx))/d(ln(P))
          if (ipv.eq.2) then
            xjacob(nc+2,i)=R*t1*zeta*(cf*dfydv(i)+vf*dfxdv(i))/1000.d0
            if (ityp.eq.0)
     &      xjacob(nc+3,i)=R*t1*zeta*(cf*dfydv(i)-vf*dfxdv(i))
            xjacob(i,nc+2)= dfxdv(i)/rhox1                             !d(ln(fy/fx))/d(ln(rhox))
            xjacob(i,nc+3)=-dfydv(i)/rhoy1                             !d(ln(fy/fx))/d(ln(rhoy))
          endif
        enddo

c  set up the last section in the Jacobian for the input variables
        if (ityp.eq.1) then          !temperature
          xjacob(nvars,nc+1)=1.d0/s
        elseif (ipv.ne.2) then       !pressure based method
          if (ityp.eq.0) then        !pressure
            xjacob(nvars,nvars)=1.d0/s
          elseif (ityp.eq.5) then    !entropy
            xjacob(nvars,nc+1)=(vf*cpy+cf*cpx)/s   !d(ln(s))/d(ln(T))
            xjacob(nvars,nc+2)=p1*(vf*dty/rhoy1**2+cf*dtx/rhox1**2)/s    !d(ln(s))/d(ln(P))
            if (vf.gt.0.d0 .and. vf.lt.1.d0) then
              do j=1,nc
                zeta=z(j)*phi(j)*cf*vf/(cf+vf*phi(j))**2
                dsdyi=-R*(log(y(j))+phy(j)+dfydt(j))
                dsdxi= R*(log(x(j))+phx(j)+dfxdt(j))
                xjacob(nvars,j)=zeta*(dsdyi+dsdxi)/s
              enddo
            endif
          elseif (ityp.eq.6) then     !density
            xjacob(nvars,nc+1)=t1*(cf* dtx/rhox1+vf* dty/rhoy1)/s      !d(ln(rho))/d(ln(T))
            xjacob(nvars,nc+2)=p1*(cf/dpxd/rhox1+vf/dpyd/rhoy1)/s      !d(ln(rho))/d(ln(P))
            if (vf.gt.0.d0 .and. vf.lt.1.d0) then
              ierr=81
              herr='SATGV not set up for vf>0 and vf<1 with ityp=6'
              goto 999
            endif
          endif
        else
          if (ityp.eq.0) then        !pressure
            xjacob(nvars,nc+1)=-t1*(vf*dpxt+cf*dpyt)
            xjacob(nvars,nc+2)=-vf*rhox1*dpxd
            xjacob(nvars,nc+3)=-cf*rhoy1*dpyd
          elseif (ityp.eq.5) then    !Not implemented for entropy
          elseif (ityp.eq.6) then    !density
            xjacob(nvars,nc+3)=vf*1.d0/s
            xjacob(nvars,nc+2)=cf*1.d0/s
          endif
        endif

c  uncomment the following lines to test the calculation of Jacobian elements
c  by numerical perturbation of variables vrb on the functions:  d(f(1..nc+3))/d(vrb)
!        do i = 1,nc
!          xincr(i)=1.d-4          ! delta ln(Ki)
!        enddo
!        xincr(nc+1)=1.d-4         ! delta t
!        xincr(nc+2)=1.d-4         ! delta p or delta rhox
!        xincr(nc+3)=1.d-4         !            delta rhoy
!        do i=1,nvars
!          phio=exp(vrb(i))  !old value of fugacity coef.
!          vrb(i)=vrb(i)+xincr(i)
!          t2=exp(vrb(nc+1))
!          p2=exp(vrb(nc+2))
!          if (ipv.ne.2) then
!            call GETXY (z,vf,vrb,phi,x2,y2)
!            rhox2=rhox1
!            rhoy2=rhoy1
!            call LGPHI(2,iyp,t2,rhoy2,p2,y2,phy,d1,d2,d3,d4,ierr,herr)
!            call LGPHI(2,ixp,t2,rhox2,p2,x2,phx,d1,d2,d3,d4,ierr,herr)
!          else
!            call GETXY (z,vf,vrb,phi,x2,y2)
!            rhox2=exp(vrb(nc+2))
!            rhoy2=exp(vrb(nc+3))
!            if (i.le.nc) then
!c             phi(1:nc)=exp(vrb(1:nc))
!c             x2(1:nc)=z(1:nc)/(1.d0-vf+vf*phi(1:nc))
!c             y2(1:nc)=x2(1:nc)*phi(1:nc)
!              dxki=phi(i)-phio
!              if (vf.eq.1) then
!c               dnxdn=-dxki*x(i)/(1.d0-x(i))/phio
!                dnxdn=-x(i)**2/y(i)*dxki  !This is not working quite right
!                rhox2=(1.d0+dnxdn)*rhox2
!              else
!                dnydn=dxki*x(i)/(1.d0-y(i))
!                rhoy2=(1.d0+dnydn)*rhoy2
!              endif
!            endif
!           call LGPHI(3,iyp,t2,rhoy2,py2,y2,phy,d1,d2,d3,d4,ierr,herr)
!           call LGPHI(3,ixp,t2,rhox2,px2,x2,phx,d1,d2,d3,d4,ierr,herr)
!          endif
!          do j=1,nvars
!            if (j.le.nc) then
!              tjcb(j,i)=(phy(j)-phx(j)+vrb(j)-f(j))/xincr(i)
!            elseif (j.eq.nc+1) then
!              sumx=sum(z(1:nc)*(phi(1:nc)-1.d0)/(cf+vf*phi(1:nc)))
!              tjcb(j,i)=(sumx-f(j))/xincr(i)
!            elseif (j.eq.nvars) then
!              if (ipv.eq.2) then
!                p2=px2
!                if (i.eq.nvars .and. j.eq.nvars) p2=py2
!              endif
!              if (ityp.eq.0) tjcb(j,i)=(p2/s-1.d0-f(j))/xincr(i)
!              if (ityp.eq.0 .and. ipv.eq.2)
!     &                       tjcb(j,i)=(s-p2-f(j))/xincr(i)
!              if (ityp.eq.1) tjcb(j,i)=(log(t2)/s-1.d0-f(j))/xincr(i)
!              if (ityp.eq.5) then
!                call ENTRO (t2,rhox2,x2,sx)
!                call ENTRO (t2,rhoy2,y2,sy)
!                tjcb(j,i)=((vf*sy+cf*sx)/s-1.d0-f(j))/xincr(i)
!              elseif (ityp.eq.6) then
!                tjcb(j,i)=((vf*log(rhoy2)+cf*log(rhox2))/s
!     &                   -1.d0-f(j))/xincr(i)
!              endif
!            elseif (j.eq.nc+2) then
!              tjcb(j,i)=((px2-py2)/1000.d0-f(j))/xincr(i)
!            endif
!            if (ipv.eq.2 .and. rhoy.gt.5.6 .and. rhoy.lt.5.65) then
!              abc=1    !Use for break points
!            endif
!          enddo
!          vrb(i)=vrb(i)-xincr(i)
!        enddo





!c  calculation of jacobian by numerical perturbation of
!c  variables (x,t) of functions f(x,t)
!        if (ityp.eq.2 .or. ityp.eq.3) then
!          dt=0
!          dp=0
!          if (ityp.eq.3) dt=1.d-4
!          if (ityp.eq.2) dp=1.d-4
!          dd=dt+dp
!          xincr(1:nc)=1.d-5
!          xincr(nc+1)=1.d-4          ! K
!          xincr(nc+2)=1.d-4          ! kPa
!          do i=1,nvars
!            vrb(i)=vrb(i)+xincr(i)
!            call GETXY (z,vf,vrb,phi,x,y)
!            p1=exp(vrb(nc+2))
!            t1=exp(vrb(nc+1))
!            rhox2=rhox1
!            rhoy2=rhoy1
!            iz=0
!            call LGPHI (1,ixp,t1,rhox2,p1,x,phx,d1,d2,d3,d4,j,herr)
!            call LGPHI (1,iyp,t1,rhoy2,p1,y,phy,d1,d2,d3,d4,j,herr)
!            call LGPHI (1,iz,   t1,rhoz2,p1,z,phz,d1,d2,d3,d4,j,herr)
!            iz=0
!           call LGPHI(1,ixp,t1+dt,rhox2,p1+dp,x,phx1,d1,d2,d3,d4,j,hr)
!           call LGPHI(1,iyp,t1+dt,rhoy2,p1+dp,y,phy1,d1,d2,d3,d4,j,hr)
!           call LGPHI(1,iz,   t1+dt,rhoz2,p1+dp,z,phz1,d1,d2,d3,d4,j,hr)
!            sumx=0.d0
!            do k=1,nc
!              fuggy=(phy1(k)-phy(k))/dd
!              fuggx=(phx1(k)-phx(k))/dd
!              fuggz=(phz1(k)-phz(k))/dd
!              sumx=sumx+cf*y(k)*(fuggy-fuggz)+vf*x(k)*(fuggx-fuggz)
!            enddo
!            xjacob(nc+2,i)=(sumx-f(nc+2))/xincr(i)
!            vrb(i)=vrb(i)-xincr(i)
!          enddo
!        endif

c  check for trivial solution
        itest=0
        do i=1,nc
          if (dabs(vrb(i)).le.1.d-6) itest=itest+1
        enddo
        if (itest.eq.nc) then
          ierr=74
          write (herr,1074) ierr,(vrb(i),i=1,nc)
          goto 999
        endif

c  solve linearized equations by LU decomposition
c  f is the solution vector [xnew-xold]
        f(1:nvars)=-f(1:nvars)
        call LUdecomp (nvars,50,xjacob,f,ierr,herr)
        if (ierr.ne.0) goto 999
        vrb0(1:nvars)=vrb(1:nvars)
        vrb(1:nvars)=vrb(1:nvars)+f(1:nvars)
        sum0=DOT_PRODUCT(f(1:nvars),f(1:nvars))/nvars





        if (ipv.eq.2) then
          iter1=0
11        continue
          tt=t1
          t1=exp(vrb(nc+1))
          rhox1=exp(vrb(nc+2))
          rhoy1=exp(vrb(nc+3))
          call GETXY (z,vf,vrb,phi,x,y)
          call PRESS (t1,rhox1,x,px2)
          call PRESS (t1,rhoy1,y,py2)
          pp=(cf*py2+vf*px2)
          pp1=(cf*py1+vf*px1)
          if (pp.le.0 .or. pp/pp1.gt.100 .or. pp/pp1.lt.0.01 .or.
     &        t1/tt.lt.0.9 .or. t1/tt.gt.1.1) then
            f(1:nvars)=f(1:nvars)/2.d0
            vrb(1:nvars)=vrb0(1:nvars)+f(1:nvars)
            iter1=iter1+1
            if (iter1.lt.10) goto 11
          endif
        endif


        lconv=sum0.le.error2
!        if (ityp.eq.2 .or. ityp.eq.3) then
!          sum1=DOT_PRODUCT(f(1:nc+1),f(1:nc+1))/(nc+1)
!          lconv=sum1.le.error2 .and. dabs(f(nvars)).le.error3
!        endif
        if ((lconv).and.iters.ne.1) then
          if (ityp.ne.1) t=exp(vrb(nc+1))
          if (ityp.ne.0) p=exp(vrb(nc+2))
          call GETXY (z,vf,vrb,phi,x,y)
          if (ipv.ne.2) then
            rhox=rhox1
            rhoy=rhoy1
            call TPRHO (t,p,x,ixp,1,rhox,ierr,herr)
            if (ierr.ne.0) call TPRHO (t,p,x,3-ixp,0,rhox,ierr,herr)
            call TPRHO (t,p,y,iyp,1,rhoy,ierr,herr)
            if (ierr.ne.0) call TPRHO (t,p,y,3-iyp,0,rhoy,ierr,herr)
          else
            rhox=exp(vrb(nc+2))
            rhoy=exp(vrb(nc+3))
            if (ityp.ne.0) then
              call PRESS (t,rhox,x,px1)
              call PRESS (t,rhoy,y,py1)
              p=(px1+py1)/2.d0
            endif
          endif
          itest=0
          do i=1,nc+1
            if (dabs(f(i)).le.1.d-5) itest=itest+1
          enddo
          if (itest.ne.nc+1) then
            ierr=75
            write (herr,1075) ierr,iters,(f(i),i=1,nvars)
          endif
          if (ixp.eq.2 .and. iyp.eq.2) then
            ierr=76
            herr='[SATGV error 76] False roots. ixphase=iyphase=2'
          endif
          if (ierr.gt.0) goto 999
          RETURN
        endif
      enddo

      ierr=71
      write (herr,1071) ierr,iters,sum0
 999  continue
      call ERRMSG (ierr,herr)
      x(1:nc)=xo(1:nc)
      y(1:nc)=yo(1:nc)
      RETURN

 1071 format('[SATGV error ',i2,'] Routine did not converge in ',i2,
     &       ' iterations.  Sum = ',e11.4)
 1072 format('[SATGV error ',i2,'] ln(',i1,') value too high: ',e11.4)
 1073 format('[SATGV error ',i2,'] Pressure or Temperature outside ',
     &       'bounds.  Pressure = ',e11.4,' Temperature = ',e11.4)
 1074 format('[SATGV error ',i2,'] Trivial solution.  ',
     &       'ln(ki) = ',20(e9.2,1x))
 1075 format('[SATGV error ',i2,'] Converged in ',i2,' iterations.  ',
     &       'But F < acceptable. ', 20(e9.2,1x))
 1077 format('[SATGV error ',i2,'] Density outside ',
     &       'bounds.  Density = ',e11.4,' Temperature = ',e11.4)
      end                                              !subroutine SATGV
c
c        1         2         3         4         5         6         7
c23456789012345678901234567890123456789012345678901234567890123456789012
c
c ======================================================================
c                                                     end file sat_sub.f
c ======================================================================
c  begin file setup2.f
c
c  This file contains routine which initialize the models, fluid-
c  specific parameters and coefficients, etc.  The subroutine SETUP (in
c  file setup.f) must be called before any of the other property routines
c  are called.  Call(s) to SETMOD and SETREF are optional and may be used
c  to specify non-standard models and reference states.
c
c  If the transport models, dielectric models, and surface tension eqs.
c  (vis, tcx, st, de) are not required, and only the default values in the
c  fluid files are used, the following files do not have to be compiled and
c  linked with the other source code:  CORE_DE, CORE_STN,
c  SETUP2, TRNS_ECS, TRNS_TCX, TRNS_VIS, TRNSP.  In addition,
c  the line in SETUP.FOR calling STFLD2 must be commented out.
c  The file FLASH2.FOR is not required but contains additional property
c  calculation routines.
c
c  contained here are:
c     subroutine STFLD2 (nread,i,hcasn,hcite,heqn,hetemp,hfile,hflag,
c    &                    href,hstar,httemp,htype,leta,ltcx,ierr,herr)
c     subroutine GETMOD (icomp,htype,hcode,hcite)
c     subroutine SETKTV (icomp,jcomp,hmodij,fij,hfmix,ierr,herr)
c     subroutine GETKTV (icomp,jcomp,hmodij,fij,hfmix,hfij,hbinp,hmxrul)
c     subroutine GETFIJ (hmodij,fij,hfij,hmxrul)
c
c
c ======================================================================
c
      subroutine STFLD2 (nread,i,hcasn,hcite,heqn,hetemp,hfile,hflag,
     &                    hreff,hstar,httemp,htype,leta,ltcx,ierr,herr)
c
c  define transport, dielectric, and surface tension models
c  see comments to SETFLD for additional information
c
c  written by M. McLinden, NIST Thermophysics Division, Boulder, Colorado
c  11-19-94  MM, original version (SETFLD)
c  09-01-00 EWL, remove pieces from SETFLD and create new SETFLD2 subroutine
c  11-16-01 MLH, activated TK6 model for ecs crit enh; added common block CREMOD2
c  01-23-02 EWL, split common block CITE into 2 pieces for some compilers
c  08-27-04 EWL, rename SETFLD2 to STFLD2 to conform with standard f77 code
c  07-22-05 MLH, allow multiple transport reference fluids
c  11-08-06 EWL, load TCX and ETA coefficients into negative arrays
c  12-26-06 MLH, add VS4 model
c  11-02-07 MLH, add Chung model
c
      include 'commons.for'
      include 'comtrn.for'
      character*1 hstar
      character*3 heqn
      character*3 hetemp,httemp
      character*3 hmaux
      character*3 hvs,htc
      character*3 hflag,htype
      character*12 hcasn(n0:nx)
      character*255 hfile(n0:nx),hreff
      character*255 herr,herr1
      character*251 hcite
      logical leta,ltcx
c
      ierrtc=0
      ierrvs=0
      ierrst=0
      hreff=' '
      ier=0
      ierr=0
      ierr1=0
      herr=' '
      herr1=' '
      if (hflag.eq.'AUX') then
c
c  set up auxiliary model(s)
c  (model(s) are specified in call to appropriate SETmod routine)
c
c       write (*,*) ' SETUP--aux model (',htype,') found in fld file '
c       write (*,*) ' SETUP--i,htype,hmodcp(i): ',i,htype,hmodcp(i)
        ierr1=0
        hmaux=hmodcp(i)    !possible use in error message
        if (i.ge.nrf0) then
c  allow calls to transport ref. fluids, i.lt.-ncmax
c  do not call collision integral model (or other auxiliary models
c  associated with the transport properties) if component number < 0
c  (there is only one reference fluid for transport props so arrays
c  are not dimensioned for the negative component numbers set up to
c  accommodate the multiple reference fluids in the ECS-thermo model)
          if (htype(1:2).eq.'CI') hmaux=htype       !possible use in
          if (htype(1:2).eq.'TK') hmaux=htcxcr(i)   !error message
          if (htype.eq.'CI1' .and. hmdeta(i).eq.htype) then
c  functions for collision integral (used in transport correlations)
c           write (*,*) ' SETUP--about to call SETCI1'
            call SETCI1 (nread,i,hcasn(i),ierr1,herr1)
          elseif (htype.eq.'CI1' .and. hmdtcx(i).eq.htype) then
c  functions for collision integral (used in transport correlations)
c           write (*,*) ' SETUP--about to call SETCI1'
            call SETCI1 (nread,i,hcasn(i),ierr1,herr1)
          else if (htype.eq.'CI2' .and. hmdeta(i).eq.htype) then
c           write (*,*) ' SETUP--about to call SETCI2'
            call SETCI2 (nread,i,hcasn(i),ierr1,herr1)
          else if (htype.eq.'CI2' .and. hmdtcx(i).eq.htype) then
c           write (*,*) ' SETUP--about to call SETCI2'
            call SETCI2 (nread,i,hcasn(i),ierr1,herr1)
c  thermal conductivity critical enhancement models
          else if (htype.eq.'TK1' .and. htcxcr(i).eq.htype) then
c           write (*,*) ' SETUP--about to call SETTK1'
            call SETTK1 (nread,i,hcasn(i),ierr1,herr1)
            hitcxc(i)=htype//hcite//hnull
c         else if (htype.eq.'TK2' .and. htcxcr(i).eq.htype) then
c  the TK2 model is linked with TC2 and is initialized directly by SETTC2
c           call SETTK2 (nread,i,hcasn(i),ierr1,herr1)
            hitcxc(i)=htype//hcite//hnull
          else if (htype.eq.'TK3' .and. htcxcr(i).eq.htype) then
c           write (*,*) ' SETUP--about to call SETTK3'
            call SETTK3 (nread,i,hcasn(i),ierr1,herr1)
            hitcxc(i)=htype//hcite//hnull
          else if (htype.eq.'TK4' .and. htcxcr(i).eq.htype) then
c           write (*,*) ' SETUP--about to call SETTK4'
            call SETTK4 (nread,i,hcasn(i),ierr1,herr1)
            hitcxc(i)=htype//hcite//hnull
          else if (htype.eq.'TK6' .and. htcxcrecs(i).eq.htype) then
c           write (*,*) ' SETUP--about to call SETTK6'
            call SETTK6 (nread,i,hcasn(i),ierr1,herr1)
            hitcxc(i)=htype//hcite//hnull
          end if
        end if
        if (ierr1.ne.0) then
          ierr=104
          write (herr,2104) hmaux,i,herr1(1:182),hnull
          call ERRMSG (ierr,herr)
        end if
      end if
c
c  transport property models
c
c  do not call transport models if component number is 0
      if (i.ge.nrf0) then
c
c  the 'TRN' models apply to both the viscosity and thermal conductivity
c
        if (hflag.eq.'TRN' .or. hflag.eq.'trn') then
          if (hstar.eq.'#') then
c  special case for NIST-recommended model
            if (nc.eq.1) then
              if (hetamx.eq.'NBS') hetamx=htype
              if (htcxmx.eq.'NBS') htcxmx=htype
            end if
            if (i.ge.1 .and. heta(i).eq.'NBS') then
              heta(i)=htype
            end if
            if (i.ge.1 .and. htcx(i).eq.'NBS') then
              htcx(i)=htype
            end if
c  in the case that the TRN model is the NIST-recommended one, the ECS
c  method is equivalent to a fluid-specific model for purposes of the
c  leta and ltcx flags
            leta=.true.
            ltcx=.true.
          else
c  load the 'TRN' model if a fluid-specific 'ETA' or 'TCX' has not yet
c  been loaded (e.g. if a fluid-specific correlation is not available);
c  this is indicated by the flags leta and ltcx; if a fluid-specific
c  correlation is encountered later in the file this will be overwritten;
c  this is necessary to cover the case of a fluid-specific (and NIST-rec)
c  model available for only one of the transport properties
            if (.not.leta) hetemp=htype
            if (.not.ltcx) httemp=htype
          end if
c
          if (htype.eq.'ECS') then
c  extended corresponding states model found in file
c  always load the ECS model (if any transport props are asked for)
c  for possible use if a pure fluid correlation is out of range
            if (hetamx.ne.'NUL' .or. htcxmx.ne.'NUL') then
c             write (*,*) ' SETUP--about to call SETTRN (ECS-transport)'
              if (hieta(i)(1:3).eq.'NUL') hieta(i)=htype//hcite//hnull
              if (hitcx(i)(1:3).eq.'NUL') hitcx(i)=htype//hcite//hnull
              call SETTRN(nread,i,hcasn(i),hreff,heqn,hvs,htc,ier,herr1)
              if (ier.ne.0) then
                ierr=104
                write (herr,2104) htype,i,herr1(1:182),hnull
                call ERRMSG (ierr,herr)
              end if
              if (i.ge.1) then
c  store info for ECS reference fluid
c  (but not if current fluid is the reference fluid)
c  add directory information to reference fluid file
                call RFFILE (hfile(i),hreff)
c               write (*,1160) heqn,hvs,htc
c1160           format ('  SETFLD--transport ref fluid mods:',3(1x,a3))
                hfile(izero0)=hreff         !.fld file for reference fluid
                hmxeos(izero0)=heqn        !model for ref fluid eqn of state
                heta(izero0)=hvs          !model for ref fluid viscosity
                htcx(izero0)=htc          !model for ref fluid conductivity
              end if
            end if
          else
c  unidentified model found in file
            ierr=-103
            write (herr,2103) htype,i,hnull
            call ERRMSG (ierr,herr)
          end if
        end if      !end of ECS-transport block
c
c  pure fluid viscosity models
c
        if (hflag.eq.'ETA' .or. hflag.eq.'eta' .or.
     &      hflag.eq.'VIS' .or. hflag.eq.'vis') then
          if (hstar.eq.'#') then
c  special case for NIST-recommended model
            if (nc.eq.1 .and. hetamx.eq.'NBS') then
              hetamx=htype
            end if
            if (i.ne.0 .and. heta(i).eq.'NBS') then
              heta(i)=htype
            end if
c           if (i.lt.-ncmax .and. heta(i).eq.'NBS') heta(i)=htype
          end if
c
c  viscosity model "0" found in .fld file
          if (htype.eq.'VS0') then
            if (heta(i).eq.'VS0') then
c             write (*,*) ' SETUP--about to call SETVS0'
              call SETVS0 (nread,i,hcasn(i),ierrvs,herr1)
              leta=.true.   !flag that fluid-specific vis model loaded
              hieta(i)=htype//hcite//hnull
            end if
c  viscosity model "1" found in .fld file
          elseif (htype.eq.'VS1') then
            if (heta(i).eq.'VS1') then
c             write (*,*) ' SETUP--about to call SETVS1'
              call SETVS1 (nread,i,hcasn(i),ierrvs,herr1)
              leta=.true.   !flag that fluid-specific vis model loaded
              hieta(i)=htype//hcite//hnull
            end if
c  viscosity model "2" found in .fld file
          else if (htype.eq.'VS2') then
            if (heta(i).eq.'VS2') then
c             write (*,*) ' SETUP--about to call SETVS2'
              call SETVS2 (nread,i,hcasn(i),ierrvs,herr1)
              leta=.true.   !flag that fluid-specific vis model loaded
              hieta(i)=htype//hcite//hnull
            end if
c  viscosity model "3" found in .fld file
          else if (htype.eq.'VS3') then
            if (heta(i).eq.'VS3') then
c             write (*,*) ' SETUP--about to call SETVS3'
              call SETVS3 (nread,i,hcasn(i),ierrvs,herr1)
              leta=.true.   !flag that fluid-specific vis model loaded
              hieta(i)=htype//hcite//hnull
            end if
c  viscosity model "4" found in .fld file
          else if (htype.eq.'VS4') then
            if (heta(i).eq.'VS4') then
c             write (*,*) ' SETUP--about to call SETVS4'
              call SETVS4 (nread,i,hcasn(i),ierrvs,herr1)
              leta=.true.   !flag that fluid-specific vis model loaded
              hieta(i)=htype//hcite//hnull
            end if
c   viscosity model "5" found in .fld file
          else if (htype.eq.'VS5') then
            if (heta(i).eq.'VS5') then
c             write (*,*) ' SETUP--about to call SETVS5'
              call SETVS5 (nread,i,hcasn(i),ierrvs,herr1)
              leta=.true.   !flag that fluid-specific vis model loaded
              hieta(i)=htype//hcite//hnull
            end if
c  viscosity model "6" found in .fld file
          else if (htype.eq.'VS6') then
            if (heta(i).eq.'VS6') then
c             write (*,*) ' SETUP--about to call SETVS6'
              call SETVS6 (nread,i,hcasn(i),ierrvs,herr1)
              leta=.true.   !flag that fluid-specific vis model loaded
              hieta(i)=htype//hcite//hnull
            end if
c  ignore the NUL model
          else if (htype.eq.'NUL') then
          else
c  unidentified model found in file
            ierr=-103
            write (herr,2103) htype,i,hnull
            call ERRMSG (ierr,herr)
          end if
        end if
        if (ierrvs.ne.0) then
          ierr=104
          write (herr,2104) heta(i),i,herr1(1:182),hnull
          call ERRMSG (ierr,herr)
        end if
c  end of viscosity block
c
c  pure fluid thermal conductivity models
c
        if (hflag.eq.'TCX' .or. hflag.eq.'tcx') then
          if (hstar.eq.'#') then
c  special case for NIST-recommended model
            if (nc.eq.1 .and. htcxmx.eq.'NBS') then
              htcxmx=htype
            end if
            if (i.ne.0 .and. htcx(i).eq.'NBS') then
              htcx(i)=htype
            end if
c           if (i.lt.-ncmax .and. htcx(i).eq.'NBS') htcx(i)=htype
          end if
c
c  thermal conductivity model "0" found in .fld file
          if (htype.eq.'TC0') then
            if (htcx(i).eq.'TC0') then
c             write (*,*) ' SETUP--about to call SETTC0'
              call SETTC0 (nread,i,hcasn(i),ierrtc,herr1)
              ltcx=.true.   !flag that fluid-specific t.c. model loaded
              hitcx(i)=htype//hcite//hnull
            end if
c  thermal conductivity model "1" found in .fld file
          elseif (htype.eq.'TC1') then
            if (htcx(i).eq.'TC1') then
c             write (*,*) ' SETUP--about to call SETTC1'
              call SETTC1 (nread,i,hcasn(i),ierrtc,herr1)
              ltcx=.true.   !flag that fluid-specific t.c. model loaded
              hitcx(i)=htype//hcite//hnull
            end if
c  thermal conductivity model "2" found in .fld file
          else if (htype.eq.'TC2') then
            if (htcx(i).eq.'TC2') then
c             write (*,*) ' SETUP--about to call SETTC2'
              call SETTC2 (nread,i,hcasn(i),ierrtc,herr1)
              ltcx=.true.   !flag that fluid-specific t.c. model loaded
              hitcx(i)=htype//hcite//hnull
            end if
c  thermal conductivity model "3" found in .fld file
          else if (htype.eq.'TC3') then
            if (htcx(i).eq.'TC3') then
c             write (*,*) ' SETUP--about to call SETTC3'
              call SETTC3 (nread,i,hcasn(i),ierr,herr1)
              ltcx=.true.   !flag that fluid-specific t.c. model loaded
              hitcx(i)=htype//hcite//hnull
            end if
c  thermal conductivity model "5" found in .fld file
          else if (htype.eq.'TC5') then
            if (htcx(i).eq.'TC5') then
c             write (*,*) ' SETUP--about to call SETTC5'
              call SETTC5 (nread,i,hcasn(i),ierr,herr1)
              ltcx=.true.   !flag that fluid-specific t.c. model loaded
              hitcx(i)=htype//hcite//hnull
            end if
c  thermal conductivity model "6" found in .fld file
          else if (htype.eq.'TC6') then
            if (htcx(i).eq.'TC6') then
c             write (*,*) ' SETUP--about to call SETTC6'
              call SETTC6 (nread,i,hcasn(i),ierrtc,herr1)
              ltcx=.true.   !flag that fluid-specific t.c. model loaded
              hitcx(i)=htype//hcite//hnull
            end if
c  ignore the NUL model
          else if (htype.eq.'NUL') then
          else
c  unidentified model found in file
            ierr=-103
            write (herr,2103) htype,i,hnull
            call ERRMSG (ierr,herr)
          end if
        end if
        if (ierrtc.ne.0) then
          ierr=104
          write (herr,2104) htcx(i),i,herr1(1:182),hnull
          call ERRMSG (ierr,herr)
        end if
c  end of thermal conductivity block
      end if          !end of overall transport properties block
c
c  pure fluid surface tension models
c
c  do not call surface tension models if component number less than 0
      if (i.ge.nrf0) then
        if (hflag.eq.'STN' .or. hflag.eq.'stn') then
          if (hstar.eq.'#') then
c  special case for NIST-recommended model
            if (nc.eq.1 .and. hsten.eq.'NBS') then
              hsten=htype
            end if
            if (i.ge.1 .and. hstenk(i).eq.'NBS') then
              hstenk(i)=htype
            end if
          end if
c
c  surface tension model "1" found in .fld file
          if (htype.eq.'ST1') then
            if (hstenk(i).eq.'ST1') then
c             write (*,*) ' SETUP--about to call SETST1'
              call SETST1 (nread,i,hcasn(i),ierrst,herr1)
              histn(i)=htype//hcite//hnull
            end if
c  surface tension model "2" found in .fld file
c         else if (htype.eq.'ST2') then
c           if (hstenk(i).eq.'ST2') then
c             write (*,*) ' SETUP--about to call SETST2'
c             call SETST2 (nread,i,hcasn(i),ierrst,herr1)
c             histn(i)=htype//hcite//hnull
c           end if
          else
c  unidentified model found in file
            ierr=-103
            write (herr,2103) htype,i,hnull
            call ERRMSG (ierr,herr)
          end if
        end if
        if (ierrst.ne.0) then
          ierr=104
          write (herr,2104) hstenk(i),i,herr1(1:182),hnull
          call ERRMSG (ierr,herr)
        end if
      end if          !end of surface tension block
c
c  pure fluid dielectric constant models
c
c  do not call dielectric constant models if component number less than 0
      if (i.ge.nrf0) then
        if (hflag.eq.'DE ' .or. hflag.eq.'de ') then
          if (hstar.eq.'#') then
c  special case for NIST-recommended model
            if (nc.eq.1 .and. hdiel.eq.'NBS') then
              hdiel=htype
            end if
            if (i.ge.1 .and. hdielk(i).eq.'NBS') then
              hdielk(i)=htype
            end if
          end if
c
          if (htype(1:2).eq.'DE') then
c  dielectric constant model found in .fld file
            if (hdielk(i)(1:2).eq.'DE') then
c             write (*,*) ' SETUP--about to call SETDE'
              call SETDE (nread,i,hcasn(i),ierrst,herr1)
              hidiel(i)=htype//hcite//hnull
            end if
          else
c  unidentified model found in file
            ierr=-103
            write (herr,2103) htype,i,hnull
            call ERRMSG (ierr,herr)
          end if
        end if
        if (ierrst.ne.0) then
          ierr=104
          write (herr,2104) hdielk(i),i,herr1(1:182),hnull
          call ERRMSG (ierr,herr)
        end if
      end if          !end of dielectric constant block
      RETURN
 2103 format ('[SETUP warning -103] unknown model (',a3,
     &        ') encountered in file for component #',i3,'.',a1)
 2104 format ('[SETUP error 104] error in setup of (',a3,
     &        ') model for component #',i3,':  ',a182,a1)
      end                                             !subroutine STFLD2
c
c ======================================================================
c
      subroutine GETMOD (icomp,htype,hcode,hcite)
c
c  retrieve citation information for the property models used
c
c  inputs:
c    icomp--pointer specifying component number
c           zero and negative values are used for ECS reference fluid(s)
c    htype--flag indicating which model is to be retrieved [character*3]
c           'EOS':  equation of state for thermodynamic properties
c           'CP0':  ideal part of EOS (e.g. ideal-gas heat capacity)
c           'ETA':  viscosity
c           'VSK':  viscosity critical enhancement
c           'TCX':  thermal conductivity
c           'TKK':  thermal conductivity critical enhancement
c           'STN':  surface tension
c           'DE ':  dielectric constant
c           'MLT':  melting line (freezing line, actually)
c           'SBL':  sublimation line
c           'PS ':  vapor pressure equation
c           'DL ':  saturated liquid density equation
c           'DV ':  saturated vapor density equation
c  outputs:
c    hcode--component model used for property specified in htype
c
c           some possibilities for thermodynamic properties:
c           'FEQ':  Helmholtz free energy model
c           'BWR':  pure fluid modified Benedict-Webb-Rubin (MBWR)
c           'ECS':  pure fluid thermo extended corresponding states
c
c           some possibilities for viscosity:
c           'ECS':  extended corresponding states (all fluids)
c           'VS1':  the 'composite' model for R134a, R152a, NH3, etc.
c           'VS2':  Younglove-Ely model for hydrocarbons
c           'VS4':  generalized friction theory of Quinones-Cisneros and Dieters
c           'VS5':  Chung et al model
c
c           some possibilities for thermal conductivity:
c           'ECS':  extended corresponding states (all fluids)
c           'TC1':  the 'composite' model for R134a, R152a, etc.
c           'TC2':  Younglove-Ely model for hydrocarbons
c           'TC5':  predictive model of Chung et al. (1988)
c
c           some possibilities for surface tension:
c           'ST1':  surface tension as f(tau); tau = 1 - T/Tc
c
c    hcite--component model used for property specified in htype;
c           the first 3 characters repeat the model designation of hcode
c           and the remaining are the citation for the source
c
c  written by M. McLinden, NIST Phys & Chem Properties Div, Boulder, CO
c  01-26-00  MM, original version
c  01-23-02 EWL, split common block CITE into 2 pieces for some compilers
c
cx DEC$ ATTRIBUTES DLLEXPORT :: GETMOD
c
      include 'commons.for'
      character*3 htype,hcode
      character*255 hcite
c
      if (htype.eq.'EOS' .or. htype.eq.'eos') then
c  equation of state specification
        hcite=hieos(icomp)
      else if (htype.eq.'CP0' .or. htype.eq.'cp0' .or.
     &         htype.eq.'Cp0' .or. htype.eq.'cpo') then
c  ideal-gas heat capacity
        hcite=hicp0(icomp)
      else if (htype.eq.'ETA' .or. htype.eq.'eta' .or.
     &         htype.eq.'VIS' .or. htype.eq.'vis') then
c  viscosity
        hcite=hieta(icomp)
      else if (htype.eq.'VSK' .or. htype.eq.'vsk') then
c  viscosity critical enhancement
c  note:   as of 01/2000, no models employ a viscosity critical enhancement
        hcite=hietac(icomp)
      else if (htype.eq.'TCX' .or. htype.eq.'tcx') then
c  thermal conductivity
        hcite=hitcx(icomp)
      else if (htype.eq.'TKK' .or. htype.eq.'tkk') then
c  thermal conductivity critical enhancement
        hcite=hitcxc(icomp)
      else if (htype.eq.'STN' .or. htype.eq.'stn') then
c  surface tension
        hcite=histn(icomp)
      else if (htype.eq.'DE ' .or. htype.eq.'de ') then
c  dielectric constant
        hcite=hidiel(icomp)
      else if (htype.eq.'MLT' .or. htype.eq.'mlt') then
c  melting line
        hcite=himelt(icomp)
      else if (htype.eq.'SBL' .or. htype.eq.'sbl') then
c  sublimation line
        hcite=hisubl(icomp)
      else if (htype.eq.'PS ' .or. htype.eq.'ps ') then
c  vapor pressure equation
        hcite=hips(icomp)
      else if (htype.eq.'DL ' .or. htype.eq.'dl ') then
c  saturated liquid density equation
        hcite=hidl(icomp)
      else if (htype.eq.'DV ' .or. htype.eq.'dV ') then
c  saturated vapor density equation
        hcite=hidv(icomp)
      end if
      hcode=hcite(1:3)
c
      RETURN
c
      end                                             !subroutine GETMOD
c
c ======================================================================
c
      subroutine SETKTV (icomp,jcomp,hmodij,fij,hfmix,ierr,herr)
c
c  set mixture model and/or parameters
c
c  This subroutine must be called after SETUP, but before any call to
c  SETREF; it need not be called at all if the default mixture
c  parameters (those read in by SETUP) are to be used.
c
c  inputs:
c    icomp--component i
c    jcomp--component j
c   hmodij--mixing rule for the binary pair i,j [character*3]
c           e.g. 'LJ1' (Lemmon-Jacobsen model)
c                'LM1' (modified Lemmon-Jacobsen model) or
c                'LIN' (linear mixing rules)
c           'RST' indicates reset all pairs to values from
c                 original call to SETUP (i.e. those read from file)
c                 [all other inputs are ignored]
c      fij--binary mixture parameters [array of dimension nmxpar;
c           currently nmxpar is set to 6]
c           the parameters will vary depending on hmodij;
c           for example, for the Lemmon-Jacobsen model (LJ1):
c             fij(1) = zeta
c             fij(2) = xi
c             fij(3) = Fpq
c             fij(4) = beta
c             fij(5) = gamma
c             fij(6) = 'not used'
c    hfmix--file name [character*255] containing generalized parameters
c           for the binary mixture model; this will usually be the same
c           as the corresponding input to SETUP (e.g.,':fluids:hmx.bnc')
c  outputs:
c     ierr--error flag:  0 = successful
c                        111 = error in opening mixture file
c                        112 = mixture file of wrong type
c                       -113 = illegal i,j specification
c                              (i = j or i > nc or j > nc)
c                       -114 = possibility of mismatch of interaction parameters
c     herr--error string (character*255 variable if ierr<>0)
c     [mixture parameters returned via various common blocks]
c
c  written by M. McLinden, NIST Thermophysics Division, Boulder, Colorado
c  05-07-96  MM, original version
c  05-08-96  MM, add /MXINFO/ and load corresponding information
c  11-04-96  MM, change nmxpar from 4 to 6
c  11-22-96  MM, 'RST' option now calls SETHMX, i.e. resets all pairs
c  11-25-96  MM, reorder such that 'RST' option is tested first
c  10-01-97  MM, add compiler switch to allow access by DLL
c  02-06-98  MM, initial use of icount uninitialized, use nbin instead
c  03-11-99 EWL, reset lsatt and lsatp to .false. when called
c  02-14-01 EWL, change dimension of amix from 3 to 4
c  01-23-02 EWL, split common block MXINFO into 2 pieces for some compilers
c  11-01-05 EWL, remove open statement, etc., to check for same model
c  10-23-06 EWL, read open statement
c  02-13-09 EWL, add check for fluid order in KW model (add fmix2)
c
cx DEC$ ATTRIBUTES DLLEXPORT :: SETKTV
c
      include 'commons.for'
      character*3 hmodij,htype
      character*255 hfmix
      character*255 herr
      dimension fij(nmxpar)
      logical lij(ncmax,ncmax)
c
c  commons associated with the binary mixing rule(s)
c  the amix(i,j,k,1..3) are the coefs for the (general) mixing term
c  the fmix(i,j,1..nmxpar) are the parameters for the i-j binary
c  /MXINFO/ contains information on the mixing rules and parameters
c  hmfile specifies the files from which mixing rules originate
c  (stored in order 1,2  1,3  2,3; element zero is file called in SETUP)
c  hbin provides documentation for the current binary parameters
c  hrule contains descriptions of the currently available mixing rules
c  hbpar contains descriptions of the binary parameters (e.g. Kt, Kv)
c  associated with the currently available mixing rules
c  common to pass flags associated with reference state
c
      lsatt=.false.
      lsatp=.false.
      ierr=0
      herr=' '
c
c  set flag indicating that reference state needs to be recalculated
c  (for use with the ixflag = 2 option of SETREF)
      ixfsav=0
c  special case:  reset parameters to original values
      if (hmodij.eq.'RST' .or. hmodij.eq.'rst') then
c  retrieve file specified on original call to SETUP
        hfmix=hmfile(0)
        call SETHMX (hfmix,ierr,herr)
c       do i=1,icount
        do i=1,nbin
          hmfile(i)=hmfile(0)
        enddo
c       write (*,*) ' SETKTV--reset all parameters to original values'
c       write (*,*) '  i  j  mod     Kt        Kv        Fpq      alpha'
c       do i=i,nc
c         do j=1,nc
c           write (*,1010) i,j,hmodmx(i,j),(fmix(i,j,k),k=1,nmxpar)
c         enddo
c       enddo
c1010   format (1x,2i3,2x,a3,4f10.5)
        RETURN
      end if
c
c  check if icomp or jcomp > nc, also do not allow change of
c  pure fluid or i=j parameters
c
      if (icomp.gt.nc .or. jcomp.gt.nc) then
        ierr=-113
        herr='[SETKTV warning -113] i > nc and/or j > nc'//hnull
        call ERRMSG (ierr,herr)
c       write (*,*) herr
        RETURN
      else if (nc.le.1 .or. icomp.eq.jcomp) then
        ierr=-113
        herr='[SETKTV warning -113] binary parameters for i = j '//
     &       'cannot be changed.'//hnull
        call ERRMSG (ierr,herr)
c       write (*,*) herr
        RETURN
      end if
c
c  match input icomp,jcomp with binary pair number
      icount=0
      ibin=1      !initialize only
      do i=1,nc-1
        do j=i+1,nc
          icount=icount+1
          if ((i.eq.icomp .and. j.eq.jcomp) .or.
     &      (i.eq.jcomp .and. j.eq.icomp)) then
            ibin=icount
          end if
        enddo
      enddo
c
      i=0
      if (hmodij(1:2).eq.'KW') then
        i=1
        if  (abs(fmix (icomp,jcomp,1)-1.d0).gt.1.d-20
     &  .or. abs(fmix (icomp,jcomp,3)-1.d0).gt.1.d-20) i=2
        if  (abs(fmix2(icomp,jcomp,1)-1.d0).gt.1.d-20
     &  .or. abs(fmix2(icomp,jcomp,3)-1.d0).gt.1.d-20) i=3
      end if
      do k=1,nmxpar
        fmix(icomp,jcomp,k)=fij(k)
        fmix(jcomp,icomp,k)=fij(k)     !pair (j,i) is same as (i,j)
      enddo
      if (i.eq.1) then
        if (ierr.eq.0) then
          ierr=-114
          herr='[SETKTV warning -114] there is a possibility that '//
     &         'the mixture parameters are set incorrectly if the '//
     &         'fluid order is different from that in the '//
     &         'HMX.BNC file.'//hnull
          call ERRMSG (ierr,herr)
        endif
      elseif (i.eq.3) then
        fmix2(jcomp,icomp,1)=fmix(jcomp,icomp,1)   !Input pair is reverse of that in the hmx.bnc file
        fmix2(jcomp,icomp,3)=fmix(jcomp,icomp,3)
        fmix2(icomp,jcomp,1)=fmix(icomp,jcomp,1)
        fmix2(icomp,jcomp,3)=fmix(icomp,jcomp,3)
        fmix(jcomp,icomp,1)=1.d0
        fmix(jcomp,icomp,3)=1.d0
        fmix(icomp,jcomp,1)=1.d0
        fmix(icomp,jcomp,3)=1.d0
      endif
      hbin(ibin)='The binary parameter(s) for ('//
     &            hname(icomp)//'+'//hname(jcomp)//
     &           ') have been modified from their original values.'
c
c  check if the mixture model has changed for the binary pair, if so,
c  must read coefficients for that model
c
      if (hmodij.ne.hmodmx(icomp,jcomp)) then
        hmodmx(icomp,jcomp)=hmodij
        hmodmx(jcomp,icomp)=hmodij   !pair (j,i) is same as (i,j)
c
        nread=12             !logical unit for file reads
        call OPENFL (nread,hfmix,1,ierr,herr)
        if (ierr.ne.0) goto 999
        rewind (nread)
        read (nread,2003) htype
        read (nread,'(i2)') ivrsnm
c
c       write (*,1105) hfmix
c1105   format (/1x,' SETKTV--mixture parameters from file: (',a80,')')
c  store file containing mixture parameters
        hmfile(ibin)=hfmix
c       write (*,*) ' SETKTV--new file for ibin =',ibin,' ',hmfile(ibin)
        call RDMIX (nread,icomp,jcomp,hmodij,lij,ierr,herr)
c  rewind and close the file
        rewind (nread)
        close (nread)
      end if
c
c     write (*,*) ' SETKTV:  return'
c     write (*,*) '  i  j  mod     Kt        Kv        Fpq      alpha'
c     i=icomp
c     j=jcomp
c     write (*,1280) i,j,hmodmx(i,j),(fmix(i,j,k),k=1,nmxpar)
c1280 format (1x,2i3,2x,a3,6f10.5)
      RETURN
c
 999  continue
      ierr=111
      write (herr,2111) hfmix(1:80),hnull
 2111 format ('[SETKTV error 111] error in opening mixture file',
     &        '; filename = (',a80,').',a1)
      call ERRMSG (ierr,herr)
      RETURN
c
 2003 format (a3)
c
      end                                             !subroutine SETKTV
c
c ======================================================================
c
      subroutine GETKTV (icomp,jcomp,hmodij,fij,hfmix,hfij,hbinp,hmxrul)
c
c  retrieve mixture model and parameter info for a specified binary
c
c  This subroutine should not be called until after a call to SETUP.
c
c  inputs:
c    icomp--component i
c    jcomp--component j
c  outputs:
c   hmodij--mixing rule for the binary pair i,j (e.g. LJ1 or LIN)
c           [character*3]
c      fij--binary mixture parameters [array of dimension nmxpar;
c           currently nmxpar is set to 6]; the parameters will vary
c           depending on hmodij;
c    hfmix--file name [character*255] containing parameters for the
c           binary mixture model
c     hfij--description of the binary mixture parameters [character*8
c           array of dimension nmxpar]
c           for example, for the Lemmon-Jacobsen model (LJ1):
c             fij(1) = zeta
c             fij(2) = xi
c             fij(3) = Fpq
c             fij(4) = beta
c             fij(5) = gamma
c             fij(6) = 'not used'
c    hbinp--documentation for the binary parameters [character*255]
c           terminated with ASCII null character
c   hmxrul--description of the mixing rule [character*255]
c
c  written by M. McLinden, NIST Thermophysics Division, Boulder, Colorado
c  05-08-96  MM, original version
c  08-01-96  MM, bug fix: ibin not defined for icomp=jcomp
c  11-04-96  MM, change nmxpar from 4 to 6
c  10-01-97  MM, add compiler switch to allow access by DLL
c  02-14-01 EWL, change dimension of amix from 3 to 4
c  01-23-02 EWL, split common block MXINFO into 2 pieces for some compilers
c  02-13-09 EWL, add check for fluid order in KW model (add fmix2)
c
cx DEC$ ATTRIBUTES DLLEXPORT :: GETKTV
c
      include 'commons.for'
      character*3 hmodij
      character*8 hfij(nmxpar)
      character*255 hfmix,hmxrul
      character*255 hbinp
      character*255 herr
      dimension fij(nmxpar)
c
c  commons associated with the binary mixing rule(s)
c  the amix(i,j,k,1..3) are the coefs for the (general) mixing term
c  the fmix(i,j,1..nmxpar) are the parameters for the i-j binary
c  /MXINFO/ contains information on the mixing rules and parameters
c  hmfile specifies the files from which mixing rules originate
c  (stored in order 1,2  1,3  2,3; element zero is file called in SETUP)
c  hbin provides documentation for the current binary parameters
c  hrule contains descriptions of the currently available mixing rules
c  hbpar contains descriptions of the binary parameters (e.g. Kt, Kv)
c  associated with the currently available mixing rules
c
      hmodij=hmodmx(icomp,jcomp)
      do k=1,nrule
        if (hmodij.eq.hrule(k)(1:3)) then
          irule=k
          goto 100
        end if
      enddo
c     write (*,*) ' GETKTV ERROR--mixing rule not found: ',hmodij
      ierr=-117
      write (herr,2117) icomp,jcomp,hnull
 2117 format ('[GETKTV error 117] mixing rule not found for components',
     &        i3,' +',i3,'.',a1)
      call ERRMSG (ierr,herr)
      RETURN
 100  continue
      ibin=0
      if (icomp.eq.jcomp .or. nc.le.1) then
        hbinp='trivial case--identical components'//hnull
      else
c  match input icomp,jcomp with binary pair number
        icount=0
        do i=1,nc-1
          do j=i+1,nc
            icount=icount+1
            if ((i.eq.icomp .and. j.eq.jcomp) .or.
     &          (i.eq.jcomp .and. j.eq.icomp)) then
              ibin=icount
c  old GUI combines hbinp with 3-letter code, so can use only 251 char
              hbinp=hbin(ibin)(1:251)//hnull
            end if
          enddo
        enddo
      end if
c  file containing mixture parameters
c     write (*,*) ' GETKTV--file for ibin =',ibin,' ',hmfile(ibin)
      hfmix=hmfile(ibin)
      hmxrul=hrule(irule)(1:254)//hnull
      do k=1,nmxpar
        hfij(k)=hbpar(irule,k)
        fij(k)=fmix(icomp,jcomp,k)
        if (hmodij(1:2).eq.'KW') then
          if  (abs(fmix (icomp,jcomp,k)-1.d0).lt.1.d-20
     &   .and. abs(fmix2(icomp,jcomp,k)-1.d0).gt.1.d-20)
     &         fij(k)=fmix2(icomp,jcomp,k)
        end if
      enddo
c
c     write (*,1278) hfmix,hbinp,hmxrul
c1278 format (/1x,' GETKTV  hfile:  ',a80/
c    &         1x,'         hbinp:  ',a255/
c    &         1x,'        hmxrul:  ',a255)
c     write (*,1280) (hfij(k),k=1,nmxpar),
c    &  icomp,jcomp,hmodmx(icomp,jcomp),(fmix(icomp,jcomp,k),k=1,nmxpar)
c1280 format (1x,'  i  j  mod  ',6(a8,2x)/
c    &        1x,2i3,2x,a3,6f10.5)
      RETURN
c
      end                                             !subroutine GETKTV
c
c ======================================================================
c
      subroutine GETFIJ (hmodij,fij,hfij,hmxrul)
c
c  retrieve parameter info for a specified mixing rule
c
c  This subroutine should not be called until after a call to SETUP.
c
c  inputs:
c   hmodij--mixing rule for the binary pair i,j (e.g. LJ1 or LIN)
c           [character*3]
c  outputs:
c      fij--binary mixture parameters [array of dimension nmxpar;
c           currently nmxpar is set to 6]; the parameters will vary
c           depending on hmodij;
c     hfij--description of the binary mixture parameters [character*8
c           array of dimension nmxpar]
c   hmxrul--description of the mixing rule [character*255]
c
c  written by E.W. Lemmon, NIST Thermophysics Division, Boulder, Colorado
c  01-10-01  MM, original version
c  01-23-02 EWL, split common block MXINFO into 2 pieces for some compilers
c
cx DEC$ ATTRIBUTES DLLEXPORT :: GETFIJ
c
      include 'commons.for'
      character*3 hmodij
      character*8 hfij(nmxpar)
      character*255 hmxrul,herr
      dimension fij(nmxpar)
c
      do k=1,nrule
        if (hmodij.eq.hrule(k)(1:3)) then
          irule=k
          goto 100
        end if
      enddo
c     write (*,*) ' GETKTV ERROR--mixing rule not found: ',hmodij
      ierr=-117
      write (herr,2117) hnull
 2117 format ('[GETKTV error 117] mixing rule not found',a1)
      call ERRMSG (ierr,herr)
      RETURN
 100  continue
      hmxrul=hrule(irule)(1:254)//hnull
      do k=1,nmxpar
        hfij(k)=hbpar(irule,k)
        fij(k)=bideal(irule,k)
      enddo
      RETURN
c
      end                                             !subroutine GETFIJ
c
c
c        1         2         3         4         5         6         7
c23456789012345678901234567890123456789012345678901234567890123456789012
c
c ======================================================================
c                                                      end file setup2.f
c ======================================================================
c  begin file setup.for
c
c  This file contains the routines which initialize the models, fluid-
c  specific parameters and coefficients, etc.  The subroutine SETUP must
c  be called before any of the other routines (except SETMOD) are called.
c  Call(s) to SETMOD and SETREF are optional and may be used to specify
c  non-standard models and reference states.
c
c  Subroutine SETUP0 calls subroutine SETUP using the same techniques as
c  those used by the graphical interface and the Excel spreadsheet.
c
c  Subroutine SETMIX reads the *.MIX files and makes the appropriate call
c  to subroutine SETUP.
c
c  Subroutine SETPATH sets the path where the *.fld files can be found
c
c  Subroutine PUREFLD allows the user to calculate the properties of a pure
c  fluid when a mixture has been loaded and the fluid is one of the
c  constituents in the mixture.
c
c  contained here are:
c     subroutine SETUP (ncomp,hfiles,hfmix,hrf,ierr,herr)
c     subroutine SETUP0 (i,hfld,hfm,hrf,ierr,herr)
c     subroutine SETFLD (icomp,hfile,ierr,herr)
c     subroutine SETMOD (ncomp,htype,hmix,hcomp,ierr,herr)
c     subroutine SETREF (hrf,ixflag,x0,h0,s0,t0,p0,ierr,herr)
c     subroutine SETMIX (hmxnme,hfmix,hrf,ncc,hfiles,x,ierr,herr)
c     subroutine SETPATH (hpth)
c     subroutine SETNC (ncomp)
c     subroutine RFFILE (hfilei,hflref)
c     subroutine OPENFL (nread,hfl,idir,ierr,herr)
c     subroutine PUREFLD (icomp)
c     subroutine GERG04 (ncomp,iflag,ierr,herr)
c     subroutine RESETA
c     block data BDSET
c
c  these routines set the values in the following common blocks
c     common /CCAS/ hcas(n0:nx)
c     common /CNAM/ hname(n0:nx)
c     common /EOSMOD/ hpheq,heos,hmxeos(n0:nx),hmodcp(n0:nx)
c     common /TRNMOD/ hetamx,heta(nrf0:nx),htcxmx,htcx(nrf0:nx)
c     common /STNMOD/ hsten,hstenk(n0:nx)
c     common /DEMOD/ hdiel,hdielk(n0:nx)
c     common /MELTMOD/ hmelt,hmeltk(n0:nx)
c     common /SUBLMOD/ hsubl,hsublk(n0:nx)
c     common /PSMOD/ hpsa,hpsk(n0:nx)
c     common /PLMOD/ hpla,hplk(n0:nx)
c     common /DLMOD/ hdla,hdlk(n0:nx)
c     common /DVMOD/ hdva,hdvk(n0:nx)
c     common /REFST/ hsvrfs,hsvrfd(n0:nx)
c     common /CREF/ tref(n0:nx),rhoref(n0:nx),href(n0:nx),sref(n0:nx)
c
c  various arrays are dimensioned with parameter statements
c
c ======================================================================
c ======================================================================
c
      subroutine SETUP (ncomp,hfiles,hfmix,hrf,ierr,herr)
c
c  define models and initialize arrays
c
c  A call to this routine is required.
c
c  inputs:
c    ncomp--number of components (1 for pure fluid) [integer]
c           if called with ncomp=-1, the version number*100 will be returned in ierr
c   hfiles--array of file names specifying fluid/mixture components
c           [character*255 variable] for each of the ncomp components;
c           e.g., :fluids:r134a.fld (Mac) or fluids\r134a.fld (DOS) or
c           [full_path]/fluids/r134a.fld (UNIX)
c    hfmix--mixture coefficients [character*255]
c           file name containing coefficients for mixture model,
c           if applicable
c           e.g.,  fluids\hmx.bnc
c      hrf--reference state for thermodynamic calculations [character*3]
c           'DEF':  default reference state as specified in fluid file
c                   is applied to each pure component
c           'NBP':  h,s = 0 at pure component normal boiling point(s)
c           'ASH':  h,s = 0 for sat liquid at -40 C (ASHRAE convention)
c           'IIR':  h = 200, s = 1.0 for sat liq at 0 C (IIR convention)
c           other choices are possible, but these require a separate
c           call to SETREF
c  outputs:
c     ierr--error flag:  0 = successful
c                      101 = error in opening file
c                      102 = error in file or premature end of file
c                     -103 = unknown model encountered in file
c                      104 = error in setup of model
c                      105 = specified model not found
c                      111 = error in opening mixture file
c                      112 = mixture file of wrong type
c                      114 = nc<>nc from setmod
c                     -117 = binary pair not found, all parameters will be estimated
c                      117 = No mixture data are available, mixture is outside the
c                            range of the model and calculations will not be made
c     herr--error string (character*255 variable if ierr<>0)
c     [fluid parameters, etc. returned via various common blocks]
c
c  explanation of parameters (used to dimension arrays)
c     ncmax:    maximum number of mixture components
c        n0:    lower bound on component arrays (-ncmax to accommodate
c               multiple ECS-thermo reference fluids)
c        nx:    same as ncmax
c      nrf0:    lower bound on arrays associated with transport props
c               (element 0 stores reference fluid information)
c
c  explanation of commons
c    /NCOMP/    nc--number of components
c
c    /EOSMOD/   equation of state (thermodynamic) models
c        hpheq--model for phase equilibria calcs (not currently used)
c         heos--equation of state model currently loaded (equal to hmxeos(1) if nc=1)
c       hmxeos--models for mixture components
c       hmodcp--ideal heat capacity model to use for component i
c               (set by call to SETeos routine)
c
c    /TRNMOD/   transport property models
c       hetamx--viscosity model for mixture
c         heta--viscosity models for mixture components
c       htcxmx--thermal conductivity model for mixture
c         htcx--conductivity models for mixture components
c
c    /STNMOD/   surface tension models
c        hsten--surface tension model for mixture
c       hstenk--surface tension models for mixture components
c
c    /DEMOD/    dielectric constant models
c    /MELTMOD/  melting line models
c    /SUBLMOD/  sublimation line models
c    /PSMOD/    vapor pressure equations
c    /PLMOD/    liquid pressure equations
c    /DLMOD/    saturated liquid density equations
c    /DVMOD/    saturated vapor density equations
c
c    /REFST/
c       hsvrfs--reference state (as specified by input argument hrf)
c       hsvrfd--default reference state for each component
c
c    /CCON/     constants for each of the NCMAX components; these values
c               are taken from the coefficients/array of selected model
c      Tcrit(i):  critical temperature (K)
c      Pcrit(i):  critical pressure (kPa)
c      Dcrit(i):  critical density (mol/L)
c      zcrit(i):  critical compressibility factor (Pc/(R*Tc*rhoc))
c      ttpn(i):   triple point temperature (K)
c      ptpn(i):   triple point pressure (kPa)
c      dtpn(i):   triple point density (mol/L)
c      tnbp(i):   normal boiling point temperature (K)
c      wmas(i):   molecular mass (g/mol)
c      accen(i):  acentric factor
c      dipole(i): dipole moment (debye) at normal boiling pt
c
c    /CREF/     reference state for each of the NCMAX components
c      tref(i):   reference temperature for enthalpy and entropy
c      rhoref(i): reference density for enthalpy and entropy
c      href(i):   enthalpy at tref(i), rhoref(i) for component i
c      sref(i):   entropy at tref(i), rhoref(i) for component i
c
c    /CCAS/     CAS numbers for the n0..ncmax components
c      hcas(i):   "i" is mixture component number (n0..ncmax)
c
c    /CNAM/     short-hand names for the nc components
c      hname(i):  "i" is mixture component number
c
c    /HCHAR/    characters used to delimit/terminate output
c      htab:      tab (or other character) to delimit output tables
c      hnull:     ASCII null character to terminate error strings
c                 (for compatibility with mixed-language DLLs)
c
c
c  written by M. McLinden, NIST Thermophysics Division, Boulder, Colorado
c  11-19-94  MM, original version
c  07-21-95  MM, restructure to add subordinate (model-specific)
c                set-up routines
c  07-24-95  MM, fluid const (e.g. Tc) set in SETeos rather than here
c  09-10-95  MM, add common /HCHAR/ and define contents
c  09-13-95  MM, add ierr, herr to argument list
c  09-25-95  MM, new argument list to SATT (outputs in order p, rho, x)
c  10-03-95  MM, read coefficients from files, change argument list
c  11-02-95  MM, expand to include mixture Helmholtz (HMX) model
c                add common block CNAM with fluid names
c  11-08-95  MM, initialize hmxeos array, even if heos not HMX
c  11-29-95  MM, variable lower limit on coefficient/constant arrays
c                to accommodate ECS reference fluid
c                kludge to load R134a as ECS reference fluid
c  12-08-95  MM, move file read to separate subroutine SETFLD
c  12-12-95  MM, remove R134a reference fluid kludge
c  01-09-96  MM, add call to SETHMX (read HMX.bnc file)
c  01-10-96  MM, add check for inputs same as previous call
c  01-11-96  MM, move reference state calculation to SETREF
c  01-19-96  MM, reset flag ksetrf to zero on call to SETUP
c  01-31-96  MM, implement 'NBS' option for EOS (and transport model)
c  02-27-96  MM, parameter n0=-ncmax to accommodate ECS-thermo model
c                add Zcrit to common /CCON/
c  02-29-96  MM, cover case of pure-fluid model specified for mixture
c  03-13-96  MM, changes to merge with Klein's transport code,
c                add common /TRNMOD/
c  03-19-96  MM, add dipole moment to /CCON/
c  03-20-96  MM, reduce argument list, move model specification to SETMOD
c                add mix models to /TRNMOD/
c  03-21-96  MM, replace /MODEL/ with /EOSMOD/, /STNMOD/, /REFST/
c  03-27-96  MM, fix bug when nc = 1 but overall model is a mix model
c  05-08-96  MM, add /MXINFO/ load hfmix into hmfile(0)
c  05-14-96  MM, add call to SETPH0 model (Helmholtz form)
c                disable check if inputs same as previous (!temporary)
c  11-19-96  MM, add commons related to critical lines, print parameters
c  11-25-96  MM, move debug print of mixture pars to SETHMX
c  02-20-97  MM, add hsvrfd to /REFST/, new common /CREFDF/ (for default ref st)
c  02-24-97  MM, add /CREMOD/ (pointer to transport critical enhancement models)
c  03-25-97  MM, bug fix:  x0 used but not dimensioned
c  03-28-97  MM, bug:  models initialized to 'NBS' only for first call to SETUP,
c                subsequent calls find past settings or 'NUL' if ncomp has increased;
c                add flag in /RESETM/ to fix
c  05-27-97  MM, reset gas constant when lreset=.true.
c  07-03-97  MM, use 'DEF' reference state if 'OTH' is specified
c  10-01-97  MM, add compiler switch to allow access by DLL
c  03-30-98  MM, initialize ierr1
c  04-10-98  MM, do not set component models to 'NBS' if mix model is 'NBS'
c                (this had effect of undoing calls to SETMOD)
c  12-01-98 EWL, add routine to convert hfiles*80 to hfiles*255 if necessary
c  12-01-98 EWL, set hfmix2 to hfmix to avoid problems with *80 to *255 change
c  12-01-98 EWL, add Reos and triple point pressure and density to /CCON/
c  03-11-99 EWL, reset lsatt and lsatp to .false. when called
c  06-03-99  MM, change default mixture surface tension model to STH
c  11-01-99 EWL, return from SETFEQ when ierr>0
c  11-02-99 EWL, make sure that selected equation of state has been loaded
c  11-02-99 EWL, set lreset to true before RETURN's
c  01-26-00  MM, add initialization of models & citations in /CITE/
c  03-16-00 EWL, initialize variables in FXPNT
c  12-18-00 MLH, set mixture reference fluid for transport to nitrogen
c  01-23-02 EWL, split common block CITE into 2 pieces for some compilers
c  01-23-02 EWL, split common block MXINFO into 2 pieces for some compilers
c  05-27-02 EWL, check for ammonia/water mixture, adjust R, Href, Sref
c  07-29-02 EWL, changed third argument of SETREF to x0 instead of 0.d0
c  08-20-02 EWL, zero out the iamwat flag
c  09-19-02 EWL, add the ianc flag
c  09-19-02 EWL, add liquid pressure ancillary setup
c  10-31-02 EWL, add AGA8 equation of state setup
c  11-26-02 EWL, add OT0 reference state
c  10-12-04 MLH, add PR setup
c  11-19-04 EWL, read UN number
c  01-03-05 EWL, remove AGA8 equation of state setup, just call setaga after call to setup
c  07-22-05 MLH, add multiple reference fluids for transport properties model
c  09-28-05  DT, change occurrences of a backslash to 'char(92)' for compatibility
c                with some compilers using F77
c  10-07-05 EWL, only modify ammonia/water reference state if user has not redefined it
c  06-13-06 EWL, modified most of the fortran files to remove the line numbers
c                in the do...continue loops.
c  06-13-06 EWL, modified every fortran file throughout all of Refprop to enable
c                the user to load multiple fluids (as if it were a mixture) and
c                then set which pure fluid is being used (though subroutine PureFld)
c                in the calculations.  Common block NCOMP was modified everywhere
c                to include the variable ic, which sets the pure fluid currently
c                in use.  When ic is zero, then mixture calculations are made.
c  07-18-06 EWL, add linit to set strings to 'NUL' on first call
c  07-24-06 EWL, rework lreset logic
c  07-26-06 EWL, remove excess code, rework setup
c  08-10-06 EWL, add action='READ' to all open statements
c  09-25-06 EWL, changed all occurrences in every routine from herr(1:1)=hnull to herr=' '
c  03-30-07 EWL, add dll_export switches to all top level REFPROP subroutines
c  09-13-09 EWL, change loop to call SETPRCO from icomp=0 to icomp=1
c  02-04-10 EWL, change the ianc variable into an array
c  03-03-10 EWL, return version number when called with nc=-1
c  10-28-10 EWL, initialize more variables relating to transport properties
c  04-04-11 EWL, globally change g11.x to g12.x in format statements to remove error message with Intel compiler
c  05-11-11 EWL, change nc to ncomp
c  07-24-12 EWL, change hmxeos to hcomp in call to SETMOD to avoid array size mismatch
c  11-26-12 EWL, exit subroutine early if only SETREF was called after last call to SETUP (but with a reset call to SETREF)
c  01-24-13 MLH, add flag for alcohols ialc
c
c  Compiler switches to allow access to the routines in the DLL.
c  The DEC$ switch is for use with Digital Visual Fortran; this should be
c    treated as a comment by all other compilers.
c
cx DEC$ ATTRIBUTES DLLEXPORT :: SETUP
c
      include 'commons.for'
      include 'comtrn.for'
      character*3 hrf,hcomp(1:ncmax)
      character*255 hfiles(ncmax),hfile(n0:nx),hfmix,hfmix2,rflnam
      character*255 herr,herr1,ucase
      dimension x0(ncmax)
c
      if (ncomp.eq.-1) then
        ierr=91000  !Send back version number*10000.
        RETURN
      endif

c      call DATE (herr)   !Lahey

c     herr=' '
c     call DATE_AND_TIME (herr)
c     if (herr(7:8).eq.'20' .and. herr(9:9).ne.' ') then
c       herr=herr(9:10)//herr(1:2)//herr(4:5)
c     elseif (herr(1:2).eq.'20') then
c       herr=herr(3:8)
c     else
c       herr=herr(7:8)//herr(1:2)//herr(4:5)
c     endif
c                   Y M D
c     if (herr.gt.'140831') then
c       herr=
c    & 'The REFPROP DLL you are using has expired (Dec. 31, 2013). '
c    & //'Please return to the Refprop website and download the latest.'
c       ierr=1
c       RETURN
c     endif

c...to permanetly turn on the full GERG equations, uncomment the following line
c     call GERG04 (nc,1,ierr,herr)

c  initialize variables upon first call to setup
      if (linit) then
        hsveqn='NUL'
        hsvvis='NUL'
        hsvcnd='NUL'
        hsvsrf='NUL'
        hsvdil='NUL'
        hsvmix='NUL'
        hsvrfs='NUL'
        hsvph ='NUL'
        do i=1, nx
          hsveqk(i)='NUL'
          hsvvik(i)='NUL'
          hsvcnk(i)='NUL'
          hsvsrk(i)='NUL'
          hsvdik(i)='NUL'
        enddo
        do i=n0, nx
          hsvfld(i)='NUL'
          hrefdf(i)='NUL'
        enddo
        linit=.FALSE.
      endif
c
c  reset fixed points
c
      htab=CHAR(9)         !tab character for output tables
      hnull=CHAR(0)        !null character to terminate error strings
      if (n0.gt.0) izero0=1 !n0 is usually negative, but the minimizer can reset the bound to decrease array size
      ierr=0
      ierr1=0
      ierrcrt=0
      iSatFlg=0
      herr=' '
      hfmix2=hfmix
      do i=1,ncmax
        x0(i)=0.d0
      enddo
      x0(1)=1.d0
c  used to check for version 6.0 inputs:

c     if(hfmix(79:80).eq.'  '.and.hfmix(81:82).ne.'  ')hfmix2=hfmix(1:80)
c
c  compare inputs to previous values (stored in /xxxMOD/ and /SETSAV/)
c  if nothing has changed SETUP can be bypassed
c
      lsame=.false.
      if (nc.eq.ncomp .and. hsvrfs.eq.hrf) then
c       write (*,*) ' SETUP:  ncomp and ref state same as previous'
        if((hsveqn.eq.heos  .or. hsveqn.eq.'NBS') .and. !EOS model
     &     (hsvvis.eq.hetamx  .or. hsvvis.eq.'NBS') .and. !viscosity model
     &     (hsvcnd.eq.htcxmx  .or. hsvcnd.eq.'NBS') .and. !therm cond model
     &     (hsvsrf.eq.hsten .or. hsvsrf.eq.'NBS') .and. !surface ten model
C    &     (hsvdil.eq.hdiel .or. hsvdil.eq.'NBS') .and. !dielectric model
     &      hsvph.eq.hpheq) then      !phase equil method, not implemented
          lsame=.true.
c         write (*,*) ' SETUP:  after check of models lsame =  ',lsame
          do i=1,nc
c  check that .fld file and component models are the same as last call
            if(hfiles(i).ne.hsvfld(i) .or.
     &        (hsveqk(i).ne.hmxeos(i)  .and. hsveqk(i).ne.'NBS').or.
     &        (hsvsrk(i).ne.hstenk(i)  .and. hsvsrk(i).ne.'NBS').or.
C    &        (hsvdik(i).ne.hdielk(i)  .and. hsvdik(i).ne.'NBS').or.
     &        (hsvvik(i).ne.heta(i)   .and. hsvvik(i).ne.'NBS').or.
     &        (hsvcnk(i).ne.htcx(i)   .and. hsvcnk(i).ne.'NBS')) then
              lsame=.false.
            end if
c         write (*,*) ' SETUP:  after component models lsame = ',lsame
          enddo
c  check for previous call to setref with ixflag=2
          if (ixfsav.eq.2) then
            if (hrf.eq.'DEF') then  !Quick check for need to call SETREF only, without reading fluid files
              ixflag=1
              call SETREF (hrf,ixflag,x0,h0,s0,t0,p0,ierr,herr)
              call AMH2OR  !Setup ammonia/water reference state
            else
              lsame=.false.
            end if
          endif
          if (hsvmix.ne.hfmix2) lsame=.false.   !mixture coeff file
c         write (*,*) ' SETUP:  after mixture file lsame =     ',lsame
        end if
c  if lrst has been set equal to true, then both SETMOD and SETUP were called
c  simultaneously earlier, and this call to SETUP must reset the earlier call
c  to SETMOD.
        if (lrst) lsame=.false.
        if (lsame) RETURN
      end if
c
c
c-------start of main code--------
c
c
      lrst=.false.
      if (.not.lreset) lrst=.true.  !Flag to indicate that SETMOD was called outside of SETUP
      hsvmix='x'  !Delete saved input in case setup called with nc=0 to reset system
c  check state of flag lreset; a value of .true. indicates need to reset
c  all models to 'NBS'; this occurs when SETUP is called a second time
c  in a given application
      if (lreset) then
        do i=1,ncmax
          hcomp(i)=hmxeos(i)
        enddo
        call SETMOD (ncomp,'NBS',heos,hcomp,ierr,herr)
      endif
      iSpline=0
      lreset=.true.
      iamwat=0
      iwat=0
      ialc=0
      do i=0,ncmax
        ianc(i)=0
      enddo
      if (ierr.gt.0) RETURN
      if (ncomp.ne.ncset) then
        ierr=114
        herr='[SETUP error 114] number of components does not match '//
     &  'value sent to SETMOD'//hnull
        call ERRMSG (ierr,herr)
        RETURN
      endif
c
      ksetrf=0
      hsvph='NBS'
      hsvmix=hfmix2
      nc=ncomp
      R=8.314472d0   !gas constant, Mohr and Taylor, JPCRD, 28(6):1713-1852, 1999.
c     R=8.314510d0   !gas constant, CODATA recommended value
c
c     write (*,*)    'Input values'
c     write (*,1002) heos, (hmxeos(j),j=0,12),
c    &               hetamx, (heta(j),j=0,12),
c    &               htcxmx, (htcx(j),j=0,12),
c    &               hsten,(hstenk(j),j=0,12)
c     write (*,*)    'Saved values'
c     write (*,1002) hsveqn,(hsveqk(j),j=0,12),
c    &               hsvvis,(hsvvik(j),j=0,12),
c    &               hsvcnd,(hsvcnk(j),j=0,12),
c    &               hsvsrf,(hsvsrk(j),j=0,12)
c1002 format ('    heos, hmxeos: ',2(a3,3x),12(a3,1x)/
c    &        '     visc models: ',2(a3,3x),12(a3,1x)/
c    &        '      tcx models: ',2(a3,3x),12(a3,1x)/
c    &        ' surf ten models: ',2(a3,3x),12(a3,1x))
c
c  set pointers to models
c
c  special case if equation of state is NIST recommendation
c  only mixture choice at present is the HMX model
      if (heos.eq.'NBS' .or. heos.eq.'nbs') then
        heos='HMX'
        if (nc.eq.1) heos=hmxeos(1)
      else if (heos.eq.'HMX') then
c  mixture model is HMX, use component models as set in SETMOD
      else
        if (nc.gt.1) then
c  this condition should not be accessed; a mix model other than HMX
c  has been specified, but only choice at present is the HMX model
          ierr=-105
          herr='[SETUP warning -105] unknown mixture model specified,'
     &       //' the HMX model will be used.'//hnull
          call ERRMSG (ierr,herr)
          heos='HMX'
          do i=1,nc
            hmxeos(i)='NBS'
          enddo
        end if
      end if
c
c  special case if viscosity model is NIST recommendation
c  only mixture choice at present is the ECS model
      if (hetamx.eq.'NBS' .or. hetamx.eq.'nbs') then
        hetamx='ECS'
        if (nc.eq.1) hetamx=heta(1)
      else if (hetamx.eq.'ECS') then
c  mixture model is ECS, use component models as set in SETMOD
      else
        if (nc.gt.1) then
c  this condition should not be accessed; a mix model other than ECS
c  has been specified, but only choice at present is the ECS model
c         write (*,*) ' SETUP--unknown mix viscosity model, ECS used'
          hetamx='ECS'
          do i=1,nc
            heta(i)='NBS'
          enddo
        end if
      end if
c
c  special case if thermal conductivity model is NIST recommendation
c  only mixture choice at present is the ECS model
      if (htcxmx.eq.'NBS' .or. htcxmx.eq.'nbs') then
        htcxmx='ECS'
        if (nc.eq.1) htcxmx=htcx(1)
      else if (htcxmx.eq.'ECS') then
c  mixture model is ECS, use component models as set in SETMOD
      else
        if (nc.gt.1) then
c  this condition should not be accessed; a mix model other than ECS
c  has been specified, but only choice at present is the ECS model
c         write (*,*) ' SETUP--unknown mix conductivity model, ECS used'
          htcxmx='ECS'
          do i=1,nc
            htcx(i)='NBS'
          enddo
        end if
      end if
c
c  special case if surface tension model is NIST recommendation
      if (hsten.eq.'NBS' .or. hsten.eq.'nbs') then
        hsten='STH'
        if (nc.eq.1) hsten=hstenk(1)
c     else if (hsten.eq.'STM' .or. hsten.eq.'STX') then
c  mixture model is STM or STX, both are contained in routine STN;
c  use component models as specified in SETMOD
      end if
c
c  special case if dielectric constant model is NIST recommendation
      if (hdiel.eq.'NBS' .or. hdiel.eq.'nbs') then
        hdiel='DEM'
        if (nc.eq.1) hdiel=hdielk(1)
c     else if (hdiel.eq.'DEM' .or. hdiel.eq.'DEX') then
c  mixture model is DEM or DEX, both are contained in routine DE;
c  use component models as specified in SETMOD
      end if
c
c  old code for compatibility with version 6.0
c     if (hfiles(1)(79:80).eq.'  ' .and. hfiles(1)(81:82).ne.'  ') then
c       hfile(1)=hfiles(1)(1:80)
c       if (nc.ge.2) hfile(2)=hfiles(1)(81:160)
c       if (nc.ge.3) hfile(3)=hfiles(1)(161:240)
c       if (nc.ge.4) hfile(4)=hfiles(1)(241:255)//hfiles(2)(1:65)
c       if (nc.ge.5) hfile(5)=hfiles(2)(66:145)
c     endif
c
c
c  fill up info arrays for unused/undefined components/reference fluid
c
      do i=n0,nc
        hfile(i)='NUL'
        hcas(i)='not_defined'
        hname(i)='not_defined'
        hieos(i)='NUL'//hnull
        hicp0(i)='NUL'//hnull
        histn(i)='NUL'//hnull
        hidiel(i)='NUL'//hnull
        himelt(i)='NUL'//hnull
        hisubl(i)='NUL'//hnull
        hips(i)='NUL'//hnull
        hipl(i)='NUL'//hnull
        hidl(i)='NUL'//hnull
        hidv(i)='NUL'//hnull
        hitcx(i)='NUL'//hnull
        hieta(i)='NUL'//hnull
        hitcxc(i)='NUL'//hnull
        hietac(i)='NUL'//hnull
        tminst(i)=300.d0
        tmaxst(i)=300.d0
        tmtcx(i)=300.d0
        txtcx(i)=300.d0
        tmeta(i)=300.d0
        txeta(i)=300.d0
        tmecst(i)=300.d0
        txecst(i)=300.d0
        pxtcx(i)=0.d0
        Dxtcx(i)=0.d0
        pxeta(i)=0.d0
        Dxeta(i)=0.d0
        pxecst(i)=0.d0
        Dxecst(i)=0.d0
      enddo
      do i=1,nc
        hfile(i)=hfiles(i)
        hsvfld(i)=hfiles(i)
      enddo
      if (n0.le.0) then
        heta(izero0)='NUL'
        htcx(izero0)='NUL'
        hmxeos(izero0)='FEQ'     !Set default in case .fld file has no transport model
      endif
c
c  store fluid constants for each of the nc components
c
      do icomp=1,nc
        if (INDEX(UCASE(hfile(icomp),255),'PPF').ne.0) ianc(icomp)=1
        call SETFLD (icomp,hfile,ierr,herr)
        if (ierr.gt.0) RETURN  !error in opening file--further processing pointless
      enddo
c
c  store fluid constants for ECS reference fluids (if any)
c
      do icomp=-ncmax,0    !ecs ref fluids from -ncmax to 0 (not n0 to 0)
        if (icomp.ge.n0) then
          if (hfile(icomp).ne.'NUL') then
            if (icomp.eq.0 .and. nc.gt.1) then
c           no need to call SETFLD here, it gets called below for i=0
            else
              call SETFLD (icomp,hfile,ierr,herr)
              if (ierr.gt.0) RETURN  !error in opening file--further processing pointless
            endif
          end if
        endif
      enddo
c
c
c  for a mixture, set reference fluids for mixture calculations; currently
c  hfile(0) corresponds to ref fluid of last pure fluid loaded; reset to nitrogen.
c  presently there are 4 possible reference fluids for mixtures
c  slot      0: nitrogen
c     -ncmax-1: propane
c     -ncmax-2: dodecane
c     -ncmax-3: R134a
c
c     write (*,*) 'Reference fluid:  ',hfile(0)(1:60)
      if (nc.gt.1 .and. n0.lt.0) then
        ipos=0
        do ii=1,255
c  EWL change from hfile(0) to hfile(1)
          if (hfile(1)(ii:ii).eq.'/' .or. hfile(1)(ii:ii).eq.':'
     &        .or. hfile(1)(ii:ii).eq.char(92)) then
            ipos=ii
          end if
        enddo
        do ij=0,nrefluids-1
          il=-ncmax-ij
          if (ij.eq.0) then
            il=0
            rflnam='nitrogen.fld'
          elseif (ij.eq.1) then
            rflnam='propane.fld'
          elseif (ij.eq.2) then
            rflnam='c12.fld'
          elseif (ij.eq.3) then
            rflnam='r134a.fld'
          endif
          if (ipos.eq.0) then
            hfile(il)=rflnam
          else
            hfile(il)=hfile(1)(1:ipos)//rflnam !append ref fluid name
          endif
          call SETFLD (il,hfile,ierr,herr)
          if (ierr.gt.0) RETURN  !error in opening file--further processing pointless
        enddo
      endif
c
c
c  set up mixture model, if applicable
c
      if (heos.eq.'HMX') then
        call SETHMX (hfmix2,ierr1,herr1)
c       write (*,*) 'ierr from SETHMX:  ',ierr1,':  ',herr1
      end if
c
c  set reference state
c
      ixflag=1    !only 'pure fluid' reference state can be called here
      if (hrf(1:2).eq.'OT') then
        ierr=-105
        herr='[SETUP warning -105] must use routine SETREF for (OTH) '
     &      //'reference state choice; will use default (DEF) choice'
     &      //hnull
        call ERRMSG (ierr,herr)
        hrf='DEF'        !use the default reference state
        if (ierr1.eq.0) then
          ierr1=ierr
          herr1=herr
        end if
      end if
      call SETREF (hrf,ixflag,x0,h0,s0,t0,p0,ierr,herr)
c     write (*,*) ' SETUP--ierr returned from SETREF:  ',ierr
c  any error from SETREF takes precedence over error from SETHMX
      if (ierr.eq.0 .and. ierr1.ne.0) then
        ierr=ierr1
        herr=herr1
      end if
c
c  save current models into /MODSAV/--check on subsequent calls to
c  SETUP, if nothing has changed, can bypass call
c
      if (ierr.eq.0) then
        hsvph=hpheq
        hsveqn=heos
        hsvvis=hetamx
        hsvcnd=htcxmx
        hsvsrf=hsten
        hsvdil=hdiel
        do k=1,nc
          hsveqk(k)=hmxeos(k)
          hsvvik(k)=heta(k)
          hsvcnk(k)=htcx(k)
          hsvsrk(k)=hstenk(k)
          hsvdik(k)=hdielk(k)
        enddo
      endif
c
c     write (*,1442) heos,(hmxeos(j),j=-5,5),
c    &                    (hmodcp(j),j=-5,5),
c    &               hetamx,(heta(j),j=0,5),
c    &                    (hetacr(j),j=0,ncomp)
c     write (*,1443) htcxmx,(htcx(j),j=0,5),
c    &                    (htcxcr(j),j=0,ncomp)
c     write (*,1444) hsten,(hstenk(j),j=-5,5)
c1442 format ('   SETUP--heos, hmxeos: ',a3,3x,5(a3,1x),a5,3x,5(a3,1x)/
c    &        '   (exit)     Cp0 mods: ',3x,3x,5(a3,1x),a5,3x,5(a3,1x)/
c    &        '           visc models: ',a3,25x,a3,3x,5(a3,1x)/
c    &        '        visc crit mods: ',3x,25x,a3,3x,5(a3,1x))
c1443 format ('            tcx models: ',a3,25x,a3,3x,5(a3,1x)/
c    &        '        t.c. crit mods: ',3x,25x,a3,3x,5(a3,1x))
c1444 format ('       surf ten models: ',a3,3x,5(a3,1x),a5,3x,5(a3,1x))
c     write (*,*) 'ierr at SETUP exit: ',ierr,':  ',herr(1:40)
c
      call AMH2OR  !Setup ammonia/water reference state
      do icomp=1,nc
        call SETPRCO(icomp)
      enddo
c
c     do i=1,nc
c       x0=0.d0
c       x0(i)=1.d0
c       calculate critical point of eos
c       call FNCRPT(x0,d,p,t,ierr,herr)
c       if (ierr.le.0) then
c         tcrit(i)=t
c         pcrit(i)=p
c         Dcrit(i)=d
c       endif
c       determine liquid and vapor spinodals (auxiliary splines)
c       call SETLSPNDL(i,ierr,herr)
c       call SETVSPNDL(i,ierr,herr)
c     enddo
c
      RETURN
c
      end                                              !subroutine SETUP
c
c ======================================================================
c
      subroutine SETUP0 (i,hfld,hfm,hrf,ierr,herr)
c
c     call the SETUP routine with the same inputs as SETUP except for
c     the hfld variable.  This subroutine is generally used in calls
c     to the REFPROP DLL since the call cannot handle a string array.
c     The hfld variable is a string of length 10000.  For a pure fluid,
c     it simply contains the name of the fluid file (with a path if needed).
c     For a mixture, it contains the names of the constituents in the
c     mixture separated by a |.  For the air mixture, this would be
c     something like (depends on the need for paths):
c     hfld='fluids\nitrogen.fld|fluids\argon.fld|fluids\oxygen.fld|'
c
c  written by E.W. Lemmon, NIST Thermophysics Division, Boulder, Colorado
c  04-07-05 EWL, original version
c  01-16-06 EWL, check for missing '|' at end of line
c
cx DEC$ ATTRIBUTES DLLEXPORT :: SETUP0
c
      include 'commons.for'
      character hfld*10000,hfm*255,hrf*3,herr*255,hfmix*255
      character*255 hf(ncmax)
c
      do j=1,ncmax
        hf(j)=' '
      enddo
      if (i.eq.1) then
        hf(1)=hfld
        j=index(hf(1),'|')
        if (j.ne.0) hf(1)(j:)=' '
      else
        m=1
        do k=1,i
          j=index(hfld(m:10000),'|')
          if (j.ne.0) then
            j=j+m-1
            hf(k)=hfld(m:j-1)
            m=j+1
c  check for inputs without a '|' at the end
          elseif (k.eq.i .and. hfld(m:).ne.' ') then
            hf(k)=hfld(m:)
          else
            ierr=1
            herr='[SETUP0 error 1] not enough fluid names on input line'
            RETURN
          endif
        enddo
      endif
      hfmix=hfm
      call SETUP (i,hf,hfmix,hrf,ierr,herr)
      end                                             !subroutine SETUP0
c
c ======================================================================
c
      subroutine SETFLD (icomp,hfile,ierr,herr)
c
c  open a fluid file and read model coefficients (or get from block data)
c
c  inputs:
c    icomp--pointer specifying component number
c           zero and negative values are used for ECS reference fluid(s)
c    hfile--array of file names specifying fluid/mixture components
c           [character*255 variable] for each of the components;
c           --or--
c           when hf(i) is of the form:
c             BDATA:nn-nn-nn
c           use coefficients stored in block data for fluid with CAS
c           number specified by nn-nn-nn;
c           e.g. to use stored formulation for R134a,
c           hf(i) = 'BDATA:811-97-2'
c  outputs:
c     ierr--error flag:  0 = successful
c                      101 = error in opening file
c                      102 = error in file or premature end of file
c                     -103 = unknown model encountered in file
c                      104 = error in setup of model
c                      105 = specified model not found
c                      106 = cp0 equation not found
c     herr--error string (character*255 variable if ierr<>0)
c     [fluid parameters, etc. returned via various common blocks]
c
c  written by M. McLinden, NIST Thermophysics Division, Boulder, Colorado
c  12-08-95  MM, original version--extracted from old subroutine SETUP
c  12-12-95  MM, add calls to SETECS, SETETA, SETTCX
c  12-14-95  MM, add call to RFFILE (add directory to ref fluid file)
c  01-12-96  MM, do not reset hmxeos(0) if in file 0 (reference fluid)
c  01-23-96  MM, always call SETETA, SETTCX, etc. if found in .fld file
c  01-31-96  MM, implement 'NBS' option for EOS (and transport model)
c  02-27-96  MM, parameter n0=-ncmax to accommodate ECS-thermo model
c                add Zcrit to common /CCON/
c  02-29-96  MM, check only hmxeos(i) [not heos] for call to SETxxx
c  03-13-96  MM, changes to merge with Klein's transport code
c                add common /TRNMOD/; add calls to SETTRN, SETVSi, SETTCi
c  03-15-96  MM, always load ECS-transport model (unless htran = 'NUL')
c  03-19-96  MM, read dipole moment and add to /CCON/
c  03-20-96  MM, add mixture models to /TRNMOD/
c  03-21-96  MM, replace /MODEL/ with /EOSMOD/, /STNMOD/
c  03-27-96  MM, add calls to set up surface tension
c  03-28-96  MM, add flags ltcx,leta to cover case of fluid-specific
c                model available for only one of the transport props
c  06-17-96  MM, check only 'CP' rather than 'CPP' to allow CP1
c  06-18-96  MM, add calls to SETVS4-6 and SETTC2-4 for future use
c  10-16-96  MM, add call to SETCI2 (collision integral AUX function)
c  10-30-96  MM, add calls to SETTC5, SETTC6
c  11-06-96  MM, check that i.ge.nrf0 before calling collision integral
c  01-21-97  MM, add call to SETCI1 (collision integral AUX function)
c  02-06-97  MM, add /CNAM80/ to store full chemical name
c  02-20-97  MM, read in default reference state from fluid file,
c                add hsvrfd to /REFST/, new common /CREFDF/
c  02-24-97  MM, add calls to transport critical models and /CREMOD/
c  03-26-97 EWL, minor changes for Fortran 90 compatibility
c  03-27-97 EWL, if file not found, search in likely directories
c  08-22-97  MM, use double backslash on file open to avoid problem with Unix machines
c  10-28-97  MM, put fluid file version no. into common
c  12-01-97  MM, read in synonyms, add to /CNAM80/
c  03-30-98  MM, initialize ierrvs,ierrtc,ierrst
c  04-08-98 EWL, initialize ierr1
c  10-30-98 EWL, change hmxeos to FEQ when called by SETMOD with FE1, etc.
c  12-01-98 EWL, add Reos and triple point pressure and density to /CCON/
c  06-22-99 EWL, comment out the "ierr1=104" in the AUX section
c  11-01-99 EWL, add error if cp0 equation not found
c                load CPP as default (in case flag to CPP occurs after coefs. in file)
c  01-14-00 EWL, allow use of 'VIS' as well as 'ETA'
c  01-26-00  MM, read in citation in addition to model specification
c                add common /CITE/ to pass this information to GETMOD
c  02-15-00 EWL, check for case sensitive fluid names
c  03-07-00 EWL, add TC0 and VS0 models
c  05-24-00 EWL, initialize hetemp and httemp
c  08-23-00 EWL, change heos from FE1, etc. to FEQ, and similarly for BWR and ECS
c  01-17-01 EWL, remove double backslash, which caused problems in Windows
c  01-23-02 EWL, split common block CITE into 2 pieces for some compilers
c  07-08-02 EWL, revise checks on location of fld file
c  01-13-05 WLJ, add new checks for open failure (ORNL)
c  07-22-05 MLH, allow for transport reference fluids
c  09-28-05  DT, change occurrences of a backslash to 'char(92)' for compatibility
c                with some compilers using F77
c  04-18-06 EWL, make call to "inquire" to check for multiple use of nread=12
c  07-24-06 EWL, do not call setfld again if @FEQ found after #FE1, etc.
c  08-10-06 EWL, create new subroutine to open file and move appropriate code
c  10-30-06 EWL, check for FEK
c  11-08-06 EWL, after the call to STFLD2, add href to hfiles() in the negative position so that the transport routines of the reference fluid will be loaded.
c  04-18-07 EWL, add checks for UN parameters
c  12-12-07 MLH, allow FEX for generalized model of Xiang and Deiters
c  01-09-08 EWL, read in heat of combustion
c  02-26-09 EWL, check for missing '.fld' on file names
c
      include 'commons.for'
      include 'comtrn.for'
      character*1 h1,hstar
      character*3 hsveq
      character*3 hetemp,httemp
      character*3 hmaux
      character*3 hflag,htype
      character*12 hcasn(n0:nx)
      character*255 hfile(n0:nx),hreff
      character*255 herr,herr1
      character*251 hcite
      character*255 hstr
      logical lbdata,leta,ltcx,leosfl,lprfl
c
 10   continue
      ierr1=0
      herr=' '
      herr1=hnull
      i=icomp
      icpflg=0
      lprfl=.false.
      ltcx=.false.
      leta=.false.
      leosfl=.false.
      hetemp=' '
      httemp=' '
      igenfl(i)=0
      UNNumb(i)=' '
      family(i)=' '
      hcmbst(i)=-1.d0
c     initialize
      if (i.ge.0) iunflg(i)=0
c     do not set pr coef for transport/ecs ref fluids other than zero slot
      if (i.ge.0) then
        do j=1,20
          prcoef(i,j)=0.d0
        enddo
        iprflag(i)=0
      endif
c     write (*,1102) i,hfile(i)
c1102 format (/1x,'input file for fluid ',i3,': (',a40,')')
c     write (*,1003) heos,(hmxeos(j),j=n0,ncmax),
c    &               hetamx,(heta(j),j=nrf0,nx),htcxmx,(htcx(j),j=nrf0,nx)
c    &              ,hsten,(hstenk(j),j=n0,ncmax)
c1003 format ('  SETFLD--heos, hmxeos: ',a3,3x,5(a3,1x),a5,3x,5(a3,1x)/
c    &        '  (input)  visc models: ',a3,25x,a3,3x,5(a3,1x)/
c    &        '            tcx models: ',a3,25x,a3,3x,5(a3,1x)/
c    &        '       surf ten models: ',a3,3x,5(a3,1x),a5,3x,5(a3,1x))
      if (hfile(i)(1:5).eq.'BDATA' .or. hfile(i)(1:5).eq.'bdata') then
c  get coefficients from common blocks
        lbdata=.true.
        nread=0
        hcasn(i)=hfile(i)(7:18)
        hcas(i)=hcasn(i)
c       write (*,1104) hcasn(i)
c1104   format (1x,'coefficients from block data; CAS no.: (',a12,')')
      else
c  read coefficients from file
c       write (*,1105) hfile(i)
c1105   format (1x,'reading coefficients from file: (',a40,')')
        lbdata=.false.
        nread=12             !logical unit for file reads
        if (index(hfile(i),'.').eq.0) then   !Check for missing '.fld'
          j=index(hfile(i),' ')
          if (j.ne.0 .and. hfile(i)(j:j+3).eq.'    ')
     &        hfile(i)=hfile(i)(1:j-1)//'.fld'
        endif
        call OPENFL (nread,hfile(i),1,ierr,herr)
        if (ierr.ne.0) goto 998
c
        read (nread,2060) hnam60(i)           !short name
        j=INDEX(hnam60(i),'!')
        if (j.ne.0) hnam60(i)=hnam60(i)(1:j-1)
        hname(i)=hnam60(i)(1:12)
        read (nread,2012) hcasn(i)           !CAS number
        hcas(i)=hcasn(i)
        read (nread,2080) hnam80(i)          !full chemical name
c       write (*,*) ' SETUP--full name:  ',hnam80(i)
        read (nread,2080) hsyn1(i)           !synonym 1
        read (nread,2080) hsyn2(i)           !synonym 2
c  note:  read in generic fluid constants; these may be reset by
c         some SETeos routines to correspond with the values used
c         in the respective models
        read (nread,*) wmas(i)           !molecular weight [g/mol]
        read (nread,*) ttpn(i)         !triple point temperature [K]
        read (nread,*) tnbp(i)         !normal boiling point [K]
        read (nread,*) tcrit(i)        !critical temperature [K]
        read (nread,*) pcrit(i)        !critical pressure [kPa]
        read (nread,*) Dcrit(i)        !critical density [mol/L]
        read (nread,*) accen(i)        !acentric factor [-]
        read (nread,*) dipole(i)       !dipole moment [debye]
        read (nread,2003) hrefdf(i)    !default reference state
        if (hrefdf(i)(1:2).eq.'OT') then
c  for 'OTHer' reference state read in reference T,p,h,s
          read (nread,*)  tdef(i),pdef(i),hdef(i),sdef(i)
        end if
        read (nread,*) verfl(i)        !version number
c
 150    continue
        read (nread,2080) hstr
        if (hstr.ne.' ') then
          j=INDEX(hstr,'!')
          if (j.ne.0) then
            if (hstr(j:j+2).eq.'!UN') then
              UNNumb(i)=hstr(1:j-1)
            elseif (hstr(j:j+2).eq.'!fa') then
              family(i)=hstr(1:j-1)
            elseif (hstr(j:j+2).eq.'!he') then
              read (hstr(1:j-1),*) hcmbst(i)
            endif
          endif
          goto 150
        endif
c       write (*,*) ' SETUP--end of constants; default = ',hsvrfd(i)
      end if
c
c  search for key characters in cols 1 and 2-4 (if reading from file)
c  and branch to subsidiary setup routines for specified models
c
 100  continue
      if (.not.lbdata) then           !read from file
        read (nread,2013,end=199,err=199) hstar,hflag
        if (hstar.eq.'!') goto 100
c       write (*,*) ' SETUP--input line:   ',hstar,hflag
c  hstar = '#' or '@' indicates start of model specification
c        # indicates NIST-recommended model
c        @ indicates other model(s)
c  hflag indicates type of model:
c        'EOS' = equation of state
c        'TRN' = transport property model (i.e. ECS model)
c        'ETA' = pure fluid viscosity model
c        'TCX' = pure fluid thermal conductivity model
c        'AUX' = auxiliary model, such as ideal heat capacity
        if (hstar.eq.'#' .or. hstar.eq.'@') then
          read (nread,2083) htype,hcite
c  htype is 3-letter key for particular models + 1-line citation, for example:
c         'NBS' = NIST-recommended model
c         'BWR' = modified Benedict-Webb-Rubin equation of state
c         'FEQ' = fundamental (Helmholtz) equation of state
c         'ECS' = extended corresponding states model
c         'HMX' = mixture Helmholtz model
c         'CPP' = polynomial fit of ideal gas heat capacity
c         'VSi' = pure fluid viscosity model #i
c         'TCi' = pure fluid thermal conductivity model #i
c         write (*,*) ' SETUP--hstar,hflag:  ',hstar,hflag
c         write (*,*) ' SETUP--htype:        ',htype
c
          do k=1,1000             !skip over source comments
            read (nread,2001) h1
            if (h1.ne.'?') goto 120   !comment block terminated by '!'
          enddo
 120      continue
        end if
      end if
c
      if (lbdata) then
        hflag='EOS'
        htype=heos
      end if
c
      if (hflag.eq.'EOS' .or. hflag.eq.'eos') then
c
c  set up equation of state
c
        if (hstar.eq.'#') then
c  special case for NIST-recommended model
          if (nc.eq.1 .and. heos.eq.'NBS') heos=htype
          if (i.ge.1 .and. hmxeos(i).eq.'NBS') hmxeos(i)=htype
c  allow for transport reference fluids
          if (i.lt.-ncmax .and. hmxeos(i).eq.'NBS') hmxeos(i)=htype
        end if
c
        if (htype(1:2).eq.'BW') then
c  modified Benedict-Webb-Rubin equation of state found in file
c         if (heos.eq.'BWR' .or. hmxeos(i).eq.'BWR') then
          if (hmxeos(i).eq.htype) then
c           write (*,*) ' SETUP--about to call SETBWR'
            if (.not.leosfl) then
              hmxeos(i)='BWR'
              if (heos(1:2).eq.'BW') heos='BWR'
              call SETBWR (nread,i,hcasn(i),ierr1,herr1)
              hieos(i)=htype//hcite//hnull
              leosfl=.true.
            end if
          end if
        else if (htype(1:2).eq.'FE') then
c  fundamental (Helmholtz) equation of state found in file
c         if (heos.eq.'FEQ' .or. hmxeos(i).eq.'FEQ') then
          if (htype(1:3).eq.'FEX') igenfl(i)=1
          if (hmxeos(i).eq.htype) then
            if (.not.leosfl) then
c           write (*,*) ' SETUP--about to call SETFEQ'
              if (heos(1:2).eq.'FE') heos='FEQ'
              call SETFEQ (nread,i,hcasn(i),ierr1,herr1)
              hieos(i)=htype//hcite//hnull
              leosfl=.true.
            end if
          end if
        else if (htype(1:2).eq.'QU') then
c  fundamental Quintic (Helmholtz) equation of state found in file
c         if (heos.eq.'QUI' .or. hmxeos(i).eq.'QUI') then
          if (hmxeos(i).eq.htype) then
            if (.not.leosfl) then
c           write (*,*) ' SETUP--about to call SETQUI'
              if (heos(1:2).eq.'QU') heos='QUI'
              call SETQUI (nread,i,hcasn(i),ierr1,herr1)
              hieos(i)=htype//hcite//hnull
              leosfl=.true.
            end if
          end if
        else if (htype(1:2).eq.'EC') then
c  extended corresponding states (ECS) thermo model found in file
c         if (heos.eq.'ECS' .or. hmxeos(i).eq.'ECS') then
          if (hmxeos(i).eq.htype) then
c           write (*,*) ' SETUP--about to call SETECS (thermo)'
            if (.not.leosfl) then
              hmxeos(i)='ECS'
              if (heos(1:2).eq.'EC') heos='ECS'
              call SETECS (nread,i,hcasn(i),hreff,hsveq,ierr1,herr1)
c  add directory information to reference fluid file
              call RFFILE (hfile(i),hreff)
              iref=-i
              if (iref.ge.n0) then
                hfile(iref)=hreff
                hmxeos(iref)=hsveq
                hieos(i)=htype//hcite//hnull
                leosfl=.true.
              endif
            end if
          end if
        else if (htype(1:2).eq.'PR') then
c  cubic (Peng-Robinson, etc.) equation of state found in file
          if (hmxeos(i)(1:2).eq.htype(1:2)) then
            hmxeos(i)='PR'
            if (heos(1:2).eq.'PR') heos='PR'
            call SETPR (nread,i,hcasn(i),ierr1,herr1)
            hieos(i)=htype//hcite//hnull
            leosfl=.true.
          else
c  get tpr coefficients from fluid file, but nothing else
            call SETPR (-nread,i,hcasn(i),ierr1,herr1)
          end if
          lprfl=.true.
        else
c  unidentified model found in file
          ierr=-103
          write (herr,2103) htype,i,hnull
          call ERRMSG (ierr,herr)
        end if
        if (ierr1.ne.0) then
          ierr=104
          write (herr,2104) hmxeos(i),i,herr1(1:182),hnull
          call ERRMSG (ierr,herr)
        end if
      end if
c
      if (lbdata) then
        hflag='AUX'
        htype=hmodcp(i)
      end if
c
      if (hflag.eq.'AUX') then
c
c  set up auxiliary model(s)
c  (model(s) are specified in call to appropriate SETmod routine)
c
c       write (*,*) ' SETUP--aux model (',htype,') found in fld file '
c       write (*,*) ' SETUP--i,htype,hmodcp(i): ',i,htype,hmodcp(i)
        ierr1=0
        hmaux=hmodcp(i)    !possible use in error message
        if (htype(1:2).eq.'CP' .and. hmodcp(i).eq.htype) then
c  ideal gas heat capacity function
c         write (*,*) ' SETUP--about to call SETCPP'
          call SETCPP (nread,i,hcasn(i),ierr1,herr1)
          hicp0(i)=htype//hcite//hnull
          icpflg=2
        else if (htype(1:2).eq.'PH' .and. hmodcp(i).eq.htype) then
c  Helmholtz for ideal gas heat state
c         write (*,*) ' SETUP--about to call SETPH0'
          call SETPH0 (nread,i,hcasn(i),ierr1,herr1)
          hicp0(i)=htype//hcite//hnull
          icpflg=2
        elseif (htype(1:3).eq.'CPP' .and. (hmodcp(i)(1:2).eq.'CP'
     &         .or. hmodcp(i).eq.'NBS') .and. icpflg.eq.0) then
          call SETCPP (nread,i,hcasn(i),ierr1,herr1)
          hicp0(i)=htype//hcite//hnull
          icpflg=1
        elseif (htype(1:2).eq.'UN') then
          read (nread,*) tminUN(i)             !lower temperature limit
          read (nread,*) tmaxUN(i)             !upper temperature limit
          read (nread,*) pmaxUN(i)             !upper pressure limit
          read (nread,*) rhomUN(i)             !upper density limit
          read (nread,*) iunflg(i)             !flag to allow calcs
          read (nread,*) ntrmUN(i)
          jterm=0
          if (ntrmUN(i).ge.1) then
            do j=1,ntrmUN(i)           !read coefficients
              jterm=jterm+1
              read (nread,*) prmUN(i,jterm)
            enddo
          end if
        end if
        if (ierr1.ne.0) then
          ierr=104
          write (herr,2104) hmaux,i,herr1(1:182),hnull
          call ERRMSG (ierr,herr)
        end if
      end if
c
      if (lbdata) hflag='TRN'
c
c  If the transport models, dielectric models, and surface tension eqs.
c  (vis, tcx, st, de) are not required, and only the default values in the
c  fluid files are used, the following files do not have to be compiled and
c  linked with the other source code:  CORE_DE, CORE_STN, SETUP2,
c  TRNS_ECS, TRNS_TCX, TRNS_VIS, and TRNSP.  In addition, the
c  following two lines should be commented out:
      call STFLD2 (nread,i,hcasn,hcite,hsveq,hetemp,hfile,hflag,
     &              hreff,hstar,httemp,htype,leta,ltcx,ierr,herr)
      if (hreff.ne.' ' .and. i.gt.0) then
        iref=-i
        if (iref.ge.n0) then
          if (hfile(iref).eq.'NUL') then
            hfile(iref)=hreff
            hmxeos(iref)=hsveq
          endif
        endif
      endif
c
c  do not call the following models if component number less than 0
      if (i.ge.nrf0 .and. hstar.eq.'#') then
c
c  melting line models
        ierr1=0
        if (hflag.eq.'MLT' .or. hflag.eq.'mlt') then
          hmelt=htype
          hmeltk(i)=htype
          call SETMLT (nread,i,ierr1,herr1)
          himelt(i)=htype//hcite//hnull
c  sublimation line models
        elseif (hflag.eq.'SBL' .or. hflag.eq.'sbl') then
          hsubl=htype
          hsublk(i)=htype
          call SETSBL (nread,i,ierr1,herr1)
          hisubl(i)=htype//hcite//hnull
c  vapor pressure equations
        elseif (hflag.eq.'PS ' .or. hflag.eq.'ps ') then
          hpsa=htype
          hpsk(i)=htype
          call SETPS (nread,i,ierr1,herr1)
          hips(i)=htype//hcite//hnull
c  liquid pressure equations (for pseudo-pure fluids)
        elseif (hflag.eq.'PL ' .or. hflag.eq.'pl ') then
          hpla=htype
          hplk(i)=htype
          call SETPL (nread,i,ierr1,herr1)
          hipl(i)=htype//hcite//hnull
c  saturated liquid density equations
        elseif (hflag.eq.'DL ' .or. hflag.eq.'dl ') then
          hdla=htype
          hdlk(i)=htype
          call SETDL (nread,i,ierr1,herr1)
          hidl(i)=htype//hcite//hnull
c  saturated vapor density equations
        elseif (hflag.eq.'DV ' .or. hflag.eq.'dv ') then
          hdva=htype
          hdvk(i)=htype
          call SETDV (nread,i,ierr1,herr1)
          hidv(i)=htype//hcite//hnull
        end if
        if (ierr1.ne.0 .and. ierr.eq.0) then
          ierr=104
          write (herr,2104) hflag,i,herr1(1:182),hnull
          call ERRMSG (ierr,herr)
        end if
      end if
c
      if (lbdata) RETURN                  !next component
c
      if (hflag.eq.'END') then
c  if fluid-specific 'ETA' and/or 'TCX' models have not been loaded, use
c  the 'TRN' model (e.g. the ECS model)
        if (i.ge.nrf0) then
          if (.not.leta) heta(i)=hetemp
          if (.not.ltcx) htcx(i)=httemp
        end if
c  close the file, return to setup and process the next component
        rewind (nread)
        close (unit=nread,err=998)
c       write (*,1190) hfile(i)
c1190   format ('  SETUP--file closed: ',a80)
        if (.not.leosfl) then
        if (i.ge.-ncmax) then
c  if a pure fluid equation for the GERG-2004 model was requested, but does
c  not exist, use the default (FEQ) without returning an error message
          if (hmxeos(i).eq.'FEK') then
            hmxeos(i)='FEQ'
            goto 10
          endif
          ierr=105
          write (herr,2105) i,hfile(i)(1:100),hnull
 2105     format ('[SETUP error 105] selected equation of state',
     &            ' not found for component #',i3,':  ',a100,a1)
          call ERRMSG (ierr,herr)
          RETURN
        endif
        if (icpflg.eq.0 .or. (icpflg.eq.1.and.hmodcp(i).ne.'CPP')) then
          ierr=106
          write (herr,2106) i,hnull
 2106     format ('[SETUP error 106] ideal gas heat capacity equation',
     &            ' not found for component #',i3,'.',a1)
          call ERRMSG (ierr,herr)
        endif
        endif
c  call SETPR to put constants into PR common block if PRT not in FLD file
        if (.not.lprfl) call SETPR(999,i,hcasn(i),ierr1,herr1)
        RETURN
      else
        goto 100
      end if
 199  continue
      ierr=102
      write (herr,2102) i,hnull
 2102 format ('[SETUP error 102] error in file or premature end of',
     &        ' file for component #',i3,'.',a1)
      call ERRMSG (ierr,herr)
c  rewind and close the file
      rewind (nread)
      close (unit=nread,err=998)
c     write (*,1199) hfile(i)
c1199 format (1x,'SETFLD--premature end of file: ',a80)
c  if fluid-specific 'ETA' and/or 'TCX' models have not been loaded, use
c  the 'TRN' model (e.g. the ECS model)
      if (i.ge.nrf0) then
        if (.not.leta) heta(i)=hetemp
        if (.not.ltcx) htcx(i)=httemp
      end if
      RETURN
c
 998  continue
      ierr=101
      write (herr,2101) i,hfile(i)(1:80),hnull
 2101 format ('[SETUP error 101] error in opening file for component #',
     &        i3,'; filename = (',a80,').',a1)
      call ERRMSG (ierr,herr)
      RETURN
c
 2001 format (a1)
 2003 format (a3)
 2012 format (a12)
 2013 format (a1,a3)
 2060 format (a60)
 2080 format (a255)
 2083 format (a3,a251)
 2103 format ('[SETUP warning -103] unknown model (',a3,
     &        ') encountered in file for component #',i3,'.',a1)
 2104 format ('[SETUP error 104] Error in setup of (',a3,
     &        ') model for component #',i3,':  ',a182,a1)
c
      end                                             !subroutine SETFLD
c
c ======================================================================
c
      subroutine SETMOD (ncomp,htype,hmix,hcomp,ierr,herr)
c
c  set model(s) other than the NIST-recommended ('NBS') ones
c
c  This subroutine must be called before SETUP; it need not be called
c  at all if the default (NIST-recommended) models are desired.
c
c  inputs:
c    ncomp--number of components (1 for pure fluid) [integer]
c    htype--flag indicating which models are to be set [character*3]
c           'EOS':  equation of state for thermodynamic properties
c           'ETA':  viscosity
c           'TCX':  thermal conductivity
c           'STN':  surface tension
c           'NBS':  reset all of the above model types and all
c                   subsidiary component models to 'NBS';
c                   values of hmix and hcomp are ignored
c     hmix--mixture model to use for the property specified in htype [character*3];
c           ignored if number of components = 1
c           some allowable choices for hmix:
c             'NBS':  use NIST recommendation for specified fluid/mixture
c             'HMX':  mixture Helmholtz model for thermodynamic properties
c             'ECS':  extended corresponding states for viscosity or therm. cond.
c             'STX':  surface tension mixture model
c    hcomp--component model(s) to use for property specified in htype [array (1..ncomp) of character*3]
c             'NBS':  NIST recommendation for specified fluid/mixture
c           some allowable choices for an equation of state:
c             'FEQ':  Helmholtz free energy model
c             'BWR':  pure fluid modified Benedict-Webb-Rubin (MBWR)
c             'ECS':  pure fluid thermo extended corresponding states
c           some allowable choices for viscosity:
c             'ECS':  extended corresponding states (all fluids)
c             'VS1':  the 'composite' model for R134a, R152a, NH3, etc.
c             'VS2':  Younglove-Ely model for hydrocarbons
c             'VS4':  Generalized friction theory of Quinones-Cisneros and Deiters
c             'VS5':  Chung et al. (1988) predictive model
c           some allowable choices for thermal conductivity:
c             'ECS':  extended corresponding states (all fluids)
c             'TC1':  the 'composite' model for R134a, R152a, etc.
c             'TC2':  Younglove-Ely model for hydrocarbons
c             'TC5':  Chung et al. (1988) predictive model
c           some allowable choices for surface tension:
c             'ST1':  surface tension as f(tau); tau = 1 - T/Tc
c
c  outputs:
c     ierr--error flag:  0 = successful
c                      113 = ncomp outside of bounds
c     herr--error string (character*255 variable if ierr<>0)
c     [fluid parameters, etc. returned via various common blocks]
c
c  written by M. McLinden, NIST Thermophysics Division, Boulder, Colorado
c  03-20-96  MM, original version
c  03-21-96  MM, replace /MODEL/ with /EOSMOD/, /STNMOD/
c  03-28-96  MM, add option if htype='NBS' reset all models
c  03-28-97  MM, add initialization of hnull (repeat of SETUP initialization);
c                add /RESETM/ to check for initialization of models
c  03-31-97  MM, reset all models if lreset true, even for htype<>'NBS'
c  04-10-97  MM, add and initialize /CREMOD/ (critical enhancements)
c  10-01-97  MM, add compiler switch to allow access by DLL
c  10-30-98 EWL, change heos to FEQ when called by SETMOD with FE1, etc.
c  03-11-99 EWL, reset lsatt and lsatp to .false. when called
c  01-14-00 EWL, allow use of 'VIS' as well as 'ETA'
c  07-24-06 EWL, remove excess code
c  07-24-06 EWL, only use hmix if ncomp<>1
c  12-12-07 MLH, add generalized Helmholtz model FEX of Xiang and Deiters (2007)
c  05-17-11 EWL, change nc to ncomp
c
cx DEC$ ATTRIBUTES DLLEXPORT :: SETMOD
c
      include 'commons.for'
      include 'comtrn.for'
      character*3 htype,hmix,hcomp(1:ncmax)
      character*255 herr
c
c  repeat initialization of following from SETUP in case SETMOD is called
c  before first call to SETUP
      hnull=CHAR(0)        !null character to terminate error strings
      hprsav=' '
      do i=izero0,ncomp
        ntrmUN(i)=0
        iunflg(i)=0
      enddo
      do i=n0,nx
        hmxsv(i)=' '
      enddo
      lsatt=.false.
      lsatp=.false.
      ierr=0
      herr=' '
      if (ncomp.lt.1 .or. ncomp.gt.ncmax) then
        ierr=113
        herr='[SETUP error 113] number of components out of bounds'
        call ERRMSG (ierr,herr)
        RETURN
      endif
      ncset=ncomp
c
c     write (*,1000) ncomp,htype,hmix,(hcomp(i),i=1,ncomp)
c1000 format (1x,' SETMOD--input ncomp,htype,hmix,hcomp:  ',i3,7(1x,a3))
      if (htype.eq.'NBS' .or. htype.eq.'nbs' .or. lreset) then
c  reset all models
c       write (*,*) ' SETMOD--about to reset all models to NBS'
        heos='NBS'
        hpheq='NBS'   !phase equilibria model, not currently implemented
        hetamx='NBS'
        htcxmx='NBS'
        hsten='NBS'
        hdiel='NBS'
        hmelt='NBS'
        hsubl='NBS'
        hpsa='NBS'
        hpla='NBS'
        hdla='NBS'
        hdva='NBS'
        do i=n0,ncmax
          if (i.ge.1 .and. (htype.eq.'NBS' .or. htype.eq.'nbs'))
     &        hcomp(i)='NBS'
          hmxeos(i)='NBS'
          hmodcp(i)='NBS'
          hstenk(i)='NBS'
          hdielk(i)='NBS'
          hmeltk(i)='NBS'
          hsublk(i)='NBS'
          hpsk(i)='NBS'
          hplk(i)='NBS'
          hdlk(i)='NBS'
          hdvk(i)='NBS'
        enddo
        do i=nrf0,ncmax
          heta(i)='NBS'
          hetacr(i)='NUL'
          htcx(i)='NBS'
          htcxcr(i)='NUL'
          hmdeta(i)='NUL'
          hmdtcx(i)='NUL'
        enddo
        lreset=.false.
      end if
      if (htype.eq.'EOS' .or. htype.eq.'eos') then
c  equation of state specification
        heos=hmix
c       if (heos(1:3).eq.'FEX') igenfl(i)=1
        if (ncomp.eq.1) heos=hcomp(1)
        if (heos(1:2).eq.'FE') heos='FEQ'
        if (heos(1:2).eq.'QU') heos='QUI'
        if (heos(1:2).eq.'BW') heos='BWR'
        if (heos(1:2).eq.'EC') heos='ECS'
        do i=1,ncomp
          hmxeos(i)=hcomp(i)
        enddo
      else if (htype.eq.'ETA' .or. htype.eq.'eta' .or.
     &         htype.eq.'VIS' .or. htype.eq.'vis') then
c  viscosity specification
        hetamx=hmix
        if (ncomp.eq.1) hetamx=hcomp(1)
        do i=1,ncomp
          heta(i)=hcomp(i)
        enddo
      else if (htype.eq.'TCX' .or. htype.eq.'tcx') then
c  viscosity specification
        htcxmx=hmix
        if (ncomp.eq.1) htcxmx=hcomp(1)
        do i=1,ncomp
          htcx(i)=hcomp(i)
        enddo
      else if (htype.eq.'STN' .or. htype.eq.'stn') then
c  surface tension specification
        hsten=hmix
        if (ncomp.eq.1) hsten=hcomp(1)
        do i=1,ncomp
          hstenk(i)=hcomp(i)
        enddo
      end if
c     write (*,1003) heos,(hmxeos(j),j=n0,ncmax),
c    &               hetamx,(heta(j),j=nrf0,nx),
c    &               htcxmx,(htcx(j),j=nrf0,nx),
c    &               hsten,(hstenk(j),j=n0,ncmax)
c1003 format ('  SETMOD--heos, hmxeos: ',a3,3x,5(a3,1x),a5,3x,5(a3,1x)/
c    &        '  (exit)   visc models: ',a3,25x,a3,3x,5(a3,1x)/
c    &        '           t.c. models: ',a3,25x,a3,3x,5(a3,1x)/
c    &        '       surf ten models: ',a3,3x,5(a3,1x),a5,3x,5(a3,1x))
c
      RETURN
c
      end                                             !subroutine SETMOD
c
c ======================================================================
c
      subroutine GERG04 (ncomp,iflag,ierr,herr)
c
c  set the pure model(s) to those used by the GERG 2004 formulation.
c
c  This subroutine must be called before SETUP; it need not be called
c  at all if the default (NIST-recommended) models are desired.
c  To turn off the GERG settings, call this routine again with iflag=0,
c  and then call the SETUP routine to reset the parameters of the equations
c  of state.
c
c  inputs:
c    ncomp--number of components (1 for pure fluid)
c    iflag--set to 1 to load the GERG 2004 equations, set to 0 for defaults
c  outputs:
c     ierr--error flag:  0 = successful
c     herr--error string returned from SETMOD
c
c  written by E.W. Lemmon, NIST Thermophysics Division, Boulder, Colorado
c  01-24-07 EWL, original version
c
cx DEC$ ATTRIBUTES DLLEXPORT :: GERG04
c
      include 'commons.for'
      character*255 herr
      character*3 htype,hmix,hcomp(1:ncmax)
c
      htype='EOS'
      hmix='HMX'
      do i=1,ncomp
        hcomp(i)='DEF'
        if (iflag.eq.1) hcomp(i)='FEK'
      enddo
      call SETMOD (ncomp,htype,hmix,hcomp,ierr,herr)
      iGERG04=iflag
      RETURN
      end                                             !subroutine GERG04
c
c ======================================================================
c
      subroutine SETREF (hrf,ixflag,x0,h0,s0,t0,p0,ierr,herr)
c
c  set reference state enthalpy and entropy
c
c  This subroutine must be called after SETUP; it need not be called at
c  all if the reference state specified in the call to SETUP is to be
c  used.
c
c  inputs:
c      hrf--reference state for thermodynamic calculations [character*3]
c           'NBP':  h,s = 0 at normal boiling point(s)
c           'ASH':  h,s = 0 for sat liquid at -40 C (ASHRAE convention)
c           'IIR':  h = 200, s = 1.0 for sat liq at 0 C (IIR convention)
c           'DEF':  default reference state as specified in fluid file
c                   is applied to each component (ixflag = 1 is used)
c           'OTH':  other, as specified by h0, s0, t0, p0 (real gas state)
c           'OT0':  other, as specified by h0, s0, t0, p0 (ideal gas state)
c           'NA' :  not applicable, do not set up reference state (for use in debugging or fitting)
c           '???':  change hrf to the current reference state and exit.
c   ixflag--composition flag:  1 = ref state applied to pure components
c                              2 = ref state applied to mixture x0
c  following input has meaning only if ixflag = 2
c       x0--composition for which h0, s0 apply; array(1:nc) [mol frac]
c           this is useful for mixtures of a predefined composition,
c           e.g. refrigerant blends such as R410A
c  following inputs have meaning only if hrf = 'OTH'
c       h0--reference state enthalpy at t0,p0 {x0} [J/mol]
c       s0--reference state entropy at t0,p0 {x0} [J/mol-K]
c       t0--reference state temperature [K]
c           t0 = -1 indicates saturated liquid at normal boiling point
c                   (bubble point for a mixture)
c       p0--reference state pressure [kPa]
c           p0 = -1 indicates saturated liquid at t0 {and x0}
c           p0 = -2 indicates saturated vapor at t0 {and x0}
c  outputs:
c     ierr--error flag:  0 = successful
c                       22 = Tmin > Tref for IIR reference state
c                       23 = Tcrit < Tref for IIR reference state
c                       24 = Tmin > Tref for ASHRAE reference state
c                       25 = Tcrit < Tref for ASHRAE reference state
c                       26 = Tmin > Tnbp for NBP reference state
c                       27 = Tref, Pref for OTH ref state outside limits
c                      -28 = can't apply 'DEF' to mixture;
c                            will apply to pure components
c                      -29 = unknown reference state specified;
c                            will use 'DEF'
c                      119 = convergence failure in calculating reference state
c     herr--error string (character*255 variable if ierr<>0)
c     [fluid parameters, etc. returned via various common blocks]
c
c  written by M. McLinden, NIST Thermophysics Division, Boulder, Colorado
c  01-11-96  MM, original version--extracted from old subroutine SETUP
c  01-16-96  MM, add check for inputs same as previous call
c  01-19-96  MM, bug fixes and set flag ksetrf to 1 when SETREF called
c  02-27-96  MM, parameter n0=-ncmax to accommodate ECS-thermo model
c                add Zcrit to common /CCON/
c  03-19-96  MM, add dipole moment to /CCON/
c  03-21-96  MM, replace /MODEL/ with /REFST/
c  06-18-96  MM, check ref state temperature against LIMITX
c  01-07-97  MM, check limits for case of NBP ref state (re: CO2 bug)
c  01-10-97  MM, pass error flag from limits errors to calling routine
c  02-20-97  MM, add 'DEF' option (default ref state read from fld file)
c                add hsvrfd to /REFST/, new common /CREFDF/
c  03-25-97  MM, xliq,xvap used but not dimensioned; change to xl,xv
c  03-26-97 EWL, changes for Fortran 90 compatibility
c  05-14-97  MM, fix bug in checking for inputs same as last call
c  10-01-97  MM, add compiler switch to allow access by DLL
c  10-16-97  MM, allow ixflag = 2 for 'DEF' when all fluids are same
c  11-24-97  MM, check for errors on calls to SATT, SATP, TPFLSH
c  04-24-98  MM, move check for hrf='DEF' with ixflag=2;
c                add check for 'DEF' within mixture-adjust calc
c  08-13-98  MM, initialize "negative" components only for ECS model
c                (do 200 loop); add common /EOSMOD/
c  08-14-98  MM, pass tref to LIMITX (avoid undefined variable error)
c  08-17-98  MM, initialize Dx,px for ixflag=2 case
c  08-21-98  MM, initialize ierrsv,herrsv
c  12-01-98 EWL, add Reos and triple point pressure and density to /CCON/
c  11-25-02 EWL, reset tsvcp0 so that cp0 is recalculated (because Tref changed)
c  11-26-02 EWL, add OTO input when h0 and s0 are given for the ideal gas
c  08-31-04 EWL, only do ixflg=2 option if nc.gt.1
c  08-30-05 EWL, add check for OTH when storing reference entropy and enthalpy in common
c  05-31-06 EWL, add ability to find out what the reference state is when hrf='???'
c  09-06-06 EWL, update logic and fix several small bugs
c  12-06-12 EWL, remove calls to PUREFLD
c
cx DEC$ ATTRIBUTES DLLEXPORT :: SETREF
c
      include 'commons.for'
      character*3 hrf
      character*3 hrefi(n0:nx),hrdef
      character*255 herr,herr2,herrsv
      dimension x(ncmax),x0(ncmax),xl(ncmax),xv(ncmax),prefi(n0:nx)
c
c  initialize error codes and strings
      ierr=0
      ierrsv=0
      herr=' '
      herrsv=hnull
c     write (*,1000) hrf,ixflag,nc
c1000 format (/1x,' SETREF--entering reference state = ',a3,
c    &           '; with ixflag, nc =',2i4)
c     write (*,1001) 'input',hrf,ixflag,h0,s0,t0,p0,(x0(i),i=1,nc)
c     write (*,1001) 'saved',hsvrfs,ixfsav,h0sav,s0sav,t0sav,p0sav,
c    &                (x0sav(i),i=1,nc)
c1001 format ('  SETREF--',a5,' href,xflag,h0,s0,t0,p0: ',a3,i3,4f10.4/
c    &        '          ',5x,'                     x0: ',6x,5f10.4)
c
c  compare inputs to previous values (stored in /REFST/ and /REFSAV/)
c  if nothing has changed SETREF can be bypassed
c
      l1same=.false.    !flag for initialization of pure components
      l2same=.false.    !flag for application of ref state to mixture
      ixflg=ixflag      !input value changed if input href not valid
      if (hrf.eq.'???') then
        hrf=hrefdf(1)      !Return the default reference state for a pure fluid
        RETURN
      endif
      if (hrf.eq.hsvrfs) then
        l1same=.true.
        if (hrf(1:2).eq.'OT') then
c  check h0, s0, t0, p0 only if 'OTHer' reference state is used
          if (abs(s0-s0sav).gt.1.0d-10 .or.
     &        abs(h0-h0sav).gt.1.0d-10 .or.
     &        abs(t0-t0sav).gt.1.0d-10 .or.
     &        abs(p0-p0sav).gt.1.0d-10) then
            l1same=.false.
          end if
        end if
        if (ixflag.eq.ixfsav) then
          l2same=.true.
          if (ixflag.eq.2) then
c  check x0 only if ixflag = 2
            do i=1,nc
              if (abs(x0(i)-x0sav(i)).gt.1.0d-10) then
                l2same=.false.
              end if
            enddo
          end if
        end if
        if (l1same .and. l2same .and. ksetrf.eq.1) then
c  return if all inputs are same and also SETUP has not been executed
c  since last call to SETREF (as indicated by ksetrf)
c         write (*,*)
c         write (*,*) ' SETREF--inputs are identical, return'
          RETURN
        end if
      end if
c
      if ((hrf.eq.'DEF' .or. hrf.eq.'def') .and. ixflag.eq.2 .and.
     &    nc.gt.1) then
c  check if all fluids have same reference state
        ldef=.true.
c       write (*,2001) (hsvrfd(i),i=1,nc)
c2001   format (1x,' SETREF--default ref states:  ',5(a3,1x))
        do i=1,nc
          if (hrefdf(1).ne.hrefdf(i) .or. hrefdf(i)(1:2).eq.'OT') then
            ldef=.false.
          end if
        enddo
        if (.not.ldef) then
          ierrsv=-28
          herrsv='[SETREF warning -28] cannot apply reference '
     &         //'state (DEF) at a specified mixture composition '
     &         //'when components have different default reference '
     &         //'states; will apply defaults to each pure component'
     &         //hnull
          call ERRMSG (ierrsv,herrsv)
          ixflg=1
        end if
      end if
c
c     write (*,*)
      if (l1same .and. ksetrf.eq.1 .and. ixflg.ge.ixfsav) then
c  can skip initialization of pure components if:
c  --reference state is the same (as indicated by l1same)
c  --SETUP has not been called since last call to SETREF (indicated by ksetrf)
c  --value of ixflag is >= ixfsav, i.e. this call applies ref state to mixture
c    while last call applied to the pures, or if both applied to pures,
c    but not if last call was applied to mix, this call to pures
c       write (*,*) ' SETREF--skip initialization of pure components'
      else
c  must initialize pure component reference states
        do i=n0,nc
c  following is temporary assignment, needed for SATP and/or THERM
c  (SATP calls ENTRO, and ENTRO needs rhoref, but SATP is used to
c  calculate rhoref; thus need to put in temporary value here)
          rhoref(i)=1.0d0
        enddo
c
c  initialize reference temperature, entropy, and enthalpy
c
c       write (*,*) ' SETREF--240 loop from/to: ',-nc,nc
        do i=-nc,nc
c  "negative" components refer to ECS reference fluids, for other models
c  the "negative" components are not defined
c       write (*,*) 'SETREF--start init for i,model: ',i,hmxeos(i)
          lcheck=.false.
          if (i.ge.n0) then
            if (hmxeos(i).ne.'NUL') lcheck=.true.  !Do this inside an if statement in case i=-1 but n0=1
          endif
          if (i.ge.1) lcheck=.true.
          if (lcheck) then
c         write (*,*) 'SETREF--start init for i,model: ',i,hmxeos(i)
            if (hrf.eq.'IIR' .or. hrf.eq.'ASH' .or. hrf.eq.'NBP' .or.
     &          hrf(1:2).eq.'OT' .or. hrf.eq.'NA') then
              hrefi(i)=hrf
            else         !DEFault or unknown reference state
              hrefi(i)=hrefdf(i)
              ixflg=1    !must apply ref state to pures only
              if (hrf.ne.'DEF' .and. hrf.ne.'def') then
                ierr=-29
                herr='[SETREF warning -29] reference state not found, '
     &             //'using default reference state'//hnull
                call ERRMSG (ierr,herr)
              end if
            end if
c
c         write (*,*) ' SETREF--i,hrefi:  ',i,' ',hrefi(i)
            href(i)=0.0d0
            sref(i)=0.0d0
            if (hrefi(i).eq.'IIR') then
c  IIR reference state
c           write (*,*) ' SETREF--IIR ref state with ixflag =',ixflg
              tref(i)=273.15d0
              prefi(i)=-1.0d0   !code for reference state of sat liquid
              href(i)=200.0d0*wmas(i) !reference enthalpy is 200.0 kJ/kg
              sref(i)=wmas(i)         !reference entropy is 1.0 kJ/(kg.K)
            else if (hrefi(i).eq.'ASH') then
c  ASHRAE reference state
c           write (*,*) ' SETREF--ASH ref state with ixflag =',ixflg
              tref(i)=233.15d0
              prefi(i)=-1.0d0   !code for reference state of sat liquid
            else if (hrefi(i).eq.'NBP') then
c  normal boiling point reference state
c           write (*,*) ' SETREF--NBP ref state with ixflag =',ixflg
              tref(i)=tnbp(i)
              prefi(i)=-1.0d0   !code for ref state of saturated liquid
            else if (hrefi(i)(1:2).eq.'OT') then
c  'other' reference state--use input values of h0, s0, t0, p0
c           write (*,*) ' SETREF--OTHer ref state with ixflag =',ixflg
              if (hrf.eq.'DEF' .or. hrf.eq.'def') then
c  if input to SETREF is 'DEF' reference t,p,h,s come from fluid file
                tref(i)=tdef(i)
                prefi(i)=pdef(i)
                href(i)=hdef(i)
                sref(i)=sdef(i)
              else
c  otherwise, reference t,p,h,s are inputs to SETREF
                tref(i)=t0
                prefi(i)=p0
                href(i)=h0
                sref(i)=s0
              end if
            else if (hrefi(i).eq.'NUL') then
c  this case should be encountered only for i<0 when any model other
c  than the ECS model is specified; fill arrays with dummy values
              tref(i)=300.0
              prefi(i)=1.0d-6
            else if (hrefi(i).eq.'NA') then
c  this case is for bypassing the reference state in equation development
              tref(i)=300.0
              prefi(i)=1.0d-6
            else
c  unknown reference state (use normal boiling point)
              ierr=-29
              write (herr,1238) hrefi(i),i,hnull
 1238         format ('[SETREF warning -29] reference state (',a3,') ',
     &           'for component ',i3,' not found; will use ',
     &           'NBP reference state. ',a1)
              call ERRMSG (ierr,herr)
              tref(i)=tnbp(i)
              prefi(i)=-1.0d0   !code for ref state of saturated liquid
            end if
          end if
        enddo
c
c  check limits of equation of state against reference state temperature
c
        do 400 i=1,nc
        Dx=0.0d0
        px=0.0d0
        t=tref(i)
        call LIMITK ('EOS',i,t,Dx,px,tmin,tmax,Dmax,pmax,ierr2,herr2)
c
        if (hrefi(i).eq.'IIR') then
c  IIR reference state
          if (tmin.gt.273.15d0) then
c  minimum temperature of EOS is above IIR reference state temperature
c  issue error message
            ierr=22
            write (herr,1022) i,tmin,hrefdf(i),hnull
 1022       format ('[SETUP warning 22] ',
     &        'minimum temperature for component ',i3,' is greater ',
     &        'than IIR reference temperature; Tmin =',g12.5,
     &        ' K, Tref = 273.15 K.; will use default (',a3,'). ',a1)
          else
            if (Tcrit(i).lt.274.15d0) then
c  critical temperature is too low to use IIR reference state
c  issue error message
              ierr=23
              write (herr,1023) i,Tcrit(i),hrefdf(i),hnull
 1023         format ('[SETUP warning 23] ',
     &        'critical temperature for component ',i3,' is less ',
     &        'than IIR reference temperature; Tcrit =',g12.5,
     &        ' K, Tref = 273.15 K; will use default (',a3,'). ',a1)
            end if
          end if
c
        else if (hrefi(i).eq.'ASH') then
c  ASHRAE reference state
          if (tmin.gt.233.15d0) then
c  minimum temperature of EOS is above reference state temperature
            ierr=24
            write (herr,1024) i,tmin,hrefdf(i),hnull
 1024       format ('[SETUP warning 24] ',
     &        'minimum temperature for component ',i3,' is greater ',
     &        'than ASHRAE reference temperature; Tmin =',g12.5,
     &        ' K, Tref = 233.15 K; will use default (',a3,'). ',a1)
          else
            if (Tcrit(i).lt.234.15d0) then
c  critical temperature is too low to use IIR reference state
              ierr=25
              write (herr,1025) i,Tcrit(i),hrefdf(i),hnull
 1025         format ('[SETUP warning 25] ',
     &        'critical temperature for component ',i3,' is less ',
     &        'than ASHRAE reference temperature; Tcrit =',g12.5,
     &        ' K, Tref = 233.15 K; will use default (',a3,'). ',a1)
            end if
          end if
        else if (hrefi(i).eq.'NBP') then
c  Normal Boiling Point reference state
          if (tmin.gt.tnbp(i)) then
c  minimum temperature of EOS is above boiling point temperature
c  issue error message (this is a problem with CO2)
            ierr=26
            write (herr,1026) i,tmin,tnbp(i),hrefdf(i),hnull
 1026       format ('[SETUP warning 26] ',
     &        'minimum temperature for component ',i3,' is greater ',
     &        'than boiling point temperature; Tmin =',g12.5,
     &        ' K, Tnbp =',g12.5,' K; will use default (',a3,'). ',a1)
          end if
        end if
c
        if (ABS(ierr).ge.22) then
c  if specified reference state is outside limits for component i,
c  use default state (read in from fluid file); this code assumes
c  that the specification in the fluid file is valid
          call ERRMSG (ierr,herr)
          href(i)=0.0d0
          sref(i)=0.0d0
          if (hrefdf(i).eq.'IIR') then
c           write (*,1282) i,hrefi(i),hsvrfd(i)
c1282       format (2x,'SETREF--specified reference state for component'
c    &                ,i4,' (',a3,'), is not valid; will apply default '
c    &                ,'reference state (',a3,') to pures. ')
            tref(i)=273.15d0
            prefi(i)=-1.0d0
            href(i)=200.0d0*wmas(i) !reference enthalpy is 200.0 kJ/kg
            sref(i)=wmas(i)         !reference entropy is 1.0 kJ/(kg.K)
          else if (hrefdf(i).eq.'ASH') then
c           write (*,1282) i,hrefi(i),hsvrfd(i)
            tref(i)=233.15d0
            prefi(i)=-1.0d0
          else if (hrefdf(i).eq.'NBP') then
c           write (*,1282) i,hrefi(i),hsvrfd(i)
            tref(i)=tnbp(i)
            prefi(i)=-1.0d0
          else if (hrefdf(i)(1:2).eq.'OT') then
c           write (*,1282) i,hrefi(i),hsvrfd(i)
            tref(i)=tdef(i)
            prefi(i)=pdef(i)
            href(i)=hdef(i)
            sref(i)=sdef(i)
          else     !unknown reference state; set to reasonable values
c           write (*,*) ' SETREF--default reference state is unknown'
            tref(i)=0.8d0*Tcrit(i)
            prefi(i)=-1.0d0
          end if
          hrefi(i)=hrefdf(i)
          ixflg=1                 !must apply ref state to pures only
        end if
c  save any error flags/messages to pass up the chain; then reset
        if (ierr.ne.0) then
          ierrsv=ierr
          herrsv=herr
        endif
        ierr=0
        herr=' '
 400    continue
c
c  apply reference enthalpy and entropy to each component; this for
c  case of ixflag =1; also used as initialization for ixflag = 2
c
        do 600 i=1,nc
c       write (*,1002) i,tref(i),href(i),sref(i)
c1002   format (1x,' SETREF--i,tref,href,sref: ',i3,f7.2,f10.1,f10.3)
c       x(1:nc)=0.d0
        x=0.d0
        x(i)=1.d0
        if (hrefi(i).eq.'NBP') then
c  find bubble point at one atmosphere for each pure component
          pnbp=101.325d0
          call SATP (pnbp,x,1,tbub,rhol,rhov,xl,xv,ierr,herr)
          if (rhol.gt.0.d0) rhoref(i)=rhol
          tref(i)=tbub
        elseif (hrefi(i).eq.'NA') then
c  Don't do anything if deactivated
        else if (prefi(i).lt.0.0d0) then
c  find saturated liquid or vapor density (includes ASH and IIR states)
          if (prefi(i).lt.-1.99d0) then
            call SATT (tref(i),x,2,p,rhol,rhov,xl,xv,ierr,herr)
            rhoref(i)=rhov
          else
            call SATT (tref(i),x,1,p,rhol,rhov,xl,xv,ierr,herr)
            rhoref(i)=rhol
          end if
        else if (hrefi(i).eq.'OTH') then
c  find density at specified t,p (either input to SETREF or default value)
          t=tref(i)
          p=prefi(i)
          call TPFLSH (t,p,x,D,Dl,Dv,xl,xv,q,e,h,s,cv,cp,w,ierr,herr)
          rhoref(i)=D
        else if (hrefi(i).eq.'OT0') then
c  find density at specified t,p (either input to SETREF or default value)
          t=tref(i)
          p=prefi(i)
          call RMIX(x0)
          rhoref(i)=p/R/T
        end if
        if (ierr.ge.1) then
c  error encountered in calculating reference state--set reference
c  density to critical density?
          rhoref(i)=Dcrit(i)
          ierr=119
          herr2=herr
          write (herr,1119) i,herr2(1:162),hnull
          call ERRMSG (ierr,herr)
 1119     format ('[SETREF error 119] convergence failure in ',
     &            'calculating reference state for component #',i3,
     &            ':  ',a162,a1)
        end if
        if (hrefi(i).ne.'NA') then
          tsvcp0(i)=0.d0  !reset tsvcp0 to force recalculation of cp0
          if (hrefi(i).eq.'OT0') then
            call THERM0(tref(i),rhoref(i),x,ptherm,e,h,s,cv,cp,w,a,g)
          else
            call THERM (tref(i),rhoref(i),x,ptherm,e,h,s,cv,cp,w,hjt)
          endif
          if (ixflg.ne.2 .or. nc.eq.1 .or. hrefi(i)(1:2).ne.'OT') then
            sref(i)=s              !store reference entropy in common
            href(i)=h              !ditto for enthalpy
          endif
          tsvcp0(i)=0.d0
        endif
c       write (*,1004) i,tref(i),href(i),sref(i),rhoref(i)
c1004   format (1x,' SETREF--after SATT, etc.: ',i3,f7.2,f10.1,2f10.3)
 600    continue
      end if     !end of initialization for pure components
c
      if (ixflg.eq.2 .and. nc.gt.1) then
c
c  reference state applied to mixture of specified composition
c  this option is not available if the 'DEFault' state is chosen
c
c       write (*,1005) hrf,(x0(i),i=1,nc)
c1005   format (1x,' SETREF--about to apply ref state "',a3,
c    &             '" to mixture w/ x = ',5f10.5)
        if (hrf(1:2).eq.'OT') then
          tmix=t0
          pref=p0
          smix=s0
          hmix=h0
        else
          hrdef='NUL'   !initialize pointer to default ref state
          if (hrf.eq.'DEF' .or. hrf.eq.'def') then
c  DEFault reference state--should get here only if all components have the
c  same default ref state stored in their respective fluid files
            hrdef=hrefdf(1)
          end if
          hmix=0.0d0
          smix=0.0d0
          if (hrf.eq.'IIR' .or.hrdef.eq.'IIR') then
c  IIR reference state
            tmix=273.15d0
            pref=-1.0d0       !code for ref state of saturated liquid
            smix=1.0d0        !reference entropy is 1.0 kJ/(kg.K)
            hmix=200.0d0      !reference enthalpy is 200. kJ/kg
          else if (hrf.eq.'ASH' .or.hrdef.eq.'ASH') then
c  ASHRAE reference state
            tmix=233.15d0
            pref=-1.0d0       !code for reference state of sat liquid
          else
c  boiling point or unknown ref state
c  find bubble point of specified mixture
            pnbp=101.325d0
            call SATP (pnbp,x0,1,tbub,Dmix,rhov,xl,xv,ierr,herr)
            tmix=tbub
            pref=-1.0d0       !code for reference state of sat liquid
          end if
c  check mix reference temperature against limits, if outside limits
c  take average of component Tref's (would be different only if one or
c  more components were outside limits)
          Dx=0.0d0     !initialize (check only temperature)
          px=0.0d0
          call LIMITX ('EOS',tmix,Dx,px,x0,tmin,tmax,Dmx,pmx,ie2,herr2)
          if (tmix.lt.tmin .or. tmix.gt.tmax) then
            tmix=0.0d0
            do i=1,nc
              tmix=tmix+x0(i)*tref(i)
            enddo
          end if
c  predefined reference states are on mass basis
          wmm=WMOL(x0)
          smix=smix*wmm
          hmix=hmix*wmm
        end if
c
        if (pref.lt.0.0d0) then
c  find liquid or vapor density (includes IIR and ASHrae states)
          if (pref.lt.-1.99d0) then
            call SATT (tmix,x0,2,p,rhol,Dmix,xl,xv,ierr,herr)
          else
            call SATT (tmix,x0,1,p,Dmix,rhov,xl,xv,ierr,herr)
          end if
        else
c  find density at specified t0, p0
          call LIMITX ('EOS',t0,Dx,p0,x0,tmin,tmax,Dmx,pmx,ierr,herr2)
          if (ierr.ge.1) then
            ierr=27
            herr='[SETREF error 27] specified reference state for '//
     &           'mixture is outside equation limits: '//herr2(1:170)//
     &           hnull
            call ERRMSG (ierr,herr)
            RETURN
          end if
          call TPFLSH (t0,p0,x0,D,Dl,Dv,xl,xv,q,e,h,s,cv,cp,w,ierr,herr)
          tmix=t0
          Dmix=D
        end if
c
        call THERM (tmix,Dmix,x0,ptherm,e,h,s,cv,cp,w,hjt)
        do i=1,nc
c  modify sref, href by amount needed for specified mixture
c  to agree with s0, h0
c         write (*,1006) s,smix,h,hmix
c1006     format (1x,' SETREF  s,smix,h,hmix:  ',2f10.4,2f10.1)
          sref(i)=sref(i)+s-smix
          href(i)=href(i)+h-hmix
c         write (*,1008) i,tref(i),href(i),sref(i),rhoref(i)
c1008 format (1x,' SETREF--after mix adjust: ',i3,f7.2,f10.1,2f10.3)
        enddo
      end if
c
c  variable ksetrf is flag to indicate that SETREF has been called
c  it is reset to 0 each time SETUP is called (indicating that SETREF
c  must be recalled)
      ksetrf=1
c
c  copy inputs to common block
c
      hsvrfs=hrf
      ixfsav=ixflg
      if (hrf(1:2).eq.'OT') then
c  save h0, s0, t0, p0 only if 'OTHer' reference state is used
        h0sav=h0
        s0sav=s0
        t0sav=t0
        p0sav=p0
      end if
      if (ixflg.eq.2) then
c  save x0 only if ixflg = 2
        do i=1,nc
          x0sav(i)=x0(i)
        enddo
      end if
c
c  reset error flag/message (the more significant errors are those which
c  arise from out-of-bounds conditions, not any potential errors in calls
c  to SATT, etc.)
      if (ierr.eq.0 .and. ierrsv.ne.0) then
        ierr=ierrsv
        herr=herrsv
      end if
c
      RETURN
c
      end                                             !subroutine SETREF
c
c ======================================================================
c
      subroutine SETMIX (hmxnme,hfmix,hrf,ncc,hfiles,x,ierr,herr)
c
c  open a mixture file (e.g., R410A.mix) and read constituents and
c  mole fractions
c
c  inputs:
c    hmxnme--mixture file name to be read in [character*255]
c    hfmix--mixture coefficients [character*255]
c           file name containing coefficients for mixture model
c    hrf--reference state for thermodynamic calculations [character*3]
c         (see info in subroutine setup for specifics)
c  outputs:
c     ncc--number of fluids in mixture
c     hfiles--array of file names specifying mixture components
c             that were used to call setup. [character*255 variable]
c     x--array of mole fractions for the specified mixture
c     ierr--error flag:  0 = successful
c                      101 = error in opening file
c                     -102 = mixture file contains mixing parameters
c                     -103 = composition not equal to one
c     herr--error string (character*255 variable if ierr<>0)
c
c  written by E.W. Lemmon, NIST Thermophysics Division, Boulder, Colorado
c  03-27-06 EWL, original version
c
cx DEC$ ATTRIBUTES DLLEXPORT :: SETMIX
c
      include 'commons.for'
      character*3 hrf
      character*255 hmxnme,hfmix,hfiles(ncmax),herr,herr2,MixName
      dimension x(ncmax)
c
      ierr2=0
      nread=12             !logical unit for file reads
      call OPENFL (nread,hmxnme,2,ierr,herr)
      if (ierr.ne.0) goto 998
      read (nread,2000,err=998,end=998) MixName
      read (nread,*,err=998,end=998) xMixMolarMass,xMixTc,xMixPc,xMixDc
      read (nread,*,err=998,end=998) ncc
      do i=1,ncc
        read (nread,2000,err=998,end=998) hfiles(i)
        call RFFILE(hfmix,hfiles(i))
      enddo
      sum=0
      do i=1,ncc
        read (nread,*,err=998,end=998) x(i)
        sum=sum+x(i)
      enddo
      if (ABS(sum-1.d0).gt.0.0000001.and.sum.gt.0.d0.and.ncc.gt.1) then
        ierr2=-103
        herr2='[SETMIX error -103] '//
     &       'The composition of the mixture does not sum '//
     &       'to one. The compositions have been normalized.'
        call ERRMSG (ierr2,herr2)
        do i=1,ncc
          x(i)=x(i)/sum
        enddo
      endif
      read (nread,*,err=998,end=998) i
      if (i.ne.0) then
        ierr2=-102
        herr2='[SETMIX error -102] '//
     &       'The mixture file contains updated binary interaction '//
     &       'parameters which have been ignored.'
        call ERRMSG (ierr2,herr2)
      endif
      close (nread)
      call SETUP (ncc,hfiles,hfmix,hrf,ierr,herr)
      if (ierr.eq.0 .and. ierr2.ne.0) then
        ierr=ierr2
        herr=herr2
      endif
      RETURN
 998  continue
      ierr=101
      herr='[SETMIX error 101] error in opening mixture file:  '//hmxnme
      call ERRMSG (ierr,herr)
      RETURN
c
 2000 format (a255)
      end                                             !subroutine SETMIX
c
c ======================================================================
c
      subroutine RFFILE (hfilei,hflref)
c
c  provide a full path specification for the '.fld' file for the ECS
c  reference fluid given a specification for a component '.fld' file
c  e.g. 'c:\REFPROP\fluids\r123.fld' and the reference fluid pointer
c  which is stored in that file, e.g. 'r134a.fld'
c
c  N.B.  This routine assumes that the reference fluid '.fld' file
c        is in the same directory as the component file(s)
c
c  inputs:
c   hfilei--file name specifying mixture component (character*255)
c   hflref--file name specifying reference fluid (character*255)
c  output:
c   hflref--file name specifying reference fluid (character*255)
c           the output value of hflref consists of the directory
c           information gleaned from hfilei concatenated with the
c           input value of hflref
c
c  written by M. McLinden, NIST Thermophysics Division, Boulder, Colorado
c  12-14-95  MM, original version
c  12-18-95  MM, use htemp to concatenate character strings (cannot
c                concatenate string with itself on some compilers)
c  02-22-07 EWL, check for null character in input string
c
      include 'commons.for'
      character*255 hfilei,hflref,htemp
c
      if (hfilei(1:5).eq.'BDATA' .or. hfilei(1:5).eq.'bdata') then
c  special case if component data is read from block data;
c  assume that reference fluid is in same directory as main program
c  i.e., hflref is simply fluid name + '.fld', e.g. 'r134a.fld'
c  --or--
c  the pointer to the reference fluid in block data is also to
c  block data, e.g. 'BDATA:811-97-2' for R134a
      else
c  usual case of fluid read from '.fld' file
        ncfile=index(hfilei,char(0))
        if (ncfile.eq.0) ncfile=LEN(hfilei)
        jpoint=0
        do i=1,ncfile
          j=1+ncfile-i
c  search for directory delimiters
c  (\,:,/  for DOS, Macintosh, and Unix, respectively)
          jchar=ICHAR(hfilei(j:j))
          if (jchar.eq.92 .or. jchar.eq.58 .or. jchar .eq.47) then
            jpoint=j
            goto 100
          end if
        enddo
 100    continue             !file delimiter character has been found
c       write (*,1004) ncfile,jpoint
c1004   format (1x,' RFFILE--ncfile, jpoint: ',2i4)
        if (jpoint.le.0) then
c  no path name provided in specification of component .fld file
c  assume that reference fluid is in same directory as main program
c  i.e., hflref is simply fluid name + '.fld', e.g. r134a.fld
        else
          htemp=hfilei(1:jpoint)//hflref
          hflref=htemp
        end if
      end if
c     write (*,1005) hflref
c1005 format (1x,' RFFILE--full path for reference fld file: ',a255)
c
      RETURN
      end                                             !subroutine RFFILE
c
c ======================================================================
c
      subroutine OPENFL (nread,hfl,idir,ierr,herr)
c
c  open a file for input
c
c  inputs:
c    nread--unit number
c      hfl--file name [character*255 variable]
c  outputs:
c     ierr--error flag:  0 = successful
c                      101 = error in opening file
c     herr--error string (character*255 variable if ierr<>0)
c
c  written by E.W. Lemmon, NIST Thermophysics Division, Boulder, Colorado
c  08-10-06 EWL, original version (with code taken from old SETFLD)
c  11-10-06 EWL, add additional checks on the input file name
c  01-04-07 EWL, add even more checks
c
      include 'commons.for'
      character*26 lower,upper
      character*255 herr,hfl,hfilei,hfilej
      character*1 bs
      logical lread
c
      lower = 'abcdefghijklmnopqrstuvwxyz'
      upper = 'ABCDEFGHIJKLMNOPQRSTUVWXYZ'
!$OMP CRITICAL(REFPROP_OPEN_FILE)
      ierr=0
      herr=' '
c
c  check for ^M in filename caused by binary download to UNIX machines
      j=INDEX(hfl,CHAR(13))
      if (j.ne.0) hfl=hfl(1:j-1)//hfl(j+1:255)
c
 10   continue
      INQUIRE(unit=nread,opened=lread)  !Check that unit #nread is not
      if (lread) then                   !already being used.
        nread=nread+1
        goto 10
      endif
c
c  find last occurrence of a character other than a space
      kp=0
      if (hpath.ne.' ') then
        do j=1,255
          if (hpath(j:j).ne.' ') kp=j
        enddo
      endif
c
      do m=1,2
        bs=char(92)
        if (m.eq.2) bs='/'      !Try same options for a Unix system
c  add the file path if SETPATH called
        hfilei=hfl
        if (kp.ne.0) then
          if (hpath(kp:kp).ne.'/' .and. hpath(kp:kp).ne.char(92)) then
            hfilei=hpath(1:kp)//bs//hfl
          else
            hfilei=hpath(1:kp)//hfl
          endif
        endif
c  if your compiler reports an error message on the following line,
c  remove the action='READ' piece and try it again.
c  There are two more similar occurrences below.
        open (unit=nread,file=hfilei,status='old',iostat=ioerr,
     &        action='READ')
        if (ioerr.eq.0) goto 11
c
c  try the file path with 'fluids\' added to it if SETPATH called
        if (kp.ne.0) then
          if (idir.ne.2) then
            hfilei=hpath(1:kp)//'fluids'//bs//hfl  !Look in hpath\fluids directory
            if (hpath(kp:kp).ne.'/' .and. hpath(kp:kp).ne.char(92))
     &          hfilei=hpath(1:kp)//bs//'fluids'//bs//hfl
          else
            hfilei=hpath(1:kp)//'mixtures'//bs//hfl
            if (hpath(kp:kp).ne.'/' .and. hpath(kp:kp).ne.char(92))
     &          hfilei=hpath(1:kp)//bs//'mixtures'//bs//hfl
          endif
          open (unit=nread,file=hfilei,status='old',iostat=ioerr,
     &          action='READ')
          if (ioerr.eq.0) goto 11
        endif
      enddo
c
c  Loop over possible paths in DOS/Windows and UNIX machines
c  and try upper/lower case scenarios.
c  01-13-05 WLJ at ORNL
      do m=1,4
        bs=char(92)
        if (m.ge.3) bs='/'      !Try same options for a Unix system
        do k=1,6
          if (idir.ne.2) then
            if (k.eq.1) hfilei=' '                             ! Current directory
            if (k.eq.2) hfilei='fluids'//bs                    ! Fluids subdirectory
            if (k.eq.3) hfilei=bs//'refprop'//bs//'fluids'//bs ! From \Refprop\Fluids\
            if (k.eq.4) hfilei='..'//bs//'fluids'//bs          ! From ..\Fluids\
            if (k.eq.5) hfilei=':fluids:'                      ! Mac
            if (k.eq.6) hfilei='c:'//bs//'Program Files'//bs// ! C:\Program files\Refprop\Fluids
     &                         'Refprop'//bs//'fluids'//bs
          else
            if (k.eq.1) hfilei=' '
            if (k.eq.2) hfilei='mixtures'//bs
            if (k.eq.3) hfilei=bs//'refprop'//bs//'mixtures'//bs
            if (k.eq.4) hfilei='..'//bs//'mixtures'//bs
            if (k.eq.5) hfilei=':mixtures:'
            if (k.eq.6) hfilei='c:'//bs//'Program Files'
     &                         //bs//'Refprop'//bs//'mixtures'//bs
          endif
c  find last occurrence of a character other than a space
          kl=1
          do j=1,255
            if (hfilei(j:j).ne.' ') kl=j+1
          enddo
          hfilei(kl:)=hfl
          hfilej=hfilei
c  find last occurrence of bs so that only the part after bs gets upper/lower cased when k=1
          km=1
          do j=1,255
            if (hfilei(j:j).eq.bs) km=j+1
          enddo
          if (k.eq.1 .and. km.ne.1) kl=km
c  checks for case sensitive machines
          do kk=1,5
c  add the path from SETPATH to the beginning
            if (m.eq.2 .or. m.eq.4) then
              if (kp.ne.0) then
                if(hpath(kp:kp).ne.'/'.and.hpath(kp:kp).ne.char(92)
     &         .and. hfilei(1:1).ne.'/'.and.hfilei(1:1).ne.char(92))then
                  hfilei=hpath(1:kp)//bs//hfilei
                else
                  hfilei=hpath(1:kp)//hfilei
                endif
              endif
            endif
            open (unit=nread,file=hfilei,status='old',iostat=ioerr,
     &            action='READ')
            if (ioerr.eq.0) goto 11
            hfilei=hfilej
c  try all upper case
            if (kk.eq.1) then
              do j=kl,255
                kc=INDEX(lower, hfilei(j:j))
                if (kc.ne.0) hfilei(j:j)=upper(kc:kc)
              enddo
c  try lower case '.fld':
            elseif (kk.eq.2) then
              j=INDEX(hfilei,'.FLD')
              if (j.ne.0) then
                hfilei=hfilej(1:j-1)//'.fld'//hfilej(j+4:255)
              endif
              j=INDEX(hfilei,'.BNC')
              if (j.ne.0) then
                hfilei=hfilej(1:j-1)//'.bnc'//hfilej(j+4:255)
              endif
              j=INDEX(hfilei,'.MIX')
              if (j.ne.0) then
                hfilei=hfilej(1:j-1)//'.mix'//hfilej(j+4:255)
              endif
c  try all lower case
            elseif (kk.eq.3) then
              do j=kl,255
                kc=INDEX(upper, hfilei(j:j))
                if (kc.ne.0) hfilei(j:j)=lower(kc:kc)
              enddo
c  try upper case '.FLD'
            elseif (kk.eq.4) then
              j=INDEX(hfilei,'.fld')
              if (j.ne.0) then
                hfilei=hfilej(1:j-1)//'.FLD'//hfilej(j+4:255)
              endif
              j=INDEX(hfilei,'.bnc')
              if (j.ne.0) then
                hfilei=hfilej(1:j-1)//'.BNC'//hfilej(j+4:255)
              endif
              j=INDEX(hfilei,'.mix')
              if (j.ne.0) then
                hfilei=hfilej(1:j-1)//'.MIX'//hfilej(j+4:255)
              endif
            end if
          enddo
c         write (*,1106) hfl(i),hfl
c1106     format (1x,'initial file specification failed:  ',a80/
c    &            1x,'reading coefficients from file:     ',a80)
        enddo
      enddo
      ierr=101
 11   continue
!$OMP END CRITICAL(REFPROP_OPEN_FILE)
      RETURN
      end                                             !subroutine OPENFL
c
c ======================================================================
c
      subroutine SETPATH (hpth)
c
c  set the path where the fluid files are located
c
c  inputs:
c     hpth--location of the fluid files [character*255 variable]
c           The path does not need to contain the ending "\" and it can
c           point directly to the location where the DLL is stored if a
c           fluids subdirectory (with the corresponding fluid files) is
c           located there.
c           example:  hpth='C:\Program Files\Refprop'
c
c  written by E.W. Lemmon, NIST Thermophysics Division, Boulder, Colorado
c  09-22-06 EWL, original version
c  03-07-07 EWL, check for null character
c
cx DEC$ ATTRIBUTES DLLEXPORT :: SETPATH
c
      include 'commons.for'
      character hpth*(*)
c
      hpath=hpth
      i=index(hpath,char(0))
      if (i.ne.0) hpath(i:255)=' '
      RETURN
      end                                            !subroutine SETPATH
c
c ======================================================================
c
      subroutine PUREFLD (icomp)
c
c  Change the standard mixture setup so that the properties of one fluid
c  can be calculated as if SETUP had been called for a pure fluid.
c  Calling this routine will disable all mixture calculations.
c  To reset the mixture setup, call this routine with icomp=0.
c
c  inputs:
c   icomp--fluid number in a mixture to use as a pure fluid
c
c  written by E.W. Lemmon, NIST Thermophysics Division, Boulder, Colorado
c  06-13-06 EWL, original version
c  01-07-10 EWL, move most variables to subroutine RESETA
c  02-04-10 EWL, allow icomp to be set to values greater than nc, but not
c                greater than ncmax.  This is used for loading a mixture
c                and a ppf file, but changing nc to that of the mixture
c                so that the ppf is located at nc+1 (see subroutine SETNC)
c
cx DEC$ ATTRIBUTES DLLEXPORT :: PUREFLD
c
      include 'commons.for'
c
      call RESETA
      icnc=0
      if (icomp.ge.0 .and. icomp.le.ncmax) icnc=icomp
c
      RETURN
      end                                            !subroutine PUREFLD
c
c ======================================================================
c
      subroutine SETNC (ncomp)
c
c  Allow the user to modify the value of nc (the number of components in
c  a mixture) so that a subset of the full setup can be used.
c  For example, a 5 component mixture could be set up, but nc could
c  be set to 3 to calculate properties for just the first three components.
c  This also allows a mixture to be setup with one or more pure fluids
c  loaded after the components in the mixture.  For example, R407C could
c  be loaded by calling setup with R32.fld, R125.fld, R134a.fld, and R407C.ppf.
c  The number of components would be set to 3, and PUREFLD would be called
c  to access the properties from component 4, the pseudo-pure fluid equation.
c
c  inputs:
c   ncomp--number of components in the mixture
c
c  written by E.W. Lemmon, NIST Thermophysics Division, Boulder, Colorado
c  02-04-10 EWL, original version
c
cx DEC$ ATTRIBUTES DLLEXPORT :: SETNC
c
      include 'commons.for'
c
      nc=ncomp
      RETURN
      end                                              !subroutine SETNC
c
c ======================================================================
c
      subroutine RESETA
c
c  Reset all variables that store saved properties so that new
c  new calculations are made regardless of previous inputs.
c
c  written by E.W. Lemmon, NIST Thermophysics Division, Boulder, Colorado
c  01-07-10 EWL, original version
c  02-04-10 EWL, change the ianc variable into an array
c
      include 'commons.for'
c
c  Do not include variables such as ianc here which should not be reset
c  in general.  They belong in the call to SETUP.
c
      d72l=0.0d0
      d72v=0.0d0
      thmax=0.0d0
      hmax=0.0d0
      htpl=0.0d0
      htpv=0.0d0
      stpl=0.0d0
      stpv=0.0d0
      tsmax=0.0d0
      smax=0.0d0
      tsmin=0.0d0
      smin=0.0d0
      tsminm=0.0d0
      sminm=0.0d0
      lsatt=.false.
      lsatp=.false.
      icnc=0
      ieflg=0
      iSatFlg=0
      iSatFlg2=0
      do i=n0,nx
        delsvf(i)=0.0d0
        tausvf(i)=0.0d0
      enddo
c initialize saturated values
      tsavt=0.d0
      psavt=0.d0
      dlsavt=0.d0
      dvsavt=0.d0
      kphsvt=0
      icsavt=0
      tsavp=0.d0
      psavp=0.d0
      dlsavp=0.d0
      dvsavp=0.d0
      kphsvp=0
      icsavp=0
      do i=1,ncmax
        xsavt (i)=0.d0
        xlsavt(i)=0.d0
        xvsavt(i)=0.d0
        xsavp (i)=0.d0
        xlsavp(i)=0.d0
        xvsavp(i)=0.d0
        pstmin(i)=0.d0
        pltmin(i)=0.d0
        dltmin(i)=0.d0
        dvtmin(i)=0.d0
        x0sav(i)=0.d0
      enddo
c
      RETURN
      end                                             !subroutine RESETA
c
c ======================================================================
c
      block data BDSET
c
c  This block data initializes the common blocks which save input
c  arguments to SETUP and SETREF.  This is done to check if arguments
c  are unchanged since previous call; if so, routine can be bypassed.
c
c  written by M. McLinden, NIST Thermophysics Division, Boulder, Colorado
c  01-10-96  MM, original version
c  01-16-96  MM, add saves for SETREF
c  02-27-96  MM, parameter n0=-ncmax to accommodate ECS-thermo model
c  03-20-96  MM, changes to accommodate SETMOD:  initialize /TRNMOD/
c                initialize heos, etc to 'NBS'
c  03-21-96  MM, replace /MODEL/ with /EOSMOD/, /STNMOD/, /REFST/
c  03-22-96  MM, initialize hetamx,htcxmx,hsten to 'NBS', rather than 'NUL'
c  03-27-96  MM, ditto for component models, hmxeos,hetamx,htcxmx,hstenk
c  02-20-97  MM, initialize default ref states in /REFST/
c  03-28-97  MM, add /RESETM/ and set lreset=.true. so that models are
c                initialized by call to SETMOD rather than here
c  07-15-97  MM, move /FLAGS/ here from ftn_pas.f
c  11-25-97  MM, insert 2 extra 9's into the funny numbers in /FLAGS/
c  12-16-97  MM, set last open variable in /FLAGS/ to 'error'
c  12-01-98 EWL, add default for iprnterr
c  07-10-06 EWL, move any variables set to 'NUL' to beginning of SETUP
c                to comply with ANSI standards
c
      include 'commons.for'
      data nc,icnc /2*0/
      data lreset /.true./ !reset all models on 1st call to SETUP/SETMOD
      data lrst /.false./
      data linit /.true./
      data x0sav /nx*0.0d0/
      data h0sav,s0sav,t0sav,p0sav /4*0.0d0/
      data ixfsav,ksetrf /2*0/
      data xnota /-9.99991d6/ !flag indicating 'not applicable'
      data x2ph  /-9.99992d6/ !flag indicating '2-phase'
      data xsubc /-9.99993d6/ !flag indicating 'subcooled'
      data xsuph /-9.99994d6/ !flag indicating 'superheated'
      data xsupc /-9.99995d6/ !flag indicating 'supercritical'
      data xinf  /-9.99996d6/ !flag indicating 'infinite'
      data xerr  /-9.99997d6/ !flag indicating 'error'
      data xnotd /-9.99998d6/ !flag indicating property 'not defined'
      data xnotc /-9.99999d6/ !flag indicating property 'not calculated'
      data iprnterr /0/
      data iSatFlg2 /0/
      data iGERG04 /0/
      data hpath /' '/
      data izero0,ione1,itwo2 /0,1,2/
      data hmxeos /51*'NBS'/
      end                                              !block data BDSET
c
c
c        1         2         3         4         5         6         7
c23456789012345678901234567890123456789012345678901234567890123456789012
c
c ======================================================================
c                                                       end file setup.f
c ======================================================================
c  begin file trns_ECS.f
c
c  This file contains the routines implementing the extended corresponding
c  states (ECS) method for the transport properties.
c
c  contained here are:
c     subroutine TRNECS (t,rho,x,eta,tcx,ierr,herr)
c     subroutine TCBKMX (t,rho,x,fj,fx,hj,hx,tcx,Flam,lerrt,lerrD,
c    &                   ierr,herr,irefn)
c     subroutine SETTRN (nread,icomp,hcasno,hreff,heoss,hvs,htc,
c    &                   ierr,herr)
c     function FINT (icomp,t)
c     function PSI (icomp,tr,rhor)
c     function CHI (icomp,tr,rhor)
c     subroutine TCKVIR (icomp,t,tcx0,tcxcol,tcxvir,ierr,herr)
c     subroutine ECSLIM (t,D,tmin,tmax,Dmax,lerrt,lerrD,terr,Derr)
c     function ETA0DG (icomp,t)
c     function OMEGAS (il,is,tau)
c     FUNCTION DELHSV (TX,DX,X,hj,irefn)
c     SUBROUTINE ENSKOG (N,RHO,SIGMA,CMW,X,ETA)
c     function ETAMIX (t,x)
c     subroutine CONFTD (j,amx,Zmix,tj,rhoj,ierr,herr)
c     subroutine CONFD (j,amx,Zmix,tj,rhoj,ierr,herr)
c     subroutine CONFT (k,amx,rhok,tk,ierr,herr)
c     subroutine TRNEC (t,rho,x,eta,tcx,ierr,herr,irefn)
c     subroutine pTRNEC (icomp,t,rho,etares,tcxres,ierr,herr,irefn)
c     subroutine ETAbkp (jj,t,rho,fj,fx,hj,hx,etabk,ierr,herr)
c
c
c ======================================================================
c ======================================================================
c
      subroutine TRNECS (t,rho,x,eta,tcx,ierr,herr)
c
c  compute the transport properties of thermal conductivity and
c  viscosity as functions of temperature, density, and composition
c
c  based on the modification of the Huber-Ely ECS method given by:
c  Klein, S.A., McLinden, M.O. and Laesecke, A. (1997). An improved
c  extended corresponding states method for estimation of viscosity of
c  pure refrigerants and mixtures. Int. J. Refrigeration 20:208-217
c
c  N.B. --equation numbers below refer to this paper;
c       --factor of (ref fluid mol wt)**-0.5 is missing from Eq 31 in paper
c       --in Eq 34 reference fluid should be evaluated at (t0,rho0), not
c         at (t/fj,rho*hj)
c
c  inputs:
c        t--temperature [K]
c      rho--molar density [mol/L]
c        x--composition array [mol frac]
c  outputs:
c      eta--viscosity [uPa.s]
c      tcx--thermal conductivity [W/m.K]
c     ierr--error flag:  0 = successful
c                       -1 = inputs are out of bounds
c                      -35 = temperature out of range for conductivity of ref. fluid
c                      -36 = density out of range for conductivity of ref. fluid
c                      -37 = T and D out of range for conductivity of ref. fluid
c                      -41 = temperature out of range for viscosity of fluid j
c                      -42 = density out of range for viscosity of fluid j
c                      -43 = T and D out of range for viscosity of fluid j
c                      -45 = temperature out of range for viscosity of ref. fluid
c                      -46 = density out of range for viscosity of ref. fluid
c                      -47 = T and D out of range for viscosity of ref. fluid
c                      -48 = ref. fluid viscosity correlation in invalid region
c                      -55 = T out of range for both visc and t.c.
c                      -56 = D out of range for both visc and t.c.
c                      -57 = T and/or D out of range for both visc and t.c.
c                  -58,-59 = ECS model did not converge
c                      -60 = pure fluid is exactly at critical point; t.c. is infinite
c     herr--error string (character*255 variable if ierr<>0)
c
c  written by M. McLinden
c  NIST Physical & Chemical Properties Division, Boulder, Colorado
c  based on the routine by S.A. Klein (in turn, based on Refprop5 routine)
c  03-05-97  MM, original version
c  08-22-97  MM, evaluate critical part of t.c. at simple reduced t,rho rather
c                than the conformal t,rho used for the background part
c  08-25-97  MM, replace calls to ETA1 with ETAK0 (ref fluid) and ETA0DG
c  08-26-97  MM, break-out mix t.c. into separate subroutine TCBKMX
c  09-09-97  MM, calls to old GETFXHX routine, commented out
c                if GETFH does not converge, set to xnotc and RETURN
c  09-25-97  MM, restructure around new CONFTD for finding f's, h's
c  10-01-97  MM, make correction to Eq 34 as noted above
c  10-08-97  MM, evaluate crit part of t.c. at average of reduced and conformal
c  10-09-97  MM, fix bug in do loop associated with calc of xmij
c  10-24-97  MM, Eucken term f_int now a function of t
c  11-13-97  MM, fix bomb when rho = 0
c  12-01-98 EWL, add Reos and triple point pressure and density to /CCON/
c  11-02-99 EWL, call limitk with 300 K and 0 mol/L to avoid error messages
c  11-05-01 MLH, catch t.c. at exactly pure fluid critical point
c  11-06-01 MLH, implement new t.c. crit enhancement model, catch conftd errors
c  11-23-01 MLH, add flags to catch errors in calls to etakb,tcxkb,tcxkc,critp
c  11-26-01 MLH, flag individual fluid viscosity out of range errors in mixture calculations
c  06-28-02 MLH, added constraint on low pressure calculations as temp fix for vapor nonconvergence
c  07-01-02 MLH, allow tk6 model
c  11-26-02 EWL, check for pure fluid outside of bounds
c  09-07-04 MLH, add error flags, extrap on vapor side for ref fluid, multiple ref fluids, limit min t and max rho calcs
c  10-26-05 MLH, adapted for multiple ref fluids w/o calling setfld
c  10-30-06 MLH, revised ECS for multiple ref. fluids use fam type, w and dipole mom.
c  11-12-06 MLH, revise so that all pures self-reference and mix ref fluid is irrelevant; use nitrogen for all
c  11-13-06 MLH, limit gj near zero
c  11-30-06 MLH, remove discontinuity for size diff effects
c  12-24-06 MLH, add binary int parameters kij, lij for residual viscosity; deactivate hsdel
c  12-26-06 EWL, remove initial check on pressure
c  01-24-07 MLH, cap upper limit enhancement on mixtures; fix ref fluid bug for purefld usage
c  12-17-07 MLH, deactivate some bounds checks on ref. fluid and on indiv. fluids
c  02-13-08 MLH, adjustment of region to calc shape factors to fix problems in supercritical region of jp900
c  05-27-08 MLH, add one more binary int par for dilute gas viscosity xdij in trnbin
c  06-11-08 MLH, add second bin int for dilute gas vis xdij2
c  07-09-08 MLH, turned off out of bounds warning messages
c  04-27-10 EWL, add checks for i=j and undefined variables
c  09-20-10 MLH, corrected Null vs nul error, look only for ierr=-60 at crit point
c  10-28-10 EWL, remove composition dependence if nc=1
c  06-01-11 EWL, remove common block SHAPES; none of the variables are used in other routines
c
      include 'commons.for'
      include 'comtrn.for'
      character*255 herr,herrs,herrk,herret,hercrt
      character*255 herrvj, herrsv
c     character*255 hfile(n0:nx), refer1, refer2
      logical lertt,lertD,lervt2,lervD2
      dimension x(ncmax)
      dimension xmj(ncmax)           !equivalent mol mass (Eq 33)
c     COMMON /SHAPES/ fj(nx), hj(nx), fx, hx
      dimension fj(nx), hj(nx)
c
c     for use in k critical enhancement TCXM1C
c     ifamc1c2=0
c     ifamcyc=0
      call ISPURE (x,icomp)
c     initialize error flags
c     routines conftd, etakb, tcxkb,tcxkc, critp all reset error flag so it is necessary
c     to keep separate error counters to keep track of the errors in each routine
      irefn=0    !set reference fluid to slot 0 initially
      ierr=0
      herr=' '
      ierret=0
      herret(1:1)=hnull
      ierrk=0
      herrk(1:1)=hnull
      iercrt=0
      hercrt(1:1)=hnull
      ierrs=0
      herrs(1:1)=hnull
      ierrvj=0
      herrvj(1:1)=hnull
      ierrsv=0
      herrsv(1:1)=hnull
c  set visc and t.c. to flags indicating 'not calculated' so that some
c  value is returned to GUI in event of failure of routines
      eta=xnotc
      tcx=xnotc

      if (icomp.ne.0) then
        if (t.lt.tmecst(icomp) .or. t.gt.txecst(icomp)*1.5d0
     &                       .or. rho.gt.Dxecst(icomp)) then
          ierr=-1
          herr='[TRNECS error -1] one or more inputs are out of bounds'
     &          //hnull
          call ERRMSG (ierr,herr)
          RETURN
        endif
      end if

c  select 1st reference fluid for mixture calculations
c     IF(icomp.eq.0) then
c        acnmax=0.0d0
c        acnmin=1000.d0
c        dipmax=0.0d0
c        dipmin=1000.d0
c        acenx=0.0d0
c        do i=1,nc
c          IF((family(i).eq.'n-alkane').AND.(accen(i).lt.0.1))then
c            ifamc1c2=1
c          endif
c          IF(family(i).eq.'naphthene')then
c            ifamcyc=1
c          endif
c          acenx=x(i)*accen(i)+acenx
c          IF(accen(i).gt.acnmax)acnmax=accen(i)
c          IF(accen(i).lt.acnmin)acnmin=accen(i)
c          IF(dipole(i).gt.dipmax)dipmax=dipole(i)
c          IF(dipole(i).lt.dipmin)dipmin=dipole(i)
c        enddo
c        IF((acnmax.lt.0.1).AND.(ifamc1c2.eq.0))then
c          refer1='nitrogen.fld'
c          irefn=0
c        ELSEIF(acnmax.le.0.37)then   !up to c7
c          refer1='propane.fld'
c          irefn=-ncmax-1
c        ELSEIF((acnmax.gt.0.37))then
c          refer1='c12.fld'
c          irefn=-ncmax-2
c        ENDIF
c  If all fluids are fairly polar, use r134a
c        IF(dipmin.gt.0.5)then
c          refer1='r134a.fld'
c          irefn=-ncmax-3
c        ENDIF
c     ENDIF
c         refer1='nitrogen.fld'
c

c     irefn=0
c     if (nc.eq.1 .or. icnc.ne.0) then
c       icomp=1
c       if (icnc.ne.0) icomp=icnc
c       if (icnc.ne.0) irefn=-ic
c     endif

      irefn=0
      if (icomp.ne.0 .and. nc.ne.1) irefn=-icomp

c  find amx, Zmix and conformal t,rho for reference fluid
      call CRITP (x,tcmxec,pcmxec,dcmxec,iercrt,hercrt)
c     write (*,*) ' TRNECS--ierr from CRITP, tcmxec:  ',iercrt,tcmxec
      call REDX (x,tred,Dred)
      tau=tred/t
      del=rho/Dred
      amx=PHIX(0,0,tau,del,x)
      Zmix=1.0d0+PHIX(0,1,tau,del,x)
      t0=t*tcrit(irefn)/tcmxec          !initial guess for conformal temperature
      rho0=rho*Dcrit(irefn)/dcmxec  !initial guess for conformal density
c     default values in case of convergence failure
      fxx0=tcmxec/tcrit(irefn)
      hxx0=Dcrit(irefn)/dcmxec
      plimi=zmix*r*t0*rho0
c  find "exact" conformal t,rho only if density is significant;
c  at zero density, use the initial guesses above (CONFTD can fail at
c  very low density, and the dilute-gas contribution is dominant anyway)
      IF((zmix.gt.0.3).and. (plimi.lt.1.1*pcrit(irefn)).AND.
     &  (rho0.lt.Dcrit(irefn)))then    !vapor side
        fx=fxx0
        hx=hxx0
      ELSE
        call CONFTD (irefn,amx,Zmix,t0,rho0,ierrs,herrs)
        fx=t/t0
        hx=rho0/rho
        pctf=ABS(100.*(fx-fxx0)/fxx0)
        pcth=ABS(100.*(hx-hxx0)/hxx0)
        IF(ierrs.ne.0)then
          IF((pctf.gt.10).OR.(pcth.gt.10).OR.(t0.lt.1.d0)) THEN
            ierrsv=-58
            j00=0
            write (herrsv,1058) j00, hnull
            call ERRMSG (ierrsv,herrsv)
          ENDIF
        ENDIF
      ENDIF
      if (icomp.ne.0) then
c  for pure fluid, component f,h are same as mixture values
        fj(icomp)=fx
        hj(icomp)=hx
      else
c  for mixture, find conformal t,rho for each of the components
        do j=1,nc
          if (x(j).gt.0.d0) then
          fjj0=tcrit(j)*fx/tcmxec
          hjj0=hx*dcmxec/Dcrit(j)
c         tj=t*tcrit(j)/(fx*tcrit(0))       !initial guess for conformal temp
c         rhoj=rho*hx*Dcrit(j)/Dcrit(0) !initial guess for conformal density
          tj=t*tcrit(j)/tcmxec             !initial guess for conformal temp
c         write (*,1097) j,t,tcrit(j),tcmxec,tj
c1097     format (1x,' TRNECS--j,t,tcrit(j),tcmxec,tj: ',i3,4f12.6)
          rhoj=rho*Dcrit(j)/dcmxec     !initial guess for conformal density
          plimi=zmix*r*tj*rhoj
c  find "exact" conformal t,rho only if density is significant;
c  at zero density, use the initial guesses above (CONFTD can fail at
c  very low density, and the dilute-gas contribution is dominant anyway)
c         IF((zmix.gt.0.3).and.(plimi.lt.1.1*pcrit(j)).AND.
          IF((zmix.gt.0.3).AND.       !gas-like
     &      (rhoj.lt.Dcrit(j)))then    !vapor side
                fj(j)=fjj0
                hj(j)=hjj0
          ELSE
            call CONFTD (j,amx,Zmix,tj,rhoj,ierrs,herrs)
            fj(j)=tj*fx/t
            hj(j)=rho*hx/rhoj
c           check to make sure values are reasonable for this region
            pctf=ABS(100.*(fj(j)-fjj0)/fjj0)
            pcth=ABS(100.*(hj(j)-hjj0)/hjj0)
            IF(ierrs.ne.0)THEN
c           allow nonconvergence to small deviations
              if((pctf.gt.10).OR.(pcth.gt.10).OR.(tj.lt.1.0d0)) then
                ierrsv=-58
                write (herrsv,1058) j,hnull
                call ERRMSG (ierrsv,herrsv)
              else
                ierrs=0
                ierrsv=0
              endif
c           write (*,*) ' TRNECS--ierr from CONFTD, tj: ',ierrs,tj
c           write (*,1098) j,tj,fx,t,tcmxec
c1098       format (1x,' TRNECS--j,tj,fx,t,tcmxec: ',i3,4f12.6)
            ENDIF
          ENDIF
          ! override for sc region; linearly interpolate to value at 1000K
          ! to avoid discontinuity at tcmxec
            IF(zmix.gt.0.3) then  !gas-like
              IF(t.gt.tcmxec) then  !supercritical
              ratiof=(t-1000.0d0)*(fjj0-fj(j))/(1000.0d0-tcmxec)
              ratioh=(t-1000.0d0)*(hjj0-hj(j))/(1000.0d0-tcmxec)
              fj(j)=fjj0+ratiof
              hj(j)=hjj0+ratioh
              IF(t.gt.1000.0d0)fj(j)=fjj0
              IF(t.gt.1000.0d0)hj(j)=hjj0
              ierrs=0
              ierrsv=0
            ENDIF
          ENDIF
          endif
c       write (*,1099) j,fj(j),hj(j)
c1099   format (1x,' TRNECS--j,fj,hj:',i2,2f12.6)
        enddo
      end if
c
c  estimate the Lennard-Jones parameters, if necessary
      if (icomp.ne.0) then
        if (iLJflag(icomp).eq.0) then
          epsktr(icomp)=tcrit(icomp)/tcrit(irefn)*epsktr(irefn)
          sigtrn(icomp)=sigtrn(irefn)
     &                *(Dcrit(irefn)/Dcrit(icomp))**(1.0d0/3.0d0)
        else if (iLJflag(icomp).eq.2) then
c  estimation method of Huber & Ely (1992) FPE 80:239-248
          epsktr(icomp)=epsktr(irefn)*fj(icomp)
          sigtrn(icomp)=sigtrn(irefn)*hj(icomp)**(1.0d0/3.0d0)
        end if
      else
        do j=1,nc
          if (x(j).gt.0.d0) then
            if (iLJflag(j).eq.0) then
              epsktr(j)=tcrit(j)/tcrit(irefn)*epsktr(irefn)
              sigtrn(j)=sigtrn(irefn)
     &                 *(Dcrit(irefn)/Dcrit(j))**(1.0d0/3.0d0)
            else if (iLJflag(j).eq.2) then
c  estimation method of Huber & Ely (1992) FPE 80:239-248
              epsktr(j)=epsktr(irefn)*fj(j)
              sigtrn(j)=sigtrn(irefn)*hj(j)**(1.0d0/3.0d0)
            end if
          endif
        enddo
      endif
c
c  find correlation limits for reference fluid
      p=0.0d0
c     tt=300.0d0
c     rr=0.0d0
c     call LIMITK ('ETA',irefn,tt,rr,p,tminv,tmaxv,Deta,peta,ierr,herr)
c     call LIMITK ('TCX',irefn,tt,rr,p,tmint,tmaxt,Dtcxt,ptcxt,ierr,herr)
c  initialize error flags
      lertt=.false.
c     lervt=.false.
c     lertD=.false.
c     lervD=.false.
c     lervtj=.false.
c     lervDj=.false.
c     write (*,1013) tminv,tmaxv,Deta,tmint,tmaxt,Dtcxt
c1013 format (1x,' TRNECS--ref fluid visc limits--t,rho: ',2f8.2,f12.6/
c    &        1x,'                   t.c. limits--t,rho: ',2f8.2,f12.6)
c
      if (icomp.ne.0) then
c  special case for pure fluid
        gx=wmas(icomp)/wmas(irefn)
        tpsi=t/tcrit(icomp)
        rhopsi=rho/Dcrit(icomp)
        rho0v=rho*hj(icomp)*PSI(icomp,tpsi,rhopsi)               !Eq 21
c  reference fluid background viscosity
        call ETAKB (irefn,t0,rho0v,eta0bk,ierrs,herrs)
        IF(eta0bk.LE.-1000.0d0)THEN  !in two-phase, frozen, or other invalid region
          ierrs=-48
          write (herrs,2068)
          call ERRMSG (ierrs,herrs)
          eta0bk=0.0
        endif
        if(ierrs.ne.0)then
          ierret=ierrs
          herret=herrs
        endif
        eta1dg=ETA0DG(icomp,t)                  !dilute gas visc
        Feta=SQRT(fj(icomp)*gx)*hj(icomp)**(-2.0d0/3.0d0)          !Eq 11
        eta=eta1dg+eta0bk*Feta                             !Eqs 5,10

c  check conformal t,rho against limits of reference fluid correlation
c       call ECSLIM (t0,rho0v,tminv,tmaxv,Deta,lervt,lervD,tcf,Dcf)
c  similar terms for thermal conductivity
        tchi=tpsi
        rhochi=rhopsi
        rho0t=rho*hj(icomp)*CHI(icomp,tchi,rhochi)
c  note that F-factor for t.c. has inverse power of gx compared to visc
        Flam=SQRT(fj(icomp)/gx)*hj(icomp)**(-2.0d0/3.0d0)
        call TCXKB (irefn,t0,rho0t,tcx0b,ierrs,herrs)
        if(ierrs.ne.0)then
          ierrk=ierrs
          herrk=herrs
        endif
c  find dilute-gas parts from collisions and internal degrees of freedom
        tcx1dg=1.0d-3*15.0d0*R*eta1dg/(4.0d0*wmas(icomp))
c       tcx1in=1.32d-3*eta1dg/wmas(1)*(CP0K(1,t)-2.5d0*R)
        tcx1in=FINT(icomp,t)*eta1dg/wmas(icomp)*(CP0K(icomp,t)-2.5d0*R)
c  apply ECS method to background part of ref fluid
        tcx=tcx0b*Flam+tcx1dg+tcx1in
c  check conformal t,rho against limits of reference fluid correlation
c       call ECSLIM (t0,rho0t,tmint,tmaxt,Dtcxt,lertt,lertD,tcf,Dcf)
c
c       write (*,1015) t,1,tcx1dg+tcx1in,tcx0b*Flam,Flam,tcx
c1015   format ('  TRNECS--t,j = ',f8.2,i3,
c    &          '; tcx_dg,tcx_bk,Flam,tcx: ',4f10.6)
c       write (*,1017) PSI(1,tpsi,rhopsi),Feta,CHI(1,tchi,rhochi),Flam
c1017   format (1x,' TRNECS--psi,Feta,chi,Flam: ',4f14.8)
c
      else
c
c  general (mixture) case; begin mixture viscosity calculation
c
c  calculate "equivalent mass" gx, using pure fluid residual viscosities,
c  either from a pure fluid correlation or the pure fluid ECS method;
c  check conformal t,rho against limits of reference fluid correlation
c  and find reference fluid residual viscosity
c  allow t extrapolations on vapor side
c       call ECSLIM (t0,rho0,tminv,tmaxv,Deta,lervt,lervD,tcf,Dcf)
c        if (lervt) then
c          IF(rho0.lt.Dcrit(irefn)) lervt=.false.
c          IF(rho0.lt.1.2*Deta) lervt=.FALSE.  !allow extrap to 30% over max
c        else
c        end if
        call ETAKB (irefn,t0,rho0,eta0bk,ierrs,herrs)
        IF(eta0bk.LE.-1000.0d0)THEN  !in two-phase, frozen, or other invalid region
          ierrs=-48
          write (herrs,2068)
          call ERRMSG (ierrs,herrs)
          eta0bk=0.0
        endif
        if(ierrs.ne.0)then
          ierret=ierrs
          herret=herrs
        endif
c       write (*,1022) t0,rho0,eta0bk
c1022   format (1x,' TRNECS-- ref fluid eval at t,rho =',
c    &          f9.3,f12.6,' eta0bk = ',f12.6)
        gxsum=0.0d0
        do j=1,nc
          if (x(j).gt.0.d0) then
          ierrvj=0
          ierrs=0
          if (heta(j)(1:2).ne.'EC') then
c          a pure fluid correlation is available
c          write (*,1024) j,heta(j)
c1024      format (1x,' TRNECS--pure fluid corr for j = ',i3,':  ',a3)
           tj=t*fj(j)/fx                                    !Eq 36
           rhoj=rho*hx/hj(j)                                !Eq 37
c  check that pure fluid correlation is within its limits
c  if it isn't, continue calculation but set error flags
           call LIMITK ('ETA',j,tj,rhoj,p,tmn,tmx,Dmx,pmx,ierrvj,herrvj)
           if(ierrvj.ne.0)then
              ierrvj=0 ! do not track errors here
              herrvj=' '
c             individual viscosity correlation out of range
c              ierrvj=-40-ierrvj !error numbering consistent with TRNPRP
c              if(ierrvj.EQ.-41)then
c                WRITE(herrvj,2065)j
c                lervtj=.true.
c              elseif(ierrvj.EQ.-42)then
c                WRITE(herrvj,2066)j
c                lervDj=.true.
c              elseif(ierrvj.EQ.-43)then
c                WRITE(herrvj,2067)j
c                lervDj=.true.
c                lervtj=.true.
c                ierrvj=43
c              endif
           endif
c   don't evaluate at t less than limits or rho gt limits for j fluid
           IF(tj.lt.tmn)tj=tmn
           IF(rhoj.gt.Dmx)rhoj=Dmx
           call ETAKB (j,tj,rhoj,etaj,ierrs,herrs)
           if(ierrs.ne.0)then
             ierret=ierrs
             herret=herrs
           endif
          end if
c
          IF(heta(j)(1:2).eq.'EC')then
c        the following line revised
c        - do not switch methods upon error in ierr2
c        or a discontinuity will occur. Just keep the error flag
c        if (heta(j)(1:2).eq.'EC' .or. ierr2.ne.0) then
c  must use ECS method to estimate
c         write (*,1026) j
c1026     format (1x,' TRNECS--will use ECS method for visc, j = ',i3)
            tpsi=t*fj(j)/(fx*tcrit(j))
            rhopsi=rho*hx/(hj(j)*Dcrit(j))
            rho0j=rho*hx*PSI(j,tpsi,rhopsi)                  !Eq 39
            Deta=1000.d0
c  check conformal t,rho against limits of reference fluid correlation
            call ECSLIM(t0,rho0j,tminv,tmaxv,Deta,lervt2,lervD2,tcf,Dcf)
c  don't evaluate at t less than limits or rho gt limits
            lervt2=.false.
            lervd2=.false.
            IF(t0.lt.tmecst(irefn))t0=tmecst(irefn) !ref fluid for mix
            IF(rho0j.gt.Dxecst(irefn))rho0j=Dxecst(irefn)
            IF(t0.lt.tmecst(j))t0=tmecst(j)
            IF(rho0j.gt.Dxecst(j))rho0j=Dxecst(j)
            call ETAKB (irefn,t0,rho0j,etarfj,ierrs,herrs)
            if(ierrs.ne.0)then
              ierret=ierrs
              herret=herrs
            endif
            call etabkp (j,t,rho,fj,fx,hj,hx,etaj,ierr,herr)
          end if

          if (abs(eta0bk).lt.1.d-20) then
            ierr=-59
            write (herr,1058) 0, hnull
            call ERRMSG (ierr,herr)
            return
          endif
          if (etaj.gt.1.0d-12 .and. eta0bk.gt.1.0d-6) then
            gj=etaj/eta0bk/SQRT(fj(j))*hj(j)**(2.0d0/3.0d0)  !Eq 35
          else
c  it is possible for residual viscosity to go through zero
c           gj=wmas(j)/wmas(irefn)/SQRT(fj(j))*hj(j)**(2.0d0/3.0d0)
            IF(etaj.lt.1.0d-12)etaj=1.0d-12
            IF(eta0bk.lt.1.0d-6)eta0bk=1.0d-6
            gj=etaj/eta0bk/SQRT(fj(j))*hj(j)**(2.0d0/3.0d0)  !Eq 35
          end if
          xmj(j)=gj*gj*wmas(irefn)                                 !Eq 33
          endif
c       write (*,*) ' TRNECS--j,xmj(j) for visc:  ',j,xmj(j)
c
        enddo
        do j=1,nc
        if (x(j).gt.0.d0) then
          do i=1,nc
            if (x(i).gt.0.d0) then
              if (i.ne.j) then
                xmij=2.0d0*xmj(i)*xmj(j)/(xmj(i)+xmj(j))
                fij=SQRT(fj(j)*fj(i))*(1.0d0-xkij(i,j))         !Eq 26
                hij=(hj(j)**(1.0d0/3.0d0)+hj(i)**(1.0d0/3.0d0))**3
     &            *0.125d0*(1.0d0-xlij(i,j))                    !Eq 27
              else
                xmij=xmj(i)
                fij=fj(i)
                hij=hj(j)
              endif
              gxsum=gxsum+x(j)*x(i)*SQRT(fij*xmij)*hij**(4.0d0/3.0d0) !Eq 31
            endif
          enddo
c       write (*,1156) j,fj(j),hj(j),etaj
c1156   format (1x,' TRNECS--j,fj,hj,etaj:  ',i2,3f12.6)
        endif
        enddo
c       gx=gxsum/(SQRT(fx*wmas(0))*hx**(4.0d0/3.0d0))        !Eq 31
c       Feta=SQRT(fx)*hx**(-2.0d0/3.0d0)*gx                !Eq 30
c  Eq 30 + 31 reduce to following expression
c  factor of 1/SQRT(ref fluid mol wt) is missing from Klein paper
        Feta=gxsum/hx**2/SQRT(wmas(irefn))
c       write (*,1158) fx,hx,gxsum,Feta
c1158   format (1x,' TRNECS--fx,hx,gxsum,Feta:  ',4f12.6)
        etaxdg=ETAMIX(t,x)      !dilute gas viscosity of mixture
        if (abs(etaxdg).lt.1.d-20) then
          ierr=-59
          write (herr,1058) 0, hnull
          call ERRMSG (ierr,herr)
          return
        endif
c        if (rho.gt.1.0d-6) then
c  apply size correction only if density is significant
c          del=DELHSV(t,rho,x,hj,irefn)  !Enskog size correction
c        else
          del=0.0d0
c        end if
c don't use size correction if polar fluid is reference
c        IF(irefn.EQ.-ncmax-3)del=0.0d0  !ref fluid is R134a
        eta=etaxdg+eta0bk*Feta+del                         !Eq 23
c       write (*,1160) etaxdg,eta0bk,Feta,del,eta
c1160   format (1x,' TRNECS--etaxdg,eta0bk,Feta,del,eta:  ',5f12.6)
c
c  mixture thermal conductivity calculation
c  evaluate background part (including dilute-gas part) of mixture
c
        call TCBKMX (t,rho,x,fj,fx,hj,hx,tcx,Flam,lertt,lertD,
     &               ierrk,herrk,irefn)
c       write (*,1164) tcx,Flam,lertt,lertD
c1164   format (1x,' TRNECS--tcx,Flam,lertt,lertD out of TCBKMX:  ',
c    &          2f12.6,2(3x,i1))
c
      end if           !end mixture case
c
c  for transmitting to critical enhancement routine TCXM1C in block critenh
      etacal=eta
c
c  now compute critical enhancement part of thermal conductivity
c
c  critical enhancement part of t.c. is evaluated at simple reduced t,rho;
c  (if it were calculated at same conformal t,rho as the background part,
c  the enhancement would peak at something other than the critical point)
c     tr=t/tcmxec*tcrit(0)
c     rhor=rho/dcmxec*Dcrit(0)
c
c  The critical enhancement part of t.c. is evaluated at a weighted
c  average of the conformal t,rho and the simple reduced t,rho, such that
c  it approaches the latter at the critical point and the former away
c  from the critical point. If it were calculated at same conformal t,rho
c  as the background part (even close to the critical point), the
c  enhancement would peak at something other than the critical point.
c  But, simply evaluating it always at the reduced t,rho can result in
c  states inside the two-phase region.  Thus, the need for a compromise.
c  the following model is deprecated due to discontinuities near the critical point
c      tr=t/tcmxec
c      rhor=rho/dcmxec
c     write (*,*) ' TRNECS--tcmxec,dcmxec:  ',tcmxec,dcmxec
c      tslope=5.0d0       !revert to conformal at t > 1.2tr
c      Dslope=2.5d0
c      qt=MIN(1.0d0,tslope*ABS(1.0d0-tr))
c      qD=MIN(1.0d0,Dslope*ABS(1.0d0-rhor))
c      tr=qt*t0+(1.0d0-qt)*tr*tcrit(0)
c      rhor=qD*rho0+(1.0d0-qD)*rhor*Dcrit(0)
c
c      call TCXKC (0,tr,rhor,tcx0c,ierr,herr)
c     write (*,1168) tr,rhor,tcx0c
c1168 format (1x,' TRNECS--t,rho for ref fluid,tcx0c:  ',3f12.6)
c  scale the critical enhancement by same Flam as rest of ECS method
c      tcxcr=tcx0c*Flam
c
c    xcsum=0.0d0
c      tcrsum=0.0d0
c      do 260 j=1,nc
c      if (htcx(j)(1:2).ne.'EC') then
c  a pure fluid correlation is available for component j; use for the
c  corresponding portion of the critical enhancement; otherwise mixture
c  calculation as x-->1 would not be continuous with pure fluid
c        tr=t/tcmxec*tcrit(j)
c        rhor=rho/dcmxec*Dcrit(j)
c        call TCXKC (j,tr,rhor,tcxjc,ierr,herr)
c        xcsum=xcsum+x(j)
c        tcrsum=tcrsum+x(j)*tcxjc
c      end if
c  260 continue
c
c  now, finally, add the critical enhancement to the total t.c.
c     tcrsum=tcrsum+(1.0d0-xcsum)*tcxcr
c     call new model for mixture thermal conductivity enhancement
c     previous model had discontinuities near critical due to the scaling factors applied.

      tcrsum=TCXM1C(x,t,rho,ierr,herr)
      tcrmix=tcrsum

      y=0.0d0
c     process errors from critical enhancement
      if (ierr.eq.-60) then       ! a components is exactly at crit point
c  don't give a value if exactly at pure fluid crit point, k is infinite
        tcx=xnotc
      endif
c
c     if model used for t.c. enhancement was other than 'null','tk3', or 'tk6'
c     force mixture continuity as x-->1
c     this is a linear interpolation used close to pure fluid limit
      if (icomp.eq.0) then                      !mixtures only
        do j=1,nc
        if (x(j).gt.0.99d0) then            !only use near end point
          y=tcrmix
          if (htcxcr(j).eq.'TK3') then      !use existing mix model
          elseif (htcxcr(j).eq.'NUL') then  !use existing mix model
          elseif (htcxcr(j).eq.'TK6') then  !use existing mix model
          else              !need to adjust for pure fluid correlation
c           a pure fluid correlation is available for component j but it is
c           not in the form of a 'TK3'or 'TK6' model; use its contribution to force mixture
c           calculation as x-->1 to be continuous with pure fluid
c           get correlation value at pure fluid limit and blend linearly
            call TCXKC (j,t,rho,tcxjc,ierrs,herrs)
            if(ierrs.ne.0)then
              ierrk=ierrs
              herrk=herrs
            endif
            y=100.*(tcxjc-tcrmix)*x(j)+100.*tcrmix-99.0d0*tcxjc
          end if
        endif
        enddo
        do j=1,nc
          if (x(j).gt.0.99d0) then
            if (ierrs.eq.0) then
              tcrsum=y     !blended value
            else           !calculation failure, revert to mix value
              tcrsum=tcrmix
            endif
          endif
        enddo
      endif
c
c     add the enhancement term to the background term to get the total
c     limit enhancement for mixtures to 100% of background
      IF(tcrsum.gt.tcx)tcrsum=tcx
      tcx=tcx+tcrsum
c     write (*,1216) tcxbk0,tcbkcr,tcrsum,tcx
c1216 format (1x,' TRNECS--bk_ref,bk_mix,crit,tcx:',4f12.8)
c     write (*,1217) tcxcr
c1217 format ('  TRNECS--tcx_crit:',2f10.6)
c
c  process warning/errors for problems with calls to etakb
      if (ierret.ne.0) then !etakb failed;
c       do not return numbers for eta
        ierr=ierret
        herr=herret
        eta=xnotc  !values used by GUI as non-convergence flag
c       tcx=xnotc
      endif
c
c  process warning/errors for problems with calls to tcxkb, tcxkc
c      if (ierrk.ne.0) then !tcxkb or tcxkc failed;
c         return numbers with a warning
c        ierr=ierrk
c        herr=herrk
c       eta=xnotc  !values used by GUI as non-convergence flag
c       tcx=xnotc
c      endif
c
c  process warnings/errors for problems with CRITP routine
      if (iercrt.gt.0) then !critp failed;
c         return numbers with a warning
        ierr=iercrt
        herr=hercrt
c       eta=xnotc  !values used by GUI as non-convergence flag
c       tcx=xnotc
      endif
c
c  process warnings/errors for conformal states outside range of ref fluid
c      lertc=lertt.or.lertD
c      lervs=lervt.or.lervD
c      if (lertc .and. lervs) then
c  both thermal conductivity and viscosity generated errors
c        eta=xnotc  !values used by GUI as non-convergence flag
c        tcx=xnotc
c        return a value but with message
c        if ((lertt.or.lervt) .and. (lertD.or.lervD)) then
c          ierr=-57
c          write (herr,2057) t,rho
c        else if (lertD.or.lervD) then
c          ierr=-56
c          write (herr,2056) t,rho
c        else
c          ierr=-55
c          write (herr,2055) t,rho
c        end if
c      else if (lertc) then
c  only thermal conductivity generated errors
c       tcx=xnotc  !value used by GUI as non-convergence flag
c       return a value but with message
c         if (lertt .and. lertD) then
c          ierr=-37
c          write (herr,2037) t,rho
c        else if (lertD) then
c          ierr=-36
c          write (herr,2036) Dcf,Dtcxt
c        else
c          ierr=-35
c          write (herr,2035) tcf,tmint,tmaxt
c        end if
c      else if (lervs) then
c  only viscosity generated errors
c       eta=xnotc  !value used by GUI as non-convergence flag
c       return a value but with message
c        if (lervt .and. lervD) then
c          ierr=-47
c          write (herr,2047) t,rho
c        else if (lertD) then
c          ierr=-46
c          write (herr,2046) Dcf,Deta
c        else
c          ierr=-45
c          write (herr,2045) tcf,tminv,tmaxv
c        end if
c      end if
c
c  process warnings/errors for conformal states outside range of individual fluid
c  viscosity correlations
c      lervsj=lervtj.or.lervDj
c      if (lervsj) then
c     viscosity generated errors
c     return a number with a warning
         !eta=xnotc  !value used by GUI as non-convergence flag
c        ierr=ierrvj
c        herr=herrvj
c      end if
c
      if (ierrsv.ne.0) then !conftd failed
c       do not return numbers
        ierr=ierrsv
        herr=herrsv
        eta=xnotc  !values used by GUI as non-convergence flag
        tcx=xnotc
      endif
      if (ierr.ne.0) call ERRMSG (ierr,herr)
c
c     switch the reference fluid for mixtures and recompute
c      IF(eta.eq.xnotc)return !if major error in eta, exit
c      IF(tcx.eq.xnotc)return !if major error in k, exit
C
c     following multiple reference fluid code unnecessary with self-referencing pures
c      refer2=refer1 !initialize
c      IF(icomp.eq.0)then
c        acen00=accen(irefn)
c        eta00=eta
c        tcx00=tcx
c     first ref fluid chosen on maxim accen and dipole moment
c     select second reference fluid based on min acentric factor and dipole moment
c
c        IF((acnmin.lt.0.1).AND.(ifamc1c2.eq.0))then
c          refer2='nitrogen.fld'
c          irefn=0
c        ! naphthenes tend to be underpredicted; go for next heavier ref fluid.
c        ELSEIF((acnmin.le.0.37).AND.(ifamcyc.eq.0))then
c          refer2='propane.fld'
c          irefn=-ncmax-1
c        ELSEIF((acnmin.gt.0.37))then
c          refer2='c12.fld'
c          irefn=-ncmax-2
c        ENDIF
c       if all fluids are polar, use r134a
c        IF(dipmax.gt.0.5)then
c          refer2='r134a.fld'
c          irefn=-ncmax-3
c        ENDIF
c
c        IF(refer2.ne.refer1) then
c          acen1=accen(irefn)
c         since recursive calls are not standard, use duplicate algorithm
c          call TRNEC (t,rho,x,eta1,tcx1,ierr,herr,irefn)
c
c          IF((acnmin.ge.0.1).AND.(acnmax.le.0.4))then
c            eta=eta1
c            tcx=tcx1
c          ELSEIF((acnmin.gt.0.4).AND.(acnmax.gt.0.4))then
c            eta=eta1
c            tcx=tcx1
c          else
c         interpolate
c            acenr=(acenx-acen00)/(acen1-acen00)
c            eta= (eta1-eta00)*acenr+eta00
c            tcx= (tcx1-tcx00)*acenr+tcx00
c          endif
c          IF(eta1.eq.xnotc)eta=xnotc
c          IF(tcx1.eq.xnotc)tcx=xnotc
c        ENDIF
c      ENDIF

      RETURN
c
 1058     format ('[TRNECS warning 58] 2-D Newton-Raphson method for ',
     &        'conformal temperature and density did not converge ',
     &        'for component',i3,a1)
c2035     format ('[TRNECS warning -35] conformal temperature in ECS-',
c    &      'transport method is outside range of reference fluid ',
c    &      'thermal conductivity correlation; T_conf =',g11.5,
c    &      ' K; T_min,max =',g11.5,',',g11.5,' K')
c2036     format ('[TRNECS warning -36] conformal density in ECS-',
c    &      'transport method is outside range of reference fluid ',
c    &      'thermal conductivity correlation; rho_conf =',g11.5,
c    &      ' mol/L; rho_max =',g11.5,' mol/L')
c2037     format ('[TRNECS warning -37] T and rho input to ECS-',
c    &      'transport method are outside range of reference fluid ',
c    &      'thermal conductivity correlation; T_in =',g11.5,
c    &      ' K; rho_in =',g11.5,' mol/L')
c2045     format ('[TRNECS warning -45] conformal temperature in ECS-',
c    &      'transport method is outside range of reference fluid ',
c    &      'thermal conductivity correlation; T_conf =',g11.5,
c    &      ' K; T_min,max =',g11.5,',',g11.5,' K')
c2046     format ('[TRNECS warning -46] conformal density in ECS-',
c    &      'transport method is outside range of reference fluid ',
c    &      'viscosity correlation; rho_conf =',g11.5,
c    &      ' mol/L; rho_max =',g11.5,' mol/L')
c2047     format ('[TRNECS warning -47] T and rho input to ECS-',
c    &      'transport method are outside range of reference fluid ',
c    &      'viscosity correlation; T_in =',g11.5,
c    &      ' K; rho_in =',g11.5,' mol/L')
c2055     format ('[TRNECS warning -55] temperature input to ECS-',
c    &      'transport method is outside range of reference fluid ',
c    &      'viscosity and thermal conductivity correlations; T_in =',
c    &      g11.5,' K; rho_in =',g11.5,' mol/L')
c2056     format ('[TRNECS warning -56] density input to ECS-',
c    &      'transport method is outside range of reference fluid ',
c    &      'viscosity and thermal conductivity correlations; T_in =',
c    &      g11.5,' K; rho_in =',g11.5,' mol/L')
c2057     format ('[TRNECS warning -57] T and/or rho input to ECS-',
c    &      'transport method are outside range of reference fluid ',
c    &      'viscosity and thermal conductivity correlations; T_in =',
c    &      g11.5,' K; rho_in =',g11.5,' mol/L')
c2065     format ('[TRNECS warning -41] conformal temperature in ECS-',
c    &      'transport method is outside range of fluid ',I3,
c    &      ' viscosity correlation')
c2066     format ('[TRNECS warning -42] conformal density in ECS-',
c    &      'transport method is outside range of fluid ',I3,
c    &      ' viscosity correlation')
c2067     format ('[TRNECS warning -43] conformal temperature and ',
c    &      'density in ECS-',
c    &      'transport method is outside range of fluid ',I3,
c    &      ' viscosity correlation')
 2068     format ('[TRNECS warning -48] invalid region for ',
     &        'viscosity of reference fluid 1 ')

c
      end                                             !subroutine TRNECS
c
c ======================================================================
c
      subroutine TCBKMX (t,rho,x,fj,fx,hj,hx,tcx,Flam,lerrt,lerrD,
     &                   ierr,herr,irefn)
c
c  compute the background thermal conductivity of a mixture where the
c  background t.c. is composed of the internal, dilute-gas, and residual
c  contributions (but not the critical enhancement)
c
c  based on the modification of the Huber-Ely ECS method given by:
c  Klein, S.A., McLinden, M.O. and Laesecke, A. (1997). An improved
c  extended corresponding states method for estimation of viscosity of
c  pure refrigerants and mixtures. Int. J. Refrigeration 20:208-217
c
c  N.B. --equation numbers below refer to this paper;
c       --factor of (ref fluid mol wt)**-0.5 is missing from Eq 31 in paper
c       --in Eq 34 reference fluid should be evaluated at (t0,rho0), not
c         at (t/fj,rho*hj)
c
c  inputs:
c        t--temperature [K]
c      rho--molar density [mol/L]
c        x--composition array [mol frac]
c       fj--array of temperature shape factors for the components
c       fx--temperature shape factor for the mixture
c       hj--array of temperature shape factors for the components
c       hx--density shape factor for the mixture
c  outputs:
c      tcx--thermal conductivity [W/m.K]
c     Flam--multiplier for t.c. (t.c._j = Flam * t.c._ref)
c    lerrt--error flag:  .true. if temperature out of range
c    lerrD--error flag:  .true. if density out of range
c     ierr--error flag:  0 = successful
c                      <>0 indicates problem from underlying routine
c                          passed to calling routine
c     herr--error string (character*255 variable if ierr<>0)
c
c  written by M. McLinden, NIST Phys & Chem Properties Div, Boulder, CO
c  08-26-97  MM, original version, extracted from TRNECS
c  10-01-97  MM, make correction to Eq 34 as noted above
c                add Flam to argument list
c  10-09-97  MM, fix bug in do loop associated with calc of xmij
c  10-24-97  MM, fint is now f(T) rather than const = 1.32d-3
c  12-01-98 EWL, add Reos and triple point pressure and density to /CCON/
c  03-31-99  MM, implement "correct" ECS mixing rule and Mason & Saxena
c                modification of Wassiljewa eqn for dilute gas mixtures
c  11-23-01 MLH, revise how out of limits error on correlations are handled
c                to prevent discontinuities.
c  11-25-01 MLH, limit how small tcx0b can get to prevent asymptote in mixing
c                rule for GXSUM (prevent division by zero or very small number)
c  07-09-02 MLH, limit how small tcxj, tcx0jb can get to prevent divide by zero
c  12-07-03 MLH, add modified Hanley-based bigx factor for mixture k
c  07-22-05 MLH, allow alternative reference fluids
c  11-24-06 MLH, smooth transition to pure ends; deactivate Hanley factor no longer necessary
c  01-25-07 MLH, allow constant in Mason& Saxena mixing rule to vary depending on fluid system
c  01-28-07 MLH, allow binary interaction parameter for residual thermal conductivity
c  12-17-07 MLH, deactivate reference fluid bounds checks.
c  05-27-08 MLH, add one more binary int par for dilute gas viscosity xdij in trnbin
c  06-11-08 MLH, add second bin int for dilute gas vis xdij2
c
      include 'commons.for'
      include 'comtrn.for'
      character*255 herr
      logical lerrt,lerrD
      dimension x(ncmax)
      dimension fj(ncmax),hj(ncmax)  !reducing ratios for components
      dimension tcxin(nx),tcxdg(nx)  !internal and dilute-gas parts
      dimension xmj(ncmax)           !equivalent mol mass (Eq 33)
      dimension etadg(ncmax)
c
      ierr=0
c     ierrs=0
      herr=' '
c  find correlation limits for reference fluid
      p=0.0d0
      tcx=0.0d0
c      call LIMITK ('TCX',irefn,t,rho,p,tmint,tmaxt,Dtcxt,ptcxt,ierr2,herr)
c  conformal temperature, density for mixture
      t0=t/fx
      rho0=rho*hx
c  reference fluid thermal conductivity at conformal conditions
c  check conformal t,rho against limits of reference fluid correlation
c     call ECSLIM (t0,rho0,tmint,tmaxt,Dtcxt,lerrt,lerrD,tcf,Dcf)
      call TCXKB (irefn,t0,rho0,tcx0b,ierr,herr)

c     if (tcx0b.eq.0) RETURN
c     check for very small value of tcx0b. It can go through zero and
c     cause an asymptote in the mixing rule for gxsum (division by zero)
c     thus don't let it get too small or be negative
      if(tcx0b.lt.(1.0d-16))tcx0b=1.0d-16
c
c  calculate "equivalent mass" gx, using pure fluid residual values,
c  either from a pure fluid correlation or the pure fluid ECS method
      gxsum=0.0d0
      tdgMSW=0.0d0
c     gxsum6=0.0d0  !alternative interpretation of gx factor in Refprop6
c     tinsum=0.0d0  !summation for internal contribution--superceded
c     tdgsum=0.0d0  !summation for translational part--superceded
      do j=1,nc
        if (x(j).gt.0.d0) then
        tj=t*fj(j)/fx
        rhoj=rho*hx/hj(j)
        if (htcx(j)(1:2).ne.'EC') then
c  a pure fluid correlation is available
c       write (*,1224) j,htcx(j)
c1224   format (1x,' TRNECS--pure fluid corr for j = ',i3,':  ',a3)

c  check that pure fluid correlation is within its limits
          call LIMITK ('TCX',j,tj,rhoj,p,tmn,tmx,Dmx,pmx,ierr,herr)
c          if(ierr.ne.0)then
c             !ierrs=ierr !save the error
c             !herrs=herr
c          endif
c       removed if/then condition on ierr so that you do not switch method
c       since this leads to an obvious discontinuity. retain error parameter
c       and print error message instead.
c       if (ierr.eq.0) then
c  dilute gas visc of component j using generalized dilute-gas function
            etadg(j)=ETA0DG(j,t)
c  dilute-gas correlation also includes internal contribution; calculate
c  internal contribution separately as different mixing rule is (was) used
c           tcxin(j)=1.32d-3*etadg(j)/wmas(j)*(CP0K(j,t)-2.5d0*R)
            tcxin(j)=FINT(j,t)*etadg(j)/wmas(j)*(CP0K(j,t)-2.5d0*R)
            call TCXK0 (j,t,tcx0,ierr2,herr)
            tcxdg(j)=tcx0-tcxin(j)
c  apply ECS method to background (residual) part of t.c.
            call TCXKB (j,tj,rhoj,tcxj,ierr2,herr)

c  check for very small value of tcxj. It can go through zero and
c  cause division by zero thus don't let it get too small or be negative
            if(tcxj.lt.(1.0d-16))tcxj=1.0d-16
c         write (*,1225) j,tcx0,tcxj,htcx(j)
c1225     format ('  TRNECS--tcx_dg,bk for comp:',i3,2f10.6,' by ',a3)
c        end if
        end if
        if (htcx(j)(1:2).eq.'EC' ) then
c  dilute-gas and internal contributions for component j
          etadg(j)=ETA0DG(j,t)
          tcxin(j)=FINT(j,t)*etadg(j)/wmas(j)*(CP0K(j,t)-2.5d0*R)
          tcxdg(j)=1.0d-3*15.0d0*R*etadg(j)/(4.0d0*wmas(j))
          tcx0=tcxin(j)+tcxdg(j)
c  get ECS value for pure fluid j with respect to its own reference fluid
c  not necessarily the same as the mixture; only residual part needed.
          CALL pTRNEC (j,tJ,rhoJ,etaj,tcxJ,ierr,herr,-j)
c       write (*,1228) j,tcx0,tcxj
c1228   format ('  TRNECS--tcx_dg,bk: comp:',i3,2f10.6,' by ECS')
        end if

        if (tcxj.gt.1.0d-16) then
          gj=tcx0b/tcxj*SQRT(fj(j))/hj(j)**(2.0d0/3.0d0)
        else
c  avoid possibility of division by zero (e.g. zero density as input)
cc        gj=SQRT(wmas(irefn)/wmas(j))*SQRT(fj(j))/hj(j)**(2.0d0/3.0d0)
          tcxj=1.0d-16
          gj=tcx0b/tcxj*SQRT(fj(j))/hj(j)**(2.0d0/3.0d0)
        end if
        xmj(j)=gj*gj*wmas(irefn)
        endif
c     write (*,1254) j,tcxj,tcx0b,xmj(j)
c1254 format (1x,' TRNECS--j,tcxj,tcx0,xmj(j) for t.c.:  ',i4,3f12.6)
      enddo
c
      do j=1,nc
        if (x(j).gt.0.d0) then
        Ajisum=0.0d0
        do i=1,nc
          if (x(i).gt.0.d0) then
            if (i.ne.j) then
              xmij=2.0d0*xmj(i)*xmj(j)/(xmj(i)+xmj(j))
              fij=SQRT(fj(j)*fj(i))*(1.0d0-xkijk(i,j))
              hij=0.125d0*(hj(j)**(1.0d0/3.0d0)+hj(i)**(1.0d0/3.0d0))**3
     &           *(1.0d0-xlijk(i,j))
            else
              xmij=xmj(i)
              fij=fj(i)
              hij=hj(j)
            endif
c         gxsum6=gxsum6+x(j)*x(i)*SQRT(fij*xmij)*hij**(4.0d0/3.0d0)
          gxsum=gxsum+x(i)*x(j)*SQRT(fij/xmij)*hij**(4.0d0/3.0d0)
c  mixing rule for the internal contribution (version 6.0--superceded)
c         tinsum=tinsum
c    &      +x(i)*x(j)*2.0d0*tcxin(i)*tcxin(j)/(tcxin(i)+tcxin(j))
c  Mason & Saxena modification of Wassiljewa mixing rule
c  allow constant out front to change depending on fluid system
          if (i.ne.j) then
            Aji=(1.0d0-xaji(j,i))*(1.0d0+SQRT(etadg(j)/etadg(i))
     &         *(wmas(j)/wmas(i))**0.25d0)**2
     &         /SQRT(8.0d0*(1.0d0+wmas(j)/wmas(i)))
          else
            Aji=1.d0
          endif
          Ajisum=Ajisum+x(i)*Aji
          endif
        enddo
        tdgMSW=tdgMSW+x(j)*(tcxin(j)+tcxdg(j))/Ajisum
c  assume dilute-gas part is simple mole-fraction average--superceded
c       tdgsum=tdgsum+x(j)*tcxdg(j)
        endif
      enddo
c  mixing rule in version 6.0--superceded
c     gxroot=SQRT(wmas(0)*fx)*hx**(4.0d0/3.0d0)/gxsum6
c     Flam6=SQRT(fx)*hx**(-2.0d0/3.0d0)*gxroot
c  above two lines reduce to:
c     Flam6=fx*hx**(2.0d0/3.0d0)*SQRT(wmas(0))/gxsum6
c
c  alternative interpretation from Ely & Hanley Tech Note (1981)
c     gxroot=SQRT(wmas(0)/fx)*hx**(-4.0d0/3.0d0)*gxsum
c     Flam=SQRT(fx)*hx**(-2.0d0/3.0d0)*gxroot
c  above two lines reduce to:
      Flam=SQRT(wmas(irefn))/hx**2*gxsum
c
c     tcx6=tcx0b*Flam+tinsum+tdgsum  !version 6.0 superceded
c     write (*,*) ' TRNECS--tcx0b,Flam,tdgMSW:  ',tcx0b,Flam,tdgMSW
C
C     compute correction factor loosely based on Ind. Eng. Chem. Fundam. 22(1):90-97 (1983)
C     mixture ref fluid not necessarily the same as pures
c     with individual correction factors for all pure this is not necessary
c      zcmix=0.
c      do ii=1,nc
c        zcmix=x(ii)*zcrit(ii)+zcmix
c      enddo
c      zrat=zcrit(irefn)/zcmix
c      bigx=zrat**1.5
c      tcx=tcx0b*Flam*bigX+tdgMSW
c
       tcx=tcx0b*Flam+tdgMSW
c
c     process out of correlation limits errorc
c     if(ierrs.ne.0)then
c       ierr=ierrs
c       herr=herrs
c     endif
      RETURN
      end                                             !subroutine TCBKMX
c
c ======================================================================
c
      subroutine SETTRN (nread,icomp,hcasno,hreff,heoss,hvs,htc,
     &                   ierr,herr)
c
c  set up working arrays for the ECS transport property model
c
c  inputs:
c    nread--file to read data from
c           <= 0 get data from block data
c           >0 read from logical unit nread (file should have already
c              been opened and pointer set by subroutine SETUP)
c    icomp--component number in mixture (1..nc); 1 for pure fluid
c   hcasno--CAS number of component icomp (not req'd if reading from file)
c
c  outputs:
c     hreff--file containing reference fluid EOS (character*255)
c     heos--model ('BWR', etc) for reference fluid EOS (character*3)
c     hvs--model ('VS1', etc) for ref fluid viscosity (character*3)
c     htc--model ('TC1', etc) for ref fluid conductivity (character*3)
c     ierr--error flag:  0 = successful
c                        1 = error (e.g. fluid not found)
c     herr--error string (character*255 variable if ierr<>0)
c     other quantities returned via arrays in common /WCFBWR/
c
c  written by S. Klein, NIST Thermophysics Division, Boulder, Colorado
c  12-14-95 SAK, original version
c  03-13-96  MM, add Zcrit to common /CCON/, change parameter n0=-ncmax,
c                other modifications
c  03-05-97  MM, new commons to match with new version of TRNECS
c  08-19-97  MM, get rid of herr=herr (avoid warning); flag nread<=0
c  09-04-97  MM, add second polynomial fit (w/ crossover t or rho)
c  10-24-97  MM, read in f_int term in Eucken correlation in ECS method for t.c.
c  10-28-97  MM, read in f_int only for fluid file version no >= 6.001
c  07-08-98 EWL, change character strings from *80 to *255
c  12-01-98 EWL, add Reos and triple point pressure and density to /CCON/
c  11-15-01 MLH, allow ecs to read critical enhancement model
c
      include 'commons.for'
      include 'comtrn.for'
      character*3 heoss,hvs,htc
      character*12 hcasno
      character*255 hreff
      character*255 herr
c
      if (nread.le.0) then
        ierr=101
        write (herr,1101) nread,hcasno,hnull
        call ERRMSG (ierr,herr)
 1101   format ('[SETTRN error 101] illegal file specified; nread = ',
     &          i4,'; CAS no. = ',a12,a1)
        RETURN
      end if
c
c  read data from file
c     write (*,*) ' SETTRN--read component',icomp,' from unit',nread
      read (nread,*) tmecst(icomp)              !lower temperature limit
      read (nread,*) txecst(icomp)              !upper temperature limit
      read (nread,*) pxecst(icomp)              !upper pressure limit
      read (nread,*) Dxecst(icomp)            !upper density limit
      read (nread,2083) heoss,hreff    !reference fluid EOS and .fld file
      read (nread,2003) hvs          !reference fluid viscosity model
      read (nread,2003) htc          !reference fluid conductivity model
      read (nread,*) iLJflag(icomp)   !Lennard-Jones flag
      read (nread,*) sigtrn(icomp)    !Lennard-Jones coef Sig
      read (nread,*) epsktr(icomp)     !Lennard-Jones coef EPS
c     write (*,*) ' SETTRN--L-J parameters:  ',sigtrn(icomp),epsktr(icomp)
c
c  read number of terms for f_int in Eucken correlation
c     write (*,*) ' SETTRN--icomp, version #: ',icomp,verfl(icomp)
      if (verfl(icomp).ge.6.0009d0) then
        read (nread,*) nEuck(icomp)
        if (nEuck(icomp).ge.1) then
c  read polynomial term(s) for f_int
          do j=1,nEuck(icomp)
c  read coeff, power of T, spare1, spare2
            read (nread,*) (cEuck(icomp,j,k),k=1,4)
c         write (*,*) ' SETTRN--Eucken par:',(cEuck(icomp,j,k),k=1,2)
          enddo
        end if
      else
        nEuck(icomp)=0
      end if
c
c  read number of terms for viscosity shape factor (incl. spare)
      read (nread,*) npsi1(icomp),npsi2(icomp),npsi3(icomp)
      if (npsi1(icomp).ge.1) then
c  read polynomial term
        do j=1,npsi1(icomp)
c  read coeff, power of Tr, power of Dr, spare
          read (nread,*) (cpsi(icomp,j,k),k=1,4)
c       write (*,*) ' SETTRN--psi par:  ',(cpsi(icomp,j,k),k=1,3,2)
        enddo
      end if
      if (npsi2(icomp).ge.1) then
c  read coeff, power of Tr, power of Dr, spare for 2nd polynomial term
c  first set of coeff is crossover (t or rho)
        do j=npsi1(icomp)+1,npsi1(icomp)+npsi2(icomp)
          read (nread,*) (cpsi(icomp,j,k),k=1,4)
        enddo
      end if
c
c  ditto for thermal conductivity shape factor
      read (nread,*) nchi1(icomp),nchi2(icomp),nchi3(icomp)
      if (nchi1(icomp).ge.1) then
        do j=1,nchi1(icomp)
c  read coeff, power of Tr, power of Dr, spare
          read (nread,*) (cchi(icomp,j,k),k=1,4)
c       write (*,*) ' SETTRN--chi par:  ',(cchi(icomp,j,k),k=1,3,2)
        enddo
      end if
      if (nchi2(icomp).ge.1) then
c  read coeff, power of Tr, power of Dr, spare for 2nd polynomial term
c  first set of coeff is crossover (t or rho)
        do j=nchi1(icomp)+1,nchi1(icomp)+nchi2(icomp)
          read (nread,*) (cchi(icomp,j,k),k=1,4)
        enddo
      end if
c
c     read pointer to enhancement model for ecs
      read (nread,2003) htcxcrecs(icomp)

      RETURN
 2003 format (a3)
 2083 format (a3,1x,a255)
      end                                             !subroutine SETTRN
c
c ======================================================================
c
      function FINT (icomp,t)
c
c  factor f_int appearing in Eucken correlation for thermal conductivity
c
c  inputs:
c    icomp--component number in mixture (1..nc); 1 for pure fluid
c        t--temperature [K]
c  output (as function value):
c     FINT--the factor f_int
c
c  written by M. McLinden, NIST Phys & Chem Properties Div, Boulder, CO
c  10-24-97  MM, original version
c
      include 'commons.for'
      include 'comtrn.for'
c
      if (nEuck(icomp).le.0) then
c  no correlation for f_int is present, use value corresponding to
c  modified Eucken correlation
        FINT=1.32d-3
      else
        fsum=0.0d0
        do k=1,nEuck(icomp)
          fsum=fsum+cEuck(icomp,k,1)*t**cEuck(icomp,k,2)
        enddo
        FINT=fsum
      end if
c     write (*,*) ' FINT--t,f_int:  ',t,FINT
c
      RETURN
      end                                                 !function FINT
c
c ======================================================================
c
      function PSI (icomp,tr,rhor)
c
c  viscosity shape factor for a pure fluid or mixture component, as
c  defined by:  Klein et al., Int J Refrigeration 20:208-217 (1997)
c
c  inputs:
c    icomp--component number in mixture (1..nc); 1 for pure fluid
c       tr--reduced temperature; = t/tc for a pure fluid
c                                = (t/fx)/(tc_j/fj) for a mixture
c     rhor--reduced density;     = rho/rhoc for a pure fluid
c                                = rho*hx/(hj*rhoc_j) for a mixture
c  output (as function value):
c      psi--the viscosity shape factor, i.e. an additional factor entering
c           into the definition of the conformal density in the ECS method
c           such that:  rho_0 = rho*hj*psi
c
c  written by M. McLinden, NIST Phys & Chem Properties Div, Boulder, CO
c  03-05-97  MM, original version
c  09-04-97  MM, add second polynomial fit (w/ crossover t or rho)
c  10-24-97  MM, changes in /WNTTRN/ to accommodate Eucken correlation
c
      include 'commons.for'
      include 'comtrn.for'
c
      i=icomp
      if (npsi1(i).le.0) then
c  no transport shape factor is present
        PSI=1.0d0
      else
        psisum=0.0d0
        if (npsi2(i).ge.2) then
c  a second polynomial term is present; check whether input (t or rho)
c  is below the crossover value (k = 1,2 in cpsi(i,npsi1(i)+1,k));
c  this term allows for a piece-wise fit of PSI
          nz=npsi1(i)+1
          if (tr.lt.cpsi(i,nz,1) .or. rhor.lt.cpsi(i,nz,2)) then
            do k=nz+1,npsi1(i)+npsi2(i)
             psisum=psisum+cpsi(i,k,1)*tr**cpsi(i,k,2)*rhor**cpsi(i,k,3)
            enddo
            PSI=psisum
            RETURN
          end if
        end if
c  apply the first polynomial term (either it's the only one present
c  or the 2nd polynomial term does not apply)
        do k=1,npsi1(i)
          if (rhor.gt.0) then
            psisum=psisum+cpsi(i,k,1)*tr**cpsi(i,k,2)*rhor**cpsi(i,k,3)
          else
            psisum=psisum+cpsi(i,k,1)*tr**cpsi(i,k,2)
          endif
        enddo
        PSI=psisum
      end if
c     write (*,*) ' PSI:  ',PSI
c
      RETURN
      end                                                  !function PSI
c
c ======================================================================
c
      function CHI (icomp,tr,rhor)
c
c  thermal conductivity shape factor for a pure fluid or mixture
c  component, analogous to the viscosity shape factor defined by
c  Klein et al., Int J Refrigeration 20:208-217 (1997)
c
c  inputs:
c    icomp--component number in mixture (1..nc); 1 for pure fluid
c       tr--reduced temperature; = t/tc for a pure fluid
c                                = (t/fx)/(tc_j/fj) for a mixture
c     rhor--reduced density;     = rho/rhoc for a pure fluid
c                                = rho*hx/(hj*rhoc_j) for a mixture
c  output (as function value):
c      chi--thermal conductivity shape factor, i.e. an additional factor
c           entering into the definition of the conformal density in
c           the ECS method such that:  rho_0 = rho*hj*psi
c
c  written by M. McLinden, NIST Phys & Chem Properties Div, Boulder, CO
c  03-05-97  MM, original version
c  09-04-97  MM, add second polynomial fit (w/ crossover t or rho)
c  10-24-97  MM, changes in /WNTTRN/ to accommodate Eucken correlation
c
      include 'commons.for'
      include 'comtrn.for'
c
      i=icomp
      if (nchi1(i).le.0) then
c  no transport shape factor is present
        CHI=1.0d0
      else
        chisum=0.0d0
        if (nchi2(i).ge.2) then
c  a second polynomial term is present; check whether input (t or rho)
c  is below the crossover value (k = 1,2 in cchi(i,nchi1(i)+1,k));
c  this term allows for a piece-wise fit of CHI
          nz=nchi1(i)+1
          if (tr.lt.cchi(i,nz,1) .or. rhor.lt.cchi(i,nz,2)) then
            do k=nz+1,nchi1(i)+nchi2(i)
             chisum=chisum+cchi(i,k,1)*tr**cchi(i,k,2)*rhor**cchi(i,k,3)
            enddo
            CHI=chisum
            RETURN
          end if
        end if
c  apply the first polynomial term (either it's the only one present
c  or the 2nd polynomial term does not apply)
        do k=1,nchi1(i)
          if (rhor.gt.0) then
            chisum=chisum+cchi(i,k,1)*tr**cchi(i,k,2)*rhor**cchi(i,k,3)
          else
            chisum=chisum+cchi(i,k,1)*tr**cchi(i,k,2)
          endif
        enddo
        CHI=chisum
      end if
c     write (*,*) ' CHI:  ',CHI
c
      RETURN
      end                                                  !function CHI
c
c ======================================================================
c
      subroutine TCKVIR (icomp,t,tcx0,tcxcol,tcxvir,ierr,herr)
c
c  thermal conductivity virial coefficient for a pure fluid or mixture
c  component, based on:
c    Nieto de Castro, C.A., Friend, D.G., Perkins, R.A. and Rainwater,
c    J.C. (1990). Thermal conductivity of a moderately dense gas.
c    Chemical Physics  145: 19-26.
c  equation numbers in the comments refer to this paper
c
c  inputs:
c    icomp--component number in mixture (1..nc); 1 for pure fluid
c        t--temperature [K]
c  output (as function value):
c     tcx0--dilute gas thermal conductivity [W/m-K]
c   tcxcol--contribution of collisions to the dilute-gas t.c. [W/m-K]
c   tcxvir--thermal conductivity second virial coefficient [L/mol];
c           i.e. the multiplier times the collisional part of the dilute-
c           gas conductivity which gives the initial density dependence
c           of that part of the thermal conductivity
c     ierr--error flag:  0 = successful
c                      <>0 = error code originating in TCXK0
c     herr--error string (character*255 variable if ierr<>0)
c
c  written by M. McLinden, NIST Phys & Chem Properties Div, Boulder, CO
c  09-24-97  MM, original version
c  10-24-97  MM, fint is now f(T) rather than const = 1.32d-3
c  10-26-06  MLH, changed htcx(1) to htcx(icomp)
c
      include 'commons.for'
      include 'comtrn.for'
      character*255 herr
c
      ierr=0
      herr=' '
c
      etadg=ETA0DG(icomp,t)
      tcxcol=1.0d-3*15.0d0*R*etadg/(4.0d0*wmas(icomp))            !Eq 7
      if (htcx(icomp)(1:2).eq.'EC') then
c  component is modeled with ECS--use generalized function for internal
c  contributions to t.c.
c       tcxint=1.32d-3*etadg/wmas(icomp)*(CP0K(icomp,t)-2.5d0*R)
        tcxint=FINT(icomp,t)*etadg/wmas(icomp)*(CP0K(icomp,t)-2.5d0*R)
        tcx0=tcxcol+tcxint
      else
c  use fluid-specific correlation
        call TCXK0 (icomp,t,tcx0,ierr,herr)
      end if
      if (abs(epsktr(icomp)).lt.1.d-20) return
      tstar=t/epsktr(icomp)
      bprime=(2.9749d0+0.1140d0*tstar)/(tstar-0.04953d0)        !Eq 12
      blam=(bprime-0.625d0*(tcx0/tcxcol-1.0d0))/(tcx0/tcxcol)
c  Eq 3, where the const = 2*pi*N0/3 *1d-27 (sigtrn in nm) *1d3 (vol in L)
      tcxvir=blam*1.26127336d0*sigtrn(icomp)**3
c
      RETURN
      end                                             !subroutine TCKVIR
c
c ======================================================================
c
      subroutine ECSLIM (t,D,tmin,tmax,Dmax,lerrt,lerrD,terr,Derr)
c
c  check input t,rho against limits and return error flags
c
c  inputs:
c        t--temperature [K]
c        D--molar density [mol/L]
c     tmin--minimum temperature for model [K]
c     tmax--maximum temperature [K]
c     Dmax--maximum density [mol/L]
c  outputs:
c    lerrt--logical flag; .true. if t outside limits, set only if .true.
c    lerrD--logical flag; .true. if D outside limits, set only if .true.
c     terr--same as input t, but set only if lerrt = .true.
c     Derr--same as input D, but set only if lerrD = .true.
c
c  written by M. McLinden, NIST Phys & Chem Properties Div, Boulder, CO
c  03-24-97  MM, original version
c  01-27-00 EWL, add check for nitrogen: no bounds checking on temperature
c  07-09-08 MLH, no upper temp bounds checking
c
      include 'commons.for'
      include 'comtrn.for'
      logical lerrt,lerrD
c
      if (D.gt.Dmax) then
        lerrD=.true.
        Derr=D
      end if
c
c  Nitrogen has no limits:
      if (hcas(izero0).eq.'7727-37-9' .and. t.gt.0.0d0) RETURN
c
c     if (t.gt.1.5d0*tmax .or. t.lt.tmin) then
      if (t.lt.tmin) then
       lerrt=.true.
        terr=t
      end if
c
      RETURN
      end                                             !subroutine ECSLIM
c
c ======================================================================
c
      function ETA0DG (icomp,t)
c
c  dilute-gas contribution to viscosity for use with ECS model
c
c  inputs:
c    icomp--component number in mixture (1..nc); 1 for pure fluid
c        t--temperature [K]
c  output (as function value):
c   eta0dg--the dilute-gas part of the viscosity [uPa-s]
c
c  written by M. McLinden, NIST Phys & Chem Properties Div, Boulder, CO
c  08-25-97  MM, original version, based on ETA1 function by S.A. Klein
c  12-01-98 EWL, add Reos and triple point pressure and density to /CCON/
c
      include 'commons.for'
      include 'comtrn.for'
c
      ETA0DG=0.d0
      i=icomp
      tau=1.0d0
      if (abs(epsktr(i)).lt.1.d-20) return
      tau=t/epsktr(i)
c  in this case, the dilute gas is simply the Chapman-Enskog term
      if (abs(sigtrn(i)).gt.1.d-20)
     &ETA0DG=26.692d-3*SQRT(wmas(i)*t)/(sigtrn(i)**2*OMEGAS(2,2,tau))
c    write (*,1001) i,t,tau,ETA0DG
c1001  format (1x,' ETA0DG--dilute-gas visc: i,t,tau,eta',i4,2f9.4,f12.6)
c    write (*,*) ' ETA0DG--sigtrn,omega_2,2:  ',sigtrn(i),OMEGAS(2,2,tau)
c
      RETURN
      end                                               !function ETA0DG
c
c ======================================================================
c
      function OMEGAS (il,is,tau)
c
c  collision integral for Lennard-Jones fluid; returns value for
c  Omega_1,1 or Omega_2,2; based on:
c  Neufeld, Janzen, and Aziz. (1972). J Chem Phys 57:1100-1102
c
c  inputs:
c       il--order of integral
c       is--order of integral
c      tau--dimensionless temperature = t/epsktr, where epsktr is the Lennard-
c           Jones energy parameter (epsilon/k)
c  output (as function value):
c   OMEGAS--value of collision integral
c
c     N.B.--only inputs of (il = is = 1) and (il = is = 2) are valid
c
c  originally implemented in MIPROPS/SUPERTRAPP by J.F. Ely
c  08-25-97 MM, revised and documented by M. McLinden,
c               NIST Physical & Chemical Properties Div, Boulder, CO
c
      include 'commons.for'
      include 'comtrn.for'
c
      if (il.eq.1 .and. is.eq.1) then
        OMEGAS=1.06036d0/tau**0.15610d0
     &        +0.19300d0*EXP(-0.47635d0*tau)
     &        +1.03587d0*EXP(-1.52996d0*tau)
     &        +1.76474d0*EXP(-3.89411d0*tau)
      else
        OMEGAS=1.16145d0/tau**0.14874d0
     &        +0.52487d0*EXP(-0.77320d0*tau)
     &        +2.16178d0*EXP(-2.43787d0*tau)
      end if
c     write (*,1001) il,is,tau,omegas
c1001 format (1x,' OMEGAS--il,is,tau,omega:  ',2i3,2f12.7)
c
      RETURN
      end                                               !function OMEGAS
c
c ======================================================================
c
      FUNCTION DELHSV (TX,DX,X,hj,irefn)
C
C     ENSKOG CORRECTION FOR SIZE AND MASS DIFFERENCE EFFECTS
C     IN MIXTURE VISCOSITY PREDICTION
C
C     BASED ON : J.F. ELY, J. RES. NBS 86(6) 1981, P597-604
C     11-06-01 MLH changed calls to CBRT to CBRTX to avoid compiler complaints
C     03-18-02 MLH changed 200 (propane value) to VC0REF (ref fluid crit vol)
C     06-15-04 MLH corrected units
C     07-22-05 MLH allow selection of alternative ref fluid
c     11-30-06 mlh revised to allow negative values, and scaled so that n2 matches Reid et al.
C
      include 'commons.for'
      include 'comtrn.for'
      dimension hj(ncmax)
      DIMENSION X(nx), Z(nx), S(nx), SIGM(nx,nx)
      DIMENSION SIGDUM(nx,nx), CMWDUM(nx), ZDUM(nx)
      DIMENSION CMW(ncmax)
      parameter (DCON=6.023D-4, IONE=1)
C
      SIGDUM(1,1) = 1.0D0
      CMWDUM(1)   = 1.0D0
      ZDUM(1)     = 1.0D0
      CMWN = wmas(NC)
      DO N = 1, NC
        CMW(N)=wmas(N)
        Z(N) = X(N)
        IF (X(N).LE.0.0D0) Z(N) = 1.0D-8
        VC0REF=1000.0D0/Dcrit(irefn)
C     VC0REF is reference fluid critical volume, cm3/mol
c       S(N) = CBRTX(VC0REF * hj(N)/(3.058D0 * 0.6023D0) )
C       ORIGINAL ELY MATCHED METHANE WITH METHANE REF FLUID
C       REVISE TO MATCH NITROGEN WITH NITROGEN REF FLUID 3.798 FROM REID ET AL.
        S(N) = CBRTX(VC0REF * HJ(N)/(2.71D0 * 0.6023D0) )
        CMW(N) = CMW(N) / CMWN
      ENDDO
C
      SN = S(NC)
      DO N = 1, NC
        S(N) = S(N) / SN
      ENDDO
      RHOX = DCON * DX * SN**3
      SIG1 = 0.0D0
      CMW1 = 0.0D0
      DO I=1,NC
        SI = 0.0D0
        CI = 0.0D0
        DO J = 1,NC
          SIJ = 0.5D0 * (S(I) + S(J))
          TERM = Z(J) * SIJ**3
          SI = SI + TERM
          CI = CI + SIJ * TERM * SQRT(CMW(I) * CMW(J) / (CMW(I)+CMW(J)))
          SIGM(I,J) = SIJ
          ENDDO
        SIG1 = SIG1 + Z(I) * SI
        CMW1 = CMW1 + Z(I) * CI
      ENDDO
      TERM = CBRTX(SIG1)
      CMW1 = 2.0D0 * CMWN * (CMW1 / (SIG1 * TERM ))**2
      SIG1 = SN * TERM
      RHO1 = DCON * DX * SIG1**3
C
c  change arg from nc -> ncc (should not pass element in common)
      ncc=NC
      CALL ENSKOG(ncc,RHOX,SIGM,CMW,Z,VISX)
      VIS0 = 26.692D-3 * SQRT(CMWN*TX) / (SN * SN)
      VISX = VIS0 * VISX
C
      CALL ENSKOG(IONE,RHO1,SIGDUM,CMWDUM,ZDUM,VIS1)
      VIS0 = 26.692D-3 * SQRT(CMW1*TX) / (SIG1*SIG1)
      VIS1 = VIS0 * VIS1
      DO N = 1, NC
        CMW(N) = CMW(N) * CMWN
      ENDDO
C
      DELHSV = VISX - VIS1
      DELHSV=DELHSV*100.0D0  !convert to uPa.s
C     IF(delhsv.lt.0)delhsv=0.d0
C     OK TO LET CORRECTION BE NEGATIVE
      RETURN
      END                                               !function DELHSV
c
c ======================================================================
c
      SUBROUTINE ENSKOG (N,RHO,SIGM,CMW,X,ETA)
      include 'commons.for'
      include 'comtrn.for'
      double precision MJI
      DIMENSION SIGM(nx,nx), CMW(nx), X(nx), Y(nx)
      DIMENSION H(nx,21), S(nx,nx)
      SAVE
      parameter (PI6=0.523598776D0)
C
C                        PRELIMINARY CALCULATIONS
      ETA = 0.0D0
      TERM = RHO * PI6
      S2 = 0.0D0
      S3 = 0.0D0
      DO I=1,N
        TEMP = X(I) * TERM * SIGM(I,I)**2
        S2 = S2 + TEMP
        S3 = S3 + TEMP * SIGM(I,I)
      ENDDO
      S3 = 1.0 - S3
      A1 = S3 * S3
      A2 = S3 * S2
      A3 = S2 * S2
      A4 = S3 * A1
C
      DO I = 1, N
        Y(I) = 0.0
        ETA2 = 0.0
        DO J = 1, N
          S2 = SIGM(I,I) * SIGM(J,J) / (SIGM(I,I) + SIGM(J,J))
          S3 = 2.0 * S2 * S2
          S2 = 3.0 * S2
          BIJ = 4.0 * PI6 * RHO * SIGM(I,J)**3
          YIJ = BIJ * (A1 + A2*S2 + A3*S3) / A4
          MJI = CMW(J) / (CMW(I) + CMW(J))
          EIJ = BIJ * SQRT(2.0D0 * CMW(I) * MJI) / SIGM(I,J)**2
          Y(I) = Y(I) + X(J) * MJI * YIJ
          ETA2 = ETA2 + X(J) * EIJ * YIJ
          S(I,J) = X(J) * YIJ * MJI * MJI / EIJ
        ENDDO
        Y(I) = X(I) * (1.0D0 + 0.8D0 * Y(I))
        ETA = ETA + X(I) * ETA2
      ENDDO
C                        GENERATE THE H MATRIX
      DO I = 1, N
      DO J = 1, N
        S2 = 0.0D0
        A1 = 0.0D0
        IF (J.EQ.I) A1 = 1.0D0
        DO K = 1, N
          RATIO = CMW(I) / (3.0D0 * CMW(K))
          A2 = 0.0D0
          IF (K.EQ.J) A2 = 2.0D0
          TERM = A1 * (1.0D0 + 5.0D0 * RATIO) - A2 * RATIO
          S2 = S2 + S(I,K) * TERM
        ENDDO
        H(I,J) = 2.0D0 * X(I) * S2
      ENDDO
      ENDDO
C                        SOLVE FOR THE EXPANSION COEFFICIENTS
      N1 = N + 1
      IF (N.LE.1) THEN
        H(1,2) = Y(1) / H(1,1)
      ELSE
        DO I = 1, N
          H(I,N1) = Y(I)
        ENDDO
        DO I = 1, N
          I1 = I + 1
          DO J = I1, N1
            H(I,J) = H(I,J) / H(I,I)
          ENDDO
          H(I,I) = 1.0
          DO J = 1, N
            IF (J.NE.I) THEN
              DO K = I1, N1
                H(J,K) = H(J,K) - H(J,I) * H(I,K)
              ENDDO
              H(J,I) = 0.0D0
            ENDIF
          ENDDO
        ENDDO
      ENDIF
      ETA1 = 0.0D0
      DO I = 1, N
        ETA1 = ETA1 + H(I,N1) * Y(I)
      ENDDO
      ETA = ETA1 + 8.0D0 * ETA / (25.0D0 * PI6)
      RETURN
      END                                             !subroutine ENSKOG
c
c ======================================================================
c
      function ETAMIX (t,x)
c
c  compute the viscosity of a dilute-gas mixture assuming the components
c  are described by a Lennard-Jones potential
c
c  inputs:
c        t--temperature [K]
c        x--composition array [mol frac]
c  outputs:
c      eta--viscosity [uPa.s]
c
c  source of original version lost to history (possibly J.F. Ely)
c  adopted for use in Refprop by S.A. Klein, January, 1996
c  08-25-97  MM, revised and documented by M. McLinden,
c                NIST Physical & Chemical Properties Div, Boulder, CO
c                name changed from ETA0 to ETAMIX
c  12-01-98 EWL, add Reos and triple point pressure and density to /CCON/
c  08-29-01 EWL, fix the mixture values at the pure fluid limits to the
c                pure fluid correlations.
c  12-11-06 MLH, implement alternative method to match pure fluid ends,
c                add interaction parameters
c  05-27-08 MLH, add one more binary int par for dilute gas viscosity xdij in trnbin
c  06-12-08 MLH, revised empirical correction for binaries
c  04-27-10 EWL, add code to check for x(i)=0
c
      include 'commons.for'
      include 'comtrn.for'
      dimension x(ncmax),etai(ncmax)
      character*255 herr
      DIMENSION EOK(nx,nx), SIGM(nx,nx), RM(nx,nx), H(nx,nx+1)
      parameter (DCON=0.320300D0, VCON2=26.692D-3)
C
      ETAMIX=0.0D0
      NC1 = NC + 1
      DO I = 1, NC
      DO J = 1, NC1
        H(I,J) = 1.0D0
      ENDDO
      ENDDO
C
      DO I = 1, NC
      if (x(i).gt.0.d0) then
        DO J = 1, NC
          RM(I,J) = 2.0D0 * WMAS(I) * WMAS(J) / (WMAS(I) + WMAS(J))
          IF(I.EQ.J)then
           DIJS = 1.0D0
           DIJE = 1.0D0
          else
           DIJS = 1.0D0 - xljs(I,J)
           DIJE = 1.0D0 - xlje(I,J)
          endif
          EOK(I,J) = SQRT(epsktr(I) * epsktr(J)) * DIJE
          SIGM(I,J) = 0.5D0 * (sigtrn(I) + sigtrn(J)) * DIJS
        ENDDO
      endif
      ENDDO
C
      DO I = 1, NC
      if (x(i).gt.0.d0) then
      DO J = 1, NC
        if (x(j).gt.0.d0) then
        DIJ = 0.0D0
        IF (I.EQ.J) DIJ = 1.0D0
        SUML = 0.0D0
        DO K = 1, NC
          if (x(K).gt.0.d0) then
            IF (abs(EOK(I,K)).lt.1.d-20) return
            TS = T / EOK(I,K)
            TERM = SQRT(RM(I,K)*T) / SIGM(I,K)**2
            RHODIL = DCON * TERM / OMEGAS(1,1,TS)
            ETAIL  = VCON2 * TERM / OMEGAS(2,2,TS)
            IF (I.EQ.K) ETAI(I)=ETAIL
            DJL = 0.0D0
            IF (J.EQ.K) DJL = 1.0D0
            TERM=(RM(J,J)/(RHODIL*RM(K,K)))*(DIJ-DJL)+
     &            0.5D0*(DIJ+DJL)/ETAIL
            SUML = SUML + X(K) * RM(I,K) * RM(I,K) * TERM
          endif
        ENDDO
        H(I,J) = SUML / (RM(I,I) * RM(J,J))
        endif
      ENDDO
      endif
      ENDDO
C
      DO I = 1, NC
        if (x(i).gt.0.d0) then
        DO J = I+1, NC1
          H(I,J) = H(I,J) / H(I,I)
        ENDDO
        H(I,I) = 1.0D0
        DO J = 1, NC
          IF (J.NE.I .and. x(j).gt.0.d0) THEN
            DO K = I+1, NC1
              H(J,K) = H(J,K) - H(J,I) * H(I,K)
            ENDDO
            H(J,I) = 0.0D0
          ENDIF
        ENDDO
        endif
      ENDDO
c
c     additional empirical correction for binaries
      do i=1,nc
      if (x(i).gt.0.d0) then
      do j=1,nc
         if (i.ne.j) then
           if (x(j).gt.0.d0) then
c            xijpr=x(i)*x(j)
             xis=x(i)/(x(i)+x(j)) !scaled binary composition
             ff=1+xdij(i,j)*xis-(xdij(i,j)+xdij2(i,j))*xis**2
     &        +xdij2(i,j)*xis**3
             xijsum=x(i)+x(j)
             xijdif=1.0d0-xijsum
             h(i,nc1)=h(i,nc1)*ff*xijsum+h(i,nc1)*xijdif
           endif
         endif
      end do
      endif
      end do
C
c     Force the pure ends to match (individual correlation sometimes
c     does not use LJ but mixture always does)
      ETAM = 0.0D0
      DO I = 1, NC
        if (x(i).gt.0.d0) then
        call ETAK0 (I,T,eta,ierr,herr)
        IF(ierr.eq.0) THEN
          ETAM = ETAM + X(I) * H(I,NC1)* eta/etai(i)
        ELSE
          ETAM = ETAM + X(I) * H(I,NC1)
        ENDIF
        endif
      ENDDO
      ETAMIX = ETAM
c
c     etamix = 0.0d0
c      do i=1,nc
c        call ETAK0 (i,t,eta,ierr,herr)
c        if (ABS(eta).lt.1.d-12) call ETAK (i,t,0.d0,eta,ierr,herr)
c        if (etai(i).ne.0.d0) ETAMIX=ETAMIX+x(i)*ETAM/etai(i)*eta
c      enddo
      RETURN
      END                                               !function ETAMIX
c ======================================================================
c
      subroutine CONFTD (j,amx,Zmix,tj,rhoj,ierr,herr)
c
c  Find the conformal temperature and density for component j (which
c  might be the reference fluid) which give a reduced residual Helmholtz
c  energy and compressibility which match the input value.  The system
c  of equations to be solved is thus:
c    aj(tj,rhoj) - amx = 0
c    Zj(tj,rhoj) - Zmix = 0
c  these are put into dimensionless temperature and density tau and del
c  and linearized to the form:
c    (da/dtau)*deltau + (da/ddel)*deldel = amx - aj(tj,rhoj)
c    (dZ/dtau)*deltau + (dZ/ddel)*deldel = Zmix - Zj(tj,rhoj)
c  to allow a solution by the classic Newton-Raphson method in two
c  dimensions.  In the following code, the above nomenclature becomes:
c    a11*x1 + a12*x2 = fx1
c    a21*x1 + a22*x2 = fx2
c
c  inputs:
c        j--component number
c           j = 0:  find conformal conditions for reference fluid
c           j > 0:  find conformal conditions for component j
c     amx--reduced residual Helmholtz energy (A - A*)/RT [-]
c     Zmix--compressibility (pV/RT) [-]
c       tj--initial guess for conformal temperature for component j [K]
c     rhoj--initial guess for conformal density for component j [mol/L]
c  outputs:
c       tj--converged conformal temperature for component j [K]
c     rhoj--converged conformal density for component j [mol/L]
c     ierr--error flag:  0 = successful
c                      -58 = did not converge
c     herr--error string (character*255 variable if ierr<>0)
c
c  written by M. McLinden, NIST Phys & Chem Properties Div, Boulder, CO
c  09-29-97  MM, original version, replaces MINH by S.A. Klein
c  01-13-98  MM, check for error from CONFD in case CONFTD does not converge
c  12-01-98 EWL, add Reos and triple point pressure and density to /CCON/
c  11-22-99 EWL, increase itmax from 25 to 50 for better vapor convergence
c   1-24-00 EWL, increase itmax from 50 to 200 for better vapor convergence
c   1-31-00 EWL, increase maximum change from 5% to 20%
c  11-06-01 MLH, added check to see if alternative solution from CONFD actually is a root
c                further study on this needed, as there are multiple solutions to the eqn.
c  11-21-01 MLH, check that solution is reasonable (t not too high)
c  12-04-01 MLH, deactivate alternative solution mode
c  06-28-02 LV,  correct dz/ddel
c  09-06-04 MLH, on nonconvergence, do not return initial guess- return actual value
c  12-25-06 MLH, allow up to twice max t
c
      include 'commons.for'
      include 'comtrn.for'
      character*255 herr
      parameter (itmax=200)
      parameter (tolf=1.0d-7)  !convergence tol for function evaluations
      parameter (tolx=1.0d-12) !tolerance for step in independent variables
c
c  save initial guesses in case of non-convergence
c      tjsav=tj
c      rhojsv=rhoj
c  set maximum acceptable temperature
      tjmax=1.10*txecst(j)  !allow small extrapolation above max T
c  find the reducing ratios for component j
      tredj=tz(j)
      Dredj=rhoz(j)
c     write (*,*) ' CONFTD--reducing t,rho: ',tredj,Dredj
      x1=tredj/tj       !tauj (dimensionless temperature)
      x2=rhoj/Dredj     !delj (dimensionless density)
c     write (*,1788) j,tj,rhoj,x1,x2
c1788 format (1x,' CONFTD--input j,tj,rhoj: ',i2,2e14.6,
c    &           '; resulting tau,del: ',2e14.6)
c  begin iteration
      do 800 it=0,itmax
c  check for reasonableness of guess by means of derivative dP/d(rho)
c  [actually, the quantity calculated is (1/RT)*(dP/drho)]
      phi00=PHIK(j,0,0,x1,x2)
      phi01=PHIK(j,0,1,x1,x2)
      phi02=PHIK(j,0,2,x1,x2)
      dpdrho=1.0d0+2.0d0*phi01+phi02
      if (dpdrho.lt.0.0d0) then
c     write (*,1799) j,it,x1,x2,dpdrho
c1799 format (' CONFTD--j,it,tau,del: (dpdrho < 0),dP/dD: ',2i3,2e15.6,
c    &        30x,e15.6)
        if (x2*Dredj.gt.Dcrit(j)) then
c  liquid-phase, go to higher density
          x2=1.04d0*x2
        else
c  vapor-phase, go to higher temperature (lower tau)
          x1=0.96d0*x1
        end if
        goto 800        !use up one iteration (avoid infinite loop)
      end if
c  evaluate objective function
      fx1=amx-phi00
      fx2=Zmix-1.0d0-phi01
c     write (*,1800) j,it,x1,x2,fx1,fx2,dpdrho
c1800 format (' CONFTD--j,it,tau,del,amx-a,Zmix-Z,dP/dD: ',2i3,5e15.6)
c  check for convergence
      error1=ABS(fx1)+ABS(fx2)
      if (error1.lt.tolf) then
c  iteration has converged
        goto 840
      end if
c
c  calc remaining derivatives and new guess for independent variables
      phi10=PHIK(j,1,0,x1,x2)
      phi11=PHIK(j,1,1,x1,x2)
      a11=phi10/x1          !partial a w.r.t. tau
      a12=phi01/x2          !partial a w.r.t. del
      a21=phi11/x1          !partial Z w.r.t. tau
      a22=(phi02+phi01)/x2  !partial Z w.r.t. del
      denom=a11*a22-a21*a12
      if (ABS(denom).lt.1.0d-16) then
c  system has singularity, no solution for this guess, try another
        delx1=0.05d0*x1
        delx2=-0.05d0*x2
      else
        delx1=(a22*fx1-a12*fx2)/denom
        delx2=(a11*fx2-a21*fx1)/denom
      end if
      sumdel=ABS(delx1)+ABS(delx2)
c  do not allow too great a step (x1,x2 should always be positive)
c     write (*,'(8f12.6)') tredj/x1,dredj*x2,sumdel,error
      x1=x1+SIGN(1.0d0,delx1)*MIN(ABS(delx1),0.20d0*x1)
      x2=x2+SIGN(1.0d0,delx2)*MIN(ABS(delx2),0.20d0*x2)
c  if step is within tolerance, also consider iteration finished
      if (sumdel.lt.tolx) goto 840
  800 continue
c
c  iteration loop has not converged, try another scheme
      ierr=-58
      write (herr,1058) j,hnull
 1058 format ('[TRNECS warning 58] 2-D Newton-Raphson method for ',
     &        'conformal temperature and density did not converge ',
     &        'for component',i3,a1)
      call ERRMSG (ierr,herr)
c     write (*,1801) x1,x2,fx1,fx2
c1801 format (' CONFTD--2-D Newton''s method iteration did not',
c    &        ' converge; x1,x2,fx1,fx2: ',4e15.6)
c  go back to starting guesses for tj, rhoj
      ! not in use
      !tj=tjsav
      !rhoj=rhojsv
c
c     although the following code sometimes finds a root, it apparently is
c     not always and appropriate solution. Apparently there are multiple
c     roots. deactivate until method to determine correct root is found.
c     try alternative CONFD method
c     call CONFD (j,amx,Zmix,tj,rhoj,ierr1,herr1)
c     since confd just minimizes the function, doesn't actually find a root,
c     it may not satisfy original equation. Thus check to
c     see if it is a true solution before accepting it.
c     NOTE: there are known bugs with this procedure- there can be multiple roots
c           and it doesn't always get the correct one!
c      x1=tredj/tj       !tauj (dimensionless temperature)
c      x2=rhoj/Dredj     !delj (dimensionless density)
c      phi00=PHIK(j,0,0,x1,x2)
c      phi01=PHIK(j,0,1,x1,x2)
c      fx1=amx-phi00
c      fx2=Zmix-1.0d0-phi01
c      error2=ABS(fx1)+ABS(fx2)
c     accept only if it meets original criteria and t is not too high
c      if ((error2.lt.tolf).AND.(tj.le.tjmax)) then
c        ierr=0
c        herr=' '
c      else
c        tj=tjsav      !return original guess of tj, rhoj
c        rhoj=rhojsv
c        ierr=-58
c        write (herr,1058) j,hnull
c        call ERRMSG (ierr,herr)
c      endif
c
c
c     the following code has been deactivated and superceded by the code above.
c     call CONFD (j,amx,Zmix,tj,rhoj,ierr1,herr1)
c     write (*,*) ' CONFTD--ierr,tj from CONFD: ',ierr1,tj
c     if (ierr1.ne.0) then
c       write (*,*) ' CONFD--did not converge; using initial tj,rhoj'
c        ierr=ierr1
c        herr=herr1
c        tj=tjsav
c        rhoj=rhojsv
c      end if
       GOTO 840
C      RETURN
c
c  iteration has converged, assign outputs
  840 continue
      tj=tredj/x1
      rhoj=x2*Dredj
c     check to make sure converged solution is reasonable
      if(tj.gt.2.0d0*tjmax)then
       ! tj=tjsav
       ! rhoj=rhojsv
        ierr=-58
        write (herr,1058) j,hnull
        call ERRMSG (ierr,herr)
      endif
c
      RETURN
      end                                             !subroutine CONFTD
c
c ======================================================================
c
      subroutine CONFD (j,amx,Zmix,tj,rhoj,ierr,herr)
c
c  Find the conformal temperature and density for component j (which
c  might be the reference fluid) which give a reduced residual Helmholtz
c  energy and compressibility which match the input value.  The quantity
c    FX = [a(tj,rhoj) - amx]**2 + [Z(tj,rhoj) - Zmix]**2
c  is minimized using Brent's method adapted from:
c    Press, W.H., Flannery, B.P., Teukolsky, S.A. and Vettering, W.T.
c    (1986).  Numerical Recipes:  The Art of Scientific Computing,
c    Cambridge University Press.
c  This minimization is in terms of density.  The single-dimension
c  Brent's method is extended to the two-dimensional problem here by an
c  auxiliary routine CONFT which finds the optimum conformal temperature
c  for a given guess of the conformal density.
c
c  inputs:
c        j--component number
c           j = 0:  find conformal conditions for reference fluid
c           j > 0:  find conformal conditions for component j
c     amx--reduced residual Helmholtz energy (A - A*)/RT [-]
c     Zmix--compressibility (pV/RT) [-]
c       tj--initial guess for conformal temperature for component j [K]
c     rhoj--initial guess for conformal density for component j [mol/L]
c  outputs:
c       tj--converged conformal temperature for component j [K]
c     rhoj--converged conformal density for component j [mol/L]
c     ierr--error flag:  0 = successful
c                      -58 = did not converge
c     herr--error string (character*255 variable if ierr<>0)
c
c  written by M. McLinden, NIST Phys & Chem Properties Div, Boulder, CO
c  09-26-97  MM, original version, based on MINH by S.A. Klein
c  01-24-00 EWL, decrease TOL to 1E-11
c  09-04-00 EWL, change variable R to RR to avoid conflict with R in Gcnst
c
      include 'commons.for'
      include 'comtrn.for'
      character*255 herr
      parameter (CGOLD=0.61803399, ZEPS=1E-20)
      parameter (TOL=1E-11, ITMAX=50)
c
      ierr=0
      herr=' '
      V=rhoj                           !first guess for rhoj
      A=0.80d0*rhoj                    !lower bound on rhoj
      B=1.20d0*rhoj                    !upper bound on rhoj
      W=V
      X=V
      E=0.0d0
      D=0.0d0
c  find the reducing ratios for component j
      tredj=tz(j)
      Dredj=rhoz(j)
c  find the optimum tj for the initial guess of rhoj and evaluate the
c  objective function FX
c     write (*,*) ' CONFD--j,tj input to CONFT, first iteration: ',j,tj
      tj0=tj    !save initial guess
      call CONFT (j,amx,rhoj,tj,ierr,herr)
      if (ABS(tj/tj0-1.0d0).ge.0.2) then
c  do not allow too great a change in tj
c       write (*,*) ' CONFD--unconstrained tj from CONFT: ',tj
        tj=tj0*(1.0d0+SIGN(0.2d0,tj/tj0-1.0d0))
      end if
c     write (*,*) ' CONFD--ierr,tj from CONFT:  ',ierr,tj
      tauj=tredj/tj
      delj=rhoj/Dredj
      aj=PHIK(j,0,0,tauj,delj)
      dela=amx-aj
      Zj=1.0d0+PHIK(j,0,1,tauj,delj)
      delZ=Zmix-Zj
      FX=dela**2+delZ**2
c     call DPDDK (j,tj,rhoj,dpdrho)             !debug only
c     write (*,1089) j,0,tj,rhoj,amx,aj,Zmix,Zj,dpdrho
c
      FV=FX
      FW=FX
      DO ITER=1,ITMAX
      XM=0.5d0*(A+B)
      TOL1=TOL*ABS(X)+ZEPS
      TOL2=2.0d0*TOL1
      IF (ABS(X-XM).LE.TOL2-0.5d0*(B-A)) THEN
        rhoj=X                !value which minimizes objective function
c       write (*,1099) j,amx,Zmix,tj,rhoj,FU
        RETURN
      ENDIF
      IF (ABS(E).GT.TOL1) THEN
        RR=(X-W)*(FX-FV)
        Q=(X-V)*(FX-FW)
        P=(X-V)*Q-(X-W)*RR
        Q=2.0*(Q-RR)
        IF (Q.GT.0.0d0) P=-P
        Q=ABS(Q)
        ETEMP=E
        E=D
        IF ((ABS(P).GE.ABS(0.5d0*Q*ETEMP)).or.(P.LE.Q*(A-X)).or.
     &        (P.GE.Q*(B-X))) THEN
          IF (X.GE.XM) THEN
             E=A-X
          else
             E=B-X
          endif
          D=CGOLD*E
        else
          D=P/Q     !Parabolic step
          U=X+D
          IF ((U-A.LT.TOL2).or.(B-U.LT.TOL2)) D=SIGN(TOL1,XM-X)
        endif
      else
        IF (X.GE.XM) THEN
          E=A-X
        else
          E=B-X
        endif
        D=CGOLD*E
      endif
      IF (ABS(D).GE.TOL1) THEN
        U=X+D
      else
        U=X+SIGN(TOL1,D)
      endif
c  find the optimum tj for the current guess of rhoj and evaluate the
c  objective function
      rhoj=U
c     write (*,*) ' CONFD--it,tj input to CONFT: ',iter,tj
      call CONFT (j,amx,rhoj,tj,ierr,herr)
c     write (*,*) ' CONFD--ierr,tj from CONFT:   ',ierr,tj
      tauj=tredj/tj
      delj=rhoj/Dredj
      aj=PHIK(j,0,0,tauj,delj)
      dela=amx-aj
      Zj=1.0d0+PHIK(j,0,1,tauj,delj)
      delZ=Zmix-Zj
c     call DPDDK (j,tj,rhoj,dpdrho)             !debug only
c     write (*,1089) j,ITER,tj,rhoj,amx,aj,Zmix,Zj,dpdrho
c1089 format (' CONFD--j,it,tj,rhoj,amx,aj,Zmix,Zj,dP/dD:  ',2i3,f9.3,
c    &        f10.5,2e14.6,2f9.5,e14.6)
      FU=dela**2+delZ**2
c
      IF (FU.LE.FX) THEN
        IF (U.GE.X) THEN
          A=X
        else
          B=X
        endif
        V=W
        FV=FW
        W=X
        FW=FX
        X=U
        FX=FU
      else
        IF (U.LT.X) THEN
          A=U
        else
          B=U
        endif
        IF ((FU.LE.FW).or.(ABS(W-X).LT.1.0D-12)) THEN
          V=W
          FV=FW
          W=U
          FW=FU
        else
          IF ((FU.LE.FV) .or. (ABS(V-W).LT.1.0D-12) .or.
     &        (ABS(V-X).LT.1.0D-12)) THEN
            V=U
            FV=FU
          endif
        endif
      endif
      ENDDO
      IERR=-58
      herr='[CONFD error 58] ECS-transport routines did not converge'//
     &     hnull
      call ERRMSG (ierr,herr)
c     write (*,1099) j,amx,Zmix,tj,rhoj,FU
c1099 format (' CONFD--j,A,Z,tj,rhoj,resid: ',i3,e14.6,f9.5,f9.3,f10.5,
c    &        e14.6)
      RETURN
      end                                              !subroutine CONFD
c
c ======================================================================
c
      subroutine CONFT (k,amx,rhok,tk,ierr,herr)
c
c  Find the conformal temperature for component k (including, possibly,
c  the reference fluid) which gives a reduced residual Helmholtz energy
c  which matches the input value.  The zero of the function
c    FX = [a(tk,rhok) - amx]
c  is found using a damped secant method combined with a reguli-falsi.
c  This routine is called from within CONFTD, and the value of rhok is
c  the current guess value from that routine.
c
c  inputs:
c        k--component number
c           k = 0:  find conformal conditions for reference fluid
c           k > 0:  find conformal conditions for component k
c     amx--reduced residual Helmholtz energy (A - A*)/RT [-]
c     rhok--conformal density for component k [mol/L]
c       tk--initial guess for conformal temperature for component k [K]
c  outputs:
c       tk--converged conformal temperature for component k [K]
c     ierr--error flag:  0 = successful
c                      -58 = did not converge
c     herr--error string (character*255 variable if ierr<>0)
c
c  written by M. McLinden, NIST Phys & Chem Properties Div, Boulder, CO
c  09-26-97  MM, original version, replaces MINF by S.A. Klein
c  01-13-98  MM, set damping ratio to 0.8 and constrain new guesses
c  01-24-00 EWL, decrease tolr to 1.0d-11
c
      include 'commons.for'
      include 'comtrn.for'
      character*255 herr
      logical lxneg,lxpos
      dimension x(3),fx(2)
      parameter (itmax=20)
      parameter (tolr=1.0d-11)    !convergence tolerance
      parameter (xdamp=0.8d0)    !damping (or acceleration) ratio, normal=1
c
      ierr=0
      herr=' '
c  find the reducing ratios for component k
      tredk=tz(k)
      Dredk=rhoz(k)
      delk=rhok/Dredk       !density is fixed for this iteration
c
c  begin iteration--the basic iteration is a secant method, but
c  positive and negative roots are stored, allowing use of slower, but
c  more robust, reguli-falsi method in event that guess by secant method
c  is further from solution
c
      lxpos=.false.         !initialize flags for reguli-falsi iteration
      lxneg=.false.
      xneg=0.0d0
      xpos=0.0d0
      fxneg=0.0d0
      fxpos=0.0d0
      j=1                   !j=1 for first iteration, j=2 for all others
      x(1)=tk               !first guess for independent variable
      do it=1,itmax
c  evaluate objective function
        tauk=tredk/x(j)       !x(j) is current guess for tk
        fx(j)=amx-PHIK(k,0,0,tauk,delk)
c  check for convergence
        if (ABS(fx(j)).lt.tolr) then
c  iteration has converged
          goto 840
        else
          if (fx(j).lt.0.0d0) then
            lxneg=.true.
            xneg=x(j)
            fxneg=fx(j)
          else
            lxpos=.true.
            xpos=x(j)
            fxpos=fx(j)
          end if
        end if
c
c  compute new guess for independent variable
        if (j.eq.1) then
c  for first iteration, new guess is ratio of old
          x(2)=x(1)*1.005
          j=2
        else
c  subsequent iterations--use (damped) secant method
          if (ABS(fx(2)-fx(1)).lt.1.0d-12) then
c  avoid division by zero, use average of previous guesses; if fx(1) was
c  equal to fx(2) by coincidence, this should allow solution; if there
c  is a more severe problem iteration will probably not converge, but
c  neither will it blow up
            x(3)=0.5d0*(x(1)+x(2))
          else
            x(3)=x(2)-xdamp*fx(2)*(x(2)-x(1))/(fx(2)-fx(1))
          end if
          if (ABS(x(3)/x(2)-1.0d0).ge.0.6) then
c  do not allow too great a change in tk, a.k.a. x
c         write (*,*) '   CONFD--unconstrained tk from CONFT: ',x(3)
            x(3)=x(2)*(1.0d0+SIGN(0.6d0,x(3)/x(2)-1.0d0))
          end if
c       write (*,*) '   CONFT--old, new tk: ',x(2),x(3)
c  check that new guess is not outside bounds, if so use reguli-falsi
c  (provided that bounds on root have been found)
          if ((x(3).gt.MAX(xpos,xneg).or. x(3).lt.MIN(xpos,xneg))
     &       .and. lxneg .and. lxpos) then
            x(3)=xpos-fxpos*(xpos-xneg)/(fxpos-fxneg)
          end if
c  discard oldest iteration
          x(1)=x(2)
          x(2)=x(3)
          fx(1)=fx(2)
        end if
      enddo
c
c  iteration loop has not converged
c     write (*,1801) k,x(1),x(2),fx(1)
c1801 format (' CONFT--secant method for t_conf did not converge; ',
c    &        'k,tk1,tk2,ft1: ',i3,2f10.3,e14.6)
c
  840 continue
      tk=x(j)
c
      RETURN
      end                                              !subroutine CONFT

c ======================================================================
c
      subroutine pTRNEC (icomp,t,rho,etares,tcxres,ierr,herr,irefn)
c
c  compute the excess contribution of transport properties of thermal conductivity and
c  viscosity as functions of temperature, density for pure fluids in
c  a mixture using their individual reference fluids
c
c  based on the modification of the Huber-Ely ECS method given by:
c  Klein, S.A., McLinden, M.O. and Laesecke, A. (1997). An improved
c  extended corresponding states method for estimation of viscosity of
c  pure refrigerants and mixtures. Int. J. Refrigeration 20:208-217
c
c  N.B. --equation numbers below refer to this paper;
c       --factor of (ref fluid mol wt)**-0.5 is missing from Eq 31 in paper
c       --in Eq 34 reference fluid should be evaluated at (t0,rho0), not
c         at (t/fj,rho*hj)
c
c  inputs:
c    irefn--reference fluid number
c        t--temperature [K]
c      rho--molar density [mol/L]
c
c  outputs:
c      eta--viscosity [uPa.s]
c      tcx--thermal conductivity [W/m.K]
c     ierr--error flag:  0 = successful
c                       -1 = inputs are out of bounds
c                      -35 = temperature out of range for conductivity of ref. fluid
c                      -36 = density out of range for conductivity of ref. fluid
c                      -37 = T and D out of range for conductivity of ref. fluid
c                      -41 = temperature out of range for viscosity of fluid j
c                      -42 = density out of range for viscosity of fluid j
c                      -43 = T and D out of range for viscosity of fluid j
c                      -45 = temperature out of range for viscosity of ref. fluid
c                      -46 = density out of range for viscosity of ref. fluid
c                      -47 = T and D out of range for viscosity of ref. fluid
c                      -48 = ref. fluid viscosity correlation in invalid region
c                      -55 = T out of range for both visc and t.c.
c                      -56 = D out of range for both visc and t.c.
c                      -57 = T and/or D out of range for both visc and t.c.
c                  -58,-59 = ECS model did not converge
c                      -60 = pure fluid is exactly at critical point; t.c. is infinite
c     herr--error string (character*255 variable if ierr<>0)
c
c  NIST Physical & Chemical Properties Division, Boulder, Colorado
c  based on the routine by S.A. Klein (in turn, based on Refprop5 routine)
c  11-11-06 MLH, initial version.
c  12-17-07 MLH, deactivate some bounds checks on ref. fluids
c  02-13-08 MLH, deactivate more bounds checks on fluids
c
      include 'commons.for'
      include 'comtrn.for'
      character*255 herr,herrs,herrk,herret,hercrt
      character*255 herrvj, herrsv
c     character*255 hfile(n0:nx)
      logical lervtj,lervDj,lervsj
      dimension fj(nx), hj(nx)
      dimension zx(ncmax)
c
c     initialize error flags
c     routines conftd, etakb, tcxkb,tcxkc, critp all reset error flag so it is necessary
c     to keep separate error counters to keep track of the errors in each routine

      ierr=0
      herr=' '
      ierret=0
      herret(1:1)=hnull
      ierrk=0
      herrk(1:1)=hnull
      iercrt=0
      hercrt(1:1)=hnull
      ierrs=0
      herrs(1:1)=hnull
      ierrvj=0
      herrvj(1:1)=hnull
      ierrsv=0
      herrsv(1:1)=hnull
c
      do i=1,nc
        zx(i)=0.d0
      end do
      zx(icomp)=1.d0


c  find amx, Zmix and conformal t,rho for reference fluid
      call CRITP (zx,tcmxec,pcmxec,dcmxec,iercrt,hercrt)
c     write (*,*) ' pTRNECS--ierr from CRITP, tcmxec:  ',iercrt,tcmxec
      call REDX (zx,tred,Dred)
      tau=tred/t
      del=rho/Dred
      amx=PHIX(0,0,tau,del,zx)
      Zmix=1.0d0+PHIX(0,1,tau,del,zx)
      t0=t*tcrit(irefn)/tcmxec      !initial guess for conformal temperature
      rho0=rho*Dcrit(irefn)/dcmxec  !initial guess for conformal density

c     default values in case of convergence failure
      fxx0=tcmxec/tcrit(irefn)
      hxx0=Dcrit(irefn)/dcmxec
      plimi=zmix*r*t0*rho0
c  find "exact" conformal t,rho only if density is significant;
c  at zero density, use the initial guesses above (CONFTD can fail at
c  very low density, and the dilute-gas contribution is dominant anyway)
      IF((zmix.gt.0.3).and. (plimi.lt.1.1*pcrit(irefn)).AND.
     &  (rho0.lt.Dcrit(irefn)))then    !vapor side
        fx=fxx0
        hx=hxx0
      ELSE
        call CONFTD (irefn,amx,Zmix,t0,rho0,ierrs,herrs)
        fx=t/t0
        hx=rho0/rho
        pctf=ABS(100.*(fx-fxx0)/fxx0)
        pcth=ABS(100.*(hx-hxx0)/hxx0)
        IF(ierrs.ne.0)then
          IF((pctf.gt.10).OR.(pcth.gt.10).OR.(t0.lt.1.d0)) THEN
            ierrsv=-58
            j00=0
            write (herrsv,1058) j00, hnull
            call ERRMSG (ierrsv,herrsv)
          ENDIF
        ENDIF
      ENDIF


c  for component j in a mixture, find conformal t,rho for the component
          j=icomp
          fjj0=tcrit(j)*fx/tcmxec
          hjj0=hx*dcmxec/Dcrit(j)
c         tj=t*tcrit(j)/(fx*tcrit(0))       !initial guess for conformal temp
c         rhoj=rho*hx*Dcrit(j)/Dcrit(0) !initial guess for conformal density
          tj=t*tcrit(j)/tcmxec         !initial guess for conformal temp
c         write (*,1097) j,t,tcrit(j),tcmxec,tj
c1097     format (1x,' pTRNECS--j,t,tcrit(j),tcmxec,tj: ',i3,4f12.6)
          rhoj=rho*Dcrit(j)/dcmxec     !initial guess for conformal density
          plimi=zmix*r*tj*rhoj
c  find "exact" conformal t,rho only if density is significant;
c  at zero density, use the initial guesses above (CONFTD can fail at
c  very low density, and the dilute-gas contribution is dominant anyway)
          IF((zmix.gt.0.3).and.(plimi.lt.1.1*pcrit(j)).AND.
     &      (rhoj.lt.Dcrit(j)))then    !vapor side
                fj(j)=fjj0
                hj(j)=hjj0
          ELSE
            call CONFTD (j,amx,Zmix,tj,rhoj,ierrs,herrs)
            fj(j)=tj*fx/t
            hj(j)=rho*hx/rhoj
c           check to make sure values are reasonable for this region
            pctf=ABS(100.*(fj(j)-fjj0)/fjj0)
            pcth=ABS(100.*(hj(j)-hjj0)/hjj0)
            IF(ierrs.ne.0)THEN
c           allow nonconvergence to small deviations
              if((pctf.gt.10).OR.(pcth.gt.10).OR.(tj.lt.1.d0)) then
                ierrsv=-58
                write (herrsv,1058) j,hnull
                call ERRMSG (ierrsv,herrsv)
              endif
c           write (*,*) ' pTRNECS--ierr from CONFTD, tj: ',ierrs,tj
c           write (*,1098) j,tj,fx,t,tcmxec
c1098       format (1x,' pTRNECS--j,tj,fx,t,tcmxec: ',i3,4f12.6)
            ENDIF
          ENDIF
c       write (*,1099) j,fj(j),hj(j)
c1099   format (1x,' pTRNECS--j,fj,hj:',i2,2f12.6)


c  find correlation limits for reference fluid
      p=0.0d0
      tt=300.0d0
      rr=0.0d0
      call LIMITK ('ETA',irefn,tt,rr,p,tminv,tmaxv,Deta,peta,ierr,herr)
c      call LIMITK ('TCX',irefn,tt,rr,p,tmint,tmaxt,Dtcxt,ptcxt,ierr,herr)
c  initialize error flags
c     lertt=.false.
c     lervt=.false.
c     lertD=.false.
c     lervD=.false.
      lervtj=.false.
      lervDj=.false.

      tchi=t/fj(icomp)
      rhochi=rho*hx/(hj(icomp)*Dcrit(icomp))
      rho0j=rho*hx*CHI(icomp,tchi,rhochi)
      gxj=wmas(icomp)/wmas(-icomp)
      Flam=SQRT(fj(icomp)/gxj)*hj(icomp)**(-2.0d0/3.0d0)
      call TCXKB (-icomp,tchi,rho0j,tcx0b,ierrs,herrs)
      tcxres=flam*tcx0b

      tpsi=t/fj(icomp)
      rhopsi=rho*hx/(hj(icomp)*Dcrit(icomp))
      rho0j=rho*hx*psi(icomp,tpsi,rhopsi)
      gxj=wmas(icomp)/wmas(-icomp)
      Feta=SQRT(fj(icomp)*gxj)*hj(icomp)**(-2.0d0/3.0d0)
c  do not let ref fluid for viscosity be evaluated beyond its limits
c  since the correlations generally do not extrapolate well
      IF(tpsi.lt.tminv)tpsi=tminv !ref fluid for fluid of interest
      IF(rho0j.gt.Deta)rho0j=Deta
      call ETAKB (-icomp,tpsi,rho0j,eta0b,ierrs,herrs)
      etares=feta*eta0b

c  process warning/errors for problems with calls to etakb
      if (ierret.ne.0) then !etakb failed;
c       do not return numbers for eta
        ierr=ierret
        herr=herret
c       eta=xnotc  !values used by GUI as non-convergence flag
c       tcx=xnotc
      endif
c
c  process warning/errors for problems with calls to tcxkb, tcxkc
      if (ierrk.ne.0) then !tcxkb or tcxkc failed;
c         return numbers with a warning
        ierr=ierrk
        herr=herrk
c       eta=xnotc  !values used by GUI as non-convergence flag
c       tcx=xnotc
      endif
c
c  process warnings/errors for problems with CRITP routine
      if (iercrt.gt.0) then !critp failed;
c         return numbers with a warning
        ierr=iercrt
        herr=hercrt
c       eta=xnotc  !values used by GUI as non-convergence flag
c       tcx=xnotc
      endif
c
c  process warnings/errors for conformal states outside range of ref fluid
c     lertc=lertt.or.lertD
c     lervs=lervt.or.lervD
c      if (lertc .and. lervs) then
c  both thermal conductivity and viscosity generated errors
c       eta=xnotc  !values used by GUI as non-convergence flag
c       tcx=xnotc
c       if ((lertt.or.lervt) .and. (lertD.or.lervD)) then
c         ierr=-57
c          write (herr,2057) t,rho
c        else if (lertD.or.lervD) then
c          ierr=-56
c          write (herr,2056) t,rho
c        else
c          ierr=-55
c          write (herr,2055) t,rho
c        end if
c      else if (lertc) then
c  only thermal conductivity generated errors
c       tcx=xnotc  !value used by GUI as non-convergence flag
c       if (lertt .and. lertD) then
c          ierr=-37
c          write (herr,2037) t,rho
c        end if
c      else if (lervs) then
c  only viscosity generated errors
c       eta=xnotc  !value used by GUI as non-convergence flag
c       if (lervt .and. lervD) then
c          ierr=-47
c          write (herr,2047) t,rho
c        end if
c      end if
c
c  process warnings/errors for conformal states outside range of individual fluid
c  viscosity correlations
      lervsj=lervtj.or.lervDj
      if (lervsj) then
c     viscosity generated errors
c     return a number with a warning
c       eta=xnotc  !value used by GUI as non-convergence flag
        ierr=ierrvj
        herr=herrvj
      end if
c
      if (ierrsv.ne.0) then !conftd failed
c       do not return numbers
        ierr=ierrsv
        herr=herrsv
c        eta=xnotc  !values used by GUI as non-convergence flag
c        tcx=xnotc
      endif
      if (ierr.ne.0) call ERRMSG (ierr,herr)
c
c700  continue
      RETURN

c
 1058     format ('[pTRNEC warning 58] 2-D Newton-Raphson method for '
     &        ,'conformal temperature and density did not converge ',
     &        'for component',i3,a1)
c2035     format ('[pTRNEC warning -35] conformal temperature in ECS-'
c    &      ,'transport method is outside range of reference fluid ',
c    &      'thermal conductivity correlation; T_conf =',g11.5,
c    &      ' K; T_min,max =',g11.5,',',g11.5,' K')
c2036     format ('[pTRNEC warning -36] conformal density in ECS-',
c    &      'transport method is outside range of reference fluid ',
c    &      'thermal conductivity correlation; rho_conf =',g11.5,
c    &      ' mol/L; rho_max =',g11.5,' mol/L')
c2037     format ('[pTRNEC warning -37] T and rho input to ECS-',
c    &      'transport method are outside range of reference fluid ',
c    &      'thermal conductivity correlation; T_in =',g11.5,
c    &      ' K; rho_in =',g11.5,' mol/L')
c2045     format ('[pTRNEC warning -45] conformal temperature in ECS-'
c    &      ,'transport method is outside range of reference fluid ',
c    &      'thermal conductivity correlation; T_conf =',g11.5,
c    &      ' K; T_min,max =',g11.5,',',g11.5,' K')
c2046     format ('[pTRNEC warning -46] conformal density in ECS-',
c    &      'transport method is outside range of reference fluid ',
c    &      'viscosity correlation; rho_conf =',g11.5,
c    &      ' mol/L; rho_max =',g11.5,' mol/L')
c2047     format ('[pTRNEC warning -47] T and rho input to ECS-',
c    &      'transport method are outside range of reference fluid ',
c    &      'viscosity correlation; T_in =',g11.5,
c    &      ' K; rho_in =',g11.5,' mol/L')
c2055     format ('[pTRNEC warning -55] temperature input to ECS-',
c    &      'transport method is outside range of reference fluid ',
c    &      'viscosity and thermal conductivity correlations; T_in =',
c    &      g11.5,' K; rho_in =',g11.5,' mol/L')
c2056     format ('[pTRNEC warning -56] density input to ECS-',
c    &      'transport method is outside range of reference fluid ',
c    &      'viscosity and thermal conductivity correlations; T_in =',
c    &      g11.5,' K; rho_in =',g11.5,' mol/L')
c2057     format ('[pTRNEC warning -57] T and/or rho input to ECS-',
c    &      'transport method are outside range of reference fluid ',
c    &      'viscosity and thermal conductivity correlations; T_in =',
c    &      g11.5,' K; rho_in =',g11.5,' mol/L')
c2065     format ('[pTRNEC warning -41] conformal temperature in ECS-'
c    &      ,'transport method is outside range of fluid ',I3,
c    &      ' viscosity correlation')
c2066     format ('[pTRNEC warning -42] conformal density in ECS-',
c    &      'transport method is outside range of fluid ',I3,
c    &      ' viscosity correlation')
c2067     format ('[pTRNEC warning -43] conformal temperature and ',
c    &      'density in ECS-',
c    &      'transport method is outside range of fluid ',I3,
c    &      ' viscosity correlation')
c2068     format ('[pTRNEC warning -48] invalid region for ',
c    &        'viscosity of reference fluid 1 ')

c
      end                                             !subroutine pTRNEC
c ======================================================================
c
      subroutine ETAbkp (jj,t,rho,fj,fx,hj,hx,etabk,ierr,herr)
c
c  compute the background viscosity of pure fluid component in a mixture
c  using ecs, and evaluating with the individual fluids reference
c  fluid, which may differ from that of the mixture
c
c  based on the modification of the Huber-Ely ECS method given by:
c  Klein, S.A., McLinden, M.O. and Laesecke, A. (1997). An improved
c  extended corresponding states method for estimation of viscosity of
c  pure refrigerants and mixtures. Int. J. Refrigeration 20:208-217
c
c  inputs:
c        t--temperature [K]
c      rho--molar density [mol/L]
c       fj--array of temperature shape factors for the components
c       fx--temperature shape factor for the mixture
c       hj--array of temperature shape factors for the components
c       hx--density shape factor for the mixture
c  outputs:
c      etabk--background viscosity [uPa.s]
c     ierr--error flag:  0 = successful
c                      <>0 indicates problem from underlying routine
c                          passed to calling routine
c     herr--error string (character*255 variable if ierr<>0)
c
c
      include 'commons.for'
      include 'comtrn.for'
      character*255 herr
      dimension fj(ncmax),hj(ncmax)  !reducing ratios for components
c
      ierr=0
      herr=' '
      tj=t*fj(jj)/fx
      rhoj=rho*hx/hj(jj)
c  get ECS value for pure fluid j with respect to its own reference fluid
c  not necessarily the same as the mixture; only residual part needed.
      CALL pTRNEC (jj,tJ,rhoJ,etaj,tcxJ,ierr,herr,-jj)
      etabk=etaj

      RETURN
      end                                             !subroutine ETAbkp
c
c ======================================================================
c
c ======================================================================
c        1         2         3         4         5         6         7
c23456789012345678901234567890123456789012345678901234567890123456789012
c
c ======================================================================
c                                                    end file trns_ECS.f
c ======================================================================
c  begin file trnsp.f
c
c  This file contains the transport property routines
c
c  contained here are:
c     subroutine TRNPRP (t,rho,x,eta,tcx,ierr,herr)
c     subroutine ETAK (icomp,t,rho,eta,ierr,herr)
c     subroutine ETAK0 (icomp,t,eta0,ierr,herr)
c     subroutine ETAK1 (icomp,t,eta1,ierr,herr)
c     subroutine ETAKR (icomp,t,rho,etar,ierr,herr)
c     subroutine ETAKB (icomp,t,rho,etab,ierr,herr)
c     subroutine TCXK (icomp,t,rho,tcx,ierr,herr)
c     subroutine TCXK0 (icomp,t,tcx0,ierr,herr)
c     subroutine TCXKB (icomp,t,rho,tcxb,ierr,herr)
c     subroutine TCXKC (icomp,t,rho,tcxc,ierr,herr)
c     function OMEGA (icomp,t,epsk,hmodci)
c     subroutine SETCI1 (nread,icomp,hcasno,ierr,herr)
c     function OMEGA1 (icomp,t,epsk)
c     subroutine SETCI2 (nread,icomp,hcasno,ierr,herr)
c     function OMEGA2 (icomp,t,epsk)
c
c =====================================================================
c =====================================================================
c
      subroutine TRNPRP (t,rho,x,eta,tcx,ierr,herr)
c
c  compute the transport properties of thermal conductivity and
c  viscosity as functions of temperature, density, and composition
c
c  inputs:
c        t--temperature [K]
c      rho--molar density [mol/L]
c        x--composition array [mol frac]
c  outputs:
c      eta--viscosity (uPa.s)
c      tcx--thermal conductivity (W/m.K)
c     ierr--error flag:  0 = successful
c                      -31 = temperature out of range for conductivity
c                      -32 = density out of range for conductivity
c                      -33 = T and D out of range for conductivity
c                      -41 = temperature out of range for viscosity
c                      -42 = density out of range for viscosity
c                      -43 = T and D out of range for viscosity
c                      -51 = T out of range for both visc and t.c.
c                      -52 = D out of range for both visc and t.c.
c                      -53 = T and/or D out of range for visc and t.c.
c                       39 = model not found for thermal conductivity
c                       40 = model not found for thermal conductivity or viscosity
c                       49 = model not found for viscosity
c                       50 = ammonia/water mixture (no properties calculated)
c                       51 = exactly at t, rhoc for a pure fluid; k is infinite
c                  -58,-59 = ECS model did not converge
c     herr--error string (character*255 variable if ierr<>0)
c
c  written by M. McLinden, NIST Phys & Chem Properties Div, Boulder, CO
c  10-15-96  MM, original version, supercedes older routine of same name
c  02-21-97  MM, check input T,rho against limits for pures,
c                generate warning messages
c  08-20-97  MM, initialize visc and t.c. to flag indicating not calculated
c  10-01-97  MM, add compiler switch to allow access by DLL
c  02-06-98  MM, move ierret=0 so it is always initialized
c  08-14-98  MM, x array never dimensioned!?
c  01-25-00 EWL, switched "eta, tcxecs" to "etaecs, tcx" in one of the ECS calls
c  05-24-00 EWL, if no transport routines are loaded, do not calculate values.
c                this is important for D2, Fl, and NF3 which have no exp. data
c  11-01-01 EWL, black out ammonia/water mixtures
c  11-02-01 MLH, block out computation exactly at tc, rhoc for pure fluid k (its infinite)
c  09-08-04 MLH, names shortened to 6 characters
c  01-04-07 EWL, add check for mixture component with no equation
c  01-10-07 EWL, check for mixtures with water
c  01-18-07 MLH, do not switch to ECS if out of range of correlation
c  03-12-07 EWL, keep eta and tcx equal to xnota if no correlation instead of switching to xnotc at the very bottom
c  03-12-07 EWL, check for neither tcx or eta models at beginning and exit if so
c  11-16-07 MLH, updated error messages for ecs mixture failure
c  04-02-08 EWL, add check for ic<>0 with water mixtures (so that PUREFLD can be called)
c  04-21-08 EWL, add check for ic<>0 with any mixture (so that PUREFLD can be called)
c  05-08-08 MLH, add check for viscosity exactly at critical point
c  03-09-09 EWL, allow water mixtures if interaction parameters are available
c  10-28-10 EWL, remove composition dependence if nc=1
c  06-05-12 EWL, increase allowable water to 5%
c  01-24-13 MLH, don't allow transport with alcohol mixtures
c
cx DEC$ ATTRIBUTES DLLEXPORT :: TRNPRP
c
      include 'commons.for'
      include 'comtrn.for'
      character*255 herr,herrl,herrec,herrpf
      logical lecs
      dimension x(ncmax)
c
      ierr=0
      herr=' '
      call ISPURE (x,icomp)
      eta=xnotc
      tcx=xnotc
      if (icomp.ne.0) then
        if  ((heta(icomp).eq.'NUL' .or. heta(icomp).eq.'   ')
     &  .and.(htcx(icomp).eq.'NUL' .or. htcx(icomp).eq.'   ')) then
          ierr=40
          write (herr,1006) ierr,hnull
          call ERRMSG (ierr,herr)
          RETURN
        endif
      else
        do i=1,nc
          if (x(i).gt.0.d0) then
            if  ((heta(i).eq.'NUL' .or. heta(i).eq.'   ')
     &      .and.(htcx(i).eq.'NUL' .or. htcx(i).eq.'   ')) then
              ierr=40
              write (herr,1006) ierr,hnull
              call ERRMSG (ierr,herr)
              RETURN
            endif
          endif
        enddo
      endif
 1006 format ('[TRNPRP error',i3,'] transport equations are ',
     &        'not available for one or more of the fluids',a1)

      lecs=.false.
      if (icomp.eq.0) then
        iw1=1
        do i=1,nc-1
          if (x(i).gt.0.d0) then
            iw2=0
            do j=i+1,nc
              if (x(j).gt.0.d0) then
                if (abs( xljs(i,j)).gt.1.d-20) iw2=iw2+1
                if (abs( xlje(i,j)).gt.1.d-20) iw2=iw2+1
                if (abs( xkij(i,j)).gt.1.d-20) iw2=iw2+1
                if (abs(xkijk(i,j)).gt.1.d-20) iw2=iw2+1
                if (abs(xlijk(i,j)).gt.1.d-20) iw2=iw2+1
              endif
            enddo
            iw1=iw1*iw2
          endif
        enddo
        if (iw1.eq.0) then
          if (iamwat.eq.1) then
            ierr=50
            write (herr,1001) ierr,hnull
            call ERRMSG (ierr,herr)
 1001       format ('[TRNPRP error',i3,'] transport equations are ',
     &              'not available for the ammonia/water mixture',a1)
            RETURN
          end if
          if (ialc.ne.0) then
            ierr=50
            write (herr,1011) ierr,hnull
            call ERRMSG (ierr,herr)
 1011      format ('[TRNPRP error',i3,'] transport equations are ',
     &              'not available for mixtures with alcohols',a1)
            RETURN
          end if

          if (iwat.ne.0) then
            if (x(iwat).gt.0.05d0) then
              ierr=50
              write (herr,1005) ierr,hnull
              call ERRMSG (ierr,herr)
 1005         format ('[TRNPRP error',i3,'] transport equations are ',
     &                'not available for mixtures with water at ',
     &                'molar concentrations greater than 5%',a1)
              RETURN
            end if
          end if
        end if
      end if
c  set visc and t.c. to flags indicating 'not calculated' so that some
c  value is returned to GUI in event of failure of routines
c
      ierret=0         !initialize
      if (icomp.ne.0) then
c  no model was specified, so do not calculate any properties
        if (heta(icomp)(1:1).eq.' ' .or. heta(icomp).eq.'NUL') then
          eta=xnota
c  special case--pure fluid
        elseif (heta(icomp)(1:2).eq.'EC') then
c  call ECS subroutines
c         write (*,*) ' TRNPRP--about to call TRNECS for viscosity'
          call TRNECS (t,rho,x,eta,tcxecs,ierrec,herr)
          ierr=ierrec
          lecs=.true.  !set flag (no need to call TRNECS again for t.c.)
        else
c  pure fluid correlation
          pxx=0.0d0
          call LIMITX ('ETA',t,rho,pxx,x,tmin,tmax,Dmax,pmax,ierr,herrl)
c         write (*,1002) tmin,tmax,Dmax,ierr
c1002     format (1x,' TRNPRP--T,rho limits for visc: ',2f8.2,f10.4,
c    &               '; ierr = ',i3)
          if (ierr.ge.1) then
c  if out of range, call ECS model and generate warning message
            ierr=-40-ierr
            write (herr,1040) ierr,herrl(39:168),hnull
            call ERRMSG (ierr,herr)
            ierret=ierr
c           do NOT call ecs, just give warning
c            call TRNECS (t,rho,x,eta,tcxecs,ierrec,herrec)
c            lecs=.true.
c            if (ierrec.ne.0) then
c  if ECS method results in error, pass that as output, otherwise retain
c  the error from LIMITX
c              write (herr,1004) ierr,herrec(1:146),hnull
c             call ERRMSG (ierr,herr)
 1004         format ('[TRNPRP warning',i4,'] pure fluid correlation ',
     &                'out of range; attempted to use ECS method, it ',
     &                'generated error:  ',a146,a1)
c             ierr=ierrec
c            end if
          else
c  call pure fluid model
            lecs=.false.
c           check to see if viscosity is requested at exactly the crit point
            IF(abs(t-tcrit(icomp)).lt.1.d-20 .AND.
     &         abs(rho-Dcrit(icomp)).lt.1.d-20) then
              ierr=-51
              write (herr,1002) ierr,hnull
              call ERRMSG (ierr,herr)
 1002         format ('[TRNPRP warning ',i3,'] pure fluid ',
     &         'property is infinite at exactly Tc, rhoc',a1)
              eta=xnotc
            end if
            call ETAK (icomp,t,rho,eta,ierr,herr)
          end if
        end if
c
c  no model was specified, so do not calculate any properties
        if (htcx(icomp)(1:1).eq.' ' .or. htcx(icomp).eq.'NUL') then
          tcx=xnota
c  call ECS subroutines
        elseif (htcx(icomp)(1:2).eq.'EC') then
          if (lecs) then
            tcx=tcxecs       !use value computed on call above
          else
            call TRNECS (t,rho,x,etaecs,tcx,ierrec,herrec)
            if (ierrec.ne.0) then
c  if ECS method results in error, pass that as output, otherwise retain
c  the error from LIMITX
              write (herr,1004) ierr,herrec(1:146),hnull
              call ERRMSG (ierr,herr)
              ierr=ierrec
            end if
          end if
        else
c  pure fluid correlation
          pxx=0.0d0
          call LIMITX ('TCX',t,rho,pxx,x,tmin,tmx,Dmx,pmx,ierrl,herrl)
c         write (*,1003) tmin,tmx,Dmx,ierrl
c1003     format (1x,' TRNPRP--T,rho limits for t.c.: ',2f8.2,f10.4,
c    &               '; ierr = ',i3)
          if (ierrl.ge.1) then
c  out of range of thermal conductivity correlation, call ECS model
            if (ierret.ne.0) then
c  both thermal conductivity and viscosity are out of range
              if (ierret.eq.-41) then
                ierr=-50-ierrl
                write (herr,1050) ierr,herrl(39:153),hnull
                call ERRMSG (ierr,herr)
              else if (ierret.eq.-42) then
                if (ierrl.eq.2) then
                  ierr=-52
                  write (herr,1052) hnull
                  call ERRMSG (ierr,herr)
                else
                  ierr=-53
                  write (herr,1053) hnull
                  call ERRMSG (ierr,herr)
                end if
              else
                ierr=-53
                write (herr,1053) hnull
                call ERRMSG (ierr,herr)
              end if
            else
c  just thermal conductivity correlation is out of range
              ierr=-30-ierrl
              write (herr,1030) ierr,herrl(39:168),hnull
              call ERRMSG (ierr,herr)
            end if
            if (lecs) then
              tcx=tcxecs       !use value computed on call above
            else
c           do NOT switch to ECS
c             call TRNECS (t,rho,x,etaecs,tcx,ierrec,herrec)
c              if (ierrec.ne.0) then
c  if ECS method results in error, pass that as output, otherwise retain
c  the error from LIMITX
c                write (herr,1004) ierr,herrec(1:146),hnull
c                call ERRMSG (ierr,herr)
c              ierr=ierrec
c              end if
            end if
          else
c  call pure fluid model
            call TCXK (icomp,t,rho,tcx,ierrpf,herrpf)
            if (ierrpf.ne.0) then
c  if pure fluid model results in error, pass that as output, otherwise
c  retain the error from LIMITX
              ierr=ierrpf
              herr=herrpf
            end if
          end if
        end if
c       check to see if thermal conductivity is requested at exactly the crit point
        IF(abs(t-tcrit(icomp)).lt.1.d-20 .AND.
     &     abs(rho-Dcrit(icomp)).lt.1.d-20) then
          ierr=51
          write (herr,1002) ierr,hnull
          call ERRMSG (ierr,herr)
          tcx=xnotc
        end if


      else
c
c  general (mixture) case
c
        if (hetamx(1:2).eq.'EC') then
c  call ECS subroutines
          call TRNECS (t,rho,x,eta,tcxecs,ierr,herr)
          lecs=.true.  !set flag (no need to call TRNECS again for t.c.)
          IF(ierr.eq.1)then
            ierr=-54
            write (herr,1054) hnull
            call ERRMSG (ierr,herr)
          endif
        else
          lecs=.false.
c  [insert calls to additional mixture models here]
        end if
c
        if (htcxmx(1:2).eq.'EC') then
c  call ECS subroutines
          if (lecs) then
            tcx=tcxecs       !use value computed on call above
          else
            call TRNECS (t,rho,x,etaecs,tcx,ierr,herr)
            IF(ierr.eq.1)then
              ierr=-54
              write (herr,1054) hnull
              call ERRMSG (ierr,herr)
            endif
          end if
        else
          lecs=.false.
c  [insert calls to additional mixture models here]
        end if
      end if
      if (eta.lt.0 .and. eta.ne.xnota) eta=xnotc
      if (tcx.lt.0 .and. tcx.ne.xnota) tcx=xnotc
c
c     do i=1,nc      !Removed 4/21/08, should have been done earlier
c       if (heta(i).eq.'NUL' .or. heta(i).eq.'   ') eta=xnota
c       if (htcx(i).eq.'NUL' .or. htcx(i).eq.'   ') tcx=xnota
c     enddo
      RETURN
c
 1030 format ('[TRNPRP warning',i4,'] one or more inputs to the ',
     &        'thermal conductivity correlation are out of range; ',
     &        'results may be in error; ',a130,a1)
 1040 format ('[TRNPRP warning',i4,'] one or more inputs to the ',
     &        'viscosity correlation are out of range; ',
     &        'results may be in error; ',a130,a1)
 1050 format ('[TRNPRP warning',i4,'] one or more inputs to the ',
     &        'thermal conductivity and viscosity correlations are ',
     &        'out of range; results may be in error; ',a115,a1)
 1052 format ('[TRNPRP warning -52] the density input to the ',
     &        'thermal conductivity and viscosity correlations are ',
     &        'out of range; will use the ECS model. ',a1)
 1053 format ('[TRNPRP warning -53] temperature and/or density input ',
     &        'to the thermal conductivity and/or viscosity ',
     &        'correlations are out of range; will use the ECS model.',
     &         a1)
 1054 format ('[TRNPRP warning -54] temperature and/or density input ',
     &        'to the thermal conductivity and/or viscosity ',
     &        'ecs mixture model are out of range;',
     &        ' results may be in error.',
     &         a1)

      end                                             !subroutine TRNPRP
c
c ======================================================================
c
      subroutine ETAK (icomp,t,rho,eta,ierr,herr)
c
c  viscosity of a pure fluid as a function of temperature and density
c
c  inputs:
c    icomp--component number in mixture (1..nc); 1 for pure fluid
c        t--temperature [K]
c      rho--molar density [mol/L]
c  outputs:
c      eta--viscosity (uPa.s)
c     ierr--error flag:  0 = successful
c                        1 = did not converge
c                       49 = unknown model specified
c     herr--error string (character*255 variable if ierr<>0)
c
c  written by M. McLinden, NIST Phys & Chem Properties Div, Boulder, CO
c  10-15-96  MM, original version
c  10-30-96  MM, call intermediate ETAK0, etc routines rather than
c                core-level routines directly
c  01-17-97  MM, change initial-density dependence to visc virial coeff
c  11-19-07  MLH, initialized value, removed unused commons, declarations
c
      include 'commons.for'
      include 'comtrn.for'
      character*255 herr
c
      eta=0.0d0
      ierr=0
      herr=' '
c
c  the viscosity is the sum of the dilute-gas, initial-density, and
c  residual terms (separate functions for the three terms are used
c  because of the requirements of certain mixture models, e.g. ECS)
c
      call ETAK0(icomp,t,eta0,ierr,herr)
      call ETAK1(icomp,t,etaB2,ierr,herr)
      call ETAKR(icomp,t,rho,etar,ierr,herr)
      eta=eta0*(1.0d0+etaB2*rho)+etar


c     write (*,1000) icomp,t,rho,eta0,eta0*etaB2*rho,etar,eta
c1000 format (1x,' ETAK--icomp,t,rho,eta_0,B2,resid,sum:  ',i3,6f12.4)
c
      RETURN
      end                                               !subroutine ETAK
c
c ======================================================================
c
      subroutine ETAK0 (icomp,t,eta0,ierr,herr)
c
c  dilute-gas contribution to the viscosity of a pure fluid as a
c  function of temperature and density
c
c  inputs:
c    icomp--component number in mixture (1..nc); 1 for pure fluid
c        t--temperature [K]
c  outputs:
c     eta0--viscosity [uPa.s]
c     ierr--error flag:  0 = successful
c                        1 = did not converge
c                       49 = unknown model specified
c     herr--error string (character*255 variable if ierr<>0)
c
c  written by M. McLinden, NIST Phys & Chem Properties Div, Boulder, CO
c  10-30-96  MM, original version
c  03-07-00 EWL, add VS0 model
c  03-05-02 EWL, initialize eta0
c  03-21-02 MLH, modified VS0 model to have dilute gas piece
c  12-26-06 MLH, added vs4 model (generalized friction theory)
c  11-02-07 MLH, added vs5 model (Chung et al.)
c  12-10-07 MLH, added vs4 dilute call
c
      include 'commons.for'
      include 'comtrn.for'
      character*255 herr
c
      ierr=0
      eta0=0.d0
      herr=' '
c
c  call appropriate core viscosity model
      if (heta(icomp)(1:2).eq.'EC') then
        eta0=ETA0DG(icomp,t)
      else if (heta(icomp).eq.'VS0') then
        eta0=ETA0DG(icomp,t)
      else if (heta(icomp).eq.'VS1') then
        eta0=ETA1DG(icomp,t)
      else if (heta(icomp).eq.'VS2') then
        eta0=ETA2DG(icomp,t)
      else if (heta(icomp).eq.'VS3') then
        eta0=ETA3DG(icomp,t)
      else if (heta(icomp).eq.'VS4') then
        eta0=ETA4DG(icomp,t)
      else if (heta(icomp).eq.'VS5') then
        eta0=ETA5DG(icomp,t)
      else if (heta(icomp).eq.'VS6') then
c       eta0=ETA6DG(icomp,t)
        eta0=0.0d0                  !temporary
        ierr=49
        herr='[ETAK0 error 49] call to unimplemented model (VS6)'
        call ERRMSG (ierr,herr)
      else
        ierr=49
        herr='[ETAK0 error 49] unknown viscosity model specified'//hnull
        call ERRMSG (ierr,herr)
      end if
c
      RETURN
      end                                              !subroutine ETAK0
c
c ======================================================================
c
      subroutine ETAK1 (icomp,t,etaB2,ierr,herr)
c
c  the second viscosity virial coefficient (initial-density contribution)
c  of a pure fluid as a function of temperature
c
c  inputs:
c    icomp--component number in mixture (1..nc); 1 for pure fluid
c        t--temperature [K]
c  outputs:
c    etaB2--second viscosity virial coefficient [L/(mol-uPa-s)]
c     ierr--error flag:  0 = successful
c                        1 = did not converge
c                       49 = unknown model specified
c     herr--error string (character*255 variable if ierr<>0)
c
c  written by M. McLinden, NIST Phys & Chem Properties Div, Boulder, CO
c  10-30-96  MM, original version
c  01-21-97  MM, call ETA1B2 for model VS1
c  03-07-00 EWL, add VS0 model
c  03-06-02 EWL, initialize etaB2
c  12-26-06 MLH, added vs4 model
c  12-10-07 MLH, added possible etab2 for vs4 model
c
      include 'commons.for'
      include 'comtrn.for'
      character*255 herr
c
      ierr=0
      etaB2=0.0d0
      herr=' '
c
c  call appropriate core viscosity model
c  note that only the VS1 pure-fluid model presently implements an
c  explicit initial-density term
      if (heta(icomp).eq.'VS0') then
        etaB2=0.0d0
      else if (heta(icomp).eq.'VS1') then
        etaB2=ETA1B2(icomp,t)
      else if (heta(icomp).eq.'VS2') then
        etaB2=0.0d0                  !no initial-density term for Y+E
      else if (heta(icomp).eq.'VS3') then
        etaB2=0.0d0
      else if (heta(icomp).eq.'VS4') then
        etaB2=ETA1B2(icomp,t)
      else if (heta(icomp).eq.'VS5') then
        etaB2=0.0d0
      else if (heta(icomp).eq.'VS6') then
c       etaB2=ETA6B2(icomp,t)
        etaB2=0.0d0                  !temporary
      else
        ierr=49
        herr='[ETAK1 error 49] unknown viscosity model specified'//hnull
        call ERRMSG (ierr,herr)
      end if
c
      RETURN
      end                                              !subroutine ETAK1
c
c ======================================================================
c
      subroutine ETAKR (icomp,t,rho,etar,ierr,herr)
c
c  residual contribution to the viscosity of a pure fluid as a function
c  of temperature and density
c
c  inputs:
c    icomp--component number in mixture (1..nc); 1 for pure fluid
c        t--temperature [K]
c      rho--molar density [mol/L]
c  outputs:
c     etar--viscosity [uPa.s]
c     ierr--error flag:  0 = successful
c                        1 = did not converge
c                       49 = unknown model specified
c     herr--error string (character*255 variable if ierr<>0)
c
c  written by M. McLinden, NIST Phys & Chem Properties Div, Boulder, CO
c  10-30-96  MM, original version
c  03-07-00 EWL, add VS0 model
c  03-05-02 EWL, initialize etar
c  03-21-02 MLH, modified VS0 model to have residual piece
c  12-26-06 MLH, added vs4 model
c  11-02-07 MLH, added Chung model
c
      include 'commons.for'
      include 'comtrn.for'
      character*255 herr
c
      ierr=0
      etar=0.0d0
      herr=' '
c
c  call appropriate core viscosity model
      if (heta(icomp).eq.'VS0') then
c       eta0hc provides full viscosities; subtract dilute to get resid
        etar=ETA0HC(icomp,t,rho,ierr,herr)-ETA0DG(icomp,t)
      else if (heta(icomp).eq.'VS1') then
        etar=ETA1RS(icomp,t,rho)
      else if (heta(icomp).eq.'VS2') then
        etar=ETA2RS(icomp,t,rho)
      else if (heta(icomp).eq.'VS3') then
        etar=ETA3RS(icomp,t,rho)
      else if (heta(icomp).eq.'VS4') then
        etar=ETA4RS(icomp,t,rho)
      else if (heta(icomp).eq.'VS5') then
        etar=ETA5RS(icomp,t,rho)
      else if (heta(icomp).eq.'VS6') then
c       etar=ETA6RS(icomp,t,rho)
        etar=0.0d0                  !temporary
        ierr=49
        herr='[ETAKR error 49] call to unimplemented model (VS6)'
        call ERRMSG (ierr,herr)
      else
        ierr=49
        herr='[ETAKR error 49] unknown viscosity model specified'//hnull
        call ERRMSG (ierr,herr)
      end if
c
      RETURN
      end                                              !subroutine ETAKR
c
c ======================================================================
c
      subroutine ETAKB (icomp,t,rho,etab,ierr,herr)
c
c  background contribution to the viscosity of a pure fluid as a
c  function of temperature and density; this includes both the residual
c  term and any initial density (second virial) term
c
c  inputs:
c    icomp--component number in mixture (1..nc); 1 for pure fluid
c        t--temperature [K]
c      rho--molar density [mol/L]
c  outputs:
c     etab--background viscosity [uPa.s]
c     ierr--error flag:  0 = successful
c                      <>0 = error in underlying routine, passed up
c     herr--error string (character*255 variable if ierr<>0)
c
c  written by M. McLinden, NIST Phys & Chem Properties Div, Boulder, CO
c  02-04-97  MM, original version
c  11-19-07  MLH, added init values, removed unused commons, declarations
c
      include 'commons.for'
      include 'comtrn.for'
      character*255 herr
c
      etab=0.0d0
      ierr=0
      herr=' '
c
c  the viscosity is the sum of the dilute-gas, initial-density, and
c  residual terms (separate functions for the three terms are used
c  because of the requirements of certain mixture models, e.g. ECS);
c  this routine returns the sum of the initial-density and residual terms
c
      call ETAK0(icomp,t,eta0,ierr,herr)
      call ETAK1(icomp,t,etaB2,ierr,herr)
      call ETAKR(icomp,t,rho,etar,ierr,herr)
      etab=eta0*etaB2*rho+etar
c     write (*,1000) icomp,t,rho,eta0,eta0*etaB2*rho,etar,etab
c1000 format (1x,' ETAKB--icomp,t,rho,etao,B2,resid,sum:  ',i3,6f12.4)
c
      RETURN
      end                                              !subroutine ETAKB
c
c ======================================================================
c
      subroutine TCXK (icomp,t,rho,tcx,ierr,herr)
c
c  thermal conductivity of a pure fluid as a function of temp and density
c
c  inputs:
c    icomp--component number in mixture (1..nc); 1 for pure fluid
c        t--temperature [K]
c      rho--molar density [mol/L]
c  outputs:
c      tcx--thermal conductivity [W/m-K]
c     ierr--error flag:  0 = successful
c                        1 = did not converge
c                       39 = unknown model specified
c     herr--error string (character*255 variable if ierr<>0)
c
c  written by M. McLinden, NIST Phys & Chem Properties Div, Boulder, CO
c  10-15-96  MM, original version
c  10-30-96  MM, call intermediate TCXK0, etc routines rather than
c                core-level routines directly
c  11-16-07  MLH, added initial values, removed unused commons, declarations
c
      include 'commons.for'
      include 'comtrn.for'
      character*255 herr
c
      ierr=0
      herr=' '
      tcx=0.0d0
c
c  the thermal conductivity is the sum of the dilute-gas, background
c  (or residual), and critical enhancement terms (separate functions
c  for the three terms are used because of the requirements of certain
c  mixture models, e.g. ECS)
c
      call TCXK0(icomp,t,tcx0,ierr,herr)
      call TCXKB(icomp,t,rho,tcxb,ierr,herr)
      call TCXKC(icomp,t,rho,tcxc,ierr,herr)
      tcx=tcx0+tcxb+tcxc
c     write (*,1000) icomp,t,rho,tcx0,tcxb,tcxc,tcx
c1000 format (1x,' TCXK--icomp,t,rho,tcx_0,bk,crit,sum:  ',i3,6f12.6)
c
      RETURN
      end                                               !subroutine TCXK
c
c ======================================================================
c
      subroutine TCXK0 (icomp,t,tcx0,ierr,herr)
c
c  dilute-gas part of the thermal conductivity of a pure fluid as a
c  function of temp and density
c
c  inputs:
c    icomp--component number in mixture (1..nc); 1 for pure fluid
c        t--temperature [K]
c  outputs:
c     tcx0--thermal conductivity [W/m-K]
c     ierr--error flag:  0 = successful
c                        1 = did not converge
c                       39 = unknown model specified
c     herr--error string (character*255 variable if ierr<>0)
c
c  written by M. McLinden, NIST Phys & Chem Properties Div, Boulder, CO
c  10-30-96  MM, original version
c  03-07-00 EWL, add TC0 model
c  11-05-07 MLH, add TC5 model, initial values
c
      include 'commons.for'
      include 'comtrn.for'
      character*255 herr
c
      ierr=0
      herr=' '
      tcx0=0.0d0
c
c  call appropriate core thermal conductivity model
      if (htcx(icomp).eq.'TC0') then
        tcx0=0.0d0
      else if (htcx(icomp).eq.'TC1') then
        tcx0=TCX1DG(icomp,t)
      else if (htcx(icomp).eq.'TC2') then
        tcx0=TCX2DG(icomp,t)
      else if (htcx(icomp).eq.'TC3') then
        tcx0=TCX3DG(icomp,t)
      else if (htcx(icomp).eq.'TC5') then
        tcx0=TCX5DG(icomp,t)
      else if (htcx(icomp).eq.'TC6') then
c       tcx0=TCX6DG(icomp,t)
        tcx0=0.0d0                   !temporary
        ierr=39
        herr='[TCXK0 error 39] call to unimplemented model (TC6)'
        call ERRMSG (ierr,herr)
      else
        ierr=39
        herr='[TCXK0 error 39] unknown thermal conductivity model'//
     &       ' specified'//hnull
        call ERRMSG (ierr,herr)
      end if
c
      RETURN
      end                                              !subroutine TCXK0
c
c ======================================================================
c
      subroutine TCXKB (icomp,t,rho,tcxb,ierr,herr)
c
c  background part of the thermal conductivity of a pure fluid as a
c  function of temp and density
c
c  inputs:
c    icomp--component number in mixture (1..nc); 1 for pure fluid
c        t--temperature [K]
c      rho--molar density [mol/L]
c  outputs:
c     tcxb--thermal conductivity [W/m-K]
c     ierr--error flag:  0 = successful
c                        1 = did not converge
c                       39 = unknown model specified
c     herr--error string (character*255 variable if ierr<>0)
c
c  written by M. McLinden, NIST Phys & Chem Properties Div, Boulder, CO
c  10-30-96  MM, original version
c  03-07-00 EWL, add TC0 model
c  11-05-07 MLH, add TC5 model, initial values
c
      include 'commons.for'
      include 'comtrn.for'
      character*255 herr
c
      ierr=0
      herr=' '
      tcxb=0.0d0
c
c  call appropriate core thermal conductivity model
      if (htcx(icomp).eq.'TC0') then
        tcxb=TCX0HC(icomp,t,rho,ierr,herr)
      elseif (htcx(icomp).eq.'TC1') then
        tcxb=TCX1BK(icomp,t,rho)
      else if (htcx(icomp).eq.'TC2') then
        tcxb=TCX2BK(icomp,t,rho)
      else if (htcx(icomp).eq.'TC3') then
        tcxb=TCX3BK(icomp,t,rho)
      else if (htcx(icomp).eq.'TC5') then
        tcxb=TCX5BK(icomp,t,rho)
      else if (htcx(icomp).eq.'TC6') then
c       tcxb=TCX6BK(icomp,t,rho)
        tcxb=0.0d0                   !temporary
        ierr=39
        herr='[TCXKB error 39] call to unimplemented model (TC6)'
        call ERRMSG (ierr,herr)
      else
        ierr=39
        herr='[TCXKB error 39] unknown thermal conductivity model'//
     &       ' specified'//hnull
        call ERRMSG (ierr,herr)
      end if
c
      RETURN
      end                                              !subroutine TCXKB
c
c ======================================================================
c
      subroutine TCXKC (icomp,t,rho,tcxc,ierr,herr)
c
c  critical enhancement for the thermal conductivity of a pure fluid as
c  a function of temp and density
c
c  inputs:
c    icomp--component number in mixture (1..nc); 1 for pure fluid
c        t--temperature [K]
c      rho--molar density [mol/L]
c  outputs:
c     tcxc--thermal conductivity [W/m-K]
c     ierr--error flag:  0 = successful
c                        1 = did not converge
c                       39 = unknown model specified
c     herr--error string (character*255 variable if ierr<>0)
c
c  written by M. McLinden, NIST Phys & Chem Properties Div, Boulder, CO
c  10-30-96  MM, original version
c  02-24-97  MM, add /CREMOD/
c  11-06-00 EWL, add water
c  07-01-02 MLH, add TK6
c  11-19-07 MLH, added initial values, removed unused commons, declarations
c
      include 'commons.for'
      include 'comtrn.for'
      character*255 herr
      dimension xfeed(ncmax)
c
      ierr=0
      herr=' '
      tcxc=0.0d0
c
c  call appropriate core thermal conductivity model
c     write (*,1100) icomp,htcxcr(icomp),t,rho
c1100 format (1x,' TCXKC--icomp,htcxcr:  ',i2,2x,a3,'; at t,rho = ',
c    &            2e14.6)
      if (htcxcr(icomp).eq.'TK1') then
        tcxc=TCX1CR(icomp,t,rho)
      else if (htcxcr(icomp).eq.'TK2') then
c  hydrocarbon model of Younglove & Ely (critical part integral w/ TC2)
        tcxc=TCX2CR(icomp,t,rho)
      else if (htcxcr(icomp).eq.'TK3') then
c       write (*,*) ' TCXKC--call critical model TK3'
        tcxc=TCX3CR(icomp,t,rho)
c       write (*,*) ' TCXKC--critical enhancement from TK3: ',tcxc
      else if (htcxcr(icomp).eq.'TK4') then
        tcxc=TCX4CR(icomp,t,rho)
      else if (htcxcr(icomp).eq.'TK6') then
        do i=1,ncmax
          xfeed(i)=0.d0
        enddo
        xfeed(icomp)=1.0d0
        tcxc=TCXM1C(xfeed,t,rho,ierr,herr)
c       tcxc=0.0d0                   !temporary
c       ierr=39
c       herr='[TCXKC error 39] call to unimplemented model (TK6)'
c       call ERRMSG (ierr,herr)
      else if (htcxcr(icomp).eq.'NUL') then
c  no critical enhancement is used
        tcxc=0.0d0
      else if (htcxcr(icomp).eq.'NH3') then
c  special function for ammonia; model of Tufeu
        tcxc=TCCNH3(icomp,t,rho)
      else if (htcxcr(icomp).eq.'CH4') then
c  special function for methane; model of Friend et al.
        tcxc=TCCCH4(icomp,t,rho)
      else
        ierr=39
        herr='[TCXKC error 39] unknown thermal conductivity critical'//
     &       ' enhancement model specified: '//htcxcr(icomp)//hnull
        call ERRMSG (ierr,herr)
      end if
c
      RETURN
      end                                              !subroutine TCXKC
c
c ======================================================================
c
      function OMEGA (icomp,t,epsk,hmodci)
c
c  collision integral for a pure fluid as a function of temperature and
c  the Lennard-Jones epsilon/k parameter
c
c  inputs:
c    icomp--component number in mixture (1..nc); 1 for pure fluid
c        t--temperature [K]
c     epsk--Lennard-Jones epsilon/k parameter [K]
c  output (as function value):
c    omega--the collision integral
c
c  written by M. McLinden, NIST Phys & Chem Properties Div, Boulder, CO
c  10-16-96  MM, original version
c  01-31-97  MM, add case of model = 'NUL'
c  03-07-00  EWL, add CI0 model
c  11-19-07  MLH, removed unused commons, declarations
c
      include 'commons.for'
      include 'comtrn.for'
      character*3 hmodci
c
c  call appropriate function for collision integral
      omega=1.0d0
      if (hmodci.eq.'CI1') then
        OMEGA=OMEGA1(icomp,t,epsk)
      else if (hmodci.eq.'CI2') then
        OMEGA=OMEGA2(icomp,t,epsk)
      else if (hmodci.eq.'CI0') then
        if (abs(epsk).gt.1.d-20) OMEGA=OMEGAS(2,2,t/epsk)
      else if (hmodci.eq.'NUL') then
c  collision integral not used; 'NUL' is place-holder in fluid file
c  should not ever get here, but return value to avoid error
        OMEGA=1.0d0   !return 1, as omega appears in denominator
      else
c       write (*,*) '[OMEGA error] unknown col integral: ',hmodci
        OMEGA=1.0d0   !return 1, as omega appears in denominator
      end if
c
      RETURN
      end                                                !function OMEGA
c
c ======================================================================
c
      subroutine SETCI1 (nread,icomp,hcasno,ierr,herr)
c
c  initialize the collision integral; this is an empirical function in
c  log(T), the form used by several authors including Fenghour (1995) for
c  ammonia and Krauss (1996) for R152a; this same form is used for the
c  "reduced effective collision cross-section" used by Wilhelm & Vogel
c  (1995) and Laesecke (1997) for R134a
c
c  inputs:
c    nread--file to read data from
c           <= 0 get data from block data
c           >0 read from logical unit nread (file should have already
c              been opened and pointer set by subroutine SETUP)
c    icomp--component number in mixture (0..nc)
c           1 for pure fluid; 0 for ECS reference fluid
c   hcasno--CAS number of component icomp (not req'd if reading from file)
c
c  outputs:
c     ierr--error flag:  0 = successful
c                       39 = error--model not implemented
c     herr--error string (character*255 variable if ierr<>0)
c     other quantities returned via arrays in commons
c
c  written by M. McLinden, NIST Phys & Chem Properties Div, Boulder, CO
c  01-21-97  MM, original version (based on SETCI2)
c  05-14-97  MM, change power of T coefficient to integer, add to /WIFOMG/
c  08-19-97  MM, change error number for nread<=0; input hcasno is not array
c  12-02-97  MM, skip over limits on file read
c  08-13-98  MM, delete obsolete (unused) format statement
c
      include 'commons.for'
      include 'comtrn.for'
      character*12 hcasno
      character*255 herr
c
c  commons storing the coefficients to the fit for collision integral
c
      if (nread.le.0) then
c  get coefficients from block data--this option not implemented,
c  place holder to maintain parallel structure with EOS setup routines
        ierr=101
        write (herr,1101) nread,hcasno,hnull
        call ERRMSG (ierr,herr)
 1101   format ('[SETCI1 error 101] illegal file specified; nread = ',
     &          i4,'; CAS no. = ',a12,a1)
      else
c  read data from file (should have been opened by SETUP)
c       write (*,*) ' SETCI1--read component',icomp,' from unit',nread
c  limits are not used with collision integral, but retain for compatibility
        read (nread,*) !tmin       !lower temperature limit (dummy)
        read (nread,*) !tmax       !upper temperature limit (dummy)
        read (nread,*) !pjunk      !upper pressure limit (n/a)
        read (nread,*) !rhojnk     !upper density limit (n/a)
        read (nread,*) nterm       !number of terms
        ntomg(icomp)=nterm
        if (ntomg(icomp).ge.1) then
          do j=1,ntomg(icomp)
c  first is numerical coeff, second is power of T
            read (nread,*) comg(icomp,j,1),icomg(icomp,j)
          enddo
        end if
c       write (*,*) ' SETCI1--final coeff: ',comg(icomp,nterm,1)
        ierr=0
        herr=' '
      end if
c
      RETURN
      end                                             !subroutine SETCI1
c
c ======================================================================
c
      function OMEGA1 (icomp,t,epsk)
c
c  collision integral for a pure fluid as a function of temperature and
c  the Lennard-Jones epsilon/k parameter; this is an empirical function
c  of a form used by several authors including Fenghour (1995) for
c  ammonia, Krauss (1996) for R152a, Laesecke (1997) for R134a, and
c  Vesovic (1990) for carbon dioxide.
c
c  inputs:
c    icomp--component number in mixture (1..nc); 1 for pure fluid
c        t--temperature [K]
c     epsk--Lennard-Jones energy (epsilon/k) parameter [K]
c  output (as function value):
c    omega--the collision integral
c
c  written by M. McLinden, NIST Phys & Chem Properties Div, Boulder, CO
c  01-21-97  MM, original version (based on OMEGA2)
c  05-14-97  MM, change power of T coefficient to integer, add to /WIFOMG/
c  01-19-00  EWL, check for tstar=0 and avoid 0**0 error message
c  11-19-07  MLH, removed unused commons, declarations
c
      include 'commons.for'
      include 'comtrn.for'
c
      omega1=1.0d0
      tstar=1.0d-20
      omgsum=0.0d0
      if (abs(epsk).gt.1.d-20) tstar=LOG(t/epsk)
      if (ABS(tstar).lt.1.0d-20) tstar=1.0d-20
      do n=1,ntomg(icomp)
        omgsum=omgsum+comg(icomp,n,1)*tstar**icomg(icomp,n)
      enddo
      OMEGA1=EXP(omgsum)
      RETURN
      end                                               !function OMEGA1
c
c ======================================================================
c
      subroutine SETCI2 (nread,icomp,hcasno,ierr,herr)
c
c  initialize the collision integral function of Younglove and Ely,
c  JPCRD 16:577-798 (1987)
c
c  inputs:
c    nread--file to read data from
c           <= 0 get data from block data
c           >0 read from logical unit nread (file should have already
c              been opened and pointer set by subroutine SETUP)
c    icomp--component number in mixture (0..nc)
c           1 for pure fluid; 0 for ECS reference fluid
c   hcasno--CAS number of component icomp (not req'd if reading from file)
c
c  outputs:
c     ierr--error flag:  0 = successful
c                       39 = error--model not implemented
c     herr--error string (character*255 variable if ierr<>0)
c     other quantities returned via arrays in commons
c
c  written by M. McLinden, NIST Phys & Chem Properties Div, Boulder, CO
c  10-16-96  MM, original version
c  01-21-97  MM, add /WIFOMG/ (store # terms) for parallel w/ OMEGA1
c  05-14-97  MM, add icomg to /WIFOMG/ (used in OMEGA1)
c  08-19-97  MM, change error number for nread<=0
c  12-02-97  MM, skip over limits on file read
c  08-13-98  MM, delete obsolete (unused) format statement
c
      include 'commons.for'
      include 'comtrn.for'
      character*12 hcasno
      character*255 herr
c
      if (nread.le.0) then
c  get coefficients from block data--this option not implemented,
c  place holder to maintain parallel structure with EOS setup routines
        ierr=101
        write (herr,1101) nread,hcasno,hnull
        call ERRMSG (ierr,herr)
 1101   format ('[SETCI2 error 101] illegal file specified; nread = ',
     &          i4,'; CAS no. = ',a12,a1)
      else
c  read data from file (should have been opened by SETUP)
c       write (*,*) ' SETCI2--read component',icomp,' from unit',nread
c  limits are not used with collision integral, but retain for compatibility
        read (nread,*) !tmin       !lower temperature limit (dummy)
        read (nread,*) !tmax       !upper temperature limit (dummy)
        read (nread,*) !pjunk      !upper pressure limit (n/a)
        read (nread,*) !rhojnk     !upper density limit (n/a)
        read (nread,*) nterm       !number of terms
        ntomg2(icomp)=nterm
        if (nterm.ge.1) then
          do j=1,nterm
            read (nread,*) comg2(icomp,j,1)
c  the second element in coeff array is not used for this model
            comg2(icomp,j,2)=0.0d0
          enddo
        end if
c       write (*,*) ' SETCI1--final coeff: ',comg2(icomp,nterm,1)
        ierr=0
        herr=' '
      end if
c
      RETURN
      end                                             !subroutine SETCI2
c
c ======================================================================
c
      function OMEGA2 (icomp,t,epsk)
c
c  collision integral for a pure fluid as a function of temperature and
c  the Lennard-Jones epsilon/k parameter; based on Equation (20) in
c  Younglove and Ely, JPCRD 16:577-798 (1987).
c
c  N.B.  there is misprint in Younglove & Ely, the exponent
c        is ((4-n)/3) not ((n+2)/3)
c
c  inputs:
c    icomp--component number in mixture (1..nc); 1 for pure fluid
c        t--temperature [K]
c     epsk--Lennard-Jones energy (epsilon/k) parameter [K]
c  output (as function value):
c    omega--the collision integral
c
c  written by M. McLinden, NIST Phys & Chem Properties Div, Boulder, CO
c  10-16-96  MM, original version
c  01-21-97  MM, add /WIFOMG/ to maintain parallel w/ OMEGA1
c  05-14-97  MM, add icomg to /WIFOMG/ (used in OMEGA1)
c  11-19-07  MLH, removed unused commons, declarations
c
      include 'commons.for'
      include 'comtrn.for'
c
      ekt3=1.0d0
      omega2=1.0d0
      omgsum=0.0d0
      if (t.gt.0.d0) ekt3=(epsk/t)**(1.0d0/3.0d0)
      do n=1,ntomg2(icomp)
        omgsum=omgsum+comg2(icomp,n,1)*ekt3**(4-n)
      enddo
      if (abs(omgsum).gt.1.d-20) OMEGA2=1.0d0/omgsum
      RETURN
      end                                               !function OMEGA2
c
c
c        1         2         3         4         5         6         7
c23456789012345678901234567890123456789012345678901234567890123456789012
c
c ======================================================================
c                                                       end file trnsp.f
c ======================================================================
c  begin file trns_TCX.f
c
c  This file contains the core routines for thermal conductivity
c
c  contained here are:
c     subroutine SETTC0 (nread,icomp,hcasno,ierr,herr)
c     function TCX0HC (icomp,t,rho,ierr,herr)
c     subroutine SETTC1 (nread,icomp,hcasno,ierr,herr)
c     function TCX1DG (icomp,t)
c     function TCX1BK (icomp,t,rho)
c     subroutine SETTC2 (nread,icomp,hcasno,ierr,herr)
c     function TCX2DG (icomp,t)
c     function TCX2BK (icomp,t,rho)
c     function TCX2CR (icomp,t,rho)
c     subroutine SETTC3 (nread,icomp,hcasno,ierr,herr)
c     function TCX3DG (icomp,t)
c     function TCX3BK (icomp,t,rho)
c     subroutine SETTC6 (nread,icomp,hcasno,ierr,herr)
c     subroutine SETTK1 (nread,icomp,hcasno,ierr,herr)
c     function TCX1CR (icomp,t,rho)
c     subroutine SETTK3 (nread,icomp,hcasno,ierr,herr)
c     function TCX3CR (icomp,t,rho)
c     subroutine SETTK4 (nread,icomp,hcasno,ierr,herr)
c     function TCX4CR (icomp,t,rho)
c     subroutine SETTC5 (nread,icomp,hcasno,ierr,herr)
c     function TCX5DG (icomp,t)
c     function TCX5BK (icomp,t,rho)
c     subroutine SETTK6 (nread,icomp,hcasno,ierr,herr)
c     function TCCNH3 (icomp,t,rho)
c     function TCCCH4 (icomp,t,rho)
c     FUNCTION TCXH2(ICOMP,T,D)
c       FUNCTION THERMX(DE,D0,THER)
c       FUNCTION DILT(ICOMP,T)
c       FUNCTION RCRIT(D,T)
c       FUNCTION RTHERM(ICOMP,DD,TIN)
c       FUNCTION CRITH2(D,T)
c       FUNCTION EXCSH2(ICOMP,D,T)
c       FUNCTION REXCES(D,T)
c     function TCXHE (icomp,t,rho)
c     function TCXETY (icomp,t,rho)
c     function TCXR23 (icomp,t,rho)
c     function TCXD2O (icomp,t,rho)
c     function TCXH2O (icomp,t,rho)
c     function TCCR_2010 (T,RHOmol,QD)
c     function TCXM1C (x,t,rho,ierr,herr)
c
c =====================================================================
c =====================================================================
c
      subroutine SETTC0 (nread,icomp,hcasno,ierr,herr)
c
c  initialize pure fluid thermal conductivity model #0; the model
c  which points to all the hardcoded equations.
c
c  inputs:
c    nread--file to read data from
c           >0 read from logical unit nread (file should have already
c              been opened and pointer set by subroutine SETUP)
c    icomp--component number in mixture (0..nc)
c           1 for pure fluid; 0 for ECS reference fluid
c   hcasno--CAS number of component icomp (not req'd if reading from file)
c
c  outputs:
c     ierr--error flag:  0 = successful
c     herr--error string (character*255 variable if ierr<>0)
c
c  written by E.W. Lemmon, NIST Phys & Chem Properties Div, Boulder, CO
c  02-29-00 EWL, original version
c
      include 'commons.for'
      include 'comtrn.for'
      character*12 hcasno
      character*255 herr
c
c  read data from file (should have been opened by SETUP)
c     write (*,*) ' SETTC0--read component',icomp,' from unit',nread
      write (herr,'(a12)') hcasno  !Use hcasno to avoid warning message
      read (nread,*) tmtcx(icomp)              !lower temperature limit
      read (nread,*) txtcx(icomp)              !upper temperature limit
      read (nread,*) pxtcx(icomp)              !upper pressure limit
      read (nread,*) Dxtcx(icomp)              !upper density limit
c
c  read in pointer to the hardcoded model
      read (nread,2003) htcxhc(icomp)
      read (nread,*) ndgnum(icomp),ndgden(icomp),
     &               nbknum(icomp),nbkden(icomp)
      jterm=0                                 !term counter
      nrsum=ndgnum(icomp)+ndgden(icomp)+nbknum(icomp)+nbkden(icomp)
      if (nrsum.ge.1) then
c  read in reducing parameters
        read (nread,*) trdbkt(icomp),Drdbkt(icomp),tcxbkt(icomp)
        do j=1,nrsum
          jterm=jterm+1
          read (nread,*) (ctcx(icomp,jterm,k),k=1,4),itcx(icomp,jterm)
        enddo
      end if
c
c  read in pointer to critical enhancement model
      read (nread,2003) htcxcr(icomp)
c     write (*,*) ' SETTC0--will use model ',htcxhc(icomp)
      ierr=0
      herr=' '
c
      RETURN
 2003 format (a3)
      end                                             !subroutine SETTC0
c
c ======================================================================
c
      function TCX0HC (icomp,t,rho,ierr,herr)
c
c  model for the hardcoded thermal conductivity models
c
c  inputs:
c    icomp--component number in mixture (1..nc); 1 for pure fluid
c        t--temperature [K]
c        d--molar density [mol/L]
c  output (as function value):
c   tcx0hc--thermal conductivity [W/m-K]
c
c  written by E.W. Lemmon, NIST Phys & Chem Properties Div, Boulder, CO
c  02-29-00 EWL, original version
c  12-21-09 MLH, added D2, T2, HE3 models
c
      include 'commons.for'
      include 'comtrn.for'
      character*255 herr
c
      ierr=0
      herr=' '
      TCX0HC=0.0d0
      if (htcxhc(icomp).eq.'ETY') THEN
        TCX0HC=TCXETY(icomp,t,rho)
      elseif (htcxhc(icomp).eq.'R23') THEN
        TCX0HC=TCXR23(icomp,t,rho)
      elseif (htcxhc(icomp).eq.'D2O') THEN
        TCX0HC=TCXD2O(icomp,t,rho)
      elseif (htcxhc(icomp).eq.'H2O') THEN
        TCX0HC=TCXH2O(icomp,t,rho)
      elseif (htcxhc(icomp).eq.'HE') THEN
        TCX0HC=TCXHE(icomp,t,rho)
      elseif (htcxhc(icomp).eq.'H2') THEN
        TCX0HC=TCXH2(icomp,t,rho)
      elseif (htcxhc(icomp).eq.'D2') THEN
        IF(t.ge.tcrit(icomp))ratlam=0.031*rho*((tcrit(icomp)/t)**5)
     &    +1.0d0/SQRT(2.d0) !1/sqrt(2) is theoretical value for gas
        IF(t.lt.tcrit(icomp))ratlam=0.031*rho+1.0d0/SQRT(2.d0)
        IF(ratlam.gt.0.92)ratlam=0.92  !match Powers 1954 for liq
        TCX0HC=TCXH2(icomp,t,rho)*ratlam
      elseif (htcxhc(icomp).eq.'T2') THEN !scale to h2 with theoretical limit for gas
        TCX0HC=TCXH2(icomp,t,rho)/SQRT(3.0d0)
      elseif (htcxhc(icomp).eq.'HE3') THEN !scale to he4 with theoretical limit for gas
        TCX0HC=TCXHE(icomp,t,rho)/SQRT(3.0d0/4.0d0)
      else
        ierr=39
        herr='[TCX0HC error 39] unknown thermal conductivity model'//
     &       ' specified'//hnull
        call ERRMSG (ierr,herr)
      endif
      RETURN
      end                                               !function TCX0HC
c
c ======================================================================
c
      subroutine SETTC1 (nread,icomp,hcasno,ierr,herr)
c
c  initialize pure fluid thermal conductivity model #1; this, the
c  "composite model," is written in a general form with terms designed
c  to include several recent correlations including those of Tufeu
c  (1984) for ammonia, Krauss (1996) for R152a, and Laesecke (1996) for
c  R123.
c
c  inputs:
c    nread--file to read data from
c           <= 0 get data from block data
c           >0 read from logical unit nread (file should have already
c              been opened and pointer set by subroutine SETUP)
c    icomp--component number in mixture (0..nc)
c           1 for pure fluid; 0 for ECS reference fluid
c   hcasno--CAS number of component icomp (not req'd if reading from file)
c
c  outputs:
c     ierr--error flag:  0 = successful
c                       49 = error--model not implemented
c     herr--error string (character*255 variable if ierr<>0)
c     other quantities returned via arrays in commons
c
c  written by M. McLinden, NIST Phys & Chem Properties Div, Boulder, CO
c  02-06-97  MM, original version
c  08-19-97  MM, change error number for nread<=0; input hcasno is not array
c
      include 'commons.for'
      include 'comtrn.for'
      character*12 hcasno
      character*255 herr
c
      if (nread.le.0) then
c  get coefficients from block data--this option not implemented,
c  place holder to maintain parallel structure with EOS setup routines
        ierr=101
        write (herr,1101) nread,hcasno,hnull
        call ERRMSG (ierr,herr)
 1101   format ('[SETTC1 error 101] illegal file specified; nread = ',
     &          i4,'; CAS no. = ',a12,a1)
      else
c  read data from file (should have been opened by SETUP)
c       write (*,*) ' SETTC1--read component',icomp,' from unit',nread
        read (nread,*) tmtcx(icomp)              !lower temperature limit
        read (nread,*) txtcx(icomp)              !upper temperature limit
        read (nread,*) pxtcx(icomp)              !upper pressure limit
        read (nread,*) Dxtcx(icomp)              !upper density limit
        jterm=0                                 !term counter
c  read the number of terms in the numerator and denominator of the
c  dilute-gas function
        read (nread,*) ndgnum(icomp),ndgden(icomp)
c       write (*,*) ' SETTC1--about to read ',ndgnum(icomp),' +',
c    &              ndgden(icomp),' dilute terms'
        if (ndgnum(icomp).ge.1) then
          read (nread,*) trddgt(icomp),tcxdgt(icomp)  !reducing par
          do j=1,ndgnum(icomp)  !read dilute-gas terms (numerator)
            jterm=jterm+1
            read (nread,*) ctcx(icomp,jterm,1),ctcx(icomp,jterm,2)
          enddo
        end if
        if (ndgden(icomp).ge.1) then
          do j=1,ndgden(icomp)  !read dilute-gas terms (denominator)
            jterm=jterm+1
            read (nread,*) ctcx(icomp,jterm,1),ctcx(icomp,jterm,2)
          enddo
        end if
c
c  read the number of terms in the numerator and denominator of the
c  background model; the coefficients themselves are given in the order:
c    constant multiplier; temperature exponent; density exponent; spare
c
        read (nread,*) nbknum(icomp),nbkden(icomp)
        nbksum=nbknum(icomp)+nbkden(icomp)
c       write (*,*) ' SETTC1--about to read ',nbknum(icomp),' +',
c    &              nbkden(icomp),' background terms'
        if (nbksum.ge.1) then
c  read in reducing parameters
          read (nread,*) trdbkt(icomp),Drdbkt(icomp),tcxbkt(icomp)
          if (nbknum(icomp).ge.1) then
            do j=1,nbknum(icomp)    !numerator of rational polynomial
              jterm=jterm+1
              read (nread,*) (ctcx(icomp,jterm,k),k=1,4)
            enddo
          end if
          if (nbkden(icomp).ge.1) then
            do j=1,nbkden(icomp)    !denominator of rational poly
              jterm=jterm+1
              read (nread,*) (ctcx(icomp,jterm,k),k=1,4)
            enddo
          end if
        end if
c
c  read in pointer to critical enhancement model
        read (nread,2003) htcxcr(icomp)
c       write (*,*) ' SETTC1--will use critical model ',htcxcr(icomp)
c
        ierr=0
        herr=' '
      end if
c
      RETURN
 2003 format (a3)
      end                                             !subroutine SETTC1
c
c ======================================================================
c
      function TCX1DG (icomp,t)
c
c  dilute-gas contribution to the thermal conductivity by the
c  composite model (TC1)
c
c  inputs:
c    icomp--component number in mixture (1..nc); 1 for pure fluid
c        t--temperature [K]
c  output (as function value):
c   tcx1dg--the dilute-gas part of the thermal conductivity [W/m-K]
c
c  written by M. McLinden, NIST Phys & Chem Properties Div, Boulder, CO
c  02-06-97  MM, original version
c  03-28-97  MM, compute tau only if d.g. terms exist
c  06-08-97  MM, add special term; power = -99: mult by (1 + coeff*(Cp0-2.5R))
c  11-17-98  MM, nterm not incremented properly, denominator not correct--
c                appears to affect only CO2
c  11-10-99 EWL, add special term; power = -96
c
      include 'commons.for'
      include 'comtrn.for'
      character*255 herr
c
      tau=1.0d0
      i=icomp
      if ((ndgnum(i)+ndgden(i)).ge.1) then
c  compute tau only if dilute-gas terms exist, otherwise treddg may
c  not be defined
        tau=t/trddgt(icomp)
c       write t(*,*) 'TCX1DG--tred,tau:  ',trddgt(icomp),tau
      end if
c
      nterm=0                                    !term counter
c  sum the dilute-gas terms, first numerator then denominator
      tcx1dg=0.0d0
      if (ndgnum(i).ge.1) then
        do j=nterm+1,nterm+ndgnum(i)
          if (ctcx(i,j,2).lt.-90.0d0) then
            if (ABS(ctcx(i,j,2)+99.0d0).lt.1.0d-6) then
c  flag:  exponent -99 indicates: multiply numerator term by
c  [1 + coeff*(Cp0 - 2.5*R)]; this is the Cv_internal as used by
c  Vesovic, et al. (1990) for carbon dioxide
              cint=CP0K(icomp,t)-2.5d0*R
              cp01=1.0d0+ctcx(i,j,1)*cint
c           write (*,*) ' TCX1DG--will mult by Cp0 - 2.5*R: ',cint
              tcx1dg=tcx1dg*cp01
            elseif (ABS(ctcx(i,j,2)+98.0d0).lt.1.0d-6) then
c  flag:  exponent -98 indicates: add Cv0*eta0 to numerator
              call ETAK0(icomp,t,eta,ierr,herr)
              cint=CP0K(icomp,t)-R
              tcx1dg=tcx1dg+ctcx(i,j,1)*cint*eta
            elseif (ABS(ctcx(i,j,2)+97.0d0).lt.1.0d-6) then
c  flag:  exponent -97 indicates: add eta0 to numerator
              call ETAK0(icomp,t,eta,ierr,herr)
              tcx1dg=tcx1dg+ctcx(i,j,1)*eta
            elseif (ABS(ctcx(i,j,2)+96.0d0).lt.1.0d-6) then
c  flag:  exponent -96 indicates: add fint*eta0/M*(Cp0-2.5R)+15/4*R*eta0/M
c         where fint was created by the previous terms.
              cint=CP0K(icomp,t)/R-2.5d0
              call ETAK0(icomp,t,eta,ierr,herr)
              fint=tcx1dg
              tcx1dg=(fint*cint+15.0d0/4.0d0)*R*eta/wmas(i)
            endif
          else
            tcx1dg=tcx1dg+ctcx(i,j,1)*tau**ctcx(i,j,2)
c         write (*,*) ' TCX1DG--j,tcx_dg(j): ',j,tcx1dg
          end if
        enddo
        nterm=nterm+ndgnum(i)
      end if
      if (ndgden(i).ge.1) then
        denom=0.0d0
        do j=nterm+1,nterm+ndgden(i)
c         write (*,*) 'denom coeff:  ',ctcx(i,j,1),ctcx(i,j,2)
          denom=denom+ctcx(i,j,1)*tau**ctcx(i,j,2)
        enddo
c       write (*,*) ' TCX1DG--num,denom: ',tcx1dg,denom
c  divide numerator by denominator
        tcx1dg=tcx1dg/denom
      end if
c
c  multiply by reducing parameter (to convert units, etc.)
      tcx1dg=tcx1dg*tcxdgt(i)
c
c     write (*,1000) icomp,tau,tcx1dg
c1000 format (' TCX1DG--icomp,tau,dilute-gas tc:',i10,d14.6,14x,d14.6)
      RETURN
      end                                               !function TCX1DG
c
c ======================================================================
c
      function TCX1BK (icomp,t,rho)
c
c  background contribution to the thermal conductivity by the
c  composite model (TC1)
c
c  inputs:
c    icomp--component number in mixture (1..nc); 1 for pure fluid
c        t--temperature [K]
c      rho--molar density [mol/L]
c  output (as function value):
c   tcx1bk--the background part of the thermal conductivity [W/m-K]
c
c  written by M. McLinden, NIST Phys & Chem Properties Div, Boulder, CO
c  02-06-97  MM, original version
c  03-28-97  MM, compute tau,del only if residual terms exist
c  02-17-99 EWL, add nbknum(i) to the "DO" statement for the denominator loop
c  01-26-00 EWL, add special terms for methane
c
      include 'commons.for'
      include 'comtrn.for'
c
      i=icomp
      tau=1.0d0
      del=1.0d0
      if ((nbknum(i)+nbkden(i)).ge.1) then
c  compute tau only if residual terms exist, otherwise tredbk, Dredbk may
c  not be defined
        tau=t/trdbkt(i)
        del=rho/Drdbkt(i)
      end if
      nterm=ndgnum(i)+ndgden(i)                        !term counter
c     write (*,*) ' TCX1BK--tau,del,coeff_1: ',tau,del,ctcx(i,nterm+1,1)
c
c  sum the background terms, first numerator then denominator
      tcx1bk=0.0d0
      if (nbknum(i).ge.1) then
        do j=nterm+1,nterm+nbknum(i)
          if (ctcx(i,j,4).lt.-90) then                      !Special cases
            if (ABS(ctcx(i,j,4)+99.0d0).lt.1.0d-6) then     !Methane
              if (t.lt.trdbkt(i) .and. rho.lt.Drdbkt(i)) then
                th = (1.0d0-t/trdbkt(i))**(1.0d0/3.0d0)
                dsat=-1.8802840d0*th**1.062d0 -2.8526531d0*th**2.500d0
     &               -3.0006480d0*th**4.500d0 -5.2511690d0*th**7.500d0
     &               -13.191869d0*th**12.50d0 -37.553961d0*th**23.50d0
                tcx1bk=tcx1bk/EXP(dsat)
              endif
            endif
          else
            hexp=1
            if (abs(ctcx(i,j,4)).gt.1.d-20) hexp=EXP(-del**ctcx(i,j,4))
            tcx1bk=tcx1bk
     &            +ctcx(i,j,1)*tau**ctcx(i,j,2)*del**ctcx(i,j,3)*hexp
          endif
        enddo
      end if
      if (nbkden(i).ge.1) then
        denom=0.0d0
        if (del.gt.0.0d0) then
          do j=nterm+nbknum(i)+1,nterm+nbknum(i)+nbkden(i)
            denom=denom+ctcx(i,j,1)*tau**ctcx(i,j,2)*del**ctcx(i,j,3)
          enddo
        endif
c  divide numerator by denominator
        if (abs(denom).gt.1.d-20) tcx1bk=tcx1bk/denom
      end if
c
c  multiply by reducing parameter (to convert units, etc.)
      tcx1bk=tcx1bk*tcxbkt(i)
c
c     write (*,1000) icomp,tau,del,tcx1bk
c1000 format (' TCX1BK--icomp,tau,del,background tc:  ',i4,3d14.6)
      RETURN
      end                                               !function TCX1BK
c
c ======================================================================
c
      subroutine SETTC2 (nread,icomp,hcasno,ierr,herr)
c
c  initialize pure fluid thermal conductivity model #2--the hydrocarbon
c  model of Younglove and Ely, JPCRD 16:577-798 (1987)
c
c  N.B.  Younglove and Ely use a special scaled equation of state to
c        compute derivatives for the critical enhancement; the default
c        EOS is used here
c
c  inputs:
c    nread--file to read data from
c           <= 0 get data from block data
c           >0 read from logical unit nread (file should have already
c              been opened and pointer set by subroutine SETUP)
c    icomp--component number in mixture (0..nc)
c           1 for pure fluid; 0 for ECS reference fluid
c   hcasno--CAS number of component icomp (not req'd if reading from file)
c
c  outputs:
c     ierr--error flag:  0 = successful
c                       39 = error--model not implemented
c     herr--error string (character*255 variable if ierr<>0)
c     other quantities returned via arrays in commons
c
c  written by M. McLinden, NIST Phys & Chem Properties Div, Boulder, CO
c  06-18-96  MM, original version (dummy placeholder)
c  10-16-96  MM, implement model of Younglove & Ely
c  08-19-97  MM, change error number for nread<=0; input hcasno is not array
c  09-00-00 EWL, change hmdci to hmdtcx and hmdeta to avoid overlapping vis.
c  03-08-00 EWL, do not read in enhancement info if pointer=NUL
c
      include 'commons.for'
      include 'comtrn.for'
      character*12 hcasno
      character*255 herr
c
      if (nread.le.0) then
c  get coefficients from block data--this option not implemented,
c  place holder to maintain parallel structure with EOS setup routines
        ierr=101
        write (herr,1101) nread,hcasno,hnull
        call ERRMSG (ierr,herr)
 1101   format ('[SETTC2 error 101] illegal file specified; nread = ',
     &          i4,'; CAS no. = ',a12,a1)
      else
c  read data from file (should have been opened by SETUP)
c       write (*,*) ' SETTC2--read component',icomp,' from unit',nread
        read (nread,*) tmtcx(icomp)              !lower temperature limit
        read (nread,*) txtcx(icomp)              !upper temperature limit
        read (nread,*) pxtcx(icomp)              !upper pressure limit
        read (nread,*) Dxtcx(icomp)              !upper density limit
        read (nread,2003) hmdtcx(icomp)         !pointer to omega model
        read (nread,*) ctcx(icomp,1,1)          !L-J sigma
        read (nread,*) ctcx(icomp,2,1)          !L-J epsilon/kappa
c  read constant in Eq 19 = 5/16*(k*MW/1000/pi/Na)**0.5*1.0d12
c  the factor of 1d12 is for sigma in nm and viscosity in micro-Pa-s
        read (nread,*) ctcx(icomp,3,1) !const in Eq 19
        do i=4,5
          read (nread,*) ctcx(icomp,i,1) !dilute-gas terms Gt(1)-Gt(2)
        enddo
        do i=6,13
          read (nread,*) ctcx(icomp,i,1) !background terms Et(1)-Et(8)
        enddo
c  read in pointer to critical enhancement model
        read (nread,2003) htcxcr(icomp)
        if (htcxcr(icomp).ne.'NUL') then
c       write (*,*) ' SETTC2--will use critical model ',htcxcr(icomp)
c  in the case of TC2, the critical enhancement is integral with the
c  model for the dilute gas and background contributions
        do i=14,17
          read (nread,*) ctcx(icomp,i,1) !critical enhancement X(1)-X(4)
        enddo
        read (nread,*) ctcx(icomp,18,1)!critical enhancement:  Z
        read (nread,*) ctcx(icomp,19,1)!critical enhancement:  k
c  following coefficients are for the viscosity function of Younglove &
c  Ely, which is also used in the thermal conductivity
        do i=20,23
          read (nread,*) ctcx(icomp,i,1) !initial rho terms:  Fv(1)-Fv(4)
        enddo
        do i=24,30
          read (nread,*) ctcx(icomp,i,1) !residual viscosity:  Ev(1)-Ev(7)
        enddo
        endif
        ierr=0
        herr=' '
      end if
c
      RETURN
 2003 format (a3)
      end                                             !subroutine SETTC2
c
c ======================================================================
c
      function TCX2DG (icomp,t)
c
c  dilute-gas contribution to the thermal conductivity by the
c  model of Younglove and Ely, JPCRD 16:577-798 (1987); Eqs 19, 27.
c
c  N.B. there are two terms missing from Eq 27 in the JPCRD article;
c       the 15R/4 is missing and a factor of 1/(mol wt) is needed to
c       convert units
c
c  inputs:
c    icomp--component number in mixture (1..nc); 1 for pure fluid
c        t--temperature [K]
c  output (as function value):
c   tcx2dg--the dilute gas part of the thermal conductivity [W/m-K]
c
c  written by M. McLinden, NIST Phys & Chem Properties Div, Boulder, CO
c  10-16-96 MM, original version
c  12-01-98 EWL, add Reos and triple point pressure and density to /CCON/
c  11-26-02 EWL, change Cp0 to Cp00 to avoid confusion with function Cp0
c
      include 'commons.for'
      include 'comtrn.for'
c
c  compute dilute-gas viscosity
      sigma=ctcx(icomp,1,1)
      epsk=ctcx(icomp,2,1)
      eta0=ctcx(icomp,3,1)*SQRT(t)/(OMEGA(icomp,t,epsk,hmdtcx(icomp))
     &    *sigma**2)
      Cp00=CP0K(icomp,t)    !ideal gas heat capacity by chosen EOS
      Gt1=ctcx(icomp,4,1)
      Gt2=ctcx(icomp,5,1)
      TCX2DG=1.0d-3*eta0/wmas(icomp)*(3.75d0*R+
     &       (Cp00-2.5d0*R)*(Gt1+Gt2*epsk/t))
c     write (*,1001) t,Cp0,TCX2ID
c1001 format (1x,' TCX2DG--t,Cp0,tcx_ideal: ',2f10.2,f12.6)
c
      RETURN
      end                                               !function TCX2DG
c
c ======================================================================
c
      function TCX2BK (icomp,t,rho)
c
c  background contribution to the thermal conductivity by the
c  model of Younglove and Ely, JPCRD 16:577-798 (1987); Eqs 26, 28-30.
c
c  N.B. the powers given in the JPCRD article are incorrect for Eqs 29
c       and 30; they should be (4 - n) and (7 - n), respectively; there
c       is an incorrect sign in Eq 26 [(1 + F2*rho), not (1 - F2*rho)]
c
c  inputs:
c    icomp--component number in mixture (1..nc); 1 for pure fluid
c        t--temperature [K]
c      rho--molar density [mol/L]
c  output (as function value):
c   tcx2bk--the background part of the thermal conductivity [W/m-K]
c
c  written by M. McLinden, NIST Phys & Chem Properties Div, Boulder, CO
c  10-16-96 MM, original version
c  12-01-98 EWL, add Reos and triple point pressure and density to /CCON/
c  11-21-07 MLH, remove unused commons and declarations
c
      include 'commons.for'
      include 'comtrn.for'
c
c  compute functions given as Eqs 28-30
      tinv=1.0d0/t
      tinv2=tinv*tinv
      F0=ctcx(icomp,6,1)+ctcx(icomp,7,1)*tinv+ctcx(icomp,8,1)*tinv2
      F1=ctcx(icomp,9,1)+ctcx(icomp,10,1)*tinv+ctcx(icomp,11,1)*tinv2
      F2=ctcx(icomp,12,1)+ctcx(icomp,13,1)*tinv
c  background term is given by Eq 26 in Younglove & Ely
      TCX2BK=(F0+F1*rho)*rho/(1.0d0+F2*rho)
c     write (*,1001) t,rho,TCX2RS
c1001 format (1x,' TCX2RS--t,rho,tcx_resid: ',f10.2,f10.4,f12.6)
c
      RETURN
      end                                               !function TCX2BK
c
c ======================================================================
c
      function TCX2CR (icomp,t,rho)
c
c  critical enhancement to the thermal conductivity by the model of
c  Younglove and Ely, JPCRD 16:577-798 (1987); Eqs D1-D4
c
c  N.B.  there are numerous errors in the equations presented in the
c        Younglove & Ely paper; the present code is derived from the
c        code of Younglove used to generate the tables in JPCRD
c
c  inputs:
c    icomp--component number in mixture (1..nc); 1 for pure fluid
c        t--temperature [K]
c      rho--molar density [mol/L]
c  output (as function value):
c   tcx2cr--the critical enhancement part of the thermal conductivity [W/m-K]
c
c  written by M. McLinden, NIST Phys & Chem Properties Div, Boulder, CO
c  10-28-96  MM, original version
c  11-14-97  MM, return zero if rho = 0 (avoid division by zero)
c  12-01-98 EWL, add Reos and triple point pressure and density to /CCON/
c  09-00-00 EWL, remove del and tau before alphar derivatives
c
      include 'commons.for'
      include 'comtrn.for'
c
c  the array ctcx contains, in order:
c       1-2:  Lennard-Jones sigma and epsilon/kappa
c         3:  constant in Eq 19 (5/16*(k*MW/1000/pi/Na)**0.5*1.0d12)
c       4-5:  dilute gas terms, Gt(1), Gt(2)
c      6-13:  background terms, Et(1) - Et(8)
c     14-17:  critical enhancement terms, X(1) - X(4)
c        18:  critical enhancement term  Z
c        19:  Boltzmann's constant, k
c  and the following terms from the Younglove & Ely viscosity model:
c     20-23:  initial density dependence terms, Fv(1) - Fv(4)
c     24-30:  residual viscosity terms, Ev(1) - Ev(7)
c
c  if density is approx zero, return zero for the critical enhancement
c  (avoid division by zero)
      if (rho.lt.1.0d-6) then
        TCX2CR=0.0d0
        RETURN
      end if
c
c  find derivatives dP/dD and dP/dT
      tau=tz(icomp)/t
      del=rho/rhoz(icomp)
      phi01=PHIK(icomp,0,1,tau,del)  !real-gas terms
      phi02=PHIK(icomp,0,2,tau,del)
      phi11=PHIK(icomp,1,1,tau,del)
c  factor 1.0d3 in next 3 lines converts kPa -> Pa
      dpdrho=R*t*(1.0d0+2.0d0*phi01+phi02)*1.0d3
      dpt=R*rho*(1.0d0+phi01-phi11)*1.0d3
      pc2=pcrit(icomp)*1.0d3
      xi=0.0d0
      if (dpdrho.gt.0.0d0)
     &xi=(pc2*rho/(Dcrit(icomp)**2*dpdrho))**ctcx(icomp,16,1)    !Eq D3
      dellam=ctcx(icomp,17,1)*ctcx(icomp,19,1)/pc2
     &      *(t*dpt*Dcrit(icomp)/rho)**2*xi                        !Eq D2
      delt=ABS(t-tcrit(icomp))/tcrit(icomp)
      delD=ABS(rho-Dcrit(icomp))/Dcrit(icomp)
      eterm=ctcx(icomp,14,1)*delt**4+ctcx(icomp,15,1)*delD**4
c  check that exponential term will not result in underflow
      if (eterm.gt.500.0d0) then
        eterm=EXP(-500.0d0)
      else
        eterm=EXP(-eterm)
      end if
c  now compute the viscosity, first the dilute gas contribution
      sigma=ctcx(icomp,1,1)
      epsk=ctcx(icomp,2,1)
      eta0=ctcx(icomp,3,1)*SQRT(t)/(OMEGA(icomp,t,epsk,hmdtcx(icomp))
     &    *sigma**2)
c  initial density term for viscosity
      eta1=rho*(ctcx(icomp,20,1)+ctcx(icomp,21,1)
     &    *(ctcx(icomp,22,1)-LOG(t/ctcx(icomp,23,1)))**2)         !Eq 21
c  now compute the residual viscosity (viscosity minus the dilute gas
c  and initial density terms)
      G=ctcx(icomp,24,1)+ctcx(icomp,25,1)/t                       !Eq 23
      H=SQRT(rho)*(rho-Dcrit(icomp))/Dcrit(icomp)                   !Eq 25
      F=G+(ctcx(icomp,26,1)+ctcx(icomp,27,1)*t**(-1.5d0))*rho**0.1d0+
     &  (ctcx(icomp,28,1)+ctcx(icomp,29,1)/t+ctcx(icomp,30,1)/(t*t))*H
      eta2=EXP(F)-EXP(G)                                          !Eq 22
      visc=(eta0+eta1+eta2)*1.0d-6       !factor of d-6 converts to Pa-s
c     write (*,1060) t,rho,eta0,eta1,eta2,visc
c1060 format (1x,' TCX2CR: t,rho,eta0,1,2,visc:  ',f8.3,f10.6,4e14.6)
c
c  combine all of the above to arrive at the critical enhancement
c  (the denominator is missing from the Younglove & Ely paper,
      TCX2CR=dellam*eterm/(6.0d0*3.141592654d0*ctcx(icomp,18,1)*visc)
c
      RETURN
      end                                               !function TCX2CR
c
c ======================================================================
c
      subroutine SETTC3 (nread,icomp,hcasno,ierr,herr)
c
c  initialize pure fluid thermal conductivity model #3; the model of:
c  Younglove, B.A. (1982). Thermophysical properties of
c  fluids. I. Argon, ethylene, parahydrogen, nitrogen, nitrogen trifluoride,
c  and oxygen. J. Phys. Chem. Ref. Data, Volume 11, Supplement 1.
c
c  N.B.  Younglove and Ely use a special scaled equation of state to
c        compute derivatives for the critical enhancement; the default
c        EOS is used here
c
c  inputs:
c    nread--file to read data from
c           <= 0 get data from block data
c           >0 read from logical unit nread (file should have already
c              been opened and pointer set by subroutine SETUP)
c    icomp--component number in mixture (0..nc)
c           1 for pure fluid; 0 for ECS reference fluid
c   hcasno--CAS number of component icomp (not req'd if reading from file)
c
c  outputs:
c     ierr--error flag:  0 = successful
c                      101 = error--block data option not implemented
c     herr--error string (character*255 variable if ierr<>0)
c     other quantities returned via arrays in commons
c
c  written by M. McLinden, NIST Phys & Chem Properties Div, Boulder, CO
c  06-18-96  MM, original version
c  08-19-97  MM, error for nread<=0; input hcasno is not array
c  06-30-98 EWL, implement model of Younglove
c
      include 'commons.for'
      include 'comtrn.for'
      character*12 hcasno
      character*255 herr
c
      if (nread.le.0) then
c  get coefficients from block data--this option not implemented,
c  place holder to maintain parallel structure with EOS setup routines
        ierr=101
        write (herr,1101) nread,hcasno,hnull
        call ERRMSG (ierr,herr)
 1101   format ('[SETTC3 error 101] illegal file specified; nread = ',
     &          i4,'; CAS no. = ',a12,a1)
      else
c  read data from file (should have been opened by SETUP)
c       write (*,*) ' SETTC3--read component',icomp,' from unit',nread
        read (nread,*) tmtcx(icomp)              !lower temperature limit
        read (nread,*) txtcx(icomp)              !upper temperature limit
        read (nread,*) pxtcx(icomp)              !upper pressure limit
        read (nread,*) Dxtcx(icomp)              !upper density limit
        read (nread,*) ctcx(icomp,1,1)          !L-J sigma
        read (nread,*) ctcx(icomp,2,1)          !L-J epsilon/kappa
        read (nread,*) ctcx(icomp,3,1)          !leading coefficient
        read (nread,*) ctcx(icomp,3,2)          !exponent on tau
        do j=4,12        !read dilute gas thermal conductivity terms
          read (nread,*) ctcx(icomp,j,1)
        enddo
        do j=13,24       !read residual thermal conductivity terms
          read (nread,*) ctcx(icomp,j,1)
        enddo
        read (nread,*) ctcx(icomp,25,1)         !F
        read (nread,*) ctcx(icomp,26,1)         !rm
c  read in pointer to critical enhancement model
        read (nread,2003) htcxcr(icomp)
        ierr=0
        herr=' '
      end if
c
      RETURN
 2003 format (a3)
      end                                             !subroutine SETTC3
c
c ======================================================================
c
      function TCX3DG (icomp,t)
c
c  dilute-gas contribution to the thermal conductivity by the model of:
c  Younglove, B.A. (1982). Thermophysical properties of
c  fluids. I. Argon, ethylene, parahydrogen, nitrogen, nitrogen trifluoride,
c  and oxygen. J. Phys. Chem. Ref. Data, Volume 11, Supplement 1.
c
c  inputs:
c    icomp--component number in mixture (1..nc); 1 for pure fluid
c        t--temperature [K]
c  output (as function value):
c   tcx3dg--the dilute-gas part of the thermal conductivity [W/m-K]
c
c  written by E.W. Lemmon, NIST Phys & Chem Properties Div, Boulder, CO
c  06-30-98 EWL, original version
c
      include 'commons.for'
      include 'comtrn.for'
c
      i=icomp
      tau=t
      omgsum=0.0d0
      ekt3=(ctcx(i,2,1)/t)**(1.0d0/3.0d0)
      do j=4,12
        omgsum=omgsum+ctcx(i,j,1)*ekt3**(7-j)
      enddo
      omgsum=1.0d0/omgsum
      tcx3dg=ctcx(i,3,1)*tau**ctcx(i,3,2)/(ctcx(i,1,1)**2*omgsum)
c     write (*,*) ' TCX3DG--dilute-gas thermal conductivity:  ',tcx3dg
c
      RETURN
      end                                               !function TCX3DG
c
c ======================================================================
c
      function TCX3BK (icomp,t,rho)
c
c  residual contribution to the thermal conductivity by the model of:
c  Younglove, B.A. (1982). Thermophysical properties of
c  fluids. I. Argon, ethylene, parahydrogen, nitrogen, nitrogen trifluoride,
c  and oxygen. J. Phys. Chem. Ref. Data, Volume 11, Supplement 1.
c
c  Although this correlation has a separate initial density term,
c  the initial density term is combined with the residual term.
c
c  inputs:
c    icomp--component number in mixture (1..nc); 1 for pure fluid
c        t--temperature [K]
c      rho--molar density [mol/L]
c  output (as function value):
c   tcx3bk--the background part of the thermal conductivity [W/m-K]
c
c  written by E.W. Lemmon, NIST Phys & Chem Properties Div, Boulder, CO
c  06-30-98 EWL, original version
c  12-01-98 EWL, add Reos and triple point pressure and density to /CCON/
c  12-01-98 EWL, add Reos and triple point pressure and density to /CCON/
c
      include 'commons.for'
      include 'comtrn.for'
      character*255 herr

      tcx3bk=0.0d0
      if (rho.le.0.d0) RETURN
c
c  initial density term for thermal conductivity
      tcx1=rho*(ctcx(icomp,13,1)+ctcx(icomp,14,1)
     &    *(ctcx(icomp,15,1)-LOG(t/ctcx(icomp,16,1)))**2)         !Eq 21
c  now compute the residual thermal conductivity (thermal conductivity minus
c  the dilute gas and initial density terms)
      G=ctcx(icomp,17,1)+ctcx(icomp,18,1)/t                       !Eq 23
      H=SQRT(rho)*(rho-ctcx(icomp,24,1))/ctcx(icomp,24,1)         !Eq 25
      F=G+(ctcx(icomp,19,1)+ctcx(icomp,20,1)*t**(-1.5d0))*rho**0.1d0+
     &  (ctcx(icomp,21,1)+ctcx(icomp,22,1)/t+ctcx(icomp,23,1)/(t*t))*H
      tcx2=EXP(F)-EXP(G)                                          !Eq 22
c
      call DPDDK (icomp,t,rho,dpdrho)
      call DPDTK (icomp,t,rho,dpt)
      dpdrho=dpdrho/wmas(icomp)*1.0d7
      dpt=dpt*1.0d4
c
      ff=ctcx(icomp,25,1)
      rm=ctcx(icomp,26,1)
      an=6.0225D+23
      bk=1.38054D-16
      dd=rho*wmas(icomp)/1000.0d0
      call ETAK (icomp,t,rho,eta,ierr,herr)
      bl=ff*(rm**5*dd*an/wmas(icomp)*ctcx(icomp,2,1)/t)**0.5d0
      y=6.0d0*3.1415927d0*eta/100000.d0*bl
     &    *(bk*t*dd*an/wmas(icomp))**0.5d0
      dl=0.0d0
      if (dpdrho.ge.0) dl=bk*(t*dpt)**2/(dd*dpdrho)**0.5d0/y
      tcx3=dl*EXP(-4.25d0*((rho-Dcrit(icomp))/Dcrit(icomp))**4
     &    -18.66d0*((t-tcrit(icomp))/tcrit(icomp))**2)/1.0d5
      TCX3BK=tcx1+tcx2+tcx3
c     write (*,*) ' TCX3BK--residual thermal conductivity:    ',tcx3bk
c
      RETURN
      end                                               !function TCX3BK

c ======================================================================
c
      subroutine SETTC5 (nread,icomp,hcasno,ierr,herr)
c
c  initialize pure fluid thermal conductivity model #5; the model of:
c  T-H. Chung, M. Ajlan, L.L. Lee, and K.E. Starling
c  "Generalized Multiparameter Correlation for Nonpolar and Polar Fluid Transport Properties"
c  Ind. Eng. Chem. Res. 1988, 27, 671-679. Also see Reid, Prausnitz and Poling Chapter 9.
c
c  inputs:
c    nread--file to read data from
c           <= 0 get data from block data
c           >0 read from logical unit nread (file should have already
c              been opened and pointer set by subroutine SETUP)
c    icomp--component number in mixture (0..nc)
c           1 for pure fluid; 0 for ECS reference fluid
c   hcasno--CAS number of component icomp (not req'd if reading from file)
c
c  outputs:
c     ierr--error flag:  0 = successful
c                      101 = error--block data option not implemented
c     herr--error string (character*255 variable if ierr<>0)
c     other quantities returned via arrays in commons
c
c  11-19-07  MLH, original
c  01-04-08  MLH, allow dilute and residual parameters to be independent
c
      include 'commons.for'
      include 'comtrn.for'
      character*12 hcasno
      character*255 herr
c
      if (nread.le.0) then
c  get coefficients from block data--this option not implemented,
c  place holder to maintain parallel structure with EOS setup routines
        ierr=101
        write (herr,1101) nread,hcasno,hnull
        call ERRMSG (ierr,herr)
 1101   format ('[SETTC5 error 101] illegal file specified; nread = ',
     &          i4,'; CAS no. = ',a12,a1)
      else
c  read data from file (should have been opened by SETUP)
c       write (*,*) ' SETTC5--read component',icomp,' from unit',nread
        read (nread,*) tmtcx(icomp)              !lower temperature limit
        read (nread,*) txtcx(icomp)              !upper temperature limit
        read (nread,*) pxtcx(icomp)              !upper pressure limit
        read (nread,*) Dxtcx(icomp)              !upper density limit
        read (nread,*) sigchk(icomp)            !L-J sigma for chung k model
        read (nread,*) epschk(icomp)            !L-J epsilon/kappa for chung k model
        read (nread,*) acchk(icomp),ddipk(icomp),hbkk(icomp) !w, dip, kappa for chung dilute
c       set residual parameters
        cctcx(icomp,1,1)=sigchk(icomp)
        cctcx(icomp,1,2)=epschk(icomp)
        cctcx(icomp,1,3)=acchk(icomp)
        cctcx(icomp,1,4)=ddipk(icomp)
        cctcx(icomp,1,5)=hbkk(icomp)

        READ (nread,*) naddk(icomp)             !additional factors for chung;not presently used
c       use these terms if residual parameters are not the same as dilute gas
        jtc=0
        do j =1, naddk(icomp)
         jtc=jtc+1
         READ(nread,*) cctcx(icomp,jtc,1),cctcx(icomp,jtc,2),
     &    cctcx(icomp,jtc,3),cctcx(icomp,jtc,4),cctcx(icomp,jtc,5)
        end do

c  read in pointer to critical enhancement model
        read (nread,2003) htcxcr(icomp)
        ierr=0
        herr=' '
      end if
c
      RETURN
 2003 format (a3)
      end                                             !subroutine SETTC5
c
c ======================================================================
c
      function TCX5DG (icomp,t)
c
c  dilute-gas contribution to the thermal conductivity by the model of:
c  T-H. Chung, M. Ajlan, L.L. Lee, and K.E. Starling
c  "Generalized Multiparameter Correlation for Nonpolar and Polar Fluid Transport Properties"
c  Ind. Eng. Chem. Res. 1988, 27, 671-679. Also see Reid, Prausnitz and Poling Chapter 9.
c
c  inputs:
c    icomp--component number in mixture (1..nc); 1 for pure fluid
c        t--temperature [K]
c  output (as function value):
c   tcx5dg--the dilute-gas part of the thermal conductivity [W/m-K]
c
c   11-19-07 MLH  original version
c   01-04-08 MLH  added additional slots to cctcx
c
      include 'commons.for'
      include 'comtrn.for'
      character*255 herr
c
      i=icomp
      r=8.314472D0
c     tstar=t/epschk(i)
c     vc = (sigchk(i)*10.0D0/0.809D0)**3 !compute vc in cm3/mol from Chung sigma
      call CVCPK (i,t,rho,cv,cp)
      alpha=cv/r-1.5D0
      beta=0.7862D0 -0.7109d0*acchk(i)+1.3168D0*acchk(i)**2
      tr = t/(1.2593d0*epschk(i))
      Z=2.0D0+10.5d0*tr**2
      psich=1.0D0+alpha*
     &    ((0.215D0+0.28288*alpha-1.061d0*beta+0.26665d0*Z)/
     &    (0.6366D0 +beta*Z+1.061D0*alpha*beta))
      call ETAK0(i,t,eta00,ierr,herr)
      eta00= eta00*1.0d-6   !convert from uPa.s to Pa.s
      tcx5dg=3.75D0*psich*eta00*r/(wmas(i)/1000.D0)
      tcx0ch=tcx5dg
c     write (*,*) ' TCX5DG--dilute-gas thermal conductivity:  ',tcx5dg
c
      RETURN
      end                                               !function TCX5DG
c
c ======================================================================
c
      function TCX5BK (icomp,t,rho)
c
c  residual contribution to the thermal conductivity by the model of:
c  T-H. Chung, M. Ajlan, L.L. Lee, and K.E. Starling
c  "Generalized Multiparameter Correlation for Nonpolar and Polar Fluid Transport Properties"
c  Ind. Eng. Chem. Res. 1988, 27, 671-679. Also see Reid, Prausnitz and Poling Chapter 9.
c
c  inputs:
c    icomp--component number in mixture (1..nc); 1 for pure fluid
c        t--temperature [K]
c      rho--molar density [mol/L]
c  output (as function value):
c   tcx5bk--the background part of the thermal conductivity [W/m-K]
c
c  note: this version allows the parameters for the residual piece to
c  be independent from the dilute gas and fit as free parameters
c  nomenclature for comparison with manuscript
c        sigchk(i)=cctcx(i,1,1)
c        epschk(i)=cctcx(i,1,2)
c        acchk(i)=cctcx(i,1,3)
c        ddipk(i)=cctcx(i,1,4)
c        hbkk(i)=cctcx(i,1,5)
c  11-19-07 MLH, original
c  01-04-08 MLH  added additional slots cctcx
c
      include 'commons.for'
      include 'comtrn.for'
      character*255 herr
      dimension B0(7), B1(7), B2(7), B3(7), BB(7)
      parameter (B0=(/2.41657D0, -0.50924D0, 6.61069D0, 14.5425D0,
     &                0.79274D0, -5.8634D0, 81.171D0 /))
      parameter (B1=(/0.74824D0, -1.50936D0, 5.62073D0, -8.91387D0,
     &                0.82019D0, 12.8005D0, 114.158D0 /))
      parameter (B2=(/-0.91858D0, -49.9912D0, 64.7599D0, -5.63794D0,
     &                -0.69369D0, 9.58926D0, -60.841D0 /))
      parameter (B3=(/121.721D0, 69.9834D0, 27.0389D0, 74.3435D0,
     &                6.31734D0, -65.52920D0, 466.775D0 /))

      r=8.314472D0
      i=icomp
      tcx5bk=0.0d0
      rho0 = 0.0d0
      if (rho.le.0.d0) RETURN
c     tstar=t/cctcx(i,1,2)
      vc = (cctcx(i,1,1)*10.0D0/0.809D0)**3 !compute vc in cm3/mol from Chung sigma

      do j=1,7
        BB(J)=B0(j)+B1(j)*cctcx(i,1,3)+B2(j)*cctcx(i,1,4)**4
     &       +B3(j)*cctcx(i,1,5)
      end do
c
      y = rho * vc/ 6.0D3
      g1=(1.0D0 -0.5D0*y)/((1.0D0-y)**3)
      g2 =( (BB(1)/y)*(1.0D0- EXP(-BB(4)*y)) +BB(2)*g1*EXP(BB(5)*y)+
     &       BB(3)*g1 )/ ( BB(1)*BB(4) + BB(2)+ BB(3) )
      call CVCPK (i,t,rho0,cv,cp)
      alpha=cv/r-1.5D0
      beta=0.7862D0 -0.7109*cctcx(i,1,3)+1.3168D0*cctcx(i,1,3)**2
      tr = t/(1.2593*cctcx(i,1,2))
      Z=2.0D0+10.5*tr**2
      psich=1.0D0+
     &    alpha*((0.215D0+0.28288d0*alpha-1.061d0*beta+0.26665*Z)/
     &    (0.6366D0 +beta*Z+1.061D0*alpha*beta))
      call ETAK0(i,t,eta00,ierr,herr)
      eta00=eta00*1.0d-6               !convert from uPa.s to Pa.s
      qq= 3.586d-3*
     &    SQRT(1.2593d0*cctcx(i,1,2)/(wmas(i)/1.0d3))/(vc**(2./3.))
      tcx5Bk=31.2*eta00 *psich*(1.0D0/g2+BB(6)*y)/(wmas(i)/1000.0D0)+
     &    qq*BB(7)*y*y*g2*SQRT(tr)
      tcx5bk=tcx5bk - tcx0ch
c     write (*,*) ' TCX5BK--residual thermal conductivity:    ',tcx5bk
c
      RETURN
      end                                               !function TCX5BK
c
c ======================================================================
c
      subroutine SETTC6 (nread,icomp,hcasno,ierr,herr)
c
c  initialize pure fluid thermal conductivity model #6
c
c  temporary place holder--this model is not yet implemented
c
c  inputs:
c    nread--file to read data from
c           <= 0 get data from block data
c           >0 read from logical unit nread (file should have already
c              been opened and pointer set by subroutine SETUP)
c    icomp--component number in mixture (0..nc)
c           1 for pure fluid; 0 for ECS reference fluid
c   hcasno--CAS number of component icomp (not req'd if reading from file)
c
c  outputs:
c     ierr--error flag:  0 = successful
c                       39 = error--model not implemented
c     herr--error string (character*255 variable if ierr<>0)
c     other quantities returned via arrays in commons
c
c  written by M. McLinden, NIST Phys & Chem Properties Div, Boulder, CO
c  10-30-96  MM, original version
c  08-19-97  MM, error for nread<=0; input hcasno is not array
c
      include 'commons.for'
      include 'comtrn.for'
      character*12 hcasno
      character*255 herr
c
      if (nread.le.0) then
c  get coefficients from block data--this option not implemented,
c  place holder to maintain parallel structure with EOS setup routines
        ierr=101
        write (herr,1101) nread,hcasno,hnull
        call ERRMSG (ierr,herr)
 1101   format ('[SETTC6 error 101] illegal file specified; nread = ',
     &          i4,'; CAS no. = ',a12,a1)
      else
c  read data from file (should have been opened by SETUP)
        htcxcr(icomp)='NUL'
        ierr=39
        herr='[SETUP error 39] thermal conductivity model #6 specified '
     &     //'in fluid file but not implemented in code.'//hnull
        call ERRMSG (ierr,herr)
      end if
c
      RETURN
      end                                             !subroutine SETTC6
c
c ======================================================================
c
      subroutine SETTK1 (nread,icomp,hcasno,ierr,herr)
c
c  initialize model #1 for the thermal conductivity critical enhancement--
c  the empirical model used by Perkins and Laesecke
c
c  inputs:
c    nread--file to read data from
c           <= 0 get data from block data
c           >0 read from logical unit nread (file should have already
c              been opened and pointer set by subroutine SETUP)
c    icomp--component number in mixture (0..nc)
c           1 for pure fluid; 0 for ECS reference fluid
c   hcasno--CAS number of component icomp (not req'd if reading from file)
c
c  outputs:
c     ierr--error flag:  0 = successful
c                        1 = error
c     herr--error string (character*255 variable if ierr<>0)
c     other quantities returned via arrays in commons
c
c  written by M. McLinden, NIST Phys & Chem Properties Div, Boulder, CO
c  02-24-97  MM, original version
c  03-27-97  MM, change powers in exp term to integer
c
      include 'commons.for'
      include 'comtrn.for'
      character*12 hcasno
      character*255 herr
c
      if (nread.le.0) then
c  get coefficients from block data--this option not implemented,
c  place holder to maintain parallel structure with EOS setup routines
        ierr=39
        write (herr,1039) hcasno,hnull
        call ERRMSG (ierr,herr)
 1039   format ('[SETUP error 39] block data option for t.c. crit ',
     &          'model #1 specified for CAS # ',a12,' but not ',
     &          'implemented in code.',a1)
      else
c  read data from file (should have been opened by SETUP)
c       write (*,*) ' SETTK1--read component',icomp,' from unit',nread
        read (nread,*) tmtck(icomp)              !lower temperature limit
        read (nread,*) txtck(icomp)              !upper temperature limit
        read (nread,*) pxtck(icomp)              !upper pressure limit
        read (nread,*) Dxtck(icomp)              !upper density limit
        jterm=0                                 !term counter
c  # terms in numerator & denominator of polynomial multiplier,
c  exponential term, and spare for future use
        read (nread,*) nnumtck(icomp),ndentck(icomp),nexptck(icomp),
     &                 nsparek(icomp)
        if (nnumtck(icomp)+ndentck(icomp).ge.1) then  !read reducing pars
          read (nread,*) trtck(icomp),Drtck(icomp),tcxred(icomp)
          if (nnumtck(icomp).ge.1) then
            do j=1,nnumtck(icomp)              !read numerator terms
              jterm=jterm+1
              read (nread,*) (ctck(icomp,jterm,k),k=1,5),
     &                       itck(icomp,jterm,0)
            enddo
          end if
          if (ndentck(icomp).ge.1) then
            do j=1,ndentck(icomp)              !read denominator terms
              jterm=jterm+1
              read (nread,*) (ctck(icomp,jterm,k),k=1,5),
     &                       itck(icomp,jterm,0)
            enddo
          end if
        end if
        if (nexptck(icomp).ge.1) then
          read (nread,*) tredex(icomp),Dredex(icomp)
          do j=1,nexptck(icomp)                !read exponential terms
            jterm=jterm+1
            read(nread,*)(ctck(icomp,jterm,k),k=1,2),itck(icomp,jterm,2)
     &                    ,ctck(icomp,jterm,3),itck(icomp,jterm,3)
     &                    ,itck(icomp,jterm,0)
          enddo
        end if
c       if (nsparek(icomp).ge.1) then
c         do j=1,nsparek(icomp)              !read spare terms
c           jterm=jterm+1
c           read(nread,*)(ctck(icomp,jterm,k),k=1,1),itck(icomp,jterm,1)
c         enddo
c       end if
      end if
c
      RETURN
      end                                             !subroutine SETTK1
c
c ======================================================================
c
      function TCX1CR (icomp,t,rho)
c
c  model #1 for the thermal conductivity critical enhancement--
c  the empirical model used by Perkins and Laesecke
c
c  inputs:
c    icomp--component number in mixture (1..nc); 1 for pure fluid
c        t--temperature [K]
c      rho--molar density [mol/L]
c  output (as function value):
c   tcx1cr--the critical enhancement to the thermal conductivity [W/m-K]
c
c  written by M. McLinden, NIST Phys & Chem Properties Div, Boulder, CO
c  02-24-97  MM, original version
c  03-27-97  MM, change powers in exp term to integer
c  01-25-00 EWL, set tcx1cr=0 if xexp<-500
c
      include 'commons.for'
      include 'comtrn.for'
c
c  compute the various parts of the critical enhancement
c  these are taken in the order:
c    rational polynomial in T, rho (first numerator, then denominator)
c    exponential term
c    spare for future use
c  the coefficients themselves are given in the order:
c    constant multiplier;
c    additive term to temperature, exponent for (T + Tadd)
c    additive term to density, exponent for (D + Dadd)
c    spare 1 [if = 99 for denominator take MAX(T, T+Tadd]
c    spare 2
c
      i=icomp
      nterm=0                                 !term counter
      tcx1cr=0.0d0
      if (nnumtck(i)+ndentck(i).ge.1) then
        if (trtck(i).le.0.0d0) then
          tau=-trtck(i)/t     !negative trtck indicates reverse order
        else
          tau=t/trtck(i)
        end if
        del=rho/Drtck(i)
        if (nnumtck(i).ge.1) then
          do j=nterm+1,nterm+nnumtck(i)              !numerator terms
            if (ABS(del).gt.1.d-12 .or. abs(ctck(i,j,5)).gt.1.d-12) then
              tcx1cr=tcx1cr+ctck(i,j,1)*(tau+ctck(i,j,2))**ctck(i,j,3)
     &              *(del+ctck(i,j,4))**ctck(i,j,5)
            else
              tcx1cr=tcx1cr+ctck(i,j,1)*(tau+ctck(i,j,2))**ctck(i,j,3)
            endif
          enddo
          nterm=nterm+nnumtck(i)
        end if
        if (ndentck(i).ge.1) then
          xden=0.0d0
          do j=nterm+1,nterm+ndentck(i)              !denominator terms
            if (itck(i,j,0).eq.99) then
c  flag for special form used by Perkins (MAX(T,2Tc-T))
              tcmax=MAX(tau,ctck(i,j,2)-tau)
              xden=xden+ctck(i,j,1)*tcmax**ctck(i,j,3)
     &            *(del+ctck(i,j,4))**ctck(i,j,5)
            else
              xden=xden+ctck(i,j,1)*(tau+ctck(i,j,2))**ctck(i,j,3)
     &            *(del+ctck(i,j,4))**ctck(i,j,5)
            end if
          enddo
          nterm=nterm+ndentck(i)
          tcx1cr=tcx1cr/xden
        end if
      end if
      if (nexptck(i).ge.1) then
        if (tredex(i).le.0.0d0) then
          tau=-tredex(i)/t   !negative tred indicates reverse order
        else
          tau=t/tredex(i)
        end if
        del=rho/Dredex(i)
        xexp=0.0d0
        do j=nterm+1,nterm+nexptck(i)              !exponential terms
          if (ABS(del).gt.1d-12 .or. itck(i,j,3).ne.0) then
            xexp=xexp+ctck(i,j,1)*(tau+ctck(i,j,2))**itck(i,j,2)
     &          *(del+ctck(i,j,3))**itck(i,j,3)
          else
            xexp=xexp+ctck(i,j,1)*(tau+ctck(i,j,2))**itck(i,j,2)
          endif
        enddo
        nterm=nterm+nexptck(i)
        if (xexp.lt.-500.0d0) then
          tcx1cr=0        !avoid underflow if exponential is almost one
        else
          tcx1cr=tcx1cr*EXP(xexp)
        end if
      end if
c     if (nsparek(i).ge.1) then
c       xspare=0.0d0
c       do j=nterm+1,nterm+nsparek(i)            !spare terms
c       enddo
c       tcx1cr=tcx1cr+xspare
c     end if
c     write (*,*) ' TCX1CR--xnum,xden,xexp: ',xnum,xden,xexp
c     write (*,*) ' TCX1CR--t,tcx_crit: ',t,tcx1cr
c
c  multiply by reducing parameter (to convert units, etc.)
      TCX1CR=tcx1cr*tcxred(i)
c
      RETURN
      end                                               !function TCX1CR
c
c ======================================================================
c
      subroutine SETTK3 (nread,icomp,hcasno,ierr,herr)
c
c  initialize model #3 for the thermal conductivity critical enhancement--
c  the simplified critical enhancement of Vesovic, et al for CO2:
c  Vesovic, V., Wakeham, W.A., Olchowy, G.A., Sengers, J.V., Watson, J.T.R.
c  and Millat, J. (1990). The transport properties of carbon dioxide.
c  J. Phys. Chem. Ref. Data  19: 763-808.
c
c  inputs:
c    nread--file to read data from
c           <= 0 get data from block data
c           >0 read from logical unit nread (file should have already
c              been opened and pointer set by subroutine SETUP)
c    icomp--component number in mixture (0..nc)
c           1 for pure fluid; 0 for ECS reference fluid
c   hcasno--CAS number of component icomp (not req'd if reading from file)
c
c  outputs:
c     ierr--error flag:  0 = successful
c                        1 = error
c     herr--error string (character*255 variable if ierr<>0)
c     other quantities returned via arrays in commons
c
c  written by M. McLinden, NIST Phys & Chem Properties Div, Boulder, CO
c  06-08-97  MM, original version
c
      include 'commons.for'
      include 'comtrn.for'
      character*12 hcasno
      character*255 herr
c
      if (nread.le.0) then
c  get coefficients from block data--this option not implemented,
c  place holder to maintain parallel structure with EOS setup routines
        ierr=39
        write (herr,1039) hcasno,hnull
        call ERRMSG (ierr,herr)
 1039   format ('[SETUP error 39] block data option for t.c. crit ',
     &          'model #3 specified for CAS # ',a12,' but not ',
     &          'implemented in code.',a1)
      else
c  read data from file (should have been opened by SETUP)
c       write (*,*) ' SETTK3--read component',icomp,' from unit',nread
        read (nread,*) tmtck(icomp)              !lower temperature limit
        read (nread,*) txtck(icomp)              !upper temperature limit
        read (nread,*) pxtck(icomp)              !upper pressure limit
        read (nread,*) Dxtck(icomp)              !upper density limit
        jterm=0                                 !term counter
c  # terms in numerator & denominator of polynomial multiplier,
c  exponential term, and spare for future use
c  put CO2 terms into arrays used for "numerator," others for future use
        read (nread,*) nnumtck(icomp),ndentck(icomp),nexptck(icomp),
     &                 nsparek(icomp)
        if (nnumtck(icomp)+ndentck(icomp).ge.1) then
c  read reducing pars
          read (nread,*) trtck(icomp),Drtck(icomp),tcxred(icomp)
          if (nnumtck(icomp).ge.1) then
            do j=1,nnumtck(icomp)              !read "numerator" terms
c  as originally implemented for CO2, these terms are:
c  ctck(icomp,1,1) = gnu (universal exponent, approx 0.63)
c  ctck(icomp,2,1) = gamma (universal exponent, approx 1.2145)
c  ctck(icomp,3,1) = R0 (universal amplitude, 1.01 +/- 0.04)
c  ctck(icomp,4,1) = z (universal exponent, 0.065 +/- 0.005)
c  ctck(icomp,5,1) = c (visc const, approx 1.075, but often set to 1)
c  ctck(icomp,6,1) = xi0 (amplitude, order 1d-10 m)
c  ctck(icomp,7,1) = gam0 (amplitude, order 0.05 - 0.06)
c  ctck(icomp,8,1) = qd_inverse (cutoff diameter, order 10d-9 m)
c  ctck(icomp,9,1) = tref (reference temperature, 1.5 - 2.0 * Tc)
              jterm=jterm+1
              read (nread,*) ctck(icomp,jterm,1)
            enddo
          end if
        end if
      end if
c
      RETURN
      end                                             !subroutine SETTK3
c
c ======================================================================
c
      function TCX3CR (icomp,t,rho)
c
c  model #3 for the thermal conductivity critical enhancement--
c  the simplified critical enhancement of:
c  Olchowy, G.A. and Sengers, J.V. (1989). A simplified representation for
c  the thermal conductivity of fluids in the critical region.
c  Int. J. Thermophysics  10: 417-426.
c
c  also applied to CO2 by:
c  Vesovic, V., Wakeham, W.A., Olchowy, G.A., Sengers, J.V., Watson, J.T.R.
c  and Millat, J. (1990). The transport properties of carbon dioxide.
c  J. Phys. Chem. Ref. Data  19: 763-808.
c  equation numbers in comments refer to Vesovic paper
c
c  inputs:
c    icomp--component number in mixture (1..nc); 1 for pure fluid
c        t--temperature [K]
c      rho--molar density [mol/L]
c  output (as function value):
c   tcx3cr--the critical enhancement to the thermal conductivity [W/m-K]
c
c  written by M. McLinden, NIST Phys & Chem Properties Div, Boulder, CO
c  06-08-97  MM, original version
c  06-16-97  MM, change DPDD, CVCP calls to DPDDK, CVCPK i.e. (t,x) to (icomp,t)
c  07-01-08  MLH, do not use viscosity critical enhancement in Olchowy-Sengers model
c  03-09-10  MLH, high t cutoff
c  04-13-10  MLH, do use viscosity critical enhancement in Olchowy-Sengers model
c  09-20-10  MLH, insert special code for new iapws water, more digits on piinv
c  11-20-10  MLH, replace call to etak with trnprp to remove problem w ecs only eta
c
      include 'commons.for'
      include 'comtrn.for'
      character*255 herr
      dimension xdummy(ncmax)
c
      xdummy(1)=1.0d0
      if (rho.lt.1.0d-6) then
c  critical enhancement is zero for low densities (avoid divide by zero)
        tcx3cr=0.0d0
        RETURN
      end if
c  recover the parameters from the storage array:
      gnu=ctck(icomp,1,1)      !nu (universal exponent, approx 0.63)
      gamma=ctck(icomp,2,1)    !gamma (universal exponent, approx 1.24)
      R0=ctck(icomp,3,1)       !R0 (universal amplitude, 1.01 +/- 0.04)
c  following two parameters not used here, but in file for future use
c     z=ctck(icomp,4,1)        !z (universal exponent, 0.065 +/- 0.005)
c     cvisc=ctck(icomp,5,1)    !visc const, approx 1.075, but often 1)
      xi0=ctck(icomp,6,1)      !xi0 (amplitude, order 1d-10 m)
      gam0=ctck(icomp,7,1)     !gam0 (amplitude, order 0.05 - 0.06)
      qd=1.0d0/ctck(icomp,8,1) !qd_inverse (cutoff dia, order 10d-9 m)
      treff=ctck(icomp,9,1)    !tref (reference temp, 1.5 - 2.0 * Tc)
c
c  if t is too high, no enhancement and return
      if (t.gt.treff) then
        tcx3cr=0.0d0
        return
      end if
c
c  check for water
      IF(hcas(icomp).eq.'7732-18-5')then
        tcx3cr= TCCR_2010 (T,RHO,QD)
        return
      endif
      call INFO (icomp,wmm,ttrp,tnbpt,tc,pc,Dc,Zc,acf,dip,Rgas)
      call DPDDK (icomp,t,rho,dpdrho)
c     write (*,*) ' TCX3CR--t,dpdrho: ',t,dpdrho
c  function chi (Eq 40 in Vesovic) evaluated at t,rho and tref,rho
c  Vesovic introduces a t/tc term which is absent in other papers
c     chi=pc/(Dc*Dc*tc)*rho*t/dpdrho               !Vesovic form
      chi=pc/(Dc*Dc)*rho/dpdrho
      call DPDDK (icomp,treff,rho,dpdrho)
c     chiref=pc/(Dc*Dc*tc)*rho*tref/dpdrho*tref/t  !Vesovic form
      chiref=pc/(Dc*Dc)*rho/dpdrho*treff/t
      delchi=chi-chiref
      if (delchi.le.0.0d0) then
c  delchi can go negative far from critical
c       write (*,*) ' TCX3CR--chi < chiref:  ',chi,chiref
        tcx3cr=0.0d0
        RETURN
      end if
c  function xi (Eq 46)
c  Olchowy, Vesovic put gam0 inside exponent, Krauss (R134a) puts this
c  term outside, but this yields incorrect values
      xi=xi0*(delchi/gam0)**(gnu/gamma)            !Vesovic form
c     xi=xi0/gam0*delchi**(gnu/gamma)              !Krauss' form
c     write (*,1150) chi,chiref,xi
c1150 format (1x,' TCX3CR--chi,chiref,xi:  ',3e14.6)
c  functions omega and omega_zero (Eqs 59 & 60)
c     write (*,1154) icomp,t,rho
c1154 format (1x,' TCX3CR--call CVCPK for icomp,t,rho =  ',i2,2e14.6)
      call CVCPK (icomp,t,rho,cv,cp)
c     write (*,1156) cv,cp
c1156 format (1x,' TCX3CR--cv,cp returned from CVCPK =  ',2e14.6)
      piinv=1.0d0/3.14159265358979d0
c     write (*,1160) cv,cp,qd,xi
c1160 format (1x,' TCX3CR--cv,cp,qd,xi:  ',4e14.6)
      xomg=2.0d0*piinv*((cp-cv)/cp*ATAN(qd*xi)+cv/cp*qd*xi)
      xomg0=2.0d0*piinv*(1.0d0-EXP(-1.0d0/(1.0d0/(qd*xi)
     &     +((qd*xi*Dc/rho)**2)/3.0d0)))
c     hetacrs =hetacr(icomp)
      !hetacr(icomp)=''       !if you want nul viscosity enhancement model in Olchowy-Sengers model
      call ETAK (icomp,t,rho,eta,ierr,herr)
      IF(ierr.ne.0)then
       ierr=0
       herr=''
       call TRNECS (t,rho,xdummy,eta,ttcx,ierr,herr) !if only have ecs for viscosity must call here
      else
      endif
      !If (hetahc(icomp).eq.'H2O') eta=etanorm  !hard coded water has enhancement in
      !hetacr(icomp)=hetacrs  !reset to original value
c     write (*,1162) xomg,xomg0,eta
c1162 format (1x,' TCX3CR--omega,omega_0,eta:  ',3e14.6)
      boltz=Rgas/6.0221367d23       !Boltzman's const
c  factor of 1d9 in next equation to convert from mol/L --> mol/m**3
c  and from micro-Pa-s to Pa-s
      tcx3cr=rho*1.0d9*cp*R0*boltz*t*piinv/(6.0d0*eta*xi)*(xomg-xomg0)
c  multiply by reducing parameter (to convert units, etc.)
      TCX3CR=tcx3cr*tcxred(icomp)
c  write (*,*) ' TCX3CR--tcx3cr: ',TCX3CR
c
      RETURN
      end                                               !function TCX3CR
c
c ======================================================================
c
      subroutine SETTK4 (nread,icomp,hcasno,ierr,herr)
c
c  initialize model #4 for the thermal conductivity critical enhancement--
c
c  inputs:
c    nread--file to read data from
c           <= 0 get data from block data
c           >0 read from logical unit nread (file should have already
c              been opened and pointer set by subroutine SETUP)
c    icomp--component number in mixture (0..nc)
c           1 for pure fluid; 0 for ECS reference fluid
c   hcasno--CAS number of component icomp (not req'd if reading from file)
c
c  outputs:
c     ierr--error flag:  0 = successful
c                       39 = error--model not implemented
c     herr--error string (character*255 variable if ierr<>0)
c     other quantities returned via arrays in commons
c
c  written by M. McLinden, NIST Phys & Chem Properties Div, Boulder, CO
c  02-24-97  MM, original version
c  08-19-97  MM, error for nread<=0; input hcasno is not array
c  02-22-99 EWL, implement TCX4CR model
c
      include 'commons.for'
      include 'comtrn.for'
      character*12 hcasno
      character*255 herr
c
      if (nread.le.0) then
c  get coefficients from block data--this option not implemented,
c  place holder to maintain parallel structure with EOS setup routines
        ierr=101
        write (herr,1101) icomp,nread,hcasno,hnull
        call ERRMSG (ierr,herr)
 1101   format ('[SETTK4 error 101] illegal file specified for icomp =',
     &          i3,'; nread = ',i4,'; CAS no. = ',a12,a1)
      else
        read (nread,*) tmtck(icomp)              !lower temperature limit
        read (nread,*) txtck(icomp)              !upper temperature limit
        read (nread,*) pxtck(icomp)              !upper pressure limit
        read (nread,*) Dxtck(icomp)              !upper density limit
        read (nread,*) nnumtck(icomp),ndentck(icomp),nexptck(icomp),
     &                 nsparek(icomp)
        if (nnumtck(icomp)+ndentck(icomp).ge.1) then
c  read reducing pars
          read (nread,*) trtck(icomp),prtck(icomp),Drtck(icomp),
     &                   tcxred(icomp)
          if (nnumtck(icomp).ge.1) then
            do j=1,nnumtck(icomp)              !read "numerator" terms
              read (nread,*) ctck(icomp,j,1)
            enddo
          end if
        end if
      end if
c
      RETURN
      end                                             !subroutine SETTK4
c
c ======================================================================
c
      function TCX4CR (icomp,t,rho)
c
c  critical enhancement to the thermal conductivity by the model of
c  Younglove and Hanley, JPCRD, 15(4):1323, 1986
c
c  inputs:
c    icomp--component number in mixture (1..nc); 1 for pure fluid
c        t--temperature [K]
c      rho--molar density [mol/L]
c  output (as function value):
c   tcx4cr--the critical enhancement part of the thermal conductivity [W/m-K]
c
c  written by E.W. Lemmon, NIST Phys & Chem Properties Div, Boulder, CO
c  02-22-99 EWL, original version
c
      include 'commons.for'
      include 'comtrn.for'
      character*255 herr
c
c  if density is approx zero, return zero for the critical enhancement
c  (avoid division by zero)
      if (rho.lt.1.0d-6) then
        TCX4CR=0.0d0
        RETURN
      end if
c
c  find derivatives dP/dD and dP/dT
      call DPDDK (icomp,t,rho,dpdrho)
      call DPDTK (icomp,t,rho,dpt)
      dc=Drtck(icomp)
      tc=trtck(icomp)
      pc=prtck(icomp)
      xi=pc*rho/(dc**2*dpdrho)
      if (xi.ge.0) xi=xi**ctck(icomp,3,1)
      dellam=ctck(icomp,1,1)*ctck(icomp,2,1)/pc
     &      *(t*dpt*dc/rho)**2*xi*1d21
      delt=ABS(t-tc)/tc
      delD=ABS(rho-dc)/dc
      eterm=ctck(icomp,4,1)*delt**2+ctck(icomp,5,1)*delD**4
c  check that exponential term will not result in underflow
      if (eterm.gt.500.0d0) then
        eterm=EXP(-500.0d0)
      else
        eterm=EXP(-eterm)
      end if
      call ETAK (icomp,t,rho,visc,ierr,herr)
c  combine all of the above to arrive at the critical enhancement
      TCX4CR=dellam*eterm/(6.0d0*3.141592654d0*ctck(icomp,6,1)*visc)
      TCX4CR=tcx4cr*tcxred(icomp)
c
      RETURN
      end                                               !function TCX4CR
c
c ======================================================================
c
      subroutine SETTK6 (nread,icomp,hcasno,ierr,herr)
c
c  initialize model #6 for the thermal conductivity critical enhancement--
c  to be used with ecs transport model. It is based on
c  the simplified critical enhancement of Vesovic, et al for CO2:
c  Vesovic, V., Wakeham, W.A., Olchowy, G.A., Sengers, J.V., Watson, J.T.R.
c  and Millat, J. (1990). The transport properties of carbon dioxide.
c  J. Phys. Chem. Ref. Data  19: 763-808.
c
c  inputs:
c    nread--file to read data from
c           <= 0 get data from block data
c           >0 read from logical unit nread (file should have already
c              been opened and pointer set by subroutine SETUP)
c    icomp--component number in mixture (0..nc)
c           1 for pure fluid; 0 for ECS reference fluid
c   hcasno--CAS number of component icomp (not req'd if reading from file)
c
c  outputs:
c     ierr--error flag:  0 = successful
c                        1 = error
c     herr--error string (character*255 variable if ierr<>0)
c     other quantities returned via arrays in commons
c
c  written by M. McLinden, NIST Phys & Chem Properties Div, Boulder, CO
c  06-08-97  MM, original version
c  11-15-01 MLH, adapted for ecs model use
c  06-02-11 MLH, change common blocks to dimension statements
c
      include 'commons.for'
      include 'comtrn.for'
      character*12 hcasno
      character*255 herr
      dimension tmtcke(nrf0:nx),txtcke(nrf0:nx),pxtcke(nrf0:nx),
     &          Dxtcke(nrf0:nx)
      dimension trtcke(nrf0:nx),Drtcke(nrf0:nx),prtcke(nrf0:nx),
     &          tcxrede(nrf0:nx),tredexe(nrf0:nx),Dredexe(nrf0:nx)
      dimension nnumtcke(nrf0:nx),ndentcke(nrf0:nx),nexptcke(nrf0:nx),
     &          nspareke(nrf0:nx)
c
c     NOTE: only the ctcke parameters are needed, everything else is not
c           saved into common blocks in order to avoid overwriting any TK3
c           parameters loaded previously for dedicated models
c
      if (nread.le.0) then
c  get coefficients from block data--this option not implemented,
c  place holder to maintain parallel structure with EOS setup routines
        ierr=39
        write (herr,1039) hcasno,hnull
        call ERRMSG (ierr,herr)
 1039   format ('[SETUP error 39] block data option for t.c. crit ',
     &          'model #3 specified for CAS # ',a12,' but not ',
     &          'implemented in code.',a1)
      else
c  read data from file (should have been opened by SETUP)
c       write (*,*) ' SETTK6--read component',icomp,' from unit',nread
        read (nread,*) tmtcke(icomp)              !lower temperature limit
        read (nread,*) txtcke(icomp)              !upper temperature limit
        read (nread,*) pxtcke(icomp)              !upper pressure limit
        read (nread,*) Dxtcke(icomp)              !upper density limit
        jterm=0                                 !term counter
c  # terms in numerator & denominator of polynomial multiplier,
c  exponential term, and spare for future use
c  put CO2 terms into arrays used for "numerator," others for future use
        read (nread,*) nnumtcke(icomp),ndentcke(icomp),nexptcke(icomp),
     &                 nspareke(icomp)
        if (nnumtcke(icomp)+ndentcke(icomp).ge.1) then
c  read reducing pars
          read (nread,*) trtcke(icomp),Drtcke(icomp),tcxrede(icomp)
          if (nnumtcke(icomp).ge.1) then
            do j=1,nnumtcke(icomp)              !read "numerator" terms
c  as originally implemented for CO2, these terms are:
c  ctck(icomp,1,1) = gnu (universal exponent, approx 0.63)
c  ctck(icomp,2,1) = gamma (universal exponent, approx 1.2145)
c  ctck(icomp,3,1) = R0 (universal amplitude, 1.01 +/- 0.04)
c  ctck(icomp,4,1) = z (universal exponent, 0.065 +/- 0.005)
c  ctck(icomp,5,1) = c (visc const, approx 1.075, but often set to 1)
c  ctck(icomp,6,1) = xi0 (amplitude, order 1d-10 m)
c  ctck(icomp,7,1) = gam0 (amplitude, order 0.05 - 0.06)
c  ctck(icomp,8,1) = qd_inverse (cutoff diameter, order 10d-9 m)
c  ctck(icomp,9,1) = tref (reference temperature, 1.5 - 2.0 * Tc)
              jterm=jterm+1
              read (nread,*) ctcke(icomp,jterm,1)
            enddo
          end if
        end if
      end if
c
      RETURN
      end                                             !subroutine SETTK6
c
c ======================================================================
c
      function TCCNH3 (icomp,t,rho)
c
c  model for the thermal conductivity critical enhancement of ammonia
c  by the empirical model of Tufeu et al.
c
c  this is a special model only for ammonia with all constants "hardwired"
c
c  inputs:
c    icomp--component number in mixture (1..nc); 1 for pure fluid
c           [not used--included to maintain parallel structure]
c        t--temperature [K]
c      rho--molar density [mol/L]
c  output (as function value):
c   tccnh3--the critical enhancement to the thermal conductivity [W/m-K]
c
c  written by S.A. Klein & M. McLinden,
c  NIST Phys & Chem Properties Div, Boulder, CO
c  02-26-97  MM, original version (adapted from TCENHC of SAK)
c  07-07-98 EWL, changed variable dpdt to dpt
c  12-01-98 EWL, add Reos and triple point pressure and density to /CCON/
c  01-19-00 EWL, avoid divide by zero if tr=0
c  01-25-00 EWL, changed 253 to 235 (for rhoc) and fixed other errors
c  01-26-00 EWL, Tufeu formulation returns an infinite Tcx at Tc for any
c                density.  Outside of the critical region, the effect was
c                removed (between 404.4 and 406.5 K and rho<9.6 or rho>18.)
c
      include 'commons.for'
      include 'comtrn.for'
c
      rhokg=rho*wmas(icomp)               !correlation in mass units
      tr=abs(t-405.4d0)/405.4d0           !405.4 is Tc
      trr=tr
      if (t.gt.404.4d0 .and. t.lt.406.5d0) then
        if (rho.lt.9.6d0 .or. rho.gt.18.0d0) then
          trr=0.002
        endif
      endif
      etab=1.0d-5*(2.6d0+1.6d0*tr)        !viscosity--Eq 9
      dPT=1.0d5*(2.18d0- 0.12d0/EXP(17.8d0*tr))  !dP/dT for rho = rhoc
c  Eq 9 of Tufeu for conductivity along critical isochore
      if (abs(trr).lt.1.d-20) then
        tcrhoc=1.0d20
        dtcid=tcrhoc
        xcon=-1.0d20                         !Eq 12
      else
        tcrhoc=1.2d0*1.38066d-23*t**2*dPT**2*0.423d-8/(trr**1.24d0)*
     &    (1.0d0+1.429d0*tr**0.50d0)/(6.0d0*3.14159*etab*(1.34d-10/trr**
     &    (0.63d0)*(1.0d0+1.0d0*tr**0.50d0)))
        dtcid=tcrhoc*EXP(-36.0d0*tr**2)     !Eq 10
        xcon=0.61d0*235d0+16.5d0*log(trr)    !Eq 12
      endif
      if (rho/Dcrit(icomp) .lt. 0.6d0) then
c  Eq 14 for rho < 0.6*rhoc (141 = 0.6*rhoc)
        tccsw=dtcid*xcon**2/(xcon**2+(141.0d0- 0.96d0*235.0d0)**2)
        TCCNH3=tccsw*rhokg**2/141.0d0**2 !SAK had 253 in denominator
      else
c  Eq 11 for rho > 0.6*rhoc       (SAK had 253)
        TCCNH3=dtcid*xcon**2/(xcon**2+(rhokg-0.96d0*235.0d0)**2)
      end if
c
      RETURN
      end                                               !function TCCNH3
c
c ======================================================================
c
      function TCCCH4 (icomp,t,rho)
c
c  model for the thermal conductivity critical enhancement of methane
c  by the empirical model of Friend et al. (1989).
c
c  this is a special model only for methane with all constants "hardwired"
c
c  inputs:
c    icomp--component number in mixture (1..nc); 1 for pure fluid
c           [not used--included to maintain parallel structure]
c        t--temperature [K]
c      rho--molar density [mol/L]
c  output (as function value):
c   tccch4--the critical enhancement to the thermal conductivity [W/m-K]
c
c  written by E.W. Lemmon
c  NIST Phys & Chem Properties Div, Boulder, CO
c  01-27-00 EWL, original version (adapted from TCENHC of SAK)
c
      include 'commons.for'
      include 'comtrn.for'
      character*255 herr
c
      call DPDTK (icomp,t,rho,dpt)
      call DPDDK (icomp,t,rho,dpdrho)
      call ETAK (icomp,t,rho,eta,ierr,herr)
      tau=tcrit(icomp)/t
      del=rho/Dcrit(icomp)
      if (ABS(rho).gt.1d-12) then
        dpt=dpt/R/rho
      else
        dpt=1.0d0
      endif
      dpdrho=dpdrho/R/t
      ts=(tcrit(icomp)-t)/tcrit(icomp)
      ds=(Dcrit(icomp)-rho)/Dcrit(icomp)
      xt=0.28631d0*del*tau/dpdrho
      IF (xt.lt.0) xt=1.0d5
      ftd=2.646d0*SQRT(ABS(ts))+2.678d0*ds**2-0.637d0*ds
      ftd=exp(-ftd)
      TCCCH4=91.855d0/eta/tau**2*dpt**2*xt**0.4681d0*ftd*1.d-3
c
      RETURN
      end                                               !function TCCCH4
c
c ======================================================================
c
c
c     The following functions (through REXCES) were taken from NIST12,
c     Version 3.1, and modified to work with the current version.
c
      FUNCTION TCXH2(ICOMP,T,D)
c
c  model for the thermal conductivity of para and normal hydrogen
c
c  inputs:
c    icomp--component number in mixture (1..nc); 1 for pure fluid
c        t--temperature [K]
c        d--molar density [mol/L]
c  output (as function value):
c     tcx5--thermal conductivity [W/m-K]
c
c  written by E.W. Lemmon, NIST Phys & Chem Properties Div, Boulder, CO
c  10-20-99 EWL, original version
c
      include 'commons.for'
      include 'comtrn.for'
      character*255 herr
      dimension x(ncmax)
c
      do i=1,nc
        x(i)=0.0d0
      enddo
      x(icomp)=1.0d0
      THER1=0.D0
      IF (T.LE.90.0D0) THEN
        D0=D
        CALL PRESS (T,D,X,PE)
        IF(PE.GE.12000.0d0) CALL TPRHO (t,12000.0d0,X,1,0,D0,ierr,herr)
        THER1=DILT(ICOMP,T)+EXCSH2(ICOMP,D0,T)*1000.0D0+RCRIT(D0,T)
        IF(D.gt.0.0D0)THER1=THERMX(D,D0,THER1)
        TCXH2=THER1/1000.0d0
        IF(T.LT.70.0D0)RETURN
      ENDIF
      D0=D
      CALL PRESS (T,D,X,PE)
      IF(PE.GE.60000.0d0) CALL TPRHO (t,60000.0d0,X,1,0,D0,ierr,herr)
      THER2=RTHERM(ICOMP,D0,T)
      IF(D.gt.0.0D0)THER2=THERMX(D,D0,THER2)
      IF(T.GT.90.0D0)THEN
        TCXH2=THER2
      ELSE
        PER=(T-70.0D0)/20.0D0
        TCXH2=(THER1/1000.0D0)*(1.0D0-PER) + THER2*PER
      END IF
      END

      FUNCTION THERMX(DE,D0,THER)
      include 'commons.for'
      include 'comtrn.for'
c
      THERMX=DEXP(LOG(THER)+(DE-D0)*0.041758537D0)
      END

      FUNCTION DILT(ICOMP,T)
      include 'commons.for'
      include 'comtrn.for'
c
      TF=T**(1.0D0/3.0D0)
      TFF=T**(-4.0D0/3.0D0)
      SUM=0
      DO I=1,9
        TFF=TFF*TF
        SUM=SUM+ctcx(icomp,I,1)*TFF
      ENDDO
      DILT=SUM*100.0D0
      END

      FUNCTION RCRIT(D,T)
      include 'commons.for'
      include 'comtrn.for'
c
      DELT=ABS(T-32.938D0)
      DELD=D-15.556D0- 0.008229*DELT**1.5D0
      X=0.138D0*DELD
      RCRIT=(0.635363D-2 -0.5863D-4*T)*DEXP(-X**2)*1000.0D0
      IF(RCRIT.LE.0.0D0)RCRIT=0.0D0
      END

      FUNCTION RTHERM(ICOMP,DD,TIN)
C     INPUT, DENSITY MOL/L, TEMPERATURE K, OP PARA FRACTION
C     OUTPUT, THERMAL CONDUCTIVITY OF HYDROGEN, W/M.K, 4 FEB 84
C     FROM NBSIR 84-3006, HM RODER MAY 86
      include 'commons.for'
      include 'comtrn.for'
      DIMENSION TNZ(35),TPZ(35),TT(35),G(3)
      parameter (TNZ=(/.0505,.0568,.0632,.0695,.0763,.0829,.0896,
     &.0962,.1026,.1092,.1157,.1220,.1282,.1342,.1401,.1458,.1514,
     &.1569,.1622,.1674,.1725,.1774,.1823,.1870,.1917,.1962,.2012,
     &.2061,.2110,.2158,.2203,.2250,.2295,.2340,.2380/))
      parameter (TPZ=(/.0529,.0617,.0714,.0816,.0924,.1028,.1125,
     &.1213,.1294,.1365,.1427,.1482,.1530,.1574,.1614,.1651,.1687,
     &.1723,.1758,.1793,.1828,.1863,.1899,.1935,.1972,.2010,.2048,
     &.2088,.2129,.2169,.2208,.2249,.2290,.2330,.2370/))
      parameter (TT=(/70.,80.,90.,100.,110.,120.,130.,140.,150.,
     &160.,170.,180.,190.,200.,210.,220.,230.,240.,250.,260.,270.,
     &280.,290.,300.,310.,320.,330.,340.,350.,360.,370.,380.,390.,
     &400.,410./))
      parameter (G=(/.1584312604d-02,.3861103193d-04,.1066433014d-06/))
      OP=ctcx(icomp,10,1)
      DO I=1,35
        IF(TIN.LT.TT(I))GOTO 4
      ENDDO
      TCZN=0.2380d0+0.0045d0*(TIN-410.0D0)/10.0D0 !Correction by EWL to account
      TCZP=0.2370d0+0.0040d0*(TIN-410.0D0)/10.0D0 !for high temperatures
      GOTO 5
    4 CONTINUE
      TCZN=TNZ(I-1)+(TNZ(I)-TNZ(I-1))*(TIN-TT(I-1))/(TT(I)-TT(I-1))
      TCZP=TPZ(I-1)+(TPZ(I)-TPZ(I-1))*(TIN-TT(I-1))/(TT(I)-TT(I-1))
    5 CONTINUE
      OPDIFF=TCZP-TCZN
      TCZADJ=OPDIFF/.75*(OP-.25)
      FACTOR=1.D0-.028484+.000070588*TIN
      TCZ=TCZN*FACTOR+TCZADJ+CRITH2(DD,TIN)
      RTHERM=TCZ+G(1)*DD+(G(2)+G(3)*TIN)*(EXP(2.1*DD**.36)-1.0D0)
      END

      FUNCTION CRITH2(D,T)
      include 'commons.for'
      include 'comtrn.for'
c
      CRITH2=0.0D0
      IF(T.LE.77..OR.T.GE. 108.35658)RETURN
      AMPL=0.00635363D0- .00005863D0*T
      RHOCEN=15.556D0- .008229D0*(T-32.938D0)**1.5
      CRITH2=AMPL*EXP(-(0.138D0*(D-RHOCEN))**2)
      END

      FUNCTION EXCSH2(ICOMP,D,T)
c  12-23-03 EWL, add D.LT.0.001 to stop infinite contribution at very low p.
c  01-23-07 EWL, check for high exponent on R2
      include 'commons.for'
      include 'comtrn.for'
      dimension ET(8)
c
      EXCSH2=0
      IF (D.LE.0.D0) RETURN
      IF(T.GT.80.D0 .OR. D.LT.0.001D0)THEN
        EXCSH2=REXCES(D,T)
        RETURN
      ENDIF
      ET(1)=ctcx(icomp,11,1)
      ET(2)=ctcx(icomp,12,1)
      ET(3)=ctcx(icomp,13,1)
      ET(4)=ctcx(icomp,14,1)
      ET(5)=ctcx(icomp,15,1)
      ET(6)=ctcx(icomp,16,1)
      ET(7)=ctcx(icomp,17,1)
      ET(8)=ctcx(icomp,18,1)
      RR=D**0.1D0
      R2=0.d0
      IF ((D-ET(8))/ET(8).LT.1000.) R2=D**((D-ET(8))/ET(8))
      X=ET(1)+ET(2)*R2+ET(3)*RR+ET(4)*R2/(T*T)
     &+ET(5)*RR/T**1.5D0+ET(6)/T+ET(7)*R2/T
      X1=ET(1)+ET(6)/T
      IF (X.LT.3000.D0) EXCSH2=(DEXP(X)-DEXP(X1))/10.D0
      END

      FUNCTION REXCES(D,T)
      include 'commons.for'
      include 'comtrn.for'
c
      DEL=.38611D-4+.10664D-7*T
      REXCES=.15843D-2*D+DEL*(DEXP(2.1D0*D**.36D0)-1.0D0)
      END
c
c ======================================================================
c
      function TCXHE (icomp,t,rho)
c
c  calculate the thermal conductivity of helium using the model of:
c  Hands, B.A. and Arp, V.D.  A Correlation of Thermal Conductivity Data
c  for Helium.  Cryogenics, 21(12):697-703 (1981).
c
c  inputs:
c    icomp--component number in mixture (1..nc); 1 for pure fluid
c        t--temperature [K]
c  output (as function value):
c   tcxhe --thermal conductivity [W/m-K]
c
c  written by E.W. Lemmon, NIST Phys & Chem Properties Div, Boulder, CO
c  07-06-98 EWL, original version
c  11-06-00 EWL, replace the TC4 version with a TC0 version and combine
c                the various subroutines into one.
c  07-23-02 EWL, initialize tcxcr
c  09-18-03 EWL, change dcc from 69.58 to 69.158 (as given by Hands and Arp)
c  08-09-05 EWL, check for rho=0
c
      include 'commons.for'
      include 'comtrn.for'
      character*255 herr
c
      bkt=0.0d0
      i=icomp
      tau=t/trdbkt(i)
      sum=0.0d0
      do j=2,ndgnum(i)
        sum=sum+ctcx(i,j,1)*tau**ctcx(i,j,2)
      enddo
      tcxdg=ctcx(i,1,1)*tau**ctcx(i,1,2)*EXP(sum)
c     write (*,*) ' TCXHE--dilute-gas thermal conductivity:  ',tcxdg
c
      tau=(t/trdbkt(i))**(1.0d0/3.0d0)
      del=rho/Drdbkt(i)
c  sum the background terms
      tcxbk=0.0d0
      do j=1,nbknum(i)
        j1=j+ndgnum(i)
        if (abs(ctcx(i,j1,4)).lt.1.d-12 .or. abs(del).lt.1.d-12) then
          tcxbk=tcxbk+ctcx(i,j1,1)*tau**ctcx(i,j1,2)*del**ctcx(i,j1,3)
        else
          tcxbk=tcxbk+ctcx(i,j1,1)*tau**ctcx(i,j1,2)*del**ctcx(i,j1,3)
     &          *LOG(del**ctcx(i,j1,4))
        endif
      enddo
c  add the critical enhancement contribution
      tcxcr=0.0d0
      IF (T.GE.3.5d0 .AND. T.LE.12.0d0) THEN
        x0=.392d0
        e1=2.8461d0
        e2=.27156d0
        beta=.3554d0
        gamma=1.1743d0
        delta=4.304d0
        dcc=69.158d0
        tcc=5.18992d0
        pcc=227460.d0
        rho1=rho*wmas(icomp)
        call DPDDK (icomp,t,rho,dpd)
        if (rho.gt.0.0d0) bkt=1.0d0/dpd/rho/1000.0d0
        deld=ABS((rho1-dcc)/dcc)
        delt=ABS((t-tcc)/tcc)
        r2=(delt/0.2d0)**2+(deld/0.25d0)**2
        if (r2.lt.1.0d0 .and. rho.gt.0.0d0) then
          xx=delt/deld**(1.0d0/beta)
          x1=(xx+x0)/x0
          x2b=x1**(2.0d0*beta)
          x2be=(1.0d0+e2*x2b)**((gamma-1.0d0)/2.0d0/beta)
          hh=e1*x1*x2be
          dhdx=e1*x2be/x0+e1*e2/x0*x2b*x2be/(1.0d0+e2*x2b)*(gamma-1.0d0)
          d2kt=(delta*hh-xx*dhdx/beta)*deld**(delta-1.0d0)
          bkt1=(dcc/rho1)**2/d2kt/pcc
          bkt=r2*bkt+(1.0d0-r2)*bkt1
        endif
        call DPDTK (icomp,t,rho,pdt)
        call ETAK (icomp,t,rho,eta,ierr,herr)
        eta=eta/1.0d6
        pdt=pdt*1.0d3
        bkcrit=0
        if (bkt.ge.0.0d0 .and. rho1.gt.0.0d0) then
          bkcrit=t**2*SQRT(bkt)/rho1/eta*pdt**2
     &          *EXP(-18.66d0*delt**2-4.25d0*deld**4)
        endif
        bkcrit=3.4685233d-17*bkcrit
        tcxcr=3.726229668d0*bkcrit
      ENDIF

c  multiply by reducing parameter (to convert units, etc.)
      tcxhe=(tcxdg+tcxbk+tcxcr)*tcxbkt(i)
c     write (*,*) ' TCXHE--residual thermal conductivity:    ',tcxhe
c
      RETURN
      end                                                !function TCXHE
c
c ======================================================================
c
      function TCXETY (icomp,t,rho)
c
c  thermal conductivity model for ethylene by Holland et al. (1983)
c
c  inputs:
c    icomp--component number in mixture (1..nc); 1 for pure fluid
c        t--temperature [K]
c      rho--molar density [mol/L]
c  output (as function value):
c   tcxety--thermal conductivity [W/m-K]
c
c  written by E.W. Lemmon, NIST Phys & Chem Properties Div, Boulder, CO
c  02-29-00 EWL, original version
c
      include 'commons.for'
      include 'comtrn.for'
      double precision gt(9)
c
      tcxety=0.0d0
      gt(1)=-2.9034235280d5
      gt(2)= 4.6806249520d5
      gt(3)=-1.8954783215d5
      gt(4)=-4.8262235392d3
      gt(5)= 2.2434093720d4
      gt(6)=-6.6206354818d3
      gt(7)= 8.9937717078d2
      gt(8)=-6.0559143718d1
      gt(9)= 1.6370306422d0
      t1=-1.3045033230d1
      t2= 1.8214616599d1
      t3=-9.9030224960d3
      t4= 7.4205216310d2
      t5=-3.0083271933d-1
      t6= 9.6456068829d1
      t7= 1.3502569620d4
      d=rho*wmas(icomp)/1000.0d0
      dc=.221d0
      th=(d-dc)/dc
      tt=t**(1.0d0/3.0d0)
      tcx0=gt(1)/t+gt(2)/tt**2+gt(3)/tt+gt(4)+gt(5)*tt
     &    +gt(6)*tt**2+gt(7)*t+gt(8)*tt**4+gt(9)*tt**5
      tcxpr=exp(t1+t4/t)*(exp(d**0.1d0*(t2+t3/t**1.5d0)
     &     +th*d**0.5d0*(t5+t6/t+t7/t**2))-1.0d0)
      tcxcr=0
c     if (rho.gt.0) then
c       an=6.0221367d23
c       xk=1.380658d-23
c       pi=3.1415927d0
c       tcc=282.34d0
c       pcc=5.039d0
c       beta=0.355d0
c       gamma=1.19d0
cc      x0=0.168d0
c       eta=ETAETY(icomp,t,rho)
c       call DPDTK (icomp,t,rho,dpt)
c       call DPDDK (icomp,t,rho,dpdrho)
c       xkt=SQRT(1.0d0/rho/dpdrho*1.d3)
c       dts=(t-tcc)/tcc
cc      b=x0**(-beta)
c       b=ABS(th)/ABS(dts)**gamma
cc      g=x0**gamma/(2.17d0*0.287d0**((gamma-1)/2.0d0/beta))
c       xts=d**2*xkt*pcc/dc**2
c       g=xts*ABS(dts)**gamma
c       xi=0.69d0/SQRT(b**2*pcc/g/xk/tcc)
c       f=EXP(-18.66d0*dts**2-4.25d0*th**4)
c       c=SQRT(wmas(icomp)/d/an/xk/t)
c       tcxcr=c*xk*t**2/6.0d0/pi/eta/xi*dpt**2*xkt*f*1.d5/sqrt(10)
c     endif
      tcxety=(tcx0+tcxpr+tcxcr)/1000.0D0
c
      RETURN
      end                                               !function TCXETY
c
c ======================================================================
c
      function TCXR23 (icomp,t,rho)
c
c  thermal conductivity model for R23
c
c  inputs:
c    icomp--component number in mixture (1..nc); 1 for pure fluid
c        t--temperature [K]
c      rho--molar density [mol/L]
c  output (as function value):
c   tcxr23--thermal conductivity [W/m-K]
c
c  written by E.W. Lemmon, NIST Phys & Chem Properties Div, Boulder, CO
c  11-01-00 EWL, original version
c
      include 'commons.for'
      include 'comtrn.for'
c
      tcxR23=0.0d0
      rhoL=ctcx(icomp,1,1)
      B1=ctcx(icomp,2,1)
      B2=ctcx(icomp,3,1)
      C1=ctcx(icomp,4,1)
      C2=ctcx(icomp,5,1)
      DG=ctcx(icomp,6,1)
      tcxmax=ctcx(icomp,7,1)
      drho=rhoL-rho
      del=rho-Drdbkt(icomp)
      tau=t-trdbkt(icomp)
      tcxdg=(B1+B2*t)*(drho/rhoL)**C1
      tcxrs=(rho/rhoL)**C1*C2*rhoL**2/drho*t**0.5d0
     &     *EXP(rho/drho*DG/R/t)
      tcxct=4.0d0*tcxmax/(exp(del)+exp(-del))/(exp(tau)+exp(-tau))
      tcxR23=(tcxdg+tcxrs+tcxct)/1000.0d0
c
      RETURN
      end                                               !function TCXR23
c
c ======================================================================
c
      function TCXD2O (icomp,t,rho)
c
c  thermal conductivity model for heavy water
c
c  inputs:
c    icomp--component number in mixture (1..nc); 1 for pure fluid
c        t--temperature [K]
c      rho--molar density [mol/L]
c  output (as function value):
c   tcxd2o--thermal conductivity [W/m-K]
c
c  written by E.W. Lemmon, NIST Phys & Chem Properties Div, Boulder, CO
c  11-06-00 EWL, original version
c
      include 'commons.for'
      include 'comtrn.for'
c
      tcxD2O=0.0d0
      tr=t/trdbkt(icomp)
      dr=rho/Drdbkt(icomp)
      tau=tr/(ABS(tr-1.1d0)+1.1d0)
      tcx0=0.d0
      j=ndgnum(icomp)
      do i=1,j
        tcx0=tcx0+ctcx(icomp,i,1)*tr**ctcx(icomp,i,2)
      enddo
      tcxr=0.d0
      do i=1,nbknum(icomp)
        j=j+1
        tcxr=tcxr+ctcx(icomp,j,1)*dr**ctcx(icomp,j,2)
      enddo
      be=ctcx(icomp,j+1,1)
      b0=ctcx(icomp,j+2,1)
      c1=ctcx(icomp,j+3,1)
      c2=ctcx(icomp,j+4,1)
      ct1=ctcx(icomp,j+5,1)
      ct2=ctcx(icomp,j+6,1)
      cr1=ctcx(icomp,j+7,1)
      cr2=ctcx(icomp,j+8,1)
      cr3=ctcx(icomp,j+9,1)
      dr1=ctcx(icomp,j+10,1)
      d1=ctcx(icomp,j+11,1)
      f1=EXP(ct1*tr+ct2*tr**2)
      f2=EXP(cr1*(dr-1.0d0)**2)+cr2*EXP(cr3*(dr-dr1)**2)
      f3=1.0d0+EXP(60.0d0*(tau-1.0d0)+20.0d0)
      f4=1.0d0+EXP(100.0d0*(tau-1.0d0)+15.0d0)
      tcxr=b0*(1.d0-EXP(be*dr))+tcxr
      tcxc=c1*f1*f2*(1.0d0+f2**2*(c2*f1**4/f3+3.5d0*f2/f4))
      tcxl=d1*f1**1.2d0*(1.d0-EXP(-(dr/2.5d0)**10))
      tcxD2O=tcxbkt(icomp)*(tcx0+tcxr+tcxc+tcxl)
c
      RETURN
      end                                               !function TCXD2O
c
c ======================================================================
c
      function TCXH2O (icomp,t,rho)
c
c  thermal conductivity model for water
c
c  inputs:
c    icomp--component number in mixture (1..nc); 1 for pure fluid
c        t--temperature [K]
c      rho--molar density [mol/L]
c  output (as function value):
c   tcxh2o--thermal conductivity [W/m-K]
c
c  written by E.W. Lemmon, NIST Phys & Chem Properties Div, Boulder, CO
c  11-07-00 EWL, original version
c  12-19-06 EWL, add check for large EXP(dr*s)
c  01-04-08 MLH, added additional slots to WNTETA
c  05-10-08 MLH, fix bug dreta instead of dr, allow for new vis model
c
      include 'commons.for'
      include 'comtrn.for'
c
      tcxH2O=0.0d0
      tr=t/trdbkt(icomp)
      dr=rho/Drdbkt(icomp)
      tau=1.0d0/tr-1.0d0
      del=dr-1.0d0
      if (ABS(tau).lt.1.0d-12 ) tau=1.0d-12
      if (ABS(del).lt.1.0d-12 ) del=1.0d-12
      s=0.0d0
      do i=1,ndgnum(icomp)
        s=s+ctcx(icomp,i,1)/tr**ctcx(icomp,i,2)
      enddo
      tcx0=SQRT(tr)/s
      s=0.0d0
      do i=1,nbknum(icomp)
        j=i+ndgnum(icomp)
        s=s+ctcx(icomp,j,1)
     &        *tau**INT(ctcx(icomp,j,2))*del**INT(ctcx(icomp,j,3))
      enddo
      tcx1=1.0d10
      if (dr*s.lt.100) tcx1=EXP(dr*s)
c  calculate water viscosity
      treta=t/tredeta(icomp)
      dreta=rho/Dredeta(icomp)
      taueta=1.0d0/treta-1.0d0
      deleta=dreta-1.0d0  !bug fix; was dr
      if (ABS(taueta).lt.1.0d-12 ) taueta=1.0d-12
      if (ABS(deleta).lt.1.0d-12 ) deleta=1.0d-12
      s=0.0d0
      do i=1,ndel0(icomp)
        s=s+ceta(icomp,i,1)/treta**ceta(icomp,i,2)
      enddo
      eta0=SQRT(treta)/s
      IF(verfl(icomp).gt.8.0)eta0=eta0/55.071d-2 !allow new viscosity model
      s=0.0d0
      do i=1,npoly(icomp)
        j=i+ndel0(icomp)
        s=s+ceta(icomp,j,1)
     &        *taueta**INT(ceta(icomp,j,2))*deleta**INT(ceta(icomp,j,3))
      enddo
      eta1=EXP(dreta*s)
c  critical region contribution to Tcx
C     skip this for beyond version 8.1 - use tk3
      IF(verfl(icomp).le.8.1)then
      call DPDTK (icomp,t,rho,dpt)
      call DPDDK (icomp,t,rho,dpdrho)
      tcx2=0.0d0
      if (dr.gt.0.0d0 .and. dpdrho.gt.0.0d0) then
        x=dr/dpdrho/Drdbkt(icomp)*22115.0d0
        tcx2=0.0013848d0*(t/dr)**2/eta0/eta1
     &      *(dpt/22115.d0)**2*x**0.4678d0*SQRT(dr)
     &      *EXP(-18.66d0*(tr-1.d0)**2-del**4)
      endif
      else
      tcx2=0.0d0 !will be added by crit routine later
      endif
      tcxH2O=tcxbkt(icomp)*(tcx0*tcx1+tcx2)
      RETURN
      end                                               !function TCXH2O
c ======================================================================
c
      function TCCR_2010 (T,RHOmol,QD)
c   critical enhancement term for water, based on simplified Olchowy Sengers
c   t--temperature K
c   rhomol--molar density mol/L
c   qd-- cutoff wave number, m
c   tccr--the critical enhancement to the thermal conductivity W/m-K
c
c   09-30-2010  based on code from R. Perkins
c
      include 'commons.for'
      include 'comtrn.for'
      character*255 herr
      dimension x(ncmax)
      parameter (Tc=647.096D0, Denc=322.0D0, Pc=22.064D0)
      parameter (xi0=0.13d-9, gammaplus=0.06d0)
      parameter (exnu=0.63d0, exgamma=1.239d0)
* boltz based on CODATA gas constant
*     parameter (RD=1.05d0, boltz=1.3806504d-23)
* boltz based on IAPWS95 (incorrect gas constant)
      parameter (RD=1.01d0, boltz=1.3806347766d-23)
      parameter (pi=3.14159265358979d0)
      wmwat=18.015268d0
      !qd=1.0d0/0.4d-9
      rhokg=rhomol*wmwat
      tbar=t/tc
      iii=1
      x(1)=1.0d0 !pure fluid
      if (rhomol.lt.1.0d-6) then
c  critical enhancement is zero for low densities (avoid divide by zero)
        tccr_2010=0.0d0
        RETURN
      end if
* calculate correlation length xi in m
      xi=xi_fun(T,RHOmol,iii)
      IF(xi.le.0.0d0) then
        tccr_2010=0.0d0
        return
      endif
*
* calculate cv and cp at T and RHO
      call THERM (t,rhomol,x,p,e,h,s,cv,cp,w,hjt)
      cpbar=(cp/wmwat)/0.46151805d0   !cp/R
      rhobar=rhokg/denc
      rkappa=cp/cv
      yval=qd*xi
      xomg_bar=2.0d0/pi*((1.0d0- 1.0d0/rkappa)*ATAN(yval)+yval/rkappa)
      xomg0_bar=2.0d0/pi*(1.0d0-EXP(-1.0d0/(1.0d0/yval
     &     +(yval**2)/(3.0d0*rhobar**2))))
      call ETAK (iii,t,rhomol,eta,ierr,herr) ! eta is in uPa-s
      etabar=eta
c smooth transition at low xi
      if (xi.gt.1.5d-12) then
        Z=1.0d0/yval*(xomg_bar-xomg0_bar)
      else
        Z=2.0d0/pi*
     &   (yval/2.0d0+yval**2*(1.0d0/3.0d0/rkappa-1.0d0/2.0d0)+
     &   yval**3*(1.0d0/3.0d0/rhobar**2+1.0d0/24.0d0)-yval**4*
     &   (1.0d0/3.0d0/rhobar**2+1.0d0/5.0d0/rkappa-3.0d0/120.0d0)+
     &   yval**5*(1.0d0/6.0d0/rhobar**2+1.0d0/270.0d0))
      end if
      tccr_2010=177.8514d0*rhobar*cpbar*tbar/etabar*Z  !dimensionless
      tccr_2010=tccr_2010*1.0d-3 !convert to w/m-k
      RETURN
      end                                           !function TCCR_2010
c
c ======================================================================
c
      function TCXM1C (x,t,rho,ierr,herr)
c
c  based on the simplified critical enhancement of:
c  Olchowy, G.A. and Sengers, J.V. (1989). A simplified representation for
c  the thermal conductivity of fluids in the critical region.
c  Int. J. Thermophysics  10: 417-426.
c
c  also applied to CO2 by:
c  Vesovic, V., Wakeham, W.A., Olchowy, G.A., Sengers, J.V., Watson, J.T.R.
c  and Millat, J. (1990). The transport properties of carbon dioxide.
c  J. Phys. Chem. Ref. Data  19: 763-808.
c  equation numbers in comments refer to Vesovic paper
c
c  Model has been adapted to use for a mixture.
c  All coefficients except qd are fixed. Qd is a mole fraction
c  sum of the components qd's. If qd has not been supplied, a value
c  of 0.5d-9 is used. The actual mixture T, rho  (not a scaled value) is used.
c
c  This routine is designed to be called from TRNS_ECS.FOR. The routine TRNS_ECS.FOR is
c  used to supply the viscosity of the fluid at T,rho by placing it in
c  common block critenh before a call to this subroutine is made.
c
c  inputs:
c      x--composition array [mol frac]
c      t--temperature [K]
c      rho--molar density [mol/L]
c  output (as function value):
c      TCXM1C--the critical enhancement to the thermal conductivity [W/m-K]
c
c  written by M. McLinden, NIST Phys & Chem Properties Div, Boulder, CO
c  06-08-97  MM, original version
c  06-16-97  MM, change DPDD, CVCP calls to DPDDK, CVCPK i.e. (t,x) to (icomp,t)
c  11-20-01  MLH, adapted for one-fluid mixture model use.
c  07-01-02  MLH, set generalized values when model not declared
c  06-13-06  EWL, modify how test for pure fluids is done
c  10-06-08  MLH, prevent ridiculous numbers for qd in tk6 model
c  06-01-11  EWL, remove common block SHAPES which was not used
c
c
      include 'commons.for'
      include 'comtrn.for'
      character*255 herr
      dimension x(ncmax)
c
      gnu =0.0d0
      gamma = 0.0d0
      r0 = 0.0d0
      xi0 = 0.0d0
      gam0 =0.0d0
      qd=0.0d0
c
      if (rho.lt.1.0d-6) then
c  critical enhancement is zero for low densities (avoid divide by zero)
        TCXM1C=0.0d0
        RETURN
      end if

      call ISPURE (x,icomp)
c
c  determine the coefficients
      gnux=0.0d0
      gammax=0.0d0
      R0x=0.0d0
c     zx=0.0d0
c     cviscx=0.0d0
      xi0x=0.0d0
      gam0x=0.0d0
      qdx=0.0d0
      trefx=0.0d0
      Rgasx=0.0d0
c
c     check to see if it is exactly at critical point of a pure fluid
      if (icomp.ne.0) then
        if (abs(t-tcrit(icomp)).lt.1.d-20 .and.
     &      abs(rho-Dcrit(icomp)).lt.1.d-20) then
          ierr=-60
          write (herr,1001) ierr,hnull
          call ERRMSG (ierr,herr)
 1001   format ('[TCXM1C error',i3,'] pure fluid is exactly at the ',
     &          'critical point; thermal conductivity is infinite',a1)
c
        endif
      endif
      do ii=1,nc
        i=0
        if (icomp.ne.0) then
          i=icomp
        elseif (x(ii).gt.0.d0) then
          i=ii
        endif
        if (i.gt.0) then
        if(htcxcr(i).eq.'TK3') then !use coeff loaded for TK3 model
           gnu=ctck(i,1,1)     !nu (universal exponent, approx 0.63)
           gamma=ctck(i,2,1)   !gamma (universal exponent, approx 1.24)
           R0=ctck(i,3,1)      !R0 (universal amplitude, 1.01 +/- 0.04)
c          following two parameters not used, in file for future use
c          z=ctck(i,4,1)       !z (universal exponent, 0.065 +/- 0.005)
c          cvisc=ctck(i,5,1)   !visc const, approx 1.075, but often 1)
           xi0=ctck(i,6,1)     !xi0 (amplitude, order 1d-10 m)
           gam0=ctck(i,7,1)    !gam0 (amplitude, order 0.05 - 0.06)
           qd=1.0d0/ctck(i,8,1) !qd_inverse (cutoff dia, order 10d-9 m)
           treff=ctck(i,9,1)     !treff (reference temp, 1.5 - 2.0 * Tc)
c
        elseif(htcxcrecs(i).eq.'TK6') then ! coeff for ecs enhancement
           gnu=ctcke(i,1,1)     !nu (universal exponent, approx 0.63)
           gamma=ctcke(i,2,1)   !gamma (universal exponent, approx 1.24)
           R0=ctcke(i,3,1)      !R0 (universal amplitude, 1.01 +/- 0.04)
c          following two parameters not used, in file for future use
c          z=ctcke(i,4,1)       !z (universal exponent, 0.065 +/- 0.005)
c          cvisc=ctcke(i,5,1)   !visc const, approx 1.075, but often 1)
           xi0=ctcke(i,6,1)     !xi0 (amplitude, order 1d-10 m)
           gam0=ctcke(i,7,1)    !gam0 (amplitude, order 0.05 - 0.06)
           IF(ctcke(i,8,1).le.0)ctcke(i,8,1)=0.5d-9
           qd=1.0d0/ctcke(i,8,1) !qd_inverse (cutoff dia, order 10d-9 m)
           treff=ctcke(i,9,1)    !treff (reference temp, 1.5 - 2.0 * Tc)
        else
C       set to generalized values;
C       see Vesovik et al. J. Phys. Che, Ref Data 19(3):762-808 (1990).
           gnu =0.63d0
           gamma=1.239d0
           R0=1.03d0
c          z=0.063d0
c          cvisc=1.0d0
           xi0=1.94d-10
           gam0=0.0496d0
           qd=1.0d0/0.5d-9
           treff=1.5*tcrit(i)
        endif
        if(icomp.eq.0)then         !compute mixture values
          gnux=gnux+x(i)*gnu
          gammax=gammax+x(i)*gamma
          R0x=R0x+x(i)*R0
c         zx=zx+x(i)*z
c         cviscx=cviscx+x(i)*cvisc
          xi0x=xi0x+x(i)*xi0
          gam0x=gam0x+x(i)*gam0
          qdx=qdx+x(i)*qd
          trefx=trefx+x(i)*treff
          Rgasx=Rgasx+x(i)*Reos(i)
        endif
        endif
      enddo
c
      if(icomp.eq.0)then
        gnu=gnux
        gamma=gammax
        R0=R0x
c       z=zx
c       cvisc=cviscx
        xi0=xi0x
        gam0=gam0x
        qd=qdx
        treff=trefx
        Rgas=Rgasx
      endif

      if(icomp.ne.0) then !pure fluid case
        call INFO (icomp,wmm,ttrp,tnbpt,tc,pc,Dc,Zc,acf,dip,Rgas)
C       Rgas in J/mol.K
        call DPDDK (icomp,t,rho,dpdrho)
      else             !adaptation for mixture
        call CRITP (x,tc,pc,Dc,ierr,herr)
        if (ierr.lt.0) ierr=0
        call DPDD (t,rho,x,dpdrho)
      endif
c     write (*,*) ' TCXM1C--t,dpdrho: ',t,dpdrho
c     function chi (Eq 40 in Vesovic) evaluated at t,rho and tref,rho
c     Vesovic introduces a t/tc term which is absent in other papers
c
c     chi=pc/(Dc*Dc*tc)*rho*t/dpdrho               !Vesovic form
      chi=pc/(Dc*Dc)*rho/dpdrho
      if(icomp.ne.0)then
        call DPDDK (icomp,treff,rho,dpdrho)
      else
        call DPDD (treff,rho,x,dpdrho)
      endif
c     chiref=pc/(Dc*Dc*tc)*rho*tref/dpdrho*tref/t  !Vesovic form
      chiref=pc/(Dc*Dc)*rho/dpdrho*treff/t
      delchi=chi-chiref
c
      if (delchi.le.0.0d0) then
c       delchi can go negative far from critical
c       write (*,*) ' TCX3CR--chi < chiref:  ',chi,chiref
        TCXM1C=0.0d0
        RETURN
      end if
c     function xi (Eq 46)
c     Olchowy, Vesovic put gam0 inside exponent, Krauss (R134a) puts this
c     term outside, but this yields incorrect values
      xi=xi0*(delchi/gam0)**(gnu/gamma)            !Vesovic form
c     xi=xi0/gam0*delchi**(gnu/gamma)              !Krauss' form
c     write (*,1150) chi,chiref,xi
c1150 format (1x,' TCXM1C--chi,chiref,xi:  ',3e14.6)
c     functions omega and omega_zero (Eqs 59 & 60)
c     write (*,1154) icomp,t,rho
c1154 format (1x,' TCXM1C--call CVCPK for icomp,t,rho =  ',i2,2e14.6)
      if(icomp.ne.0)then
        call CVCPK (icomp,t,rho,cv,cp)
      else
        call CVCP (t,rho,x,cv,cp)
      endif
c     write (*,1156) cv,cp
c1156 format (1x,' TCXM1C--cv,cp returned from CVCPK =  ',2e14.6)
      piinv=1.0d0/3.141592654d0
c     write (*,1160) cv,cp,qd,xi
c1160 format (1x,' TCXM1C--cv,cp,qd,xi:  ',4e14.6)
      xomg=2.0d0*piinv*((cp-cv)/cp*ATAN(qd*xi)+cv/cp*qd*xi)
      xomg0=2.0d0*piinv*(1.0d0-EXP(-1.0d0/(1.0d0/(qd*xi)
     &     +((qd*xi*Dc/rho)**2)/3.0d0)))
c
      eta=etacal    !for tk6 and general coef. model
c     eta is passed in through common block critenh
C     it is computed in trns_ecs.for using ECS
      if(icomp.ne.0)then
       if (heta(icomp).ne.'ECS') then
c       use recommended pure fluid correlation instead of ecs
        call ETAK (icomp,t,rho,eta,ierr,herr) !for tk3 or other models
       endif
      endif
c
c     write (*,1162) xomg,xomg0,eta
c1162 format (1x,' TCXM1C--omega,omega_0,eta:  ',3e14.6)
      boltz=Rgas/6.0221367d23       !Boltzman's const
c     factor of 1d9 in next equation to convert from mol/L --> mol/m**3
c     and from micro-Pa-s to Pa-s
      TCXM1C=0.d0
      if (eta.gt.1.d-16) TCXM1C=rho*1.0d9*cp*R0*boltz*t*piinv
     &                         /(6.0d0*eta*xi)*(xomg-xomg0)
c
c     write (*,*) ' TCXM1C--TCXM1C: ',TCXM1C
c
      RETURN
      end                                               !function TCXM1C
c
c
c        1         2         3         4         5         6         7
c23456789012345678901234567890123456789012345678901234567890123456789012
c
c ======================================================================
c                                                    end file trns_TCX.f
c ======================================================================
c  begin file trns_VIS.f
c
c  This file contains the core routines for viscosity
c
c  contained here are:
c     subroutine SETVS0 (nread,icomp,hcasno,ierr,herr)
c     function ETA0HC (icomp,t,rho,ierr,herr)
c     subroutine SETVS1 (nread,icomp,hcasno,ierr,herr)
c     function ETA1DG (icomp,t)
c     function ETA1B2 (icomp,t)
c     function ETA1RS (icomp,t,rho)
c     subroutine SETVS2 (nread,icomp,hcasno,ierr,herr)
c     function ETA2DG (icomp,t)
c     function ETA2RS (icomp,t,rho)
c     subroutine SETVS3 (nread,icomp,hcasno,ierr,herr)
c     function ETA3DG (icomp,t)
c     function ETA3RS (icomp,t,rho)
c     subroutine SETVS4 (nread,icomp,hcasno,ierr,herr)
c     function ETA4DG (icomp,t)
c     function ETA4RS (icomp,t,rho)
c     subroutine SETVS5 (nread,icomp,hcasno,ierr,herr)
c     function ETA5RS (icomp,t,rho)
c     subroutine SETVS6 (nread,icomp,hcasno,ierr,herr)
c     function ETAH2 (icomp,t,d)
c     function ETAH2mct (icomp,t,d)
c     function DELV (icomp,D1,T1,D2,T2)
c     function EXVDIL (DD,T)
c     function DILV (icomp,T)
c     function EXCESV (icomp,DD,T)
c     function ETAHE (icomp,t,rho)
c     function ETAETY (icomp,t,rho)
c     function ETANEO (icomp,t,rho)
c     function ETAR23 (icomp,t,rho)
c     function ETAH2O (icomp,t,rho)
c     function XI_FUN (t,rho,icomp)
c     function ETA_C2 (xi)
c     function ETAMEO (icomp,t,rho)
c     function ETASF6 (icomp,t,rho)
c     function ETAD2 (icomp,t,d)
c
c =====================================================================
c =====================================================================
c
      subroutine SETVS0 (nread,icomp,hcasno,ierr,herr)
c
c  initialize pure fluid viscosity model #0; the model
c  which points to all the hardcoded equations.
c
c  inputs:
c    nread--file to read data from
c           >0 read from logical unit nread (file should have already
c              been opened and pointer set by subroutine SETUP)
c    icomp--component number in mixture (0..nc)
c           1 for pure fluid; 0 for ECS reference fluid
c   hcasno--CAS number of component icomp (not req'd if reading from file)
c
c  outputs:
c     ierr--error flag:  0 = successful
c     herr--error string (character*255 variable if ierr<>0)
c
c  written by E.W. Lemmon, NIST Phys & Chem Properties Div, Boulder, CO
c  02-29-00 EWL, original version
c  09-00-00 EWL, change hmdci to hmdeta and hmdtcx to avoid overlapping tcx.
c  11-20-07 MLH, removed unused commons and declarations
c  01-04-08 MLH, added additional slots to WNTETA
c
      include 'commons.for'
      include 'comtrn.for'
      character*12 hcasno
      character*255 herr
c
c  read data from file (should have been opened by SETUP)
c     write (*,*) ' SETVS0--read component',icomp,' from unit',nread
      write (herr,'(a12)') hcasno  !Use hcasno to avoid warning message
      read (nread,*) tmeta(icomp)              !lower temperature limit
      read (nread,*) txeta(icomp)              !upper temperature limit
      read (nread,*) pxeta(icomp)              !upper pressure limit
      read (nread,*) Dxeta(icomp)              !upper density limit
c
c  read in pointer to the hardcoded model
      read (nread,2003) hetahc(icomp)
c     write (*,*) ' SETVS0--will use model ',hetahc(icomp)
      read (nread,*) ndgeta(icomp),nB2eta(icomp),ndel0(icomp),
     &               npoly(icomp),nnumeta(icomp),ndeneta(icomp),
     &               nexpn(icomp),nexpd(icomp)
c     write (*,*) ' SETVS0--about to read ',ndgeta(icomp),' dilute terms'
      jterm=0                                 !term counter
      if (ndgeta(icomp).ge.1) then
        read (nread,2003) hmdeta(icomp)       !pointer to omega model
        read (nread,*) sigmav(icomp)           !L-J sigma
        read (nread,*) epskv(icomp)            !L-J epsilon/kappa
        read (nread,*) trddge(icomp),etadge(icomp)  !reducing par
        do j=1,ndgeta(icomp)                 !read dilute-gas terms
          jterm=jterm+1
          read (nread,*) ceta(icomp,jterm,1),ceta(icomp,jterm,2)
        enddo
      end if
      nrsum=nB2eta(icomp)+ndel0(icomp)+npoly(icomp)+nnumeta(icomp)+
     &      ndeneta(icomp)+nexpn(icomp)+nexpd(icomp)
      if (nrsum.ge.1) then
c  read in reducing parameters
        read (nread,*) tredeta(icomp),Dredeta(icomp),etared(icomp)
        do j=1,nrsum
          jterm=jterm+1
          read (nread,*) (ceta(icomp,jterm,k),k=1,4),ieta(icomp,jterm)
        enddo
      end if
c
c  read in pointer to critical enhancement model
      read (nread,2003) hetacr(icomp)
c       write (*,*) ' SETVS1--will use critical model ',hetacr(icomp)
      ierr=0
      herr=' '
c
      RETURN
 2003 format (a3)
      end                                             !subroutine SETVS0
c
c ======================================================================
c
      function ETA0HC (icomp,t,rho,ierr,herr)
c
c  model for the hardcoded viscosity models
c
c  inputs:
c    icomp--component number in mixture (1..nc); 1 for pure fluid
c        t--temperature [K]
c        d--molar density [mol/L]
c  output (as function value):
c   eta0hc--viscosity [uPa-s]
c
c  written by E.W. Lemmon, NIST Phys & Chem Properties Div, Boulder, CO
c  02-29-00 EWL, original version
c  11-20-07 MLH, initialized herr
c  12-22-09 MLH, added D2, T2, HE3 models
c  04-06-11 MLH, added Altunin SF6 vis model
c  11-16-12 MLH, allow two VS0 models for viscosity
c  02-28-13 MLH, added d2
c
      include 'commons.for'
      include 'comtrn.for'
      character*255 herr
c
      ierr=0
      herr=''
      ETA0HC=0.0d0
      if (hetahc(icomp).eq.'ETY') THEN
        ETA0HC=ETAETY(icomp,t,rho)
      elseif (hetahc(icomp).eq.'NEO') THEN
        ETA0HC=ETANEO(icomp,t,rho)
      elseif (hetahc(icomp).eq.'R23') THEN
        ETA0HC=ETAR23(icomp,t,rho)
      elseif (hetahc(icomp).eq.'H2O') THEN
        ETA0HC=ETAH2O(icomp,t,rho)
      elseif (hetahc(icomp).eq.'HE') THEN
        ETA0HC=ETAHE(icomp,t,rho)
      elseif (hetahc(icomp).eq.'H2') THEN
        ETA0HC=ETAH2mct(icomp,t,rho)  ! old Mccarty model
      ELSEIF (hetahc(icomp).eq.'H2A') THEN
        ETA0HC=ETAH2(icomp,t,rho)     ! alternate h2 model of Muzny
      elseif (hetahc(icomp).eq.'D2') THEN
        ETA0HC=ETAD2(icomp,t,rho)     ! scaled h2 model of Muzny for D2
      elseif (hetahc(icomp).eq.'T2') THEN   !scale to h2 with theoretical limit for gas
        ETA0HC=ETAH2(icomp,t,rho)*SQRT(3.0d0)
      elseif (hetahc(icomp).eq.'HE3') THEN   !scale to he4 with theoretical limit for gas
        ETA0HC=ETAHE(icomp,t,rho)*SQRT(3.0d0/4.0d0)
      elseif (hetahc(icomp).eq.'MEO') THEN
        ETA0HC=ETAMEO(icomp,t,rho)
      elseif (hetahc(icomp).eq.'SF6') THEN
        ETA0HC=ETASF6(icomp,t,rho)
      else
        ierr=49
        herr='[ETA0HC error 49] unknown viscosity model specified'
     &        //hnull
        call ERRMSG (ierr,herr)
      endif
      RETURN
      end                                               !function ETA0HC
c
c ======================================================================
c
      subroutine SETVS1 (nread,icomp,hcasno,ierr,herr)
c
c  initialize pure fluid viscosity model #1; this, the "composite model,"
c  is written in a general form with terms designed to include several
c  recent correlations including those of Fenghour (1995) for ammonia,
c  Krauss (1996) for R152a, and Laesecke (1997) for R134a.
c
c  inputs:
c    nread--file to read data from
c           <= 0 get data from block data
c           >0 read from logical unit nread (file should have already
c              been opened and pointer set by subroutine SETUP)
c    icomp--component number in mixture (0..nc)
c           1 for pure fluid; 0 for ECS reference fluid
c   hcasno--CAS number of component icomp (not req'd if reading from file)
c
c  outputs:
c     ierr--error flag:  0 = successful
c                      101 = error--block data option not implemented
c     herr--error string (character*255 variable if ierr<>0)
c     other quantities returned via arrays in commons
c
c  written by M. McLinden, NIST Phys & Chem Properties Div, Boulder, CO
c  01-16-97  MM, original version
c  02-26-97  MM, read pointer for critical enhancement model (future use)
c  08-19-97  MM, change error number for nread<=0; input hcasno is not array
c  09-27-01 MLH, add Laesecke's alternative formulation for del10 term (use neg# terms to flag it)
c  11-20-07 MLH, removed unused commons and declarations, add abs(ndel0)
c  01-04-08 MLH, added additional slots to WNTETA
c
      include 'commons.for'
      include 'comtrn.for'
      character*12 hcasno
      character*255 herr
c
      if (nread.le.0) then
c  get coefficients from block data--this option not implemented,
c  place holder to maintain parallel structure with EOS setup routines
        ierr=101
        write (herr,1101) nread,hcasno,hnull
        call ERRMSG (ierr,herr)
 1101   format ('[SETVS1 error 101] illegal file specified; nread = ',
     &          i4,'; CAS no. = ',a12,a1)
      else
c  read data from file (should have been opened by SETUP)
c       write (*,*) ' SETVS1--read component',icomp,' from unit',nread
        read (nread,*) tmeta(icomp)              !lower temperature limit
        read (nread,*) txeta(icomp)              !upper temperature limit
        read (nread,*) pxeta(icomp)              !upper pressure limit
        read (nread,*) Dxeta(icomp)              !upper density limit
        jterm=0                                 !term counter
        ndg2(icomp)=0                           !numerator multiplicative terms
        ndg3(icomp)=0                           !denominator multiplicative terms
        ndg4(icomp)=0
        ndg5(icomp)=0
        ndg6(icomp)=0
        read (nread,*) ndgeta(icomp)               !# dilute-gas terms
c       write (*,*) ' SETVS1--about to read ',ndgeta(icomp),' dilute terms'
        if (ndgeta(icomp).ge.1) then
          read (nread,2003) hmdeta(icomp)       !pointer to omega model
          read (nread,*) sigmav(icomp)           !L-J sigma
          read (nread,*) epskv(icomp)            !L-J epsilon/kappa
          read (nread,*) trddge(icomp),etadge(icomp)  !reducing par
          do j=1,ndgeta(icomp)                 !read dilute-gas terms
            jterm=jterm+1
            read (nread,*) ceta(icomp,jterm,1),ceta(icomp,jterm,2)
          enddo
        end if
        read (nread,*) nB2eta(icomp)               !# visc virial terms
c       write (*,*) ' SETVS1--about to read ',nB2eta(icomp),' virial terms'
        if (nB2eta(icomp).ge.1) then
          read (nread,*) tredB2(icomp),etarB2(icomp)  !reducing par
          do j=1,nB2eta(icomp)        !read viscosity virial terms
            jterm=jterm+1
            read (nread,*) ceta(icomp,jterm,1),ceta(icomp,jterm,2)
          enddo
        end if
c
c  read the number of terms of the various parts of the residual model
c  these are in the order:
c    close-packed density function;
c    simple polynomials in T, rho, rho_0, exp(rho/rhoc);
c    numerator of rational polynomial; denominator of rational polynomial;
c    numerator of exponential term; denominator of exponential term;
c  the coefficients themselves are given in the order:
c    constant multiplier; temperature exponent (all terms);
c    density exponent; close-packed density exponent (all except del0 terms)
c    power of density inside exponential (0 indicates no exponential)
c
        read (nread,*) ndel0(icomp),npoly(icomp),nnumeta(icomp),
     &                 ndeneta(icomp)
     &                ,nexpn(icomp),nexpd(icomp)
        nrsum=ABS(ndel0(icomp))+npoly(icomp)+nnumeta(icomp)
     &       +ndeneta(icomp)
     &       +nexpn(icomp)+nexpd(icomp)
c       write (*,*) ' SETVS1--about to read ',nrsum,' residual terms'
        if (nrsum.ge.1) then
c  read in reducing parameters
          read (nread,*) tredeta(icomp),Dredeta(icomp),etared(icomp)
          if (ndel0(icomp).ge.1) then
            do j=1,ndel0(icomp)     !close-packed density term
              jterm=jterm+1
              read (nread,*) ceta(icomp,jterm,1),ceta(icomp,jterm,2)
            enddo
          elseif(ndel0(icomp).lt.0) then
c  close-packed density term; alternative form
            do j=1,ABS(ndel0(icomp))
              jterm=jterm+1
              read (nread,*) ceta(icomp,jterm,1),ceta(icomp,jterm,2)
            enddo
          end if
c
          if (npoly(icomp).ge.1) then
            do j=1,npoly(icomp)     !simple polynomial terms
              jterm=jterm+1
              read(nread,*)(ceta(icomp,jterm,k),k=1,4),ieta(icomp,jterm)
            enddo
          end if
          if (nnumeta(icomp).ge.1) then
            do j=1,nnumeta(icomp)      !numerator of rational polynomial
              jterm=jterm+1
              read(nread,*)(ceta(icomp,jterm,k),k=1,4),ieta(icomp,jterm)
            enddo
          end if
          if (ndeneta(icomp).ge.1) then
            do j=1,ndeneta(icomp)      !denominator of rational poly
              jterm=jterm+1
              read(nread,*)(ceta(icomp,jterm,k),k=1,4),ieta(icomp,jterm)
            enddo
          end if
          if (nexpn(icomp).ge.1) then
            do j=1,nexpn(icomp)     !numerator of exponential term
              jterm=jterm+1
              read(nread,*)(ceta(icomp,jterm,k),k=1,3),ieta(icomp,jterm)
            enddo
          end if
          if (nexpd(icomp).ge.1) then
            do j=1,nexpd(icomp)     !denominator of exponential term
              jterm=jterm+1
              read(nread,*)(ceta(icomp,jterm,k),k=1,3),ieta(icomp,jterm)
            enddo
          end if
        end if
c
c  read in pointer to critical enhancement model
        read (nread,2003) hetacr(icomp)
c       write (*,*) ' SETVS1--will use critical model ',hetacr(icomp)
        ierr=0
        herr=' '
      end if
c
      RETURN
 2003 format (a3)
      end                                             !subroutine SETVS1
c
c ======================================================================
c
      function ETA1DG (icomp,t)
c
c  dilute-gas contribution to the viscosity by the composite model (VS1)
c  and also the friction theory model (VS4)
c
c  inputs:
c    icomp--component number in mixture (1..nc); 1 for pure fluid
c        t--temperature [K]
c  output (as function value):
c   eta1dg--the dilute-gas part of the viscosity [uPa-s]
c
c  written by M. McLinden, NIST Phys & Chem Properties Div, Boulder, CO
c  01-17-97  MM, original version
c  03-28-97  MM, move calc of tau inside "if" (divide by zero if ndgeta(i)=0)
c  12-01-98 EWL, add Reos and triple point pressure and density to /CCON/
c   1-20-00 EWL, add check for absurd t, coming from the ECS model
c  11-20-07 MLH, removed unused commons and declarations
c  01-04-08 MLH, added additional slots to WNTETA
c
      include 'commons.for'
      include 'comtrn.for'
c
      i=icomp
      nterm=0                                    !term counter
      eta1dg=0.0d0
c
c  sum the dilute-gas terms
      eta1dg=0.0d0
      if (ndgeta(i).ge.1 .and. t.lt.1.d8) then
        tau=t/trddge(i)
c  first term is always the Chapman-Enskog term
        eta1dg=ceta(i,1,1)*SQRT(tau)/(sigmav(i)**2
     &        *OMEGA(i,t,epskv(i),hmdeta(i)))
        if (ndgeta(i).ge.2) then
c  possibility for additional, empirical terms
          do j=nterm+1,nterm+ndgeta(i)
            eta1dg=eta1dg+ceta(i,j,1)*tau**ceta(i,j,2)
          enddo
        end if
      end if
c
c  multiply by reducing parameter for viscosity (to convert units, etc.)
      eta1dg=eta1dg*etadge(i)
c      write (*,*) ' ETA1DG--d.g. visc:   ',eta1dg
      RETURN
      end                                               !function ETA1DG
c
c ======================================================================
c
      function ETA1B2 (icomp,t)
c
c  second viscosity "virial coefficient" by the composite model (VS1)
c  This model implements the initial-density dependence of the
c  Rainwater-Friend theory.  It returns a viscosity virial coefficient
c  which must be multiplied by the dilute-gas viscosity and the density
c  to yield the initial-density dependence of viscosity.
c
c  inputs:
c    icomp--component number in mixture (1..nc); 1 for pure fluid
c        t--temperature [K]
c  output (as function value):
c   eta1B2--the second viscosity virial coefficient [L/(mol-uPa-s)]
c
c  written by M. McLinden, NIST Phys & Chem Properties Div, Boulder, CO
c  01-17-97  MM, original version
c  03-28-97  MM, move calc of tau inside "if" (divide by zero if nB2eta(i)=0)
c  12-01-98 EWL, add Reos and triple point pressure and density to /CCON/
c  11-20-07 MLH, removed unused commons and declarations
c  01-30-08 MLH, added additional slots to WNTETA and modify term counter
c
      include 'commons.for'
      include 'comtrn.for'
c
c     write (*,*) ' ETA1B2--tred,etared:  ',tredB2(icomp),etarB2(icomp)
      i=icomp
      nterm=ndgeta(i)+ndg2(i)+ndg3(i)           !term counter

c
c  sum the terms comprising the viscosity virial
      eta1B2=0.0d0
      if (nB2eta(i).ge.1) then
        tau=t/tredB2(i)
        do j=nterm+1,nterm+nB2eta(i)
          eta1B2=eta1B2+ceta(i,j,1)*tau**ceta(i,j,2)
c       write (*,*) ' ETA1B2--j,c1,ti:  ',j,ceta(i,j,1),ceta(i,j,2)
        enddo
c  multiply by reducing parameter (to convert units, etc.)
        eta1B2=eta1B2*etarB2(i)
      end if
c     write (*,*) ' ETA1B2--etaB2:  ',eta1B2
c
      RETURN
      end                                               !function ETA1B2
c
c ======================================================================
c
      function ETA1RS (icomp,t,rho)
c
c  residual contribution to the viscosity by the composite model (VS1)
c
c  inputs:
c    icomp--component number in mixture (1..nc); 1 for pure fluid
c        t--temperature [K]
c      rho--molar density [mol/L]
c  output (as function value):
c   eta1rs--the background part of the viscosity [uPa-s]
c
c  written by M. McLinden, NIST Phys & Chem Properties Div, Boulder, CO
c  01-16-97  MM, original version
c  12-01-98 EWL, add Reos and triple point pressure and density to /CCON/
c   2-16-99 EWL, return if rho=0
c  09-27-01 MLH, allow Laesecke's alternative formulation for del0 term
c  11-20-07 MLH, remove unused commons and declarations, add abs(ndel0)
c  01-04-08 MLH, added additional slots to WNTETA
c
      include 'commons.for'
      include 'comtrn.for'
c
      i=icomp
      eta1rs=0.0d0
      if (rho.lt.1.0d-10) RETURN
c
      nsum=ABS(ndel0(i))+npoly(i)+nnumeta(i)+ndeneta(i)+nexpn(i)
     &    +nexpd(i)
      expdel=1.0d0    !initialize only
      tau=1.0d0
      del=1.0d0
      if (nsum.ge.1) then
c  compute tau,del only if terms present (otherwise reducing par not read in)
        tau=t/tredeta(i)
        del=rho/Dredeta(i)
c  define the density to be used in exponential multipliers
c  if the reducing density is 1.0, must divide by the critical density
        if (abs(Dredeta(i)-1.0d0).lt.0.001d0) then
          expdel=rho/Dcrit(i)
        else
          expdel=del
        end if
      end if
c
c  compute the various parts of the residual model
c  these are taken in the order:
c    close-packed density function;
c    simple polynomials in T, rho, rho_0, exp(rho/rhoc);
c    numerator of rational polynomial; denominator of rational polynomial;
c    numerator of exponential term; denominator of exponential term;
c  the coefficients themselves are given in the order:
c    constant multiplier; temperature exponent (all terms);
c    density exponent; close-packed density exponent (all except del0 terms)
c    power of density inside exponential (0 indicates no exponential)
c
      nterm=ndgeta(i)+nB2eta(i)                        !term counter
c  compute the close-packed density at given temperature, if applicable
      if (ndel0(i).ge.1) then
        del0=0.0d0
        do j=nterm+1,nterm+ndel0(i)
          del0=del0+ceta(i,j,1)*tau**ceta(i,j,2)
c       write (*,*) ' ETA1RS--j,close-packed term:  ',j,ceta(i,j,1)
        enddo
        nterm=nterm+ndel0(i)
      elseif (ndel0(i).lt.0) then   !alternative formulation for del10
        del0=1.0d0
        do j=nterm+2,nterm+ABS(ndel0(i))
          del0=del0+ceta(i,j,1)*tau**ceta(i,j,2)
        enddo
        del0=ceta(i,nterm+1,1)/del0
        nterm=nterm+ABS(ndel0(i))
      else
        del0=1.0d0
      end if
c     write (*,*) ' ETA1RS--icomp, # del0, del0:    ',i,ndel0(i),del0
c
c  sum the simple polynomial terms
      eta1rs=0.0d0
      if (npoly(i).ge.1) then
        do j=nterm+1,nterm+npoly(i)
          visci=ceta(i,j,1)*tau**ceta(i,j,2)*del**ceta(i,j,3)
     &         *del0**ceta(i,j,4)
          if (ieta(i,j).ge.1) then
            visci=visci*exp(-expdel**ieta(i,j))
          end if
          eta1rs=eta1rs+visci
c       write (*,1220) j,ceta(i,j,1),eta1rs
c1220   format (1x,' ETA1RS--j,polynomial coeff,sum:',i3,2e14.6)
        enddo
c       write (*,*) ' ETA1RS--j,polynomial sum:      ',j,eta1rs
        nterm=nterm+npoly(i)
      end if
c
c  calculate the numerator of the rational polynomial
      if (nnumeta(i).ge.1) then
        xnum=0.0d0
        do j=nterm+1,nterm+nnumeta(i)
          xnum=xnum+ceta(i,j,1)*tau**ceta(i,j,2)*del**ceta(i,j,3)
     &        *del0**ceta(i,j,4)
          if (ieta(i,j).ge.1) then
            xnum=xnum*exp(-expdel**ieta(i,j))
          end if
        enddo
c       write (*,*) ' ETA1RS--numerator term:       ',xnum
        nterm=nterm+nnumeta(i)
      else
        xnum=1.0d0
      end if
c
c  calculate the denominator of the rational polynomial
      if (ndeneta(i).ge.1) then
        xden=0.0d0
        do j=nterm+1,nterm+ndeneta(i)
          xden=xden+ceta(i,j,1)*tau**ceta(i,j,2)*del**ceta(i,j,3)
     &        *del0**ceta(i,j,4)
          if (ieta(i,j).ge.1) then
            xden=xden*exp(-expdel**ieta(i,j))
          end if
        enddo
        nterm=nterm+ndeneta(i)
c       write (*,*) ' ETA1RS--denominator term:     ',xden
      else
        xden=1.0d0
      end if
c
c  combine the two parts of the rational polynomial, if applicable
      if (nnumeta(i).ge.1 .or. ndeneta(i).ge.1) then
c       write (*,*) ' ETA1RS--num,denom:  ',xnum,xden
        eta1rs=eta1rs+xnum/xden
      end if
c
c  calculate the numerator of the exponential term
      if (nexpn(i).ge.1) then
        xnum=0.0d0
        do j=nterm+1,nterm+nexpn(i)
          xnum=xnum+ceta(i,j,1)*tau**ceta(i,j,2)*del**ceta(i,j,3)
     &        *del0**ceta(i,j,4)
        enddo
        nterm=nterm+nexpn(i)
      else
        xnum=1.0d0
      end if
c
c  calculate the denominator of the exponential term
      if (nexpd(i).ge.1) then
        xden=0.0d0
        do j=nterm+1,nterm+nexpd(i)
          xden=xden+ceta(i,j,1)*tau**ceta(i,j,2)*del**ceta(i,j,3)
     &        *del0**ceta(i,j,4)
        enddo
        nterm=nterm+nexpd(i)
      else
        xden=1.0d0
      end if
c
c  combine the two parts of the exponential term, if applicable
      if (nexpn(i).ge.1 .or. nexpd(i).ge.1) then
        eta1rs=eta1rs+EXP(xnum/xden)
      end if
c
c  multiply by reducing parameter for viscosity (to convert units, etc.)
      eta1rs=eta1rs*etared(i)
c
      RETURN
      end                                               !function ETA1RS
c
c ======================================================================
c
      subroutine SETVS2 (nread,icomp,hcasno,ierr,herr)
c
c  initialize pure fluid viscosity model #2; the hydrocarbon model of:
c  Younglove, B.A. and Ely, J.F. (1987). Thermophysical properties of
c  fluids. II. Methane, ethane, propane, isobutane and normal butane.
c  J. Phys. Chem. Ref. Data  16: 577-798.
c
c  inputs:
c    nread--file to read data from
c           <= 0 get data from block data
c           >0 read from logical unit nread (file should have already
c              been opened and pointer set by subroutine SETUP)
c    icomp--component number in mixture (0..nc)
c           1 for pure fluid; 0 for ECS reference fluid
c   hcasno--CAS number of component icomp (not req'd if reading from file)
c
c  outputs:
c     ierr--error flag:  0 = successful
c                      101 = error--block data option not implemented
c     herr--error string (character*255 variable if ierr<>0)
c     other quantities returned via arrays in commons
c
c  written by M. McLinden, NIST Phys & Chem Properties Div, Boulder, CO
c  02-21-97  MM, original version
c  02-26-97  MM, set pointer to critical enhancement to 'NUL' (not used)
c  08-19-97  MM, change error number for nread<=0; input hcasno is not array
c  07-01-98 EWL, read ceta(icomp,1,2) and ceta(icomp,e1,1) if version>6.01
c  12-01-98 EWL, add Reos and triple point pressure and density to /CCON/
c  11-20-07 MLH, removed unused commons and declarations
c
      include 'commons.for'
      include 'comtrn.for'
      character*12 hcasno
      character*255 herr
c
      if (nread.le.0) then
c  get coefficients from block data--this option not implemented,
c  place holder to maintain parallel structure with EOS setup routines
        ierr=101
        write (herr,1101) nread,hcasno,hnull
        call ERRMSG (ierr,herr)
 1101   format ('[SETVS2 error 101] illegal file specified; nread = ',
     &          i4,'; CAS no. = ',a12,a1)
      else
c  read data from file (should have been opened by SETUP)
c       write (*,*) ' SETVS2--read component',icomp,' from unit',nread
        read (nread,*) tmeta(icomp)              !lower temperature limit
        read (nread,*) txeta(icomp)              !upper temperature limit
        read (nread,*) pxeta(icomp)              !upper pressure limit
        read (nread,*) Dxeta(icomp)              !upper density limit
        read (nread,2003) hmdeta(icomp)         !pointer to omega model
 2003   format (a3)
        read (nread,*) sigmav(icomp)             !L-J sigma
        read (nread,*) epskv(icomp)              !L-J epsilon/kappa
        read (nread,*) ceta(icomp,1,1)          !Chapman-Enskog term
        ceta(icomp,1,2)=0.50d0                  !Chapman-Enskog exponent
        if (verfl(icomp).ge.6.099d0) read (nread,*) ceta(icomp,1,2)
        do j=2,12                  !read residual viscosity terms
          read (nread,*) ceta(icomp,j,1)
        enddo
        ceta(icomp,13,1)=Dcrit(icomp)
        if (verfl(icomp).ge.6.099d0) read (nread,*) ceta(icomp,13,1)
        hetacr(icomp)='NUL'       !no critical enhancement in this model
        ierr=0
        herr=' '
      end if
c
      RETURN
      end                                             !subroutine SETVS2
c
c ======================================================================
c
      function ETA2DG (icomp,t)
c
c  dilute-gas contribution to the viscosity by the hydrocarbon model of:
c  Younglove, B.A. and Ely, J.F. (1987). Thermophysical properties of
c  fluids. II. Methane, ethane, propane, isobutane and normal butane.
c  J. Phys. Chem. Ref. Data  16: 577-798.
c
c  inputs:
c    icomp--component number in mixture (1..nc); 1 for pure fluid
c        t--temperature [K]
c  output (as function value):
c   eta2dg--the dilute-gas part of the viscosity [uPa-s]
c
c  written by M. McLinden, NIST Phys & Chem Properties Div, Boulder, CO
c  02-21-97  MM, original version
c  07-01-98 EWL, replace SQRT(tau) with tau**ceta(i,1,2)
c  12-01-98 EWL, add Reos and triple point pressure and density to /CCON/
c  11-20-07 MLH, removed unused commons and declarations
c
      include 'commons.for'
      include 'comtrn.for'
c
      i=icomp
      tau=t
c  in this case, the dilute gas is simply the Chapman-Enskog term
      eta2dg=ceta(i,1,1)*tau**ceta(i,1,2)/
     &       (sigmav(i)**2*OMEGA(i,t,epskv(i),hmdeta(i)))
c     write (*,*) ' ETA2DG--dilute-gas viscosity:  ',eta2dg
c
      RETURN
      end                                               !function ETA2DG
c
c ======================================================================
c
      function ETA2RS (icomp,t,rho)
c
c  residual contribution to the viscosity by the hydrocarbon model of:
c  Younglove, B.A. and Ely, J.F. (1987). Thermophysical properties of
c  fluids. II. Methane, ethane, propane, isobutane and normal butane.
c  J. Phys. Chem. Ref. Data  16: 577-798.
c
c  Although this correlation has a separate initial density term, it is
c  not of the form required by ETAK1; thus the initial density term is
c  combined with the residual term.
c
c  inputs:
c    icomp--component number in mixture (1..nc); 1 for pure fluid
c        t--temperature [K]
c      rho--molar density [mol/L]
c  output (as function value):
c   eta2rs--the background part of the viscosity [uPa-s]
c
c  written by M. McLinden, NIST Phys & Chem Properties Div, Boulder, CO
c  02-21-97  MM, original version
c  07-01-98 EWL, replace rhoc with ceta(icomp,13,1)
c  12-01-98 EWL, add Reos and triple point pressure and density to /CCON/
c  11-20-07 MLH, removed unused commons and declarations
c
      include 'commons.for'
      include 'comtrn.for'
c
c  initial density term for viscosity
      eta1=rho*(ceta(icomp,2,1)+ceta(icomp,3,1)
     &    *(ceta(icomp,4,1)-LOG(t/ceta(icomp,5,1)))**2)           !Eq 21
c  now compute the residual viscosity (viscosity minus the dilute gas
c  and initial density terms)
      G=ceta(icomp,6,1)+ceta(icomp,7,1)/t                         !Eq 23
      H=SQRT(rho)*(rho-ceta(icomp,13,1))/ceta(icomp,13,1)         !Eq 25
      F=G+(ceta(icomp,8,1)+ceta(icomp,9,1)*t**(-1.5d0))*rho**0.1d0+
     &  (ceta(icomp,10,1)+ceta(icomp,11,1)/t+ceta(icomp,12,1)/(t*t))*H
      eta2=EXP(F)-EXP(G)                                          !Eq 22
      ETA2RS=eta1+eta2
c     write (*,*) ' ETA2RS--residual viscosity:    ',eta2rs
c
      RETURN
      end                                               !function ETA2RS
c
c ======================================================================
c
      subroutine SETVS3 (nread,icomp,hcasno,ierr,herr)
c
c  initialize pure fluid viscosity model #3, minim subroutine SETTC1
c
c  inputs:
c    nread--file to read data from
c           <= 0 get data from block data
c           >0 read from logical unit nread (file should have already
c              been opened and pointer set by subroutine SETUP)
c    icomp--component number in mixture (0..nc)
c           1 for pure fluid; 0 for ECS reference fluid
c   hcasno--CAS number of component icomp (not req'd if reading from file)
c
c  outputs:
c     ierr--error flag:  0 = successful
c                       49 = error--model not implemented
c                      101 = error--block data option not implemented
c     herr--error string (character*255 variable if ierr<>0)
c     other quantities returned via arrays in commons
c
c  written by E.W. Lemmon, NIST Phys & Chem Properties Div, Boulder, CO
c  02-16-99 EWL, mimic routines from SETTC1
c  11-20-07 MLH, removed unused commons and declarations
c
      include 'commons.for'
      include 'comtrn.for'
      character*12 hcasno
      character*255 herr
c
c  note: this model has no critical enhancement term
c
      if (nread.le.0) then
c  get coefficients from block data--this option not implemented,
c  place holder to maintain parallel structure with EOS setup routines
        ierr=101
        write (herr,1101) nread,hcasno,hnull
        call ERRMSG (ierr,herr)
 1101   format ('[SETVS3 error 101] illegal file specified; nread = ',
     &          i4,'; CAS no. = ',a12,a1)
      else
c  read data from file (should have been opened by SETUP)
c       write (*,*) ' SETVS3--read component',icomp,' from unit',nread
        read (nread,*) tmeta(icomp)              !lower temperature limit
        read (nread,*) txeta(icomp)              !upper temperature limit
        read (nread,*) pxeta(icomp)              !upper pressure limit
        read (nread,*) Dxeta(icomp)              !upper density limit
        jterm=0                                 !term counter
c  read the number of terms in the numerator and denominator of the
c  dilute-gas function
        read (nread,*) ndgnm3(icomp),ndgdn3(icomp)
c       write (*,*) ' SETVS3--about to read ',ndgnm3(icomp),' +',
c    &              ndgdn3(icomp),' dilute terms'
        if (ndgnm3(icomp).ge.1) then
          read (nread,*) trddg3(icomp),etadg3(icomp)  !reducing par
          do j=1,ndgnm3(icomp)  !read dilute-gas terms (numerator)
            jterm=jterm+1
            read (nread,*) ceta(icomp,jterm,1),ceta(icomp,jterm,2)
          enddo
        end if
        if (ndgdn3(icomp).ge.1) then
          do j=1,ndgdn3(icomp)  !read dilute-gas terms (denominator)
            jterm=jterm+1
            read (nread,*) ceta(icomp,jterm,1),ceta(icomp,jterm,2)
          enddo
        end if
c
c  read the number of terms in the numerator and denominator of the
c  background model; the coefficients themselves are given in the order:
c    constant multiplier; temperature exponent; density exponent; spare
c
        read (nread,*) nbknm3(icomp),nbkdn3(icomp)
        nbksum=nbknm3(icomp)+nbkdn3(icomp)
c       write (*,*) ' SETVS3--about to read ',nbknm3(icomp),' +',
c    &              nbkdn3(icomp),' background terms'
        if (nbksum.ge.1) then
c  read in reducing parameters
          read (nread,*) trdbk3(icomp),Drdbk3(icomp),etabk3(icomp)
          if (nbknm3(icomp).ge.1) then
            do j=1,nbknm3(icomp)    !numerator of rational polynomial
              jterm=jterm+1
              read (nread,*) (ceta(icomp,jterm,k),k=1,4)
            enddo
          end if
          if (nbkdn3(icomp).ge.1) then
            do j=1,nbkdn3(icomp)    !denominator of rational poly
              jterm=jterm+1
             read (nread,*) (ceta(icomp,jterm,k),k=1,4)
            enddo
          end if
        end if
c
        ierr=0
        herr=' '
      end if
c
      RETURN
      end                                             !subroutine SETVS3
c
c ======================================================================
c
      function ETA3DG (icomp,t)
c
c  dilute-gas contribution to the viscosity by the composite model (VS3)
c
c  inputs:
c    icomp--component number in mixture (1..nc); 1 for pure fluid
c        t--temperature [K]
c  output (as function value):
c   eta3dg--the dilute-gas part of the viscosity [uPa-s]
c
c  written by E.W. Lemmon, NIST Phys & Chem Properties Div, Boulder, CO
c  02-16-99 EWL, mimic routines from TCX1DG
c  11-20-07 MLH, removed unused commons and declarations
c
      include 'commons.for'
      include 'comtrn.for'
c
      i=icomp
      tau=1.0d0
      if ((ndgnm3(i)+ndgdn3(i)).ge.1) then
c  compute tau only if dilute-gas terms exist, otherwise treddg may
c  not be defined
        tau=t/trddg3(i)
c       write (*,*) 'ETA3DG--tred,tau:  ',trddg3(i),tau
      end if
c
      nterm=0                                    !term counter
c  sum the dilute-gas terms, first numerator then denominator
      eta3dg=0.0d0
      if (ndgnm3(i).ge.1) then
        do j=nterm+1,nterm+ndgnm3(i)
          eta3dg=eta3dg+ceta(i,j,1)*tau**ceta(i,j,2)
c         write (*,*) ' ETA3DG--j,eta_dg(j): ',j,eta3dg
        enddo
        nterm=nterm+ndgnm3(i)
      end if
      if (ndgdn3(i).ge.1) then
        denom=0.0d0
        do j=nterm+1,nterm+ndgdn3(i)
c       write (*,*) 'denom coeff:  ',ceta(i,j,1),ceta(i,j,2)
          denom=denom+ceta(i,j,1)*tau**ceta(i,j,2)
        enddo
c       write (*,*) ' ETA3DG--num,denom: ',eta3dg,denom
c  divide numerator by denominator
        eta3dg=eta3dg/denom
      end if
c
c  multiply by reducing parameter (to convert units, etc.)
      eta3dg=eta3dg*etadg3(i)
c
c     write (*,1000) icomp,tau,eta3dg
c1000 format (' ETA3DG--icomp,tau,dilute-gas tc:',i10,d14.6,14x,d14.6)
      RETURN
      end                                               !function ETA3DG
c
c ======================================================================
c
      function ETA3RS (icomp,t,rho)
c
c  background contribution to the viscosity by the composite model (VS3)
c
c  inputs:
c    icomp--component number in mixture (1..nc); 1 for pure fluid
c        t--temperature [K]
c      rho--molar density [mol/L]
c  output (as function value):
c   eta3rs--the background part of the viscosity [uPa-s]
c
c  written by E.W. Lemmon, NIST Phys & Chem Properties Div, Boulder, CO
c  02-16-99 EWL, mimic routines from TCX1BK
c  11-20-07 MLH, removed unused commons and declarations
c
      include 'commons.for'
      include 'comtrn.for'
c
      i=icomp
      tau=1.0d0
      del=1.0d0
      if ((nbknm3(i)+nbkdn3(i)).ge.1) then
c  compute tau only if residual terms exist, otherwise tredbk, Dredbk may
c  not be defined
        tau=t/trdbk3(i)
        del=rho/Drdbk3(i)
      end if
      nterm=ndgnm3(i)+ndgdn3(i)                        !term counter
c     write (*,*) ' ETA3RS--tau,del,coeff_1: ',tau,del,ceta(i,nterm+1,1)
c
c  sum the background terms, first numerator then denominator
      eta3rs=0.0d0
      if (nbknm3(i).ge.1) then
        do j=nterm+1,nterm+nbknm3(i)
          eta3rs=eta3rs+ceta(i,j,1)*tau**ceta(i,j,2)*del**ceta(i,j,3)
        enddo
      end if
      if (nbkdn3(i).ge.1) then
        denom=0.0d0
        if (del.gt.0) then
          do j=nterm+nbknm3(i)+1,nterm+nbknm3(i)+nbkdn3(i)
            denom=denom+ceta(i,j,1)*tau**ceta(i,j,2)*del**ceta(i,j,3)
          enddo
        endif
c  divide numerator by denominator
        if (abs(denom).gt.1.d-20) eta3rs=eta3rs/denom
      end if
c
c  multiply by reducing parameter (to convert units, etc.)
      eta3rs=eta3rs*etabk3(i)
c
c     write (*,1000) icomp,tau,del,eta3rs
c1000 format (' ETA3RS--icomp,tau,del,background tc:  ',i4,3d14.6)
      RETURN
      end                                               !function ETA3RS
c
c ======================================================================
c
      subroutine SETVS4 (nread,icomp,hcasno,ierr,herr)
c
c  initialize pure fluid viscosity model #4; this, the "friction theory model,"
c  S.E. Quinones-Cisneros and U.K. Deiters,
c  "Generalization of the Friction Theory for Viscosity Modeling,"
c  J. Phys. Chem. B 2006, 110,12820-12834.
c
c  inputs:
c    nread--file to read data from
c           <= 0 get data from block data
c           >0 read from logical unit nread (file should have already
c              been opened and pointer set by subroutine SETUP)
c    icomp--component number in mixture (0..nc)
c           1 for pure fluid; 0 for ECS reference fluid
c   hcasno--CAS number of component icomp (not req'd if reading from file)
c
c  outputs:
c     ierr--error flag:  0 = successful
c                      101 = error--block data option not implemented
c     herr--error string (character*255 variable if ierr<>0)
c     other quantities returned via arrays in commons
c
c  12-26-06  MLH, original version
c  01-23-07  MLH, fix mixture bug
c  11-20-07  MLH, removed unused commons and declarations
c  01-04-08 MLH, added additional slots to WNTETA
c  04-28-08 MLH, increased array size in trnft to accommodate new h2 model
c  01-08-12 MLH, increased array size in trnft to accommodate new sf6 model
c
      include 'commons.for'
      include 'comtrn.for'
      character*12 hcasno
      character*255 herr
c
      if (nread.le.0) then
c  get coefficients from block data--this option not implemented,
c  place holder to maintain parallel structure with EOS setup routines
        ierr=101
        write (herr,1101) nread,hcasno,hnull
        call ERRMSG (ierr,herr)
 1101   format ('[SETVS4 error 101] illegal file specified; nread = ',
     &          i4,'; CAS no. = ',a12,a1)
      else
c  read data from file (should have been opened by SETUP)
c       write (*,*) ' SETVS4--read component',icomp,' from unit',nread
        read (nread,*) tmeta(icomp)              !lower temperature limit
        read (nread,*) txeta(icomp)              !upper temperature limit
        read (nread,*) pxeta(icomp)              !upper pressure limit
        read (nread,*) Dxeta(icomp)              !upper density limit
        jterm=0
        ndg2(icomp)=0                           !numerator multiplicative terms
        ndg3(icomp)=0                           !denominator multiplicative terms
        ndg4(icomp)=0
        ndg5(icomp)=0
        ndg6(icomp)=0
        read (nread,*,err=10) ndgeta(icomp),ndg2(icomp),ndg3(icomp),
     &            ndg4(icomp),ndg5(icomp),ndg6(icomp)  !# dilute-gas terms
c       write (*,*) ' SETVS4--about to read ',ndgeta(icomp),' dilute terms'
  10    if (ndgeta(icomp).ge.1) then
          read (nread,2003) hmdeta(icomp)       !pointer to omega model
          read (nread,*) sigmav(icomp)           !L-J sigma
          read (nread,*) epskv(icomp)            !L-J epsilon/kappa
          read (nread,*) trddge(icomp),etadge(icomp)  !reducing par
          do j=1,ndgeta(icomp)                 !read dilute-gas terms
            jterm=jterm+1
            read (nread,*) ceta(icomp,jterm,1),ceta(icomp,jterm,2)
          enddo
          if (ndg2(icomp).ge.1) then
            do j=1,ndg2(icomp)               !read dilute-gas terms
              jterm=jterm+1
              read (nread,*) ceta(icomp,jterm,1),ceta(icomp,jterm,2)
            enddo
          end if
          if (ndg3(icomp).ge.1) then
            do j=1,ndg3(icomp)               !read dilute-gas terms
              jterm=jterm+1
              read (nread,*) ceta(icomp,jterm,1),ceta(icomp,jterm,2)
            enddo
          end if
          if (ndg4(icomp).ge.1) then
            do j=1,ndg4(icomp)               !read dilute-gas terms
              jterm=jterm+1
              read (nread,*) ceta(icomp,jterm,1),ceta(icomp,jterm,2)
            enddo
          end if
          if (ndg5(icomp).ge.1) then
            do j=1,ndg5(icomp)               !read dilute-gas terms
              jterm=jterm+1
              read (nread,*) ceta(icomp,jterm,1),ceta(icomp,jterm,2)
            enddo
          end if
          if (ndg6(icomp).ge.1) then
            do j=1,ndg6(icomp)               !read dilute-gas terms
              jterm=jterm+1
              read (nread,*) ceta(icomp,jterm,1),ceta(icomp,jterm,2)
            enddo
          end if
        end if
        read (nread,*) nB2eta(icomp)               !# visc virial terms bot presently used
c       write (*,*) ' SETVS4--about to read ',nB2eta(icomp),' virial terms'
        if (nB2eta(icomp).ge.1) then
          read (nread,*) tredB2(icomp),etarB2(icomp)  !reducing par
          do j=1,nB2eta(icomp)        !read viscosity virial terms
            jterm=jterm+1
            read (nread,*) ceta(icomp,jterm,1),ceta(icomp,jterm,2)
          enddo
        end if
c
c  read the 18 parameters in the original generalized model
c  these are in the order: a(0:2),b(0:2),c(0:2),A(0:2),B(0:2),C(0:2)
c       write (*,*) ' SETVS4--about to read residual terms'
        if (verfl(icomp) .le.8.0) then
          READ(nread,*)(ASftm(icomp,j),j=0,2)
          READ(nread,*)(BSftm(icomp,j),j=0,2)
          READ(nread,*)(CSftm(icomp,j),j=0,2)
          READ(nread,*)(ABftm(icomp,j),j=0,2)
          READ(nread,*)(BBftm(icomp,j),j=0,2)
          READ(nread,*)(CBftm(icomp,j),j=0,2)
c  one additional higher order term needed for high pressures (>500 MPa)
          READ(nread,*)(DBftm(icomp,j),j=0,2)
        else ! more terms in v8.1 and above
          READ(nread,*)(ASftm(icomp,j),j=0,4)
          READ(nread,*)(BSftm(icomp,j),j=0,4)
          READ(nread,*)(CSftm(icomp,j),j=0,4)
          READ(nread,*)(ABftm(icomp,j),j=0,4)
          READ(nread,*)(BBftm(icomp,j),j=0,4)
          READ(nread,*)(CBftm(icomp,j),j=0,4)
          READ(nread,*)(DBftm(icomp,j),j=0,4)
        endif
        if (verfl(icomp).ge.9.0) then  !read additional coefficients
          READ(nread,*)(EBftm(icomp,j),j=0,4)
        else
          do j=0,4
          EBftm(icomp,j)=0.0d0
          end do
        endif
c
c
c  read in pointer to critical enhancement model
        read (nread,2003) hetacr(icomp)
c       write (*,*) ' SETVS4--will use critical model ',hetacr(icomp)
        ierr=0
        herr=' '
      end if
c
      RETURN
 2003 format (a3)
      end                                             !subroutine SETVS4
c
c ======================================================================
c
      function ETA4DG (icomp,t)
c
c  dilute-gas contribution to the viscosity by the friction theory
c  model (VS4)   allowing for denominator terms not present in VS1 model
c
c  inputs:
c    icomp--component number in mixture (1..nc); 1 for pure fluid
c        t--temperature [K]
c  output (as function value):
c   eta4dg--the dilute-gas part of the viscosity [uPa-s]
c
c  12-10-07 MLH original version based on VS1
c  01-04-08 MLH, added additional slots to WNTETA
c
      include 'commons.for'
      include 'comtrn.for'
c
      i=icomp
      nterm=0                                    !term counter
      eta4dg=0.0d0
c

c  sum the dilute-gas terms
      eta4dg=0.0d0
      if (ndgeta(i).ge.1 .and. t.lt.1.d8) then
        tau=t/trddge(i)

c  first term is always the Chapman-Enskog term
        eta4dg=ceta(i,1,1)*SQRT(tau)/(sigmav(i)**2
     &        *OMEGA(i,t,epskv(i),hmdeta(i)))

        IF (ndgeta(i).ge.2) then
c  possibility for additional, empirical terms
          do j=nterm+1,nterm+ndgeta(i)
            eta4dg=eta4dg+ceta(i,j,1)*tau**ceta(i,j,2)
          enddo
        endif
      endif
      jterm=j
        IF(ndg2(i).gt.0)then
          sumnum = 0.0d0
          do j=jterm,jterm+ndg2(i)-1
            sumnum= sumnum +ceta(i,j,1)*tau**ceta(i,j,2)
          enddo
          eta4dg =eta4dg * sumnum
          jterm=j
        endif
        IF(ndg3(i).gt.0)then
          sumden = 0.0d0
          do j=jterm,jterm+ndg3(i)-1
            sumden = sumden +ceta(i,j,1)*tau**ceta(i,j,2)
          end do
          eta4dg = eta4dg / sumden
        endif

c  multiply by reducing parameter for viscosity (to convert units, etc.)
      eta4dg=eta4dg*etadge(i)
c     write (*,*) ' ETA4DG--d.g. visc:   ',eta1dg
      RETURN
      end                                               !function ETA4DG
c
c ======================================================================
c ======================================================================
c
      function ETA4RS (icomp,t,rho)
c
c  residual contribution to the viscosity for the friction theory model (VS4)
c  S.E. Quinones-Cisneros and U.K. Deiters,
c  "Generalization of the Friction Theory for Viscosity Modeling,"
c  J. Phys. Chem. B 2006, 110,12820-12834.
c
c  inputs:
c    icomp--component number in mixture (1..nc); 1 for pure fluid
c        t--temperature [K]
c      rho--molar density [mol/L]
c  output (as function value):
c   eta4rs--the background part of the viscosity [uPa-s]
c
c  12-28-06 MLH, original version
c  01-18-07 MLH, put fgam =psi2 to accommodate new methane equation
c  01-23-07 MLH, fix mix bug
c  02-21-07 MLH, allow for higher order repulsive terms, check for 2-phase
c  11-20-07 MLH, removed unnecessary common blocks and declarations
c  04-28-08 MLH, increased array size in trnft to accommodate new h2 model
c  02-03-10 MLH, added HSQM term for n-hydrogen and parahydrogen only
c  12-28-10 MLH, added Boshkova -Deiters diameter
c  01-08-12 MLH, added d and e parameters
C  04-12-12 MLH, allowed extra terms except keep old methane form
c  07-11-12 MLH, added terms for 1234yf
c  11-06-12 MLH, revised to not use short equ at sat bdry
c
      include 'commons.for'
      include 'comtrn.for'
      character*255 herr
      dimension FEED (ncmax),xliq(ncmax),xvap(ncmax)
c
      i=icomp
      eta4rs=0.0d0

c     set up constants
      rgas= 0.08314472d0
      conb= 100.0d0
      avo=6.02214179d23
      bolt=1.3806504d-23
      planck=6.62606896d-34
      pi=3.14159265358979d0
      chs=3.0d0*SQRT(2.0d0)
      emm=3.34707d-27

      kph=1
      feed(1)= 1.0d0
      if (rho.lt.1.0d-10) RETURN

c     get value of pressure for the pure fluid at t,rho
      icc=icnc            !Save current value of icnc in case user has called PUREFLD
      call PUREFLD(i)     !obtain p of the pure at actual t, rho
      call PRESS (t,rho,feed,pkpa)
      p=pkpa/conb         !convert to bar
c
c
c     for normal or para hydrogen, use special case here with hard spheres quantum mechanical term
      IF(hcas(i).eq.'1333-74-0'.or.hcas(i).eq.'1333-74-0p')then  !normal or parahydrogen
        tr=t/tcrit(i)
        psi1= EXP(1.0d0/tr-1.0d0)-1.0d0
        psi2= EXP(1.0d0/(tr**2)-1.0d0)-1.0d0
        psi3=EXP(1.0d0/(tr**3)-1.0d0)-1.0d0         !march 1 normal h2 model
        psi4=(1.0d0/tr-1)

        sumkapa=(ASftm(i,0)+ASftm(i,1)*psi1 +ASftm(i,2)*psi2
     &                  +ASftm(i,3)*psi3+ASftm(i,4)*psi4)/(tr)
        sumkapaa=(ABftm(i,0)+ABftm(i,1)*psi1+ABftm(i,2)*psi2
     &                  +ABftm(i,3)*psi3+ABftm(i,4)*psi4)/tr
        sumkapr=(BSftm(i,0)+BSftm(i,1)*psi1 +BSftm(i,2)*psi2
     &                  +BSftm(i,3)*psi3+BSftm(i,4)*psi4)/(tr)
        sumkaprr=(BBftm(i,0)+BBftm(i,1)*psi1+BBftm(i,2)*psi2
     &                  +BBftm(i,3)*psi3+BBftm(i,4)*psi4)/tr
        sumkaprrr=(DBftm(i,0)+DBftm(i,1)*psi1+DBftm(i,2)*psi2
     &                  +DBftm(i,3)*psi3+DBftm(i,4)*psi4)/(tr**3.0)
        if(hcas(i).eq.'1333-74-0')then  !normal
          sumkapaaa=((9.750655931493327d-11)*psi2)/tr**3    !3/1/11 normal
        else                            !para
          sumkapaaa=((3.8478220629752735d-9)*psi2)/tr**3    !1/27/11 para
        endif
c the hard sphere quantum terms
        sigg0=2.97d-10              !m specific to hydrogen
        epsi=30.41d0
        tsquig=T/epsi               !revision for soft sphere
        dnumer=1.0d0+0.4378142*tsquig+0.009951898*tsquig**2
        ddenom=1.0d0+0.4745558*tsquig+0.01338717*tsquig**2
        sigg=0.925*dnumer*sigg0/ddenom
        ppsi=rho*1000.0d0*(pi/6.0d0)*avo*sigg**3
        xlam=planck/SQRT(2.0d0*pi*emm*bolt*t)
        term1=ppsi*xlam*chs*(1.0d0+ppsi-0.5d0*ppsi**2)/((1.0d0-ppsi)**4)
        term1=term1/(sigg*100.0d0)
        term2=(1.0d0+ppsi+ppsi**2-ppsi**3)/((1.0d0-ppsi)**3)
        zr=term1+term2
        prep=zr * rho * rgas* t    !bar
        patt = p - prep            !bar
        pid = rho * rgas * t       !bar
        delpr = prep - pid         !bar
        eta4rs = sumkapr*delpr +sumkapa*patt+sumkaprr*prep**2 +
     &         sumkapaa*patt**2
     &         +sumkaprrr*prep**3  !in upa.s
     &         +sumkapaaa*patt**3
        icnc=icc                   ! reset
        return
      else
      endif
c
c  for everything except normal hydrogen and parahydrogen
c  compute the residual term

      tr=tcrit(i)/t
      psi1= EXP(tr)-1.0d0
      psi2= EXP(tr**2)-1.0d0
      psi3= tr**(-0.25d0)
      fgam = psi2

      sumkapa=(ASftm(i,0)+ASftm(i,1)*psi1 +ASftm(i,2)*psi2)*tr
      sumkapaa=(ABftm(i,0)+ABftm(i,1)*psi1 +ABftm(i,2)*psi2)*tr**3
      sumkapr=(BSftm(i,0)+BSftm(i,1)*psi1 +BSftm(i,2)*psi2)*tr
      sumkaprr=(BBftm(i,0)+BBftm(i,1)*psi1 +BBftm(i,2)*psi2)*tr**3
      sumkapi=(CSftm(i,0)+CSftm(i,1)*psi1 +CSftm(i,2)*fgam)*tr
      sumkapii=(CBftm(i,0)+CBftm(i,1)*psi1 +CBftm(i,2)*psi2)*tr**3

      if (verfl(i) .gt.8.0) then ! additional terms
        sumkapa  = sumkapa  + ASftm(i,3)*psi3*tr
        sumkapaa = sumkapaa + ABftm(i,3)*psi3*tr**3
        sumkapr  = sumkapr  + BSftm(i,3)*psi3*tr
        sumkaprr = sumkaprr + BBftm(i,3)*psi3*tr**3
        sumkapi  = sumkapi  + CSftm(i,3)*psi3*tr
        sumkapii = sumkapii + CBftm(i,3)*psi3*tr**3
      else
      endif
      ! next compute dpdt at actual t, rho
      call DPDT (t,rho,feed,dpt)
      IF(t.gt.tcrit(i))then
        prep = t*dpt/conb         !bar
        patt = p - prep           !bar
        pid = rho * rgas * t
        delpr = prep - pid
        eta4rs = sumkapr*delpr +sumkapa*patt+sumkaprr*delpr**2 +
     &         sumkapaa*patt**2 +sumkapi*pid + sumkapii*pid**2
     &         + DBftm(i,0)*(prep**3)*(tr**2)
        IF(verfl(i).gt.8.0 .and. hcas(i).ne.'74-82-8') then !extra terms except methane
         eta4rs = eta4rs+
     &     (DBftm(i,0)+DBftm(i,1)*psi1+DBftm(i,2)*psi2+DBftm(i,3)*psi3)
     &     *(prep**3)*tr**DBftm(i,4)
     &     + (EBftm(i,0)+EBftm(i,1)*psi1+EBftm(i,2)*psi2)*(patt**3)
     &     *tr**EBftm(i,4)
        else
        endif
      ELSE   !could be in two-phase region
        !find sat rhol, rhov for this t and dpdt on the boundary
        !check if short sat equations are available  revision 9.1- don't use the short eq's
        if ((hdlk(i).ne.' ' .and. hdlk(i).ne.'NBS').and.
     &      (hdvk(i).ne.' ' .and. hdvk(i).ne.'NBS'))then
          !call DLSATK (i,t,rhol,ierr,herr)
          !call DVSATK (i,t,rhov,ierr,herr)
          !call PSATK (i,t,psatkpa,ierr,herr)
          call SATT (t,feed,kph,psatkpa,rhol,rhov,xliq,xvap,ierr,herr)
        else  !no short forms present; call full
          call SATT (t,feed,kph,psatkpa,rhol,rhov,xliq,xvap,ierr,herr)
        endif
        psat=psatkpa/conb         !convert to bar
      ! if in the two-phase region, interpolate liquid and vapor endpoints to avoid
      ! bizarre behavior caused by loops from the EOS
        IF((rho.gt.rhov).AND.(rho.lt.rhol)) then   ! it is two-phase region
          p=psat
          ! get viscosity on liquid side
          call DPDT (t,rhol,feed,dptl)
          prep = t*dptl/conb      !bar
          patt = p - prep         !bar
          pid = rhol * rgas * t
          delpr = prep - pid
          eta4rsl = sumkapr*delpr +sumkapa*patt+sumkaprr*delpr**2 +
     &         sumkapaa*patt**2 +sumkapi*pid + sumkapii*pid**2
     &         + DBftm(i,0)*(prep**3)*(tr**2)
          IF(verfl(i).gt.8.0 .and. hcas(i).ne.'74-82-8') then !extra terms
            eta4rsl = eta4rsl+
     &      (DBftm(i,0)+DBftm(i,1)*psi1+DBftm(i,2)*psi2+DBftm(i,3)*psi3)
     &      *(prep**3)*tr**DBftm(i,4)
     &      + (EBftm(i,0)+EBftm(i,1)*psi1+EBftm(i,2)*psi2)*(patt**3)
     &      *tr**EBftm(i,4)
          else
          endif
          ! get viscosity on vapor side
          call DPDT (t,rhov,feed,dptv)
          prep = t*dptv/conb      !bar
          patt = p - prep         !bar
          pid = rhov * rgas * t
          delpr = prep - pid
          eta4rsv = sumkapr*delpr +sumkapa*patt+sumkaprr*delpr**2 +
     &         sumkapaa*patt**2 +sumkapi*pid + sumkapii*pid**2
     &         + DBftm(i,0)*(prep**3)*(tr**2)
          IF(verfl(i).gt.8.0 .and. hcas(i).ne.'74-82-8') then !extra terms
            eta4rsv = eta4rsv+
     &      (DBftm(i,0)+DBftm(i,1)*psi1+DBftm(i,2)*psi2+DBftm(i,3)*psi3)
     &      *(prep**3)*tr**DBftm(i,4)
     &      + (EBftm(i,0)+EBftm(i,1)*psi1+EBftm(i,2)*psi2)*(patt**3)
     &      *tr**EBftm(i,4)
          else
          endif
          drat=(rhol-rho)/(rhol-rhov)
          eta4rs=eta4rsl-drat*(eta4rsl-eta4rsv)
        ELSE !not in two-phase
          prep = t*dpt/conb       !bar
          patt = p - prep         !bar
          pid = rho * rgas * t
          delpr = prep - pid
          eta4rs = sumkapr*delpr +sumkapa*patt+sumkaprr*delpr**2 +
     &         sumkapaa*patt**2 +sumkapi*pid + sumkapii*pid**2
     &         + DBftm(i,0)*(prep**3)*(tr**2)
          IF(verfl(i).gt.8.0 .and. hcas(i).ne.'74-82-8') then !extra terms
            eta4rs = eta4rs+
     &      (DBftm(i,0)+DBftm(i,1)*psi1+DBftm(i,2)*psi2+DBftm(i,3)*psi3)
     &      *(prep**3) *tr**DBftm(i,4)
     &      + (EBftm(i,0)+EBftm(i,1)*psi1+EBftm(i,2)*psi2)*(patt**3)
     &      *tr**EBftm(i,4)
          else
          endif
        ENDIF
      ENDIF
      eta4rs=eta4rs*1000.0d0 ! convert to uPa.s
      icnc=icc               ! reset
      RETURN
      end                                               !function ETA4RS
c
c ======================================================================
c
      subroutine SETVS5 (nread,icomp,hcasno,ierr,herr)
c
c  initialize pure fluid viscosity model #5; this, the "Chung model,"
c  T-H. Chung, M. Ajlan, L.L. Lee, and K.E. Starling
c  "Generalized Multiparameter Correlation for Nonpolar and Polar Fluid Transport Properties"
c  Ind. Eng. Chem. Res. 1988, 27, 671-679.
c
c  inputs:
c    nread--file to read data from
c           <= 0 get data from block data
c           >0 read from logical unit nread (file should have already
c              been opened and pointer set by subroutine SETUP)
c    icomp--component number in mixture (0..nc)
c           1 for pure fluid; 0 for ECS reference fluid
c   hcasno--CAS number of component icomp (not req'd if reading from file)
c
c  outputs:
c     ierr--error flag:  0 = successful
c                      101 = error--block data option not implemented
c     herr--error string (character*255 variable if ierr<>0)
c     other quantities returned via arrays in commons
c
c  11-19-07  MLH, original version
c  01-04-08 MLH, added additional slots to WNTETA
c  01-04-08 MLH, allow dilute and residual parameters to be independent
c
c
      include 'commons.for'
      include 'comtrn.for'
      character*12 hcasno
      character*255 herr
c
      if (nread.le.0) then
c  get coefficients from block data--this option not implemented,
c  place holder to maintain parallel structure with EOS setup routines
        ierr=101
        write (herr,1101) nread,hcasno,hnull
        call ERRMSG (ierr,herr)
 1101   format ('[SETVS5 error 101] illegal file specified; nread = ',
     &          i4,'; CAS no. = ',a12,a1)
      else
c  read data from file (should have been opened by SETUP)
c       write (*,*) ' SETVS5--read component',icomp,' from unit',nread
        read (nread,*) tmeta(icomp)              !lower temperature limit
        read (nread,*) txeta(icomp)              !upper temperature limit
        read (nread,*) pxeta(icomp)              !upper pressure limit
        read (nread,*) Dxeta(icomp)              !upper density limit
        jterm=0                                 !term counter
        read (nread,*) ndgeta(icomp)               !# dilute-gas terms
c       write (*,*) ' SETVS5--about to read ',ndgeta(icomp),' dilute terms'
        if (ndgeta(icomp).ge.1) then
          read (nread,2003) hmdeta(icomp)       !pointer to omega model
          read (nread,*) sigchv(icomp)          !L-J sigma for chung viscosity model
          read (nread,*) epschv(icomp)          !L-J epsilon/kappa for chung viscosity model
          read (nread,*) trddge(icomp),etadge(icomp)  !reducing par
          do j=1,ndgeta(icomp)                 !read dilute-gas terms
            jterm=jterm+1
            read (nread,*) ceta(icomp,jterm,1),ceta(icomp,jterm,2)
          enddo
        end if
        read (nread,*) nB2eta(icomp)               !# visc virial terms bot presently used
c       write (*,*) ' SETVS5--about to read ',nB2eta(icomp),' virial terms'
        if (nB2eta(icomp).ge.1) then
          read (nread,*) tredB2(icomp),etarB2(icomp)  !reducing par
          do j=1,nB2eta(icomp)        !read viscosity virial terms
            jterm=jterm+1
            read (nread,*) ceta(icomp,jterm,1),ceta(icomp,jterm,2)
          enddo
        end if
c
c       write (*,*) ' SETVS5--about to read Chung-specific terms'
        READ(nread,*)acchv(icomp),ddipv(icomp),hbvk(icomp)
c       set residual parameters
        cceta(icomp,1,1)=sigchv(icomp)
        cceta(icomp,1,2)=epschv(icomp)
        cceta(icomp,1,3)=acchv(icomp)
        cceta(icomp,1,4)=ddipv(icomp)
        cceta(icomp,1,5)=hbvk(icomp)
        READ(nread,*) naddv(icomp) !additional terms
c       use these terms if residual parameters are not the same as dilute gas
        jtc=0
        do j =1, naddv(icomp)
         jtc=jtc+1
         READ(nread,*) cceta(icomp,jtc,1),cceta(icomp,jtc,2),
     &    cceta(icomp,jtc,3),cceta(icomp,jtc,4),cceta(icomp,jtc,5)
        end do
c
c  read in pointer to critical enhancement model
        read (nread,2003) hetacr(icomp)
c       write (*,*) ' SETVS5--will use critical model ',hetacr(icomp)
        ierr=0
        herr=' '
      end if
c
      RETURN
 2003 format (a3)
      end                                             !subroutine SETVS5
c
c ======================================================================
c
      function ETA5DG (icomp,t)
c
c  dilute-gas contribution to the viscosity by the Chung model (VS5)
c  T-H. Chung, M. Ajlan, L.L. Lee, and K.E. Starling
c  "Generalized Multiparameter Correlation for Nonpolar and Polar Fluid Transport Properties"
c  Ind. Eng. Chem. Res. 1988, 27, 671-679. Also see Reid, Prausnitz and Poling Chapter 9.
c
c  inputs:
c    icomp--component number in mixture (1..nc); 1 for pure fluid
c        t--temperature [K]
c  output (as function value):
c   eta1dg--the dilute-gas part of the viscosity [uPa-s]
c
c  11-02-07 MLH original
c  01-04-08 MLH, added additional slots to WNTETA
c
      include 'commons.for'
      include 'comtrn.for'
c
      i=icomp
      nterm=0                                    !term counter
      eta5dg=0.0d0
c
c  sum the dilute-gas terms
      if (ndgeta(i).ge.1 .and. t.lt.1.0d8) then
        tau=t/epschv(i)
        vc = (sigchv(i)/8.09d0)**3
c  first term is always the Chapman-Enskog term
        eta5dg=0.00040785d0*SQRT(t*wmas(i))/(vc**(2./3.)
     &        *OMEGAS(2,2,tau))
        if (ndgeta(i).ge.2) then
c  possibility for additional, empirical terms
          do j=nterm+1,nterm+ndgeta(i)
            eta5dg=eta5dg+ceta(i,j,1)*tau**ceta(i,j,2)
          enddo
        end if
      end if
c
c  multiply by Chung factor
      fchung= 1.0d0 - 0.2756d0 * acchv(i) + 0.059035d0 * ddipv(i)**4
     &        + hbvk(i)
      eta5dg = eta5dg * fchung
      eta0ch = eta5dg
c  multiply by reducing parameter for viscosity (to convert units, etc.)
      eta5dg=eta5dg*etadge(i)
c     write (*,*) ' ETA5DG--d.g. visc:   ',eta5dg
      RETURN
      end                                               !function ETA5DG
c
c ======================================================================
c
      function ETA5RS (icomp,t,rho)
c
c  residual contribution to the viscosity for the Chung model (VS5)
c  T-H. Chung, M. Ajlan, L.L. Lee, and K.E. Starling
c  "Generalized Multiparameter Correlation for Nonpolar and Polar Fluid Transport Properties"
c  Ind. Eng. Chem. Res. 1988, 27, 671-679. Also see Reid, Prausnitz and Poling Chapter 9.
c
c
c  inputs:
c    icomp--component number in mixture (1..nc); 1 for pure fluid
c        t--temperature [K]
c      rho--molar density [mol/L]
c  output (as function value):
c   eta5rs--the background part of the viscosity [uPa-s]
c
c  note: this version allows the parameters for the residual piece to
c  be independent from the dilute gas and fit as free parameters
c  nomenclature for comparison with manuscript
c        sigchv(i)=cceta(i,1,1)
c        epschv(i)=cceta(i,1,2)
c        acchv(i)=cceta(i,1,3)
c        ddipv(i)=cceta(i,1,4)
c        hbvk(i)=cceta(i,1,5)
c
C     modified 6.14.12 MLH
c
      include 'commons.for'
      include 'comtrn.for'
      dimension A0(10),A1(10),A2(10),A3(10), AA(10)
c
      parameter (A0=
     & (/6.32402D0, 0.12102D-2, 5.28346D0, 6.62263D0, 19.74540D0,
     &   -1.89992D0, 24.2745D0, 0.79716D0, -0.23816D0, 0.68629D-1 /))
      parameter (A1=
     & (/50.4119D0, -0.11536D-2, 254.209D0, 38.0957D0, 7.63034D0,
     &   -12.5367D0, 3.44945D0, 1.11764D0, 0.67695D-1, 0.34793D0 /))
      parameter (A2=
     & (/-51.6801D0, -0.62571D-2, -168.481D0, -8.46414D0,
     &   -14.3544D0, 4.98529D0, -11.2913D0, 0.12348D-1, -0.8163D0,
     &   0.59256D0 /))
      parameter (A3=
     & (/1189.02D0, 0.37283D-1, 3898.27D0, 31.4178D0, 31.5267D0,
     &   -18.1507D0, 69.3466D0, -4.11661D0, 4.02528D0, -0.72663D0 /))
      i=icomp
      eta5rs=0.0D0
      twothr=2.0d0/3.0d0
      IF(rho.lt.1.0D-10) RETURN
c
      tstar=t/cceta(i,1,2)
      vc = (cceta(i,1,1)*10.0D0/0.809D0)**3 !compute vc in cm3/mol from Chung sigma
      fchung= 1.0D0 - 0.2756D0*cceta(i,1,3) + 0.059035D0*cceta(i,1,4)**4
     &        +  cceta(i,1,5)
c
      do j=1,10
        AA(J)=A0(j)+A1(j)*cceta(i,1,3)+A2(j)*cceta(i,1,4)**4+
     &        A3(j)*cceta(i,1,5)
      end do
c
      y = rho * vc/ 6.0D3
      g1=(1.0D0 -0.5D0*y)/((1.0D0-y)**3)
      g2=(AA(1)*(1.0D0- EXP(-AA(4)*y))/y+AA(2)*g1*EXP(AA(5)*y)+AA(3)*g1)
     &   /(AA(1)*AA(4)+AA(2)+AA(3))
c
c      etass = AA(7)*y*y*g2*EXP(AA(8)+AA(9)/tstar+AA(10)/tstar**2)
      omegav = omegas(2,2,tstar)
c     etas=SQRT(tstar)*(1.0D0/g2+AA(6)*y)*fchung/omegav + etass
c
c     eta5rs=etas
c    & *36.344D0*SQRT(wmas(i)*1.2593D0*cceta(i,1,2))/(vc**twothr)
c     eta5rs=eta5rs/10.0D0 -eta0ch !convert from upoise to upa.s and subtract off dg
c
      eta0chung=4.0785d-5*SQRT(wmas(i)*t)*fchung/(omegav*vc**twothr)
      etakap=eta0chung*(1.0d0/g2+aa(6)*y)
      etap=(36.344d-6*SQRT(wmas(i)*1.2593*cceta(i,1,2))/(vc**twothr))
     & *aa(7)*y*y*g2*
     &EXP(aa(8)+aa(9)/tstar+aa(10)/tstar**2)
      etach=etakap+etap  ! in poise
      eta5rs=(etach- eta0chung)*1d5 !convert to upa.s

      RETURN
      end                                               !function ETA5RS
c
c ======================================================================
c
      subroutine SETVS6 (nread,icomp,hcasno,ierr,herr)
c
c  initialize pure fluid viscosity model #6
c
c  temporary place holder--this model is not yet implemented
c
c  inputs:
c    nread--file to read data from
c           <= 0 get data from block data
c           >0 read from logical unit nread (file should have already
c              been opened and pointer set by subroutine SETUP)
c    icomp--component number in mixture (0..nc)
c           1 for pure fluid; 0 for ECS reference fluid
c   hcasno--CAS number of component icomp (not req'd if reading from file)
c
c  outputs:
c     ierr--error flag:  0 = successful
c                       49 = error--model not implemented
c                      101 = error--block data option not implemented
c     herr--error string (character*255 variable if ierr<>0)
c     other quantities returned via arrays in commons
c
c  written by M. McLinden, NIST Phys & Chem Properties Div, Boulder, CO
c  06-18-96  MM, original version
c  08-19-97  MM, change error number for nread<=0; input hcasno is not array
c
      include 'commons.for'
      include 'comtrn.for'
      character*12 hcasno
      character*255 herr
c
      if (nread.le.0) then
c  get coefficients from block data--this option not implemented,
c  place holder to maintain parallel structure with EOS setup routines
        ierr=101
        write (herr,1101) nread,hcasno,hnull
        call ERRMSG (ierr,herr)
 1101   format ('[SETVS6 error 101] illegal file specified; nread = ',
     &          i4,'; CAS no. = ',a12,a1)
      else
c  read data from file (should have been opened by SETUP)
        hetacr(icomp)='NUL'
        ierr=49
        herr='[SETUP error 49] viscosity model #6 specified in fluid '//
     &       'file but not implemented in code.'//hnull
        call ERRMSG (ierr,herr)
      end if
c
      RETURN
      end                                             !subroutine SETVS6
c
c ======================================================================
c
c     The following functions (through EXCESV) were taken from NIST12,
c     Version 3.1, and modified to work with the current version.
c
      function ETAH2mct (icomp,t,d)
c
c  model for the viscosity of para and normal hydrogen
c
c  inputs:
c    icomp--component number in mixture (1..nc); 1 for pure fluid
c        t--temperature [K]
c        d--molar density [mol/L]
c  output (as function value):
c     eta5--viscosity [uPa-s]
c
c  written by E.W. Lemmon, NIST Phys & Chem Properties Div, Boulder, CO
c  10-20-99 EWL, original version
c  09-13-02 EWL, removed code for d>27 and d>dtest
c
      include 'commons.for'
      include 'comtrn.for'
c
c  The code for d>27 and d>dtest caused vis to be constant at any pressure
c  above 27 or dtest.  These checks were once used because the viscosity
c  starts to drop as the temperature drops in the liquid at high densities.
c  By changing the maximum density of the formulation to 44 mol/L, the drops
c  are not significant, and the tests can be removed.
      IF (T.GT.100.0D0) THEN
c       IF (D.GT.27.D0) THEN
c         ETAH2=DILV(icomp,100.D0)+EXVDIL(27.D0,100.D0)
c    &        +DELV(icomp,D,100.D0,27.D0,100.D0)
c    &        +DELV(icomp,D,T,D,100.D0)
c       ELSE
          ETAH2mct=DILV(icomp,100.D0)+EXVDIL(D,100.0D0)
     &          +DELV(icomp,D,T,D,100.0D0)
c       ENDIF
      ELSE
c       DTEST=49.D0-0.2204D0*T
c       IF (D.LE.DTEST) THEN
          ETAH2mct=DILV(icomp,T)+EXVDIL(D,T)
c       ELSE
c         ETAH2mct=DILV(icomp,T)+EXVDIL(DTEST,T)+DELV(icomp,D,T,DTEST,T)
c       ENDIF
      ENDIF
      END

      function DELV (icomp,D1,T1,D2,T2)
      include 'commons.for'
      include 'comtrn.for'
c
      DELV=DILV(icomp,T1)+EXCESV(icomp,D1,T2)
     &    -DILV(icomp,T2)-EXCESV(icomp,D2,T2)
      END

      function EXVDIL (DD,T)
      include 'commons.for'
      include 'comtrn.for'
c
      EXVDIL=0.0D0
      IF (DD.LE.0) RETURN
      D=DD*2.0159D0/1000.0D0
      A=5.7694D0+LOG(D)+0.65D2*D**1.5D0- 6.0D-6*DEXP(127.2D0*D)
      A=DEXP(A)
      B=1.0D1+7.2D0*((D/0.07D0)**6-(D/0.07D0)**(3.0D0/2.0D0))
     &-17.63D0*DEXP(-58.75D0*(D/0.07D0)**3)
      EXVDIL=A*DEXP(B/T)*0.1D0
      END

      function DILV (icomp,T)
      include 'commons.for'
      include 'comtrn.for'
c
      SUM=0.0D0
      TF=T**(1.0D0/3.0D0)
      TFF=T**(-4.0D0/3.0D0)
      DO I=1,9
        TFF=TFF*TF
        SUM=SUM+ceta(icomp,i,1)*TFF
      ENDDO
      DILV=SUM*100.0D0
      END

      function EXCESV (icomp,DD,T)
      include 'commons.for'
      include 'comtrn.for'
      double precision EV(8)
c
      EV(1)=ceta(icomp,10,1)
      EV(2)=ceta(icomp,11,1)
      EV(3)=ceta(icomp,12,1)
      EV(4)=ceta(icomp,13,1)
      EV(5)=ceta(icomp,14,1)
      EV(6)=ceta(icomp,15,1)
      EV(7)=ceta(icomp,16,1)
      EV(8)=ceta(icomp,17,1)
      D=DD*2.0159D0/1000.0D0
      R2=D**0.5D0*(D-EV(8))/EV(8)
      RR=D**0.1D0
      X=EV(1)+EV(2)*R2+EV(3)*RR+EV(4)*R2/(T*T)+EV(5)*RR/T**1.5D0+EV(6)/T
     &+EV(7)*R2/T
      X1=EV(1)+EV(6)/T
      EXCESV=(DEXP(X)-DEXP(X1))*0.1D0
      END
c
c ======================================================================
      function ETAH2 (icomp,t,d)
c
c  model for the viscosity of normal hydrogen from symbolic regression
c  Muzny, C.D., Huber, M.L., and Kazakov, A.F.,
c  "Correlation for the Viscosity of normal hydrogen obtained from symbolic regression"
c  submitted to J. Chem. Eng. Data, 2013
c
c  inputs:
c    icomp--component number in mixture (1..nc); 1 for pure fluid
c        t--temperature [K]
c        d--molar density [mol/L]
c  output (as function value):
c     etah2--viscosity [uPa-s]
c
c  11-16-12   mlh, original
c
      implicit double precision (a-h,o-z)
      implicit integer (i-n)
      DIMENSION sma(0:4), beta(6)
      DATA sma(0), sma(1), sma(2), sma(3), sma(4)
     &  / 0.209630d0,-0.455274d0,
     &  0.143602d0, -0.335325d-01, 0.276981d-02 /     ! coeff to match moldover
      DATA beta(1), beta(2), beta(3),beta(4), beta(5), beta(6)
     &    /0.118757d-05, 0.536373d0, 0.759423d+01, 0.615343d+01,
     &    -0.193070d+01, 0.011d0 /
        ts=t/30.41d0
        sum1=0.0d0
        do i=0,4
        sum1=sum1+sma(i)*(LOG(Ts))**i
        end do
        sigmast=EXP(sum1)
        etadil=0.021357*SQRT(2.01588*t)/(0.297*0.297*sigmast)
        beta1=0.6022137*(-0.187+2.4871/(t/30.41)+3.7151/(t/30.41)**2
     &  -11.0972/(t/30.41)**3+9.0965/(t/30.41)**4-3.8292/(t/30.41)**5
     &  +0.5166/(t/30.41)**6)*(0.297**3)
        eta1=etadil*beta1*d  !uPa.s
        rhokg=d*2.01588
        visa=etadil+eta1
      IF(rhokg.gt.0)then
        tred=t/33.145
        dred=rhokg*0.011
        ! nov8 machine 37 optimized by andrei
        diff2 = 6.43449673d-03*dred**2*exp(4.56334068d-02*tred +
     &  2.32797868d-01/tred + 9.58326120d-01*dred**2/(1.27941189d-01
     &  + tred) +    3.63576595d-01*dred**6)
        etares=1000*diff2
      else
        etares=0
      endif
      etah2=visa+etares
      END
c
c
      function ETAHE (icomp,t,rho)
c
c  viscosity of helium taken from:
c    Arp, V.D., McCarty, R.D., and Friend, D.G.,
c    "Thermophysical Properties of Helium-4 from 0.8 to 1500 K with
c     Pressures to 2000 MPa,"
c    NIST Technical Note 1334, Boulder, CO 1998.
c
c  inputs:
c    icomp--component number in mixture (1..nc); 1 for pure fluid
c        t--temperature [K]
c      rho--molar density [mol/L]
c  output (as function value):
c   etahe --viscosity [uPa-s]
c
c  written by E.W. Lemmon, NIST Phys & Chem Properties Div, Boulder, CO
c  07-06-98 EWL, original version
c  12-01-98 EWL, add Reos and triple point pressure and density to /CCON/
c  02-16-99 EWL, rename to ETA4RS
c  11-06-00 EWL, change to ETAHE using the hardcoded model
c  01-25-07 EWL, check for large value in the calculation of expe
c
      include 'commons.for'
      include 'comtrn.for'
c
      x=5.7037825d0
      if (t.le.300.0d0) x=log(t)
      dd=rho*wmas(icomp)/1000.0d0
      b=-47.5295259d0/x+87.6799309d0- 42.0741589d0*x
     &  +8.33128289d0*x**2-0.589252385d0*x**3
      c= 547.309267d0/x-904.870586d0+431.404928d0*x
     &  -81.4504854d0*x**2+5.37008433d0*x**3
      d=-1684.39324d0/x+3331.08630d0 -1632.19172d0*x
     &  +308.804413d0*x**2-20.2936367d0*x**3

      eta0a=exp(-0.135311743d0/x+1.00347841d0+1.20654649d0*x
     &     -0.149564551d0*x**2+0.0125208416d0*x**3)
      ee=b*dd+c*dd**2+d*dd**3
      if (ee.gt.100.d0) ee=100.0d0
      etae=exp(ee)
      if (t.gt.100.0d0) then
        eta0b=196.0d0*t**0.71938d0
     &       *exp(12.451d0/t-295.67d0/t**2-4.1249d0)
        if (t.lt.110.0d0) then
          eta0=eta0a+(eta0b-eta0a)*(t-100.0d0)/10.0d0
        else
          eta0=eta0b
        endif
        viscos=eta0a*etae+eta0-eta0a
      else
        viscos=eta0a*etae
      endif

      etahe=viscos/10.0d0
c     write (*,*) ' ETAHE--residual viscosity:    ',etahe
c
      RETURN
      end                                                !function ETAHE
c
c ======================================================================
c
      function ETAETY (icomp,t,rho)
c
c  viscosity model for ethylene by Holland et al. (1983)
c
c  inputs:
c    icomp--component number in mixture (1..nc); 1 for pure fluid
c        t--temperature [K]
c      rho--molar density [mol/L]
c  output (as function value):
c   etaety--viscosity [uPa-s]
c
c  written by E.W. Lemmon, NIST Phys & Chem Properties Div, Boulder, CO
c  02-29-00 EWL, original version
c
      include 'commons.for'
      include 'comtrn.for'
      double precision gv(9)
c
      etaety=0.0d0
      gv(1)=-3.5098225018d6
      gv(2)= 2.5008406184d6
      gv(3)=-5.8365540744d5
      gv(4)= 4.5549146583d3
      gv(5)= 2.2881683403d4
      gv(6)=-4.7318682077d3
      gv(7)= 4.5022249258d2
      gv(8)=-2.1490688088d1
      gv(9)= 4.1649263233d-1
      v1=-4.8544486732d0
      v2= 1.3033585236d1
      v3= 2.7808928908d4
      v4=-1.8241971308d3
      v5= 1.5913024509d0
      v6=-2.0513573927d2
      v7=-3.9478454708d4
      d=rho*wmas(icomp)/1000.0d0
      dc=.221d0
      th=(d-dc)/dc
      tt=t**(1.0d0/3.0d0)
      eta0=gv(1)/t+gv(2)/tt**2+gv(3)/tt+gv(4)+gv(5)*tt
     &    +gv(6)*tt**2+gv(7)*t+gv(8)*tt**4+gv(9)*tt**5
      etapr=exp(v1+v4/t)*(exp(d**0.1d0*(v2+v3/t**1.5d0)
     &     +th*d**0.5d0*(v5+v6/t+v7/t**2))-1.0d0)
      etaety=(eta0+etapr)/10.0d0
c
      RETURN
      end                                               !function ETAETY
c
c ======================================================================
c
      function ETANEO (icomp,t,rho)
c
c  viscosity model for neon of:
c
c  Rabinovich, V.A., Vasserman, A.A., Nedostup, V.I. and Veksler, L.S.
c   "Thermophysical Properties of Neon, Argon, Krypton, and Xenon,"
c   Hemisphere Publishing Corp., 1988.
c
c  The numbers calculated here do not exactly match those given by Rabinovich.
c  The ECS model is currently the preferred model.
c
c  inputs:
c    icomp--component number in mixture (1..nc); 1 for pure fluid
c        t--temperature [K]
c      rho--molar density [mol/L]
c  output (as function value):
c   etaneo--viscosity [uPa-s]
c
c  written by E.W. Lemmon, NIST Phys & Chem Properties Div, Boulder, CO
c  03-27-00 EWL, original version
c
      include 'commons.for'
      include 'comtrn.for'
c
      etaneo=0.0d0
      a0= 17.67484d0
      a1=-2.78751d0
      a2= 311498.7d0
      a3=-48826500d0
      a4= 3938774000d0
      a5=-1.654629d11
      a6= 2.86561d12
      tred=t/0.29944
      y=a0+a1*log10(tred)+a2/tred**2+a3/tred**3+a4/tred**4
     & +a5/tred**5+a6/tred**6
      y=y*0.68321d0
      etat=266.93d0*SQRT(t*wmas(icomp))/y
      a0= 1.03010d0
      a1=-0.99175d0
      a2= 2.47127d0
      a3=-3.11864d0
      a4= 1.57066d0
      b0= 0.48148d0
      b1=-1.18732d0
      b2= 2.80277d0
      b3=-5.41058d0
      b4= 7.04779d0
      b5=-3.76608d0
      om=rho/(1673.0d0/wmas(icomp))
c  The sign has been changed in Eq. 5.23 to negative
      s=a0+a1*om+a2*om**2+a3*om**3+a4*om**4
     &-(b0+b1*om+b2*om**2+b3*om**3+b4*om**4+b5*om**5)*log10(t/122.1d0)
      s=s*0.000000000305d0
      b1= 0.27676d0
      b2= 0.014355d0
      b3= 2.6480d0
      b4=-1.9643d0
      b5= 0.89161d0
      b=2.0d0/3.0d0*3.1415927d0*6.02221367d23*s**3
      brho=rho*1000.0d0*b
      etad=1.0d0+b1*brho+b2*brho**2+b3*brho**3+b4*brho**4+b5*brho**5
      etaneo=etad*etat/100.d0
c
      RETURN
      end                                               !function ETANEO
c
c ======================================================================
c
      function ETAR23 (icomp,t,rho)
c
c  viscosity model for R23
c
c  inputs:
c    icomp--component number in mixture (1..nc); 1 for pure fluid
c        t--temperature [K]
c      rho--molar density [mol/L]
c  output (as function value):
c   etaR23--viscosity [uPa-s]
c
c  written by E.W. Lemmon, NIST Phys & Chem Properties Div, Boulder, CO
c  11-01-00 EWL, original version
c
      include 'commons.for'
      include 'comtrn.for'
c
      etaR23=0.0d0
      rhoL=ceta(icomp,2,1)
      C1=ceta(icomp,3,1)
      C2=ceta(icomp,4,1)
      DG=ceta(icomp,5,1)
      etamax=ceta(icomp,6,1)
      drho=rhoL-rho
      del=rho-Dredeta(icomp)
      tau=T-tredeta(icomp)
      etadg=ETA1DG(icomp,t)*(drho/rhoL)**C1
      etars=(rho/rhoL)**C1*C2*rhoL**2/drho*t**0.5d0
     &     *EXP(rho/drho*DG/R/t)
      etacrt=4.0d0*etamax/(exp(del)+exp(-del))/(exp(tau)+exp(-tau))
      etaR23=etadg+etars+etacrt
c
      RETURN
      end                                               !function ETAR23
c
c ======================================================================
c
      function ETAH2O (icomp,t,rho)
c
c  viscosity model for water and heavy water
c
c  inputs:
c    icomp--component number in mixture (1..nc); 1 for pure fluid
c        t--temperature [K]
c      rho--molar density [mol/L]
c  output (as function value):
c   etaH2O--viscosity [uPa-s]
c
c  written by E.W. Lemmon, NIST Phys & Chem Properties Div, Boulder, CO
c  11-06-00 EWL, original version
c  01-04-08 MLH, added additional slots to WNTETA
c  05-08-08 MLH, allow for IAPWS 2008 critical enhancement term
c
      include 'commons.for'
      include 'comtrn.for'
c
      etaH2O=0.0d0
      tr=t/tredeta(icomp)
      dr=rho/Dredeta(icomp)
      tau=1.0d0/tr-1.0d0
      del=dr-1.0d0
      if (ABS(tau).lt.1.0d-12 ) tau=1.0d-12
      if (ABS(del).lt.1.0d-12 ) del=1.0d-12
      s=0.0d0
      do i=1,ndel0(icomp)
        s=s+ceta(icomp,i,1)/tr**ceta(icomp,i,2)
      enddo
      eta0=SQRT(tr)/s
      s=0.0d0
      do i=1,npoly(icomp)
        j=i+ndel0(icomp)
        s=s+ceta(icomp,j,1)
     &        *tau**INT(ceta(icomp,j,2))*del**INT(ceta(icomp,j,3))
      enddo
      eta1=EXP(dr*s)
c     critical enhancement; default is none
      eta2=1.0d0
c
      IF(hetacr(icomp).eq.'I85')then
c     previous 1985 IAPWS critical enhancement
      if (nnumeta(icomp).gt.0) then
        if (tr.gt.0.997d0 .and. tr.lt.1.0082d0) then
          if (dr.gt.0.755d0 .and. dr.lt.1.29d0) then
            call DPDDK (icomp,t,rho,dpdrho)
            i=ndel0(icomp)+npoly(icomp)+1
            x=dr/dpdrho*ceta(icomp,i,1)/Dredeta(icomp)
            if (x.ge.ceta(icomp,i+1,3))
     &          eta2=ceta(icomp,i+1,1)*x**ceta(icomp,i+1,2)
          endif
        endif
      endif
c     2008 IAPWS standard critical enhancement
      ELSEIF(hetacr(icomp).eq.'I08')then
        IF(rho.gt.1.0d-12)then
        xival= xi_fun(t,rho,icomp)
        else
        xival=0.0d0
        endif
        eta2 = eta_c2(xival)
      endif
      etaH2O=etared(icomp)*eta0*eta1*eta2
c
      RETURN
      end                                               !function ETAH2O
c
      function XI_FUN (tk,rho,icomp)
c     auxiliary functions for computing the critical enhancement of viscosity of water
c     "New International Formulation for the viscosity of water"
c     Huber, M.L., Perkins, R.A., Laesecke, A., Friend, D.G., Sengers, J.V., Assael, M.J.,
c     Metaxa, I.M., Vogel, E., Mares, R. and Miyagawa, K.
c     for submission to JPCRD, 2008
c
c     05/08/08 MLH, based on code from RAP
c     09/20/10 MLH, remove extrap limit on chi
c
      include 'commons.for'
      include 'comtrn.for'
      dimension x(ncmax)
c     Input variables
c        tk      temperature,  K
c        rho     density,      mol/L
c     Output variables
c        xi_fun  delta_xi_star
c
      parameter (Tc=647.096D0, Denc=322.0D0)
      parameter (Pc=22.064D0, wmm=18.015268d0)
      parameter (xi0=0.13d-9, gammaplus=0.06d0)
      parameter (exnu=0.63d0, exgamma=1.239d0)
      do ii =1,ncmax
        x(ii)=0.0d0
      end do
      x(icomp)=1.0d0

c calculate background chi at 1.5 * Tc
      tr=1.5d0*Tc
      Denred=wmm*rho/Denc
c added 4/28/08 RP
      if (tr.lt.tk) tr = tk

c calculate isothermal compressibility at T and RHO in units (1/MPa)
      call DPDDK (icomp,tk,rho,dpdrho_kpa)
      call DPDDK (icomp,tk,rho,dpdrhok)
c     drhodp_kpa=1.0d0/dpdrhok
      dpdrho_mpa=dpdrho_kpa/1000.0d0
      tisocomp=1.0d0/rho/dpdrho_mpa
c calculate isothermal compressibility at TR and RHO in units (1/MPa)
      call PRESS (tr,rho,x,pkpa_r)
      !pmpa_r=pkpa_r/1000.0d0
c set reference compressibility to zero if P at TR >1000 MPa (EOS Pressure Limit)
      !if (pmpa_r.gt.1000.0d0) then
      !  tisocompr = 0.0d0
      !else
        call DPDDK (icomp,tr,rho,dpdrho_r_kpa)
        call DPDDK (icomp,tr,rho,dpdrhok)
c       drhodp_r_kpa=1.0d0/dpdrhok
        dpdrho_r_mpa=dpdrho_r_kpa/1000.0d0
        tisocompr=1.0d0/rho/dpdrho_r_mpa
      !end if
c calculate difference in reduced chi at (T,RHO) and (TR,RHO)
      delchi_red=Pc*Denred**2*(tisocomp-tisocompr*tr/tk)
      IF(delchi_red.lt.0.0d0) then
        delchi_red=0.0d0
        xi_fun=0.0d0
      else
c calculate correlation length in meters
        xi_fun=xi0*(delchi_red/gammaplus)**(exnu/exgamma)
      endif
      return
      end                                               !function XI_FUN
c
      function ETA_C2 (xi)
c     auxiliary functions for computing the critical enhancement of viscosity of water
c     "New International Formulation for the viscosity of water"
c     Huber, M.L., Perkins, R.A., Laesecke, A., Friend, D.G., Sengers, J.V., Assael, M.J.,
c     Metaxa, I.M., Vogel, E., Mares, R. and Miyagawa, K.
c     for submission to JPCRD, 2008
c
c     05/08/08 MLH based on code from RAP
c
      include 'commons.for'
      include 'comtrn.for'
c     data Tc,Denc,Pc/647.096D0, 322.0D0, 22.064D0/
c     data etabkc,lamdabkc/39.3d-6,0.197d0/
      parameter (qcinv=1.9d-9, qdinv=1.1d-9)
c
c     New theoretical exponent for viscosity
      parameter (exeta=0.0680d0)
      qc=1.0d0/qcinv
      qd=1.0d0/qdinv

      if (xi .le. 0.0d0) then
        eta_c2 = 1.0d0
        return
      end if

c calculate the crossover function
      psid=ACOS(SQRT(1.0d0/(1.0d0+(qd*xi)**2)))
      w=SQRT(ABS((qc*xi-1.0d0)/(qc*xi+1.0d0)))*TAN(psid/2.0d0)
      if (qc*xi.gt.1.0d0) then
        funL=LOG((1.0d0+w)/(1.0d0-w))
      else
        funL=2.0d0*ATAN(ABS(w))
      end if
      qcxi2=(qc*xi)**2
      qcxi3=(qc*xi)**3
      if (xi.le.0.3734351887d-9) then
        Hcross=qc*xi*(qd*xi)**5/5.0d0 *
     &  (1.0d0 - qc*xi + qcxi2 - (765.0d0/504.0d0)*(qd*xi)**2)
      else
        Hcross=1.0d0/12.0d0*sin(3.0d0*psid)-1.0d0/(4.0d0*qc*xi)*
     &  sin(2.0d0*psid)+1.0d0/qcxi2*(1.0d0- 1.25d0*qcxi2)*sin(psid)-
     &  1.0d0/qcxi3*((1.0d0- 1.5d0*qcxi2)*psid-
     &  abs((qcxi2-1.0d0))**1.5d0*funL)
      end if

c calculate eta/eta_background (the enhancement)
      eta_c2 = exp(exeta*Hcross)
      return
      end                                               !function ETA_C2
c
c ======================================================================
c
      function ETAMEO (icomp,t,rhom)
c
c  viscosity model for methanol
c  Xiang, H.W., Huber, M.L. and Laesecke, A., "A New Reference
c  Correlation for the Viscosity of Methanol",
c  J. Phys. Chem. Ref. Data V35, No.4, 2006, pp. 1597-1620.
c
c  inputs:
c    icomp--component number in mixture (1..nc); 1 for pure fluid
c        t--temperature [K]
c      rhom--molar density [mol/L]
c  output (as function value):
c   etaMEOH--viscosity [uPa-s]
c
c  11.09.05 version based on code from HWX
c  05.17.11 change r to rd to avoid conflicts with gcnst
c
      include 'commons.for'
      include 'comtrn.for'
      dimension h(9),d(7),e(9)
c
      parameter (h=
     & (/-19.572881d0,219.73999d0,-1015.3226d0,2471.01251d0,
     &  -3375.1717d0,2491.6597d0,-787.26086d0,14.085455d0,-.34664158d0
     &  /))
      parameter (d=
     & (/-1.181909d0,0.5031030d0,-0.6268461d0,0.5169312d0,
     &  -0.2351349d0,5.3980235d-02,-4.9069617d-03/))
      parameter (e=
     & (/4.018368d0,-4.239180d0,2.245110d0,-0.5750698d0,
     &  2.3021026d-02,2.5696775d-02,-6.8372749d-03,7.2707189d-04,
     & -2.9255711d-05/))
      etaMEO=0.0d0
C     constants used in the correlation
      av=6.0221415d23
      ak=8.314472d0/av
      amm=32.04216d0 !value used in the methanol EOS
      am=amm/1000.0d0/av
c
      tc=512.6d0
      rc=273.0d0

c     convert from mol/l to kg/m3
      rho=rhom*amm

c     0-density parameters
      da0p=.3408d-9
      tcep=577.87d0
      delt=0.4575d0

c     B-coefficient parameters, the same as those of 0-density
      da0s=.3408d-9
      tces=577.87d0

c     C-coefficient parameters
      da0t=.43d-9
      tcet=440.0d0
      da0t=da0p
      tcet=tcep

      vmc=da0p
c     vmc is defined as in the critical-like viscosity
      vmc=(6.0d0/3.14159265d0*amm/rc/av/1000.0d0)**(1.0d0/3.0d0)

      rd=rho  !in kg/m3
      rr=rho/rc
      tr=t/tc
      tres=t/tces
      trep=t/tcep
      tret=t/tcet
      cf=1.0d0/(1.0d0+exp(5.0d0*(rr-1.0d0)))

C     calculate the hard sphere diameter, da, eq.16
      da=0.0d0
      do kk=1,7
        da=da+d(kk)/tr**(kk-1)
      enddo
      do mm=1,9
        da=da+e(mm)*(rr)**(mm)
      enddo
      da=da*vmc

      rd=amm/rho/1.0d3
       ele0=1.16145d0/trep**.14874d0+.52487d0/exp(.77320d0*trep)
     & +2.16178d0/exp(2.43787d0*trep)
       eled=0.10225d0/trep**.97346d0+.10657d0/exp(.34528d0*trep)
     & -.44557d0/exp(2.58055d0*trep)
       ele0=ele0*(1.0d0+delt**2/(1.0d0+0.95976d-3*delt**6)*eled)
       u0=5.0d0/16.0d0/da0p**2*am**.5d0*ak**.5d0*(T/3.14159265d0)**.5d0
     &  /ele0

c      B-coefficient,subcript,s
       bnr=h(1)+h(2)/tres**.25d0+h(3)/tres**.5d0+h(4)/tres**.75d0
     &  +h(5)/tres +h(6)/tres**1.25d0+h(7)/tres**1.5d0+h(8)/tres**2.5d0
     &  +h(9)/tres**5.5d0
       bn=bnr*av*da0s**3

c      C-coefficient,subcript,t
      cetar=18.6222085d-4*EXP(9.990338d0/tret**0.5d0)*tret**3
      cetam=cetar*(av*da0t**3)**2
      paa0=u0*(1.0d0+bn*rho/amm*1000.0d0+cetam*(rho/amm*1000.0d0)**2)
      b=2.0d0*3.14159265d0*av*da**3/3.0d0
      ay=b/4.0d0/rd
      gd=(1.0d0 -.5d0*ay)/(1.0d0-ay)**3
      ue0=1.0d0/gd+0.8d0*b/rd+.761d0*gd*(b/rd)**2
      paa=ue0*u0
      paf=cf*paa0+(1.0d0-cf)*paa
      etaMEO=paf *(1.0d6)

      return
      end                                               !function ETAMEO
c
c ======================================================================
c
      function ETASF6 (icomp,t,rho)
      implicit double precision (a-h,o-z)
      DIMENSION a(1:5,0:1)
      ! t(K), rho (mol/l), etasf6 (upa.s)
      !  sf6 viscosity correlation from Altunin,V.V.
      ! Equation for the viscosity of sulfur hexafluoride for a broad range of
      ! temperatures and pressures, Tr. Mosk. Energ. Inst. 1984, 622, pp12-18
      ! note: copy is very poor and difficult to read the coefficients
      a(1,0)=0.911990483d0
      a(2,0)=-0.362880599d1
      a(3,0)=0.468880707d1
      a(4,0)=-0.204822413d1
      a(5,0)=0.299289894d0
      a(1,1)=-0.798662631d0
      a(2,1)=0.548041104d1
      a(3,1)=-0.615316823d1
      a(4,1)=0.258614144d1
      a(5,1)=-0.369541671d0
      ! convert from nol/l to kg/m3
      d=rho*146.0554192d0
      tau=t/318.7d0
      del=d/738
      eta0=0.486+0.17075d2*tau-0.13976d1*tau**2
      sumi=0.0d0
      do i=1,5
      do j=0,1
        sumi=sumi+(a(i,j)*del**(i))/tau**j
      end do
      end do
      etasf6=eta0*EXP(sumi)
      end                                               !function ETASF6
c
c ======================================================================
c
      function ETAD2 (icomp,t,d)
c
c  unpublished model for the viscosity of deuterium by scaling
c  the normal hydrogen correlation from symbolic regression-
c  Muzny, C.D., Huber, M.L., and Kazakov, A.F.,
c  "Correlation for the Viscosity of normal hydrogen obtained from symbolic regression"
c  submitted to J. Chem. Eng. Data, 2013
c
c  inputs:
c    icomp--component number in mixture (1..nc); 1 for pure fluid
c        t--temperature [K]
c        d--molar density [mol/L]
c  output (as function value):
c     etad2--viscosity [uPa-s]
c
c  02-28-13   mlh, original
c
      implicit double precision (a-h,o-z)
      implicit integer (i-n)
      DIMENSION sma(0:4), beta(6)
      DATA sma(0), sma(1), sma(2), sma(3), sma(4)
     &  / 0.209630d0,-0.455274d0,
     &  0.143602d0, -0.335325d-01, 0.276981d-02 /     ! coeff to match moldover
      DATA beta(1), beta(2), beta(3),beta(4), beta(5), beta(6)
     &    /0.118757d-05, 0.536373d0, 0.759423d+01, 0.615343d+01,
     &    -0.193070d+01, 0.011d0 /
        ts=t/30.41d0
        sum1=0.0d0
        do i=0,4
        sum1=sum1+sma(i)*(LOG(Ts))**i
        end do
        sigmast=EXP(sum1)
        etadil=0.021357*SQRT(2.01588*t)/(0.297*0.297*sigmast)
        etadil=etadil*SQRT(2.) !multiply dilute by sqrt(2) (mw ratio)
        beta1=0.6022137*(-0.187+2.4871/(t/30.41)+3.7151/(t/30.41)**2
     &  -11.0972/(t/30.41)**3+9.0965/(t/30.41)**4-3.8292/(t/30.41)**5
     &  +0.5166/(t/30.41)**6)*(0.297**3)
        eta1=etadil*beta1*d  !uPa.s
        rhokg=d*2.01588
        visa=etadil+eta1
      IF(rhokg.gt.0)then
        tred=t/33.145
        dred=rhokg*0.011
        ! nov8 machine 37 optimized by andrei
        diff2 = 6.43449673d-03*dred**2*exp(4.56334068d-02*tred +
     &  2.32797868d-01/tred + 9.58326120d-01*dred**2/(1.27941189d-01
     &  + tred) +    3.63576595d-01*dred**6)
        etares=1000*diff2*1.18  !factor added to match van itterbeek liquid
      else
        etares=0
      endif
      etad2=visa+etares
      END                                                !function ETAD2
c
c        1         2         3         4         5         6         7
c23456789012345678901234567890123456789012345678901234567890123456789012
c
c ======================================================================
c                                                    end file trns_VIS.f
c ======================================================================
c  begin file utility.f
c
c  This file contains various utility subroutines to retrieve information
c  about the components.
c
c  contained here are:
c     subroutine INFO (icomp,wmm,ttrp,tnbpt,tc,pc,Dc,Zc,acf,dip,Rgas)
c     subroutine NAME (icomp,hnam,hn80,hcasn)
c     function WMOL (x)
c     subroutine XMASS (xmol,xkg,wmix)
c     subroutine XMOLE (xkg,xmol,wmix)
c     subroutine LIMITX (htyp,t,D,p,x,tmin,tmax,Dmax,pmax,ierr,herr)
c     subroutine LIMITK (htyp,icomp,t,D,p,tmin,tmax,Dmax,pmax,ierr,herr)
c     subroutine LIMITS (htyp,x,tmin,tmax,Dmax,pmax)
c     subroutine ERRMSG (ierr,herr)
c     subroutine QMASS (qmol,xl,xv,qkg,xlkg,xvkg,wliq,wvap,ierr,herr)
c     subroutine QMOLE (qkg,xlkg,xvkg,qmol,xl,xv,wliq,wvap,ierr,herr)
c     subroutine GOLD (x0i,x1i,ncc,lmax,z,z2,z3,z4,bt,xopt,yopt,ierr)
c     subroutine DOTFILL (x,ptest,filrat,ierr,herr)
c     function CBRTX (x)
c     subroutine MINP (n,xPnts,yPnts,xval,ierr,herr)
c     subroutine POLYN (n,xPnts,yPnts,xval,yval,ierr,herr)
c     subroutine LUDECOMP (n,maxn,aMatrix,cMatrix,ierr,herr)
c     subroutine PIVOT (n,maxn,j,iord,aMatrix,sdecomp)
c     subroutine CUBIC (a,z)
c     subroutine FITL (n,maxn,xPnts,yPnts,xval,yval,cmatrix,ierr,herr)
c     function UCASE (b,k)
c     subroutine IDCRV (d,x,t,ierr,herr)
c     subroutine BLCRV (d,x,t,ierr,herr)
c     subroutine JTCRV (d,x,t,ierr,herr)
c     subroutine JICRV (d,x,t,ierr,herr)
c     subroutine CSPLINE (n,xi,fi,coeff)
c     subroutine TRIDIAG (j,d,e,c,b,z)
c     subroutine SPLNROOT (isp,iderv,f,a,ierr,herr)
c     subroutine SPLNVAL (isp,iderv,a,f,ierr,herr)
c     subroutine CSPLNVAL (n,xi,fi,coeff,x,f,ierr,herr)
c     subroutine MINEIGEN (n,a,u,xlamda,ierr,herr)
c     subroutine PASSCMN (hvr,iset,icomp,jcomp,
c    &                    hstr,ilng,dbl,arr,ierr,herr)
c
c ======================================================================
c ======================================================================
c
      subroutine INFO (icomp,wmm,ttrp,tnbpt,tc,pc,Dc,Zc,acf,dip,Rgas)
c
c  provides fluid constants for specified component
c
c  input:
c    icomp--component number in mixture; 1 for pure fluid
c  outputs:
c      wmm--molecular weight [g/mol]
c     ttrp--triple point temperature [K]
c    tnbpt--normal boiling point temperature [K]
c       tc--critical temperature [K]
c       pc--critical pressure [kPa]
c       Dc--critical density [mol/L]
c       Zc--compressibility at critical point [pc/(Rgas*Tc*Dc)]
c      acf--acentric factor [-]
c      dip--dipole moment [debye]
c     Rgas--gas constant [J/mol-K]
c
c  written by M. McLinden, NIST Thermophysics Division, Boulder, Colorado
c  01-31-97  MM, original version
c  02-19-97  MM, add check that input icomp is within bounds
c  10-02-97  MM, add compiler switch to allow access by DLL
c  12-01-98 EWL, add Reos and triple point pressure and density to /CCON/
c  03-08-00 EWL, change names of inputs to avoid conflicts with CCON
c
cx DEC$ ATTRIBUTES DLLEXPORT :: INFO
c
      include 'commons.for'
c
      if (abs(icomp).le.nc) then
        wmm=wmas(icomp)
        ttrp=ttpn(icomp)
        tnbpt=tnbp(icomp)
        tc=tcrit(icomp)
        pc=pcrit(icomp)
        Dc=Dcrit(icomp)
        Zc=Zcrit(icomp)
        acf=accen(icomp)
        dip=dipole(icomp)
        Rgas=R
      else
        wmm=0.0d0
        ttrp=0.0d0
        tnbpt=0.0d0
        tc=0.0d0
        pc=0.0d0
        Dc=0.0d0
        Zc=0.0d0
        acf=0.0d0
        dip=0.0d0
        Rgas=R
      end if
c
      RETURN
      end                                               !subroutine INFO
c
c ======================================================================
c
      subroutine NAME (icomp,hnam,hn80,hcasn)
c
c  provides name information for specified component
c
c  input:
c    icomp--component number in mixture; 1 for pure fluid
c  outputs:
c     hnam--component name [character*12]
c     hn80--component name--long form [character*80]
c    hcasn--CAS (Chemical Abstracts Service) number [character*12]
c
c  written by M. McLinden, NIST Thermophysics Division, Boulder, Colorado
c  02-06-97  MM, original version
c  02-19-97  MM, add check that input icomp is within bounds
c  10-02-97  MM, add compiler switch to allow access by DLL
c  12-01-97  MM, add synonyms to /CNAM80/
c
cx DEC$ ATTRIBUTES DLLEXPORT :: NAME
c
      include 'commons.for'
      character*12 hnam,hcasn
      character*80 hn80
c
      if (abs(icomp).le.nc) then
        hnam=hname(icomp)
        hn80=hnam80(icomp)(1:80)
        hcasn=hcas(icomp)
      else
        hnam='not defined'
        hn80='not defined                             '//
     &       '                                        '
        hcasn='not defined'
      end if
c
      RETURN
      end                                               !subroutine NAME
c
c ======================================================================
c
      function WMOL (x)
c
c  molecular weight for a mixture of specified composition
c
c  input:
c        x--composition array [array of mol frac]
c
c  output (as function value):
c     WMOL--molar mass [g/mol], a.k.a. "molecular weight"
c
c  written by M. McLinden, NIST Thermophysics Division, Boulder, Colorado
c  01-10-96  MM, original version
c  02-27-96  MM, parameter n0=-ncmax to accommodate ECS-thermo model
c                add Zcrit to common /CCON/
c  03-19-96  MM, add dipole moment to /CCON/
c  10-02-97  MM, add compiler switch to allow access by DLL
c  12-01-98 EWL, add Reos and triple point pressure and density to /CCON/
c  12-02-98 EWL, remove compositional dependence for pure fluids
c
cx DEC$ ATTRIBUTES DLLEXPORT :: WMOL
c
      include 'commons.for'
      dimension x(ncmax)
c
      call ISPURE (x,icomp)
      if (icomp.ne.0) then
        WMOL=wmas(icomp)
      else
        wsum=0.0d0
        do i=1,nc
          wsum=wsum+x(i)*wmas(i)
        enddo
        WMOL=wsum
      endif
c
      RETURN
      end                                                 !function WMOL
c
c ======================================================================
c
      subroutine XMASS (xmol,xkg,wmix)
c
c  converts composition on a mole fraction basis to mass fraction
c
c  input:
c     xmol--composition array [array of mol frac]
c  outputs:
c      xkg--composition array [array of mass frac]
c     wmix--molar mass of the mixture [g/mol], a.k.a. "molecular weight"
c
c  written by M. McLinden, NIST Thermophysics Division, Boulder, Colorado
c  04-08-96  MM, original version
c  10-02-97  MM, add compiler switch to allow access by DLL
c  12-01-98 EWL, add Reos and triple point pressure and density to /CCON/
c
cx DEC$ ATTRIBUTES DLLEXPORT :: XMASS
c
      include 'commons.for'
      dimension xmol(ncmax),xkg(ncmax),xsumi(ncmax)
c
      call ISPURE (xmol,icomp)
      if (icomp.ne.0) then
        wmix=wmas(icomp)
        do i=1,nc
          xkg(i)=0.d0
        enddo
        xkg(icomp)=1.d0
        RETURN
      endif
      xsum=0.0d0
      do i=1,nc
        xsumi(i)=xmol(i)*wmas(i)
        xsum=xsum+xsumi(i)
      enddo
      wmix=xsum
      xsinv=1.d0
      if (ABS(xsum).gt.1.0d-10) xsinv=1.0d0/xsum
      do i=1,nc
        xkg(i)=xsumi(i)*xsinv
      enddo
c
      RETURN
      end                                              !subroutine XMASS
c
c ======================================================================
c
      subroutine XMOLE (xkg,xmol,wmix)
c
c  converts composition on a mass fraction basis to mole fraction
c
c  input:
c      xkg--composition array [array of mass frac]
c  outputs:
c     xmol--composition array [array of mol frac]
c     wmix--molar mass of the mixture [g/mol], a.k.a. "molecular weight"
c
c  written by M. McLinden, NIST Thermophysics Division, Boulder, Colorado
c  04-08-96  MM, original version
c  10-02-97  MM, add compiler switch to allow access by DLL
c  12-01-98 EWL, add Reos and triple point pressure and density to /CCON/
c  10-24-02 EWL, set xmol=1 for a pure fluid
c
cx DEC$ ATTRIBUTES DLLEXPORT :: XMOLE
c
      include 'commons.for'
      dimension xmol(ncmax),xkg(ncmax),xsumi(ncmax)
c
      call ISPURE (xkg,icomp)
      if (icomp.ne.0) then
        wmix=wmas(icomp)
        do i=1,nc
          xmol(i)=0.d0
        enddo
        xmol(icomp)=1.d0
        RETURN
      endif
      xsum=0.0d0
      wsum=0.0d0
      do i=1,nc
        xsumi(i)=xkg(i)/wmas(i)
        xsum=xsum+xsumi(i)
      enddo
      wmix=xsum
      xsinv=1.d0
      if (ABS(xsum).gt.1.0d-10) xsinv=1.0d0/xsum
      do i=1,nc
        xmol(i)=xsumi(i)*xsinv
        wsum=wsum+xmol(i)*wmas(i)
      enddo
      wmix=wsum
c
      RETURN
      end                                              !subroutine XMOLE
c
c ======================================================================
c
      subroutine LIMITX (htyp,t,D,p,x,tmin,tmax,Dmax,pmax,ierr,herr)
c
c  returns limits of a property model as a function of composition
c  and/or checks input t, D, p against those limits
c
c  Pure fluid limits are read in from the .fld files; for mixtures, a
c  simple mole fraction weighting in reduced variables is used.
c
c  Attempting calculations below the minimum temperature and/or above
c  the maximum density will result in an error.  These will often
c  correspond to a physically unreasonable state; also many equations of
c  state do not extrapolate reliably to lower T's and higher D's.
c
c  A warning is issued if the temperature is above the maximum but below
c  1.5 times the maximum; similarly pressures up to twice the maximum
c  result in only a warning. Most equations of state may be
c  extrapolated to higher T's and P's.  Temperatures and/or pressures
c  outside these extended limits will result in an error.
c
c  When calling with an unknown temperature, set t to -1 to avoid performing
c  the melting line check
c
c  inputs:
c     htyp--flag indicating which models are to be checked [character*3]
c           'EOS':  equation of state for thermodynamic properties
c           'ETA':  viscosity
c           'TCX':  thermal conductivity
c           'STN':  surface tension
c        t--temperature [K]
c        D--molar density [mol/L]
c        p--pressure [kPa]
c        x--composition array [mol frac]
c     N.B.--all inputs must be specified, if one or more are not
c           available, (or not applicable as in case of surface tension)
c           use reasonable values, such as:
c           t = tnbp
c           D = 0
c           p = 0
c  outputs:
c     tmin--minimum temperature for model specified by htyp [K]
c     tmax--maximum temperature [K]
c     Dmax--maximum density [mol/L]
c     pmax--maximum pressure [kPa]
c     ierr--error flag:  0 = all inputs within limits
c                      <>0 = one or more inputs outside limits:
c                       -1 = 1.5*tmax > t > tmax
c                        1 = t < tmin or t > 1.5*tmax
c                        2 = D > Dmax or D < 0
c                       -4 = 2*pmax > p > pmax
c                        4 = p < 0 or p > 2*pmax
c                        8 = component composition < 0 or > 1
c                            and/or composition sum < 0 or > 1
c                       16 = p>pmelt
c                      -16 = t<ttrp (important for water)
c           if multiple inputs are outside limits, ierr = abs[sum(ierr)]
c           with the sign determined by the most severe excursion
c           (ierr > 0 indicate an error--calculations not possible,
c            ierr < 0 indicate a warning--results may be questionable)
c     herr--error string (character*255 variable if ierr<>0)
c
c  written by M. McLinden, NIST Thermophysics Division, Boulder, Colorado
c  05-30-96  MM, original version
c  06-03-96  MM, p > 2*pmax and t > 1.5*tmax result in error
c                add htyp to argument list
c  02-21-97  MM, add checks for viscosity and thermal conductivity
c  06-03-97  MM, initialize ierr = 0 and herr = hnull
c  06-04-97 EWL, zero delsum and xsum before do loop
c  06-17-97  MM, change format on xsum error
c  10-02-97  MM, add compiler switch to allow access by DLL
c  12-05-97  MM, x(i) missing in summation for max density
c  12-01-98 EWL, add Reos and triple point pressure and density to /CCON/
c  12-01-98 EWL, reduce Tmin for mixtures by 5 degrees
c  12-01-98 EWL, reduce Tmin by 1.0d-10 to avoid machine precision problems
c  12-22-98 EWL, add ammonia-water triple-point line
c  03-05-99 EWL, add checks for melting line pressure and sublimation pressure
c  09-02-99 EWL, increase check for p>pmelt by pmelt+.0001
c  10-12-99 EWL, add transport limits for the ECS model
c  10-20-99 EWL, change herrx to 140 to accommodate full string
c  10-20-99 EWL, increased the tolerance in sum(x)<>1 for setup with single prec.
c  10-22-99 EWL, call new subroutine LIMITS to get tmin,tmax,dmax, and pmax
c  01-25-00 EWL, do not allow p>pmax for parahydrogen (bad Younglove EOS)
c  01-25-00 EWL, do not allow t>tmax for krypton (bad Juza EOS)
c  02-25-00 EWL, do not check p>pmax when t=-1
c  05-25-00 EWL, reorganize ltemp logic
c  05-25-00 EWL, remove old code for calculating pmlt
c  07-11-00 EWL, remove check on t>tmax for krypton, equation was replaced
c  11-20-01 EWL, check for t<ttrp
c  11-20-01 EWL, allow mixtures to go below ttrp by 25 degrees
c  06-30-04 EWL, allow mixtures to go below ttrp by 25 degrees only if Tc's
c                differ by more than 50 (thus, air is not included)
c  03-28-06 EWL, allow p>pmax for parahydrogen with new Leachman equation
c  10-05-07  HH, remove common block WLMETA
c
cx DEC$ ATTRIBUTES DLLEXPORT :: LIMITX
c
      include 'commons.for'
      logical lerr,lwarn,ltemp
      dimension x(ncmax)
      character*3 htyp
      character*75 herrt,herrd,herrp
      character*140 herrx
      character*255 herr
c
c  initialize flags and strings
c
c     write (*,*) ' LIMITX--entering with htyp,t = ',htyp,t
      ierr=0
      ierrt=0
      ierrd=0
      ierrp=0
      ierrx=0
      xsum=0.0d0
      herr=' '
      herrt=' '
      herrd=' '
      herrp=' '
      herrx=' '
      nchart=1
      nchard=1
      ncharp=1
      ncharx=1
      lerr=.false.
      lwarn=.false.
      pmlt=1.0d15
      call ISPURE (x,icomp)
c
      call LIMITS(htyp,x,tmin,tmax,Dmax,pmax)
      if (ABS(p).gt.1.0d-10 .and. t.gt.0) call MELTT(t,x,pmlt,ierr,herr)
c
c  Set EOS and transport routines so that they cannot be extrapolated
c  to lower temps
      ltemp=.true.
      if (htyp.eq.'STN' .or. htyp.eq.'stn') then
        ltemp=.false. !surface tension may be extrapolated to lower T's
      end if
c
      if (icomp.eq.0) then
c  general mixture case
        xsum=0.0d0
        do i=1,nc
          xsum=xsum+x(i)
          if (x(i).lt.-1.0d-10 .or. x(i).gt.1.0000000001d0) then
            lerr=.true.
            ierrx=8
          end if
        enddo
        if (xsum.lt.0.999999d0 .or. xsum.gt.1.000001d0) then
          lerr=.true.
          ierrx=8
        end if
      end if
c
c  check inputs against limits
c
      if (t.lt.tmin-1.0d-10 .and. abs(t+1.0d0).gt.1.d-15) then
        pm=0
        ierr=0
        tsub=0.d0
        if (icomp.ne.0) then
          if (t.lt.ttpn(icomp)) call SUBLT (t,x,pm,ierr,herr)
        else
c  set error number if p>pmelt.  If p=0, also set error number
          do i=1,nc-1
            do j=i+1,nc
              if (abs(tcrit(i)-tcrit(j)).gt.50) tsub=25.d0
            enddo
          enddo
        endif
        if (tsub.gt.0.d0) then
          call REDX (x,tred,Dred)
          if (tred.lt.200) tsub=5.d0
        endif
        if (ierr.ne.0 .or. p.gt.pm+1.0d-10 .or. p.lt.1.d-20) then
          if (icomp.ne.0 .or. t.lt.tmin-tsub) then
            if (ltemp) then
              lerr=.true.
              ierrt=1
            else
              lwarn=.true.
              ierrt=-1
            end if
            write (herrt,1010) t,tmin
            nchart=72
 1010       format (' temperature below lower limit, T =',g12.5,
     &              ' K, Tmin =',g12.5,' K;')
          endif
        endif
      else if (t.gt.1.5d0*tmax) then
        lerr=.true.
        ierrt=1
        write (herrt,1011) t,tmax
        nchart=74
 1011   format (' temperature > 1.5 x upper limit, T =',g12.5,
     &          ' K, Tmax =',g12.5,' K;')
      else if (t.gt.tmax) then
c       if (hcas(icomp).eq.'7439-90-9' .and. icomp.ne.0) then
c         lerr=.true.
c         ierrt=1
c       else
          lwarn=.true.
          ierrt=-1
c       endif
        write (herrt,1012) t,tmax
        nchart=72
 1012   format (' temperature above upper limit, T =',g12.5,
     &          ' K, Tmax =',g12.5,' K;')
      end if
      if (D.lt.0.0d0) then
        lerr=.true.
        ierrd=2
        write (herrd,1020) D
        nchard=37
 1020   format (' density < 0, D =',g12.5,' mol/L;')
      else if (D.gt.Dmax) then
        lerr=.true.
        ierrd=2
        write (herrd,1021) D,Dmax
        nchard=72
 1021   format (' density > upper limit, D =',g12.5,
     &          ' mol/L, Dmax =',g12.5,' mol/L;')
      end if
      if (p.lt.0.0d0) then
        lerr=.true.
        ierrp=4
        write (herrp,1040) p/1000.0d0
        ncharp=35
 1040   format (' pressure < 0, P =',g12.5,' MPa;')
      else if (p.gt.2.0d0*pmax) then
        lerr=.true.
        ierrp=4
        write (herrp,1042) p/1000.0d0,pmax/1000.0d0
        ncharp=73
 1042   format (' pressure > 2 x upper limit, P =',g12.5,
     &          ' MPa, Pmax =',g12.5,' MPa;')
      else if (p.gt.pmax+1.0d-8) then
        lwarn=.true.
        ierrp=-4
        write (herrp,1044) p/1000.0d0,pmax/1000.0d0
        ncharp=73
 1044   format (' pressure above upper limit, P =',g12.5,
     &          ' MPa, Pmax =',g12.5,' MPa;')
      end if
      if (p*0.9995d0.gt.pmlt .and. abs(pmlt).gt.1.d-20) then
        lerr=.true.
        ierrp=16
        write (herrp,1050) p/1000.0d0,pmlt/1000.0d0
        ncharp=74
 1050   format (' pressure > melting pressure, P =',g12.5,
     &          ' MPa, Pmelt =',g12.5,' MPa;')
      end if
      if (ierrx.ne.0) then
c       write (*,1080) xsum,(x(i),i=1,nc)
        write (herrx,1080) xsum,(x(i),i=1,MIN(nc,5))
        ncharx=131
 1080   format (' composition(s) out of range, Xsum =',f13.10,
     &          ' mol frac, X(i) =',5f13.10)
      end if
      if (icomp.ne.0) then
        if (t.lt.ttpn(icomp)-1.d-10 .and. ierrt.eq.0.and.t.gt.0.d0) then
c  check for cases where the temperature is less than the triple point
c  temperature, but still in a valid liquid region (like water between
c  251.165 and 273.16 K.)
          lwarn=.true.
          ierrt=-16
          write (herrt,1090) t,ttpn(icomp)
          nchart=73
 1090     format (' temperature less than triple point,',
     &          ' T=',g12.5,' K, Ttrp=',g12.5,' K;')
          if (hcas(icomp).eq.'7732-18-5' .and. abs(p).gt.1.d-20) then
            call MLTH2O (t,p1,p2)
            if (p.lt.p2*0.9999d0 .or. p.gt.p1/0.9999d0) then
              lerr=.true.
              ierrt=16
              write (herrt,1095)
              nchart=34
 1095   format (' inputs are within the solid phase;')
            endif
          endif
        endif
      endif
c
c  compose error string and compute overall value of ierr
c
      if (lerr .or. lwarn) then
c       write (*,*) ' LIMITX--nchart,d,p,x:',nchart,nchard,nchard,ncharx
c       write (*,1999) ' LIMITX--herrt: ',herrt(1:nchart)
c       write (*,1999) ' LIMITX--herrd: ',herrd(1:nchard)
c       write (*,1999) ' LIMITX--herrp: ',herrp(1:ncharp)
c       write (*,1999) ' LIMITX--herrx: ',herrx(1:ncharx)
c1999   format (1x,a16,a80)
c       write (*,*) ' LIMITX--#char: t,d,p,x,sum:  ',nchart,nchard,
c    &              ncharp,ncharx,nchart+nchard+ncharp+ncharx
        herr='one or more inputs are out of range: '//herrt(1:nchart)
     &      //herrd(1:nchard)//herrp(1:ncharp)//herrx(1:ncharx)
     &      //hnull
        if (lerr) then
          ierr=abs(ierrt)+abs(ierrd)+abs(ierrp)+abs(ierrx)
        else if (lwarn) then
          ierr=-abs(ierrt)-abs(ierrd)-abs(ierrp)-abs(ierrx)
        end if
        call ERRMSG (ierr,herr)
      end if
c
      RETURN
      end                                             !subroutine LIMITX
c
c ======================================================================
c
      subroutine LIMITK (htyp,icomp,t,D,p,tmin,tmax,Dmax,pmax,ierr,herr)
c
c  returns limits of a property model (read in from the .fld files) for
c  a mixture component and/or checks input t, D, p against those limits
c
c  This routine functions in the same manner as LIMITX except that the
c  composition x is replaced by the component number icomp.
c
c  Attempting calculations below the minimum temperature and/or above
c  the maximum density will result in an error.  These will often
c  correspond to a physically unreasonable state; also many equations of
c  state do not extrapolate reliably to lower T's and higher D's.
c
c  A warning is issued if the temperature is above the maximum but below
c  1.5 times the maximum; similarly pressures up to twice the maximum
c  result in only a warning. Most equations of state may be
c  extrapolated to higher T's and P's.  Temperatures and/or pressures
c  outside these extended limits will result in an error.
c
c  inputs:
c     htyp--flag indicating which models are to be checked [character*3]
c           'EOS':  equation of state for thermodynamic properties
c           'ETA':  viscosity
c           'TCX':  thermal conductivity
c           'STN':  surface tension
c    icomp--component number in mixture; 1 for pure fluid
c        t--temperature [K]
c        D--molar density [mol/L]
c        p--pressure [kPa]
c     N.B.--all inputs must be specified, if one or more are not
c           available, (or not applicable as in case of surface tension)
c           use reasonable values, such as:
c           t = tnbp
c           D = 0
c           p = 0
c  outputs:
c     tmin--minimum temperature for model specified by htyp [K]
c     tmax--maximum temperature [K]
c     Dmax--maximum density [mol/L]
c     pmax--maximum pressure [kPa]
c     ierr--error flag:  0 = all inputs within limits
c                      <>0 = one or more inputs outside limits:
c                       -1 = 1.5*tmax > t > tmax
c                        1 = t < tmin or t > 1.5*tmax
c                        2 = D > Dmax or D < 0
c                       -4 = 2*pmax > p > pmax
c                        4 = p < 0 or p > 2*pmax
c                       16 = p>pmelt
c                      -16 = t<ttrp (important for water)
c           if multiple inputs are outside limits, ierr = abs[sum(ierr)]
c           with the sign determined by the most severe excursion
c           (ierr > 0 indicate an error--calculations not possible,
c            ierr < 0 indicate a warning--results may be questionable)
c     herr--error string (character*255 variable if ierr<>0)
c
c  written by M. McLinden, NIST Thermophysics Division, Boulder, Colorado
c  03-18-97  MM, original version; based on LIMITX
c  06-03-97  MM, initialize ierr = 0 and herr = hnull
c  10-02-97  MM, add compiler switch to allow access by DLL
c  12-01-98 EWL, add Reos and triple point pressure and density to /CCON/
c  12-01-98 EWL, reduce Tmin by 1.0d-10 to avoid machine precision problems
c  10-12-99 EWL, add transport limits for the ECS model
c  10-22-99 EWL, add checks for melting line pressure and sublimation pressure
c  08-16-00 EWL, add dimension x(ncmax)
c  11-20-01 EWL, check for t<ttrp
c
cx DEC$ ATTRIBUTES DLLEXPORT :: LIMITK
c
      include 'commons.for'
      include 'comtrn.for'
      logical lerr,lwarn,ltemp
      character*3 htyp
      character*75 herrt,herrd,herrp
      character*120 herrx
      character*255 herr
c
c  initialize flags and strings
c
c     write (*,*) ' LIMITK--entering with htyp,t = ',htyp,t
      ierr=0
      ierrt=0
      ierrd=0
      ierrp=0
      herr=' '
      herrt=' '
      herrd=' '
      herrp=' '
      herrx=' '
      nchart=1
      nchard=1
      ncharp=1
      ncharx=1
      lerr=.false.
      lwarn=.false.
      i=icomp
c
      pmlt=0.0d0
      if (htyp.eq.'EOS' .or. htyp.eq.'eos') then
c  equation of state
        ltemp=.true.       !EOS cannot be extrapolated to lower temps
        tmin=tmeos(i)
        tmax=txeos(i)
        Dmax=Deos(i)
        pmax=peos(i)
        if (d.gt.dtpn(icomp) .or. ABS(d).lt.1.0d-10) then
          if (t.gt.tmeos(icomp).and.ABS(p).gt.1.0d-10) then
            call MELTK (icomp,t,pmlt,ierr,herr)
          end if
        endif
      else if (htyp.eq.'STN' .or. htyp.eq.'stn') then
c  surface tension model
        ltemp=.false.     !STN may be extrapolated to lower temps
        tmin=tminst(i)
        tmax=tmaxst(i)
        Dmax=-9.99d99     !density and pressure limits not applicable
        pmax=-9.99d99     !for surface tension--set to large number
      else if (htyp.eq.'TCX' .or. htyp.eq.'tcx') then
c  thermal conductivity
        ltemp=.true.    !transport cannot be extrapolated to lower temps
        tmin=tmtcx(i)
        tmax=txtcx(i)
        Dmax=Dxtcx(i)
        pmax=pxtcx(i)
      else if (htyp.eq.'ETA' .or. htyp.eq.'eta') then
c  viscosity
        ltemp=.true.    !transport cannot be extrapolated to lower temps
        tmin=tmeta(i)
        tmax=txeta(i)
        Dmax=Dxeta(i)
        pmax=pxeta(i)
      else
c  unknown model specification--use EOS limits
        ltemp=.true.
        tmin=tmeos(i)
        tmax=txeos(i)
        Dmax=Deos(i)
        pmax=peos(i)
      end if
c
c  check inputs against limits
c
      if (t.lt.tmin-1.0d-10 .and. abs(t).gt.1.d-20) then
        ierr=0
        if (i.ne.0) call SUBLK (icomp,t,pm,ierr,herr)
c  set error number if p>pmelt.  If p=0, also set error number
        if (ierr.ne.0 .or. p.gt.pm+1.0d-10 .or. p.lt.1.d-20) then
          if (ltemp) then
            lerr=.true.
            ierrt=1
          else
            lwarn=.true.
            ierrt=-1
          end if
          write (herrt,1010) t,tmin
          nchart=72
 1010     format (' temperature below lower limit, T =',g12.5,
     &            ' K, Tmin =',g12.5,' K;')
        endif
      else if (t.gt.1.5d0*tmax) then
        lerr=.true.
        ierrt=1
        write (herrt,1011) t,tmax
        nchart=74
 1011   format (' temperature > 1.5 x upper limit, T =',g12.5,
     &          ' K, Tmax =',g12.5,' K;')
      else if (t.gt.tmax) then
c       if (hcas(icomp).eq.'7439-90-9') then
c         lerr=.true.
c         ierrt=1
c       else
          lwarn=.true.
          ierrt=-1
c       endif
        write (herrt,1012) t,tmax
        nchart=72
 1012   format (' temperature above upper limit, T =',g12.5,
     &          ' K, Tmax =',g12.5,' K;')
      end if
      if (D.lt.0.0d0) then
        lerr=.true.
        ierrd=2
        write (herrd,1020) D
        nchard=37
 1020   format (' density < 0, D =',g12.5,' mol/L;')
      else if (D.gt.Dmax) then
        lerr=.true.
        ierrd=2
        write (herrd,1021) D,Dmax
        nchard=72
 1021   format (' density > upper limit, D =',g12.5,
     &          ' mol/L, Dmax =',g12.5,' mol/L;')
      end if
      if (p.lt.0.0d0) then
        lerr=.true.
        ierrp=4
        write (herrp,1040) p/1000.0d0
        ncharp=35
 1040   format (' pressure < 0, P =',g12.5,' MPa;')
      else if (p.gt.2.0d0*pmax) then
        lerr=.true.
        ierrp=4
        write (herrp,1042) p/1000.0d0,pmax/1000.0d0
        ncharp=73
 1042   format (' pressure > 2 x upper limit, P =',g12.5,
     &          ' MPa, Pmax =',g12.5,' MPa;')
      else if (p.gt.pmax+1.0d-8) then
        if (hcas(icomp).eq.'1333-74-0p') then
          lerr=.true.
          ierrp=4
        else
          lwarn=.true.
          ierrp=-4
        endif
        write (herrp,1044) p/1000.0d0,pmax/1000.0d0
        ncharp=73
 1044   format (' pressure above upper limit, P =',g12.5,
     &          ' MPa, Pmax =',g12.5,' MPa;')
      end if
      if (p*0.9995d0.gt.pmlt .and. abs(pmlt).gt.1.d-20) then
        lerr=.true.
        ierrp=16
        write (herrp,1050) p/1000.0d0,pmlt/1000.0d0
        ncharp=74
 1050   format (' pressure > melting pressure, P =',g12.5,
     &          ' MPa, Pmelt =',g12.5,' MPa;')
      end if
c
      if (icomp.ne.0) then
        if (t.lt.ttpn(icomp)-1.d-10 .and. ierrt.eq.0.and.t.gt.0.d0) then
c  check for cases where the temperature is less than the triple point
c  temperature, but still in a valid liquid region (like water between
c  251.165 and 273.16 K.)
          lwarn=.true.
          ierrt=-16
          write (herrt,1090) t,ttpn(icomp)
          nchart=73
 1090     format (' temperature less than triple point,',
     &          ' T=',g12.5,' K, Ttrp=',g12.5,' K;')
          if (hcas(icomp).eq.'7732-18-5' .and. abs(p).gt.1.d-20) then
            call MLTH2O (t,p1,p2)
            if (p.lt.p2 .or. p.gt.p1) then
              lerr=.true.
              ierrt=16
              write (herrt,1095)
              nchart=34
 1095   format (' inputs are within the solid phase;')
            endif
          endif
        endif
      endif
c
c  compose error string and compute overall value of ierr
c
      if (lerr .or. lwarn) then
c       write (*,*) ' LIMITK--nchart,d,p,x:',nchart,nchard,nchard,ncharx
c       write (*,1999) ' LIMITK--herrt: ',herrt(1:nchart)
c       write (*,1999) ' LIMITK--herrd: ',herrd(1:nchard)
c       write (*,1999) ' LIMITK--herrp: ',herrp(1:ncharp)
c       write (*,1999) ' LIMITK--herrx: ',herrx(1:ncharx)
c1999   format (1x,a16,a80)
c       write (*,*) ' LIMITK--#char: t,d,p,x,sum:  ',nchart,nchard,
c    &              ncharp,ncharx,nchart+nchard+ncharp+ncharx
        herr='one or more inputs are out of range: '//herrt(1:nchart)
     &      //herrd(1:nchard)//herrp(1:ncharp)//herrx(1:ncharx)
     &      //hnull
        if (lerr) then
          ierr=abs(ierrt)+abs(ierrd)+abs(ierrp)
        else if (lwarn) then
          ierr=-abs(ierrt)-abs(ierrd)-abs(ierrp)
        end if
        call ERRMSG (ierr,herr)
      end if
c
      RETURN
      end                                             !subroutine LIMITK
c
c ======================================================================
c
      subroutine LIMITS (htyp,x,tmin,tmax,Dmax,pmax)
c
c  returns limits of a property model as a function of composition
c
c  Pure fluid limits are read in from the .fld files; for mixtures, a
c  simple mole fraction weighting in reduced variables is used.
c
c  inputs:
c     htyp--flag indicating which models are to be checked [character*3]
c           'EOS':  equation of state for thermodynamic properties
c           'ETA':  viscosity
c           'TCX':  thermal conductivity
c           'STN':  surface tension
c        x--composition array [mol frac]
c  outputs:
c     tmin--minimum temperature for model specified by htyp [K]
c     tmax--maximum temperature [K]
c     Dmax--maximum density [mol/L]
c     pmax--maximum pressure [kPa]
c
c  written by E.W. Lemmon, NIST Thermophysics Division, Boulder, Colorado
c  10-22-99 EWL, original version
c  04-21-08 EWL, do not subtract 5 K if tmin<10 K
c  02-28-13 EWL, add dmax = dens(Ttrp) for htyp='TRP'
c
cx DEC$ ATTRIBUTES DLLEXPORT :: LIMITS
c
      include 'commons.for'
      include 'comtrn.for'
      dimension x(ncmax)
      dimension tred(ncmax),Dred(ncmax)
      dimension tmn(ncmax),tmx(ncmax),Dmx(ncmax),pmx(ncmax)
      character*3 htyp
c
      if (htyp.eq.'EOS' .or. htyp.eq.'eos') then
c  equation of state
        do i=1,nc
          tmn(i)=tmeos(i)
          tmx(i)=txeos(i)
          Dmx(i)=Deos(i)
          pmx(i)=peos(i)
        enddo
      elseif (htyp.eq.'TRP' .or. htyp.eq.'trp') then
c  equation of state but with maximum density equal to the triple point density
        do i=1,nc
          tmn(i)=tmeos(i)
          tmx(i)=txeos(i)
          pmx(i)=peos(i)
          Dmx(i)=Deos(i)
          if (dtpn(i).gt.0.1d0) Dmx(i)=dtpn(i)
        enddo
      else if (htyp.eq.'STN' .or. htyp.eq.'stn') then
c  surface tension model
        do i=1,nc
          tmn(i)=tminst(i)
          tmx(i)=tmaxst(i)
          Dmx(i)=9.99d99     !density and pressure limits not applicable
          pmx(i)=9.99d99     !for surface tension--set to large number
c         write (*,*) ' LIMITX-STN; i,Tmin,Tmax: ',i,tmn(i),tmx(i)
        enddo
      else if (htyp.eq.'TCX' .or. htyp.eq.'tcx') then
c  thermal conductivity
        do i=1,nc
          tmn(i)=tmtcx(i)
          tmx(i)=txtcx(i)
          Dmx(i)=Dxtcx(i)
          pmx(i)=pxtcx(i)
          if (htcx(i).eq.'ECS') then
            tmn(i)=tmecst(i)
            tmx(i)=txecst(i)
            Dmx(i)=Dxecst(i)
            pmx(i)=pxecst(i)
          endif
        enddo
      else if (htyp.eq.'ETA' .or. htyp.eq.'eta') then
c  viscosity
        do i=1,nc
          tmn(i)=tmeta(i)
          tmx(i)=txeta(i)
          Dmx(i)=Dxeta(i)
          pmx(i)=pxeta(i)
          if (heta(i).eq.'ECS') then
            tmn(i)=tmecst(i)
            tmx(i)=txecst(i)
            Dmx(i)=Dxecst(i)
            pmx(i)=pxecst(i)
          endif
        enddo
      else
c  unknown model specification--use EOS limits
        do i=1,nc
          tmn(i)=tmeos(i)
          tmx(i)=txeos(i)
          Dmx(i)=Deos(i)
          pmx(i)=peos(i)
        enddo
      end if
c
      call ISPURE (x,icomp)
      if (icomp.ne.0) then
c  special case--pure component
        tmin=tmn(icomp)
        tmax=tmx(icomp)
        Dmax=Dmx(icomp)
        pmax=pmx(icomp)
        if (hcas(icomp).eq.'7732-18-5' .and. tmin.gt.251.165d0)
     &      tmin=251.165d0
      else
c  general mixture case
        taumin=0.0d0
        taumax=0.0d0
        delmax=0.0d0
        pmax=0.0d0
        do i=1,nc
          tred(i)=tz(i)
          Dred(i)=rhoz(i)
          if (tmn(i).gt.0.d0) taumin=taumin+x(i)*tred(i)/tmn(i)
          if (tmx(i).gt.0.d0) taumax=taumax+x(i)*tred(i)/tmx(i)
          if (Dred(i).gt.0.d0) delmax=delmax+x(i)*Dmx(i)/Dred(i)
          pmax=pmax+x(i)*pmx(i)
        enddo
        call REDX (x,trmix,Drmix)
        Dmax=Drmix*delmax
        if (taumin.le.0.d0) taumin=100.d0
        if (taumax.le.0.d0) taumax=300.d0
        if (taumax.gt.0.d0) tmax=trmix/taumax
        if (taumin.gt.0.d0) then
          tmin=trmix/taumin
          if (tmin.gt.10.d0) tmin=tmin-5.d0
        endif
        if (tmin.lt.0.d0) tmin=100.d0
        if (tmax.lt.0.d0) tmax=300.d0
        if (iamwat.gt.0) then
          i=iamwat
          if (x(i).lt.0.33367d0) then
            tmin=273.16d0*(1.0d0-0.3439823d0*x(i)
     &          -1.3274271d0*x(i)**2-274.973d0*x(i)**7)
          elseif (x(i).lt.0.58396d0) then
            tmin=193.549d0*(1.0d0-4.987368d0*(x(i)-0.5d0)**2)
          elseif (x(i).lt.0.81473d0) then
            tmin=194.380d0*(1.0d0-4.886151d0*(x(i)-2.0d0/3.0d0)**2
     &          +10.37298d0*(x(i)-2.0d0/3.0d0)**3)
          else
            tmin=195.495d0*(1.0d0-0.323998d0*(1.0d0-x(i))
     &          -15.87560d0*(1.0d0-x(i))**4)
          endif
        endif
      end if
c
      RETURN
      end                                             !subroutine LIMITS
c ======================================================================
c
      subroutine ERRMSG (ierr,herr)
c
c  write error messages to default output; this subroutine should be
c  called immediately after any call to a subroutine which potentially
c  can error out
c
c  inputs:
c     ierr--error flag:  0 = successful (no message will be written)
c                       <0 = warning
c                       >0 = error
c     herr--error string (character*255 variable)
c
c  outputs:
c     if iprnterr in common block prnterr is equal to zero:
c     error string written to default output
c
c     if iprnterr is equal to 1:
c     error string written to screen if ierr is positive
c
c     if iprnterr is equal to -1:
c     error string written to screen
c
c     if iprnterr is equal to 3, -3:
c     same as 1, -1, but program also pauses
c
c     Note:  no information should be written to the screen
c     when compiling the DLL.
c
c  written by M. McLinden, NIST Thermophysics Division, Boulder, Colorado
c  09-11-95  MM, original version
c  07-30-96  MM, also write out the value of ierr
c  03-26-97 EWL, change name ERROR --> ERRMSG as 'error' is a standard
c                routine in Lahey Fortran90
c  10-02-97  MM, add compiler switch to allow access by DLL
c  12-01-98 EWL, add common block prterr
c  12-01-98 EWL, don't print extra spaces at end of herr
c  10-21-99 EWL, remove use of i outside of do loop
c  10-22-99 EWL, remove extra spaces before "K", "MPa", etc.
c  11-17-99  MM, new variable for printed message

cx DEC$ ATTRIBUTES DLLEXPORT :: ERRMSG
c
      include 'commons.for'
      character*255 herr,hout
      character*4 hstrg
c
      j=0
 100  continue
      i=index(herr,'   K')
      if (i.eq.0) i=index(herr,'   MPa')
      if (i.eq.0) i=index(herr,'   mol')
      if (i.eq.0) i=index(herr,'   J/mol')
      if (i.ne.0) then
        j=j+1
        herr=herr(1:i)//herr(i+3:255)
        if (j.lt.10) goto 100
      endif
      i=index(herr,'=0')
      if (i.ne.0) then
        j=j+1
        herr=herr(1:i)//' '//herr(i+1:255)
        if (j.lt.10) goto 100
      endif
      i=index(herr,';   ')
      if (i.ne.0) herr=herr(1:i-1)//herr(i+1:255)
      i=index(herr,'; '//hnull)
      if (i.ne.0) herr=herr(1:i-1)//herr(i+1:255)
      i=index(herr,';  '//hnull)
      if (i.ne.0) herr=herr(1:i-1)//herr(i+1:255)
c
      if (ierr.ne.0 .and. iprnterr.ne.0) then
        do i=255,1,-1
          if (herr(i:i).ne.' ' .and. herr(i:i).ne.hnull) then
            ilast=i
            goto 110
          end if
        enddo
        ilast=1
 110    continue
        write (hstrg,'(i4)') ierr
        if (ierr.gt.0 .or. iprnterr.lt.0) then
          hout=herr(1:ilast)//' (ierr='//hstrg//')'
          write (*,1000) hout
c         if (ABS(iprnterr).ge.2)  call error('Called')
c         if (ABS(iprnterr).ge.3)  pause
        end if
      end if
 1000 format (1x,a255)
c
      RETURN
      end                                             !subroutine ERRMSG
c
c ======================================================================
c
      subroutine QMASS (qmol,xl,xv,qkg,xlkg,xvkg,wliq,wvap,ierr,herr)
c
c  converts quality and composition on a mole basis to a mass basis
c
c  inputs:
c     qmol--molar quality [moles vapor/total moles]
c           qmol = 0 indicates saturated liquid
c           qmol = 1 indicates saturated vapor
c           0 < qmol < 1 indicates a two-phase state
c           qmol < 0 or qmol > 1 are not allowed and will result in warning
c       xl--composition of liquid phase [array of mol frac]
c       xv--composition of vapor phase [array of mol frac]
c  outputs:
c      qkg--quality on mass basis [mass of vapor/total mass]
c     xlkg--mass composition of liquid phase [array of mass frac]
c     xvkg--mass composition of vapor phase [array of mass frac]
c     wliq--molecular weight of liquid phase [g/mol]
c     wvap--molecular weight of vapor phase [g/mol]
c     ierr--error flag:  0 = all inputs within limits
c           -19:  input q < 0 or > 1
c     herr--error string (character*255 variable if ierr<>0)
c
c  written by M. McLinden, NIST Thermophysics Division, Boulder, Colorado
c  02-23-98  MM, original version, based on XMASS
c
cx DEC$ ATTRIBUTES DLLEXPORT :: QMASS
c
      include 'commons.for'
      dimension xl(ncmax),xv(ncmax),xlkg(ncmax),xvkg(ncmax)
      character*255 herr
      parameter (eps=1.0d-8)
c
      call XMASS (xl,xlkg,wliq)
      call XMASS (xv,xvkg,wvap)
      if (qmol.lt.-eps .or. qmol.gt.1.0d0+eps) then
        ierr=-19
        herr='[QMASS warning 19] input quality out of range'//hnull
        call ERRMSG (ierr,herr)
        qkg=qmol
      else
        ierr=0
        herr=' '
        qkg=qmol*wvap/(qmol*wvap+(1.0d0-qmol)*wliq)
      end if
c
      RETURN
      end                                              !subroutine QMASS
c
c ======================================================================
c
      subroutine QMOLE (qkg,xlkg,xvkg,qmol,xl,xv,wliq,wvap,ierr,herr)
c
c  converts quality and composition on a mass basis to a molar basis
c
c  inputs:
c      qkg--quality on mass basis [mass of vapor/total mass]
c           qkg = 0 indicates saturated liquid
c           qkg = 1 indicates saturated vapor
c           0 < qkg < 1 indicates a two-phase state
c           qkg < 0 or qkg > 1 are not allowed and will result in warning
c     xlkg--mass composition of liquid phase [array of mass frac]
c     xvkg--mass composition of vapor phase [array of mass frac]
c  outputs:
c     qmol--quality on mass basis [mass of vapor/total mass]
c       xl--molar composition of liquid phase [array of mol frac]
c       xv--molar composition of vapor phase [array of mol frac]
c     wliq--molecular weight of liquid phase [g/mol]
c     wvap--molecular weight of vapor phase [g/mol]
c     ierr--error flag:  0 = all inputs within limits
c           -19:  input q < 0 or > 1
c     herr--error string (character*255 variable if ierr<>0)
c
c  written by M. McLinden, NIST Thermophysics Division, Boulder, Colorado
c  02-23-98  MM, original version, based on XMOLE
c
cx DEC$ ATTRIBUTES DLLEXPORT :: QMOLE
c
      include 'commons.for'
      dimension xl(ncmax),xv(ncmax),xlkg(ncmax),xvkg(ncmax)
      character*255 herr
      parameter (eps=1.0d-8)
c
      call XMOLE (xlkg,xl,wliq)
      call XMOLE (xvkg,xv,wvap)
      if (qkg.lt.-eps .or. qkg.gt.1.0d0+eps) then
        ierr=-19
        herr='[QMOLE warning 19] input quality out of range'//hnull
        call ERRMSG (ierr,herr)
        qmol=qkg
      else
        ierr=0
        herr=' '
        qmol=qkg/wvap/(qkg/wvap+(1.0d0-qkg)/wliq)
      end if
c
      RETURN
      end                                              !subroutine QMOLE
c
c ======================================================================
c
      subroutine GOLD (x0i,x1i,ncc,lmax,z,z2,z3,z4,bt,xopt,yopt,ierr)
c
c  This subroutine carries out a Fibonnaci (golden) search
c  technique to locate an extremum (maximum or minimum) in a
c  function within a specified interval.
c
c  inputs:
c      x0i--lower bound of interval containing extremum
c      x1i--upper bound of interval containing extremum
c      ncc--number of function evaluations carried out;
c           the extremum is located with an interval of size:
c           (x1i - x0i)*0.618**ncc
c           (e.g. 29 evaluations required to reduce interval to 10**-6
c           of its original size)
c     lmax--logical flag; if lmax =
c           .true. -  locate maximum value
c           .false. - locate minimum value
c        z--composition array
c       z2--additional independent variable
c       z3--additional independent variable
c       z4--additional independent variable
c       bt--function type, 'H'-call ENTHAL, etc.
c  outputs:
c     xopt--location of extremum
c     yopt--value of function at extremum
c     ierr--integer output from external function (e.g. error flag)
c
c  taken from:
c    McLinden, M.O. (1988). Working fluid selection for space-based
c    two-phase heat transport systems. National Bureau of Standards,
c    NBSIR 88-3812.
c  by M. McLinden, NIST Chemical & Physical Properties Div, Boulder, CO
c  09-05-97  MM, transcribed from original reference, add additional comments
c                add z,z2,z3,z4 for passing to GEVAL
c  03-26-98  MM, make z an array (e.g. for passing composition)
c  01-19-01 EWL, remove external dependence
c
      include 'commons.for'
      logical lmax
      dimension z(ncmax)
      character*1 bt
      parameter (GR=0.61803398875d0)
c
c  routine always finds a maximum, so to locate a minimum multiply by -1
      ierr=0
      y38=0.d0
      if (lmax) then
        xmax=1.0d0
      else
        xmax=-1.0d0
      end if
      x0=x0i  !x0 stores the lower bound of interval containing extremum
      x1=x1i  !x0 stores the upper bound
      x62=x0+GR*(x1-x0)          !x62 is 62% of way across interval
      if (bt.eq.'H') then
        call ENTHAL (z2,x62,z,b)
      elseif (bt.eq.'E') then
        call ENERGY (z2,x62,z,b)
      elseif (bt.eq.'S') then
        call ENTRO (z2,x62,z,b)
      endif
      y62=xmax*b
c
      do ig=1,ncc
        x38=x0+(1.0d0-GR)*(x1-x0)  !x38 is 38% of way across interval
        if (bt.eq.'H') then
          call ENTHAL (z2,x38,z,b)
        elseif (bt.eq.'E') then
          call ENERGY (z2,x38,z,b)
        elseif (bt.eq.'s') then
          call ENTRO (z2,x38,z,b)
        endif
        y38=xmax*b
        if (y62.lt.y38) then
c  keep sub-interval containing maximum value of GEVAL
          x1=x62
          x62=x38
          y62=y38
        else
          x0=x1
          x1=x38
        end if
      enddo
c
      xopt=0.5d0*(x0+x1)
      yopt=xmax*MAX(y38,y62)
c
      RETURN
      end                                               !subroutine GOLD
c
c ======================================================================
c
      function UCASE (b,k)
c
c  Make all the characters in the string b uppercase, from the first
c  character to character k
c
      include 'commons.for'
      character ucase*255, a*255, b*(*)
c
      a=b
      do i=1,k
        j=ichar(a(i:i))
        if (j.gt.96 .and. j.le.122) j=j-32
        a(i:i)=char(j)
      enddo
      UCASE=a
      RETURN
      end                                                !function UCASE
c
c ======================================================================
c
      subroutine DOTFILL (x,ptest,filrat,ierr,herr)
c
c  Calculate filling ratio according to UN P200 document
c  Packing instructions for hazardous substances
c
c  Input
c    x         composition, mol fraction
c    ptest     test pressure, absolute kPa  (may also be output variable)
C
c  Output
c    filrat    filling ratio
c    ierr      error flag
c    herr      error message
c
c  Version 0.0   10.07.05
c
cx DEC$ ATTRIBUTES DLLEXPORT :: DOTFILL
c
      include 'commons.for'
      dimension x(ncmax),xliq(ncmax),xvap(ncmax),y(ncmax),z(ncmax)
      character herr*255
c
      herr=' '
      ierr=0
      rho0=999.10262d0 !kg/m3 at 15C, 0.101325 MPa (water)
      filrat=0.0d0
      ione=1
      ttest65=65.0d0+273.15d0
      ttest60=60.0d0+273.15d0
      ttest50=50.0d0+273.15d0

      if (iunflg(1).ne.1) then !do not allow calculations
        filrat=0.0d0
        ptest= 0.0d0
        ierr=1
        herr='User defined calculations not permitted for this fluid'
      else
c  obtain critical temperature to determine if fluid is high or low pressure
c  and get molecular weight of mixture
        call ISPURE (x,icomp)
        if (icomp.ne.0) then
          tcc=tcrit(icomp)
          wmx=wmas(icomp)
        else
          call CRTHMX (x,tcc,pcmix,Dcmix,ierr,herr)
          wmx=WMOL(x)
        endif
        tcc=tcc-273.15d0 !convert to C
c  get the saturation pressure at 65 C
        call SATT (ttest65,x,ione,psat65,dl,dv,xliq,xvap,ierr,herr)
c
c  begin procedure for low pressure fluids (tc<65C)
c  for these fluids, there is only one choice for test pressure- Psat at 65C
        if (tcc.gt.65.d0) then
c  obtain the density at 50C and saturation
          call SATT (ttest50,x,ione,p,dl,dv,xliq,xvap,ierr,herr)
          rhotest=0.95d0*dl !mol/L
c  perform first check; get sat liquid rho at 60C
          call SATT (ttest60,x,ione,p,dl,dv,xliq,xvap,ierr,herr)
          rhof60=dl !mol/L
c  select the lower of these two values as the fill density
          rhofill=MIN(rhof60,rhotest)
          rhofill=rhofill*wmx  !convert to kg/m3
          if (rho0.gt.0.d0) filrat=rhofill/rho0
          ptest=psat65 !kPa,abs remember to change to gauge for final results
        else
c  begin procedure for High pressure fluids (tc>65C)
          call TPFLSH (ttest65,ptest,z,D,Dl,Dv,x,y,q,e,h,s,cv,cp,w,
     &                 ierr,herr)
          rhof=d*wmx    !convert to kg/m3
          if (rho0.gt.0.d0) filrat=rhof/rho0
        endif
c
c     adjust to match accepted un values
        if (ntrmun(1).gt.0) then
          if (icomp.ne.0) filrat=filrat*prmUN(icomp,icomp)
        endif  !won't work for mixtures, must revise
c
c  test pressure must exceed saturation pressure at 65C
        if (ptest.lt.psat65) then
          ierr=-1
          herr='Test pressure must exceed saturation pressure at 65 C'
          ptest=psat65
          filrat=-999
        endif
      endif
      RETURN
      end                                            !subroutine DOTFILL
c
c ======================================================================
c
      function CBRTX (x)
c
c  cube root function--allows negative arguments
c
c  input:
c        x--value to be acted upon
c  output (as function value):
c     CBRTX--cube root of x
c
c  written by M. McLinden, NIST Thermophysics Division, Boulder, Colorado
c  08-25-97 MM, original version
c  11-06-01 MLH, changed name to CBRTX to be standard conforming.
c  09-29-04 MLH, fixed bug for neg arguments
c
      include 'commons.for'
c
      xa=ABS(x)
      xathrd=xa**thrd
      if (x.ge.0.0d0) then
        cbrtx=xathrd
      else
        cbrtx=-xathrd
      end if
c
      RETURN
      end                                                !function CBRTX
c
c ======================================================================
c
      subroutine MINP (n,xPnts,yPnts,xval,ierr,herr)
c
c  Find the minimum of a parabola.  If n=2, return x where y=0.
c
c  inputs:
c          n--number of data points
c      xPnts--array of n data points for the x-axis data
c      yPnts--array of n data points for the y-axis data
c  outputs:
c       xval--value of x where y is a minimum
c       ierr--error flag:   0 = successful
c       herr--error string (character*255 variable if ierr<>0)
c
c  written by E.W. Lemmon, NIST Thermophysics Division, Boulder, Colorado
c  05-18-10 EWL, original version
c
      include 'commons.for'
      dimension xPnts(3),yPnts(3)
      character herr*255
c
      ierr=0
      herr=' '
      nn=n
      xval=0.d0
 10   continue
      if (nn.eq.2) then
        if (yPnts(1).eq.yPnts(2)) then
          xval=xval/2.d0
          RETURN
        endif
        xval=xPnts(1)-yPnts(1)/(yPnts(1)-yPnts(2))*(xPnts(1)-xPnts(2))
      elseif (nn.eq.3) then
        xw=xPnts(2)-xPnts(3)
        xx=xPnts(3)-xPnts(1)
        xy=xPnts(1)-xPnts(2)
        If (xw*xx*xy.eq.0) goto 999
        xw=-(yPnts(1)*xw+yPnts(2)*xx+yPnts(3)*xy)/(xw*xx*xy)
        If (xy.eq.0 .or. xw.eq.0) goto 999
        xx=(yPnts(1)-yPnts(2))/xy-xw*(xPnts(1)+xPnts(2))
        xval=-xx/(2*xw)
c     Curvature is negative, so get root using linear solution
        if (xw.lt.0) then
          ierr=2
          herr='[MINP error 2] curvature of parabola is negative'//hnull
          goto 999
        endif
      else
        ierr=1
        herr='[MINP error 1] invalid inputs'//hnull
      endif
      if (xval.gt.100000) xval=100000
      if (xval.lt.-100000) xval=-100000
      RETURN
 999  continue
      nn=2
      goto 10
      end                                               !subroutine MINP
c
c ======================================================================
c
      subroutine POLYN (n,xPnts,yPnts,xval,yval,ierr,herr)
c
c  Calculate the polynomial given the n data points and return the value
c  yval at xval.
c
c  inputs:
c          n--number of data points
c      xPnts--array of n data points for the x-axis data
c      yPnts--array of n data points for the y-axis data
c       xval--value of x
c  outputs:
c       yval--value of y at x
c       ierr--error flag:   0 = successful
c       herr--error string (character*255 variable if ierr<>0)
c
c  written by E.W. Lemmon, NIST Thermophysics Division, Boulder, Colorado
c  11-28-12 EWL, original version
c
      include 'commons.for'
      dimension xPnts(*),yPnts(*),fdd(20,20)
      character herr*255
c
      ierr=0
      herr=' '
      yval=0.d0
      if (n.le.1 .or. n.gt.20) RETURN

      fdd(1:n,1)=ypnts(1:n)
      do j=2,n
        do i=1,n-j+1
          fdd(i,j)=0.d0
          xdiff=xpnts(i+j-1)-xpnts(i)
          if (abs(xdiff).gt.1.d-20)
     &        fdd(i,j)=(fdd(i+1,j-1)-fdd(i,j-1))/xdiff
        enddo
      enddo
      xt=1
      fa=fdd(1,1)
      do i=1,n-1
        xt=xt*(xval-xpnts(i))
        fa=fa+fdd(1,i+1)*xt
      enddo
      yval=fa
      RETURN
      end                                              !subroutine POLYN
c
c ======================================================================
c
      subroutine LUDECOMP (n,maxn,aMatrix,cMatrix,ierr,herr)
c
c  Use Lower-Upper decomposition to invert a 2-dimensional
c  array and solve for the roots, where [A][B]=[C]
c
c  inputs:
c          n--number of elements to solve
c       maxn--array size
c    aMatrix--input array [A] of size (maxn,maxn)
c    cMatrix--input array [C] of size (maxn)
c
c  outputs:
c    cMatrix--output array [B] of size (maxn)
c       ierr--error flag:   0 = successful
c       herr--error string (character*255 variable if ierr<>0)
c
c  written by E.W. Lemmon, NIST Thermophysics Division, Boulder, Colorado
c  01-01-92 EWL, original version
c  12-18-12 EWL, reverse order of Jacobian matrix
c
      include 'commons.for'
      dimension amatrix(maxn,maxn),cmatrix(maxn)
      dimension iord(100),ctemp(maxn),sdecomp(maxn)
      character herr*255
      common/iord/iord
c
      if (ierr.eq.-190) then
        iord(1)=1
        iord(2)=2
        iord(3)=3
        goto 10
      endif
      if (ierr.eq.-191) goto 10
      ierr=0
      herr=' '
      do i=1,n
        iord(i)=i
        sdecomp(i)=Abs(aMatrix(i,1))
        do j=2,n
          if (Abs(aMatrix(i,j)).gt.sdecomp(i))
     &        sdecomp(i)=Abs(aMatrix(i,j))
        enddo
C     Singular matrix
        if (sdecomp(i).eq.0) then
          ierr=1
          herr='[LUdecomp error 1] singular matrix'//hnull
          RETURN
        endif
      enddo

      j=1
      Call PIVOT(n,maxn,j,iord,aMatrix,sdecomp)
      if (aMatrix(iord(1),1).eq.0) then
        ierr=1
        RETURN
      endif
      do j=2,n
        aMatrix(iord(1),j)=aMatrix(iord(1),j)/aMatrix(iord(1),1)
      enddo
      do j=2,n-1
        do i=j,n
          sum=0
          do k=1,j-1
            sum=sum+aMatrix(iord(i),k)*aMatrix(iord(k),j)
          enddo
          aMatrix(iord(i),j)=aMatrix(iord(i),j)-sum
        enddo
        Call PIVOT(n,maxn,j,iord,aMatrix,sdecomp)
        do k=j+1,n
          sum=0
          do i=1,j-1
            sum=sum+aMatrix(iord(j),i)*aMatrix(iord(i),k)
          enddo
          If (aMatrix(iord(j),j).eq.0) aMatrix(iord(j),j)=1E+20
          aMatrix(iord(j),k)=(aMatrix(iord(j),k)-sum)/aMatrix(iord(j),j)
        enddo
      enddo
      sum=0
      do k=1,n-1
        sum=sum+aMatrix(iord(n),k)*aMatrix(iord(k),n)
      enddo
      aMatrix(iord(n),n)=aMatrix(iord(n),n)-sum
      If (aMatrix(iord(n),n).eq.0) aMatrix(iord(n),n)=1E+20

 10   continue
      ierr=0
      cMatrix(iord(1))=cMatrix(iord(1))/aMatrix(iord(1),1)
      do i=2,n
        sum=0
        do j=1,i-1
          sum=sum+aMatrix(iord(i),j)*cMatrix(iord(j))
        enddo
        cMatrix(iord(i))=(cMatrix(iord(i))-sum)/aMatrix(iord(i),i)
      enddo

      do i=n-1,1,-1
        sum=0
        do j=i+1,n
          sum=sum+aMatrix(iord(i),j)*cMatrix(iord(j))
        enddo
        cMatrix(iord(i))=cMatrix(iord(i))-sum
      enddo
      do i=1,n
        ctemp(i)=cMatrix(iord(i))
      enddo
      do i=1,n
        cMatrix(i)=ctemp(i)
      enddo
      end                                           !subroutine LUDECOMP
c
c ======================================================================
c
      subroutine PIVOT (n,maxn,j,iord,aMatrix,sdecomp)
c
c  Part of the LUdecomp routine
c
c  written by E.W. Lemmon, NIST Thermophysics Division, Boulder, Colorado
c  01-01-92 EWL, original version
c
      include 'commons.for'
      dimension amatrix(maxn,maxn),iord(100),sdecomp(maxn)
c
      ipivt=j
      big=Abs(aMatrix(iord(j),j)/sdecomp(iord(j)))
      do i=j+1,n
        dummy=Abs(aMatrix(iord(i),j)/sdecomp(iord(i)))
        If (dummy.gt.big) then
          big=dummy
          ipivt=i
        endif
      enddo
      idummy=iord(ipivt)
      iord(ipivt)=iord(j)
      iord(j)=idummy
      end                                              !subroutine PIVOT
c
c ======================================================================
c
      subroutine CUBIC (a,z)
c
c     General purpose routine to solve a cubic equation of the form
c       z**3 + a(3)*z**2 +a(2)*z + a(1) = 0
c
c     The smallest root is returned in z(1) and the largest in z(2).
c     The middle root, if it exists, is discarded.
c
c  written by NIST Thermophysics Division, Boulder, Colorado
c  09-24-04 original version
c  05-17-11 EWL, change r to rr to avoid conflicts with gcnst
c
      include 'commons.for'
      dimension a(3),z(3)
c
c  All of the digits are necessary for liquid densities with pressures very close to zero
      pi=3.14159265358979323846d0
      add1=2.d0*pi/3.d0
      add2=2.d0*add1
      a0=a(1)
      a1=a(2)
      a2=a(3)/3.d0
      q=a1/3.d0-a2*a2
      rr=(a1*a2-a0)/2.d0-a2*a2*a2
      test=q*q*q+rr*rr
      if (test.lt.0.d0) then       ! three distinct roots
        test=SQRT(-test)
        q=2.d0*CBRTX(SQRT(rr*rr+test*test))
        theta=pi
        if (abs(rr).gt.1.d-20) theta=ATAN(test/rr)
        if (theta.lt.0.d0) theta=theta+pi
        theta=theta/3.d0
        z(1)=q*COS(theta)-a2
        z(2)=q*COS(theta+add1)-a2
        z(3)=q*COS(theta+add2)-a2
      else                          ! either one real, or three real w/ 2 identical
        test=SQRT(test)
        s1=CBRTX(rr+test)
        s2=CBRTX(rr-test)
        z(1)=s1+s2-a2
        z(2)=z(1)
        z(3)=z(1)
        if (test.gt.0.d0) RETURN   ! only one real
        z(2)=-0.5d0*(s1+s2)-a2
        z(3)=z(2)                   ! three real, but 2 identical
      endif
      zmin=MIN(z(1),z(2),z(3))
      z(2)=MAX(z(1),z(2),z(3))
      z(1)=zmin
      if (zmin.lt.0.d0) z(1)=z(2)
      RETURN
      end                                              !subroutine CUBIC
c
c ======================================================================
c
      subroutine FITL (n,maxn,xPnts,yPnts,xval,yval,cmatrix,ierr,herr)
c
c  Linearly fit an equation to (x,y) data and return the value
c  at a specified x.
c
c  inputs:
c         n--number of data points
c      maxn--amatrix and cmatrix array sizes
c     xPnts--array of n data points for the x-axis data
c     yPnts--array of n data points for the y-axis data
c      xval--value of x where y will be calculated
c  outputs:
c      yval--value of y at xval
c   cmatrix--coefficients of the fit
c      ierr--error flag:   0 = successful
c      herr--error string (character*255 variable if ierr<>0)
c
c  written by E.W. Lemmon, NIST Thermophysics Division, Boulder, Colorado
c  07-06-11 EWL, original version
c
      include 'commons.for'
      dimension xPnts(*),yPnts(*)
      dimension amatrix(maxn,maxn),cmatrix(maxn)
      character herr*255
c
      ierr=0
      herr=' '
      yval=0.d0
      if (n.eq.1) then
        yval=yPnts(1)
      elseif (n.eq.2) then
        slope=(yPnts(1)-yPnts(2))/(xPnts(1)-xPnts(2))
        b=yPnts(1)-slope*xPnts(1)
        yval=slope*xval+b
      elseif (n.gt.2 .and. n.le.50) then
        do i=1,n
          do j=1,n
            aMatrix(i,j)=xPnts(i)**(j-1.d0)
          enddo
          cMatrix(i)=yPnts(i)
        enddo
        call LUdecomp (n,maxn,aMatrix,cMatrix,ierr,herr)
        yval=0.d0
        do j=1,n
          yval=yval+cMatrix(j)*xval**(j-1.d0)
        enddo
      else
        ierr=1
        herr='[FITL error 1] invalid inputs'//hnull
      endif
      RETURN
      end                                               !subroutine FITL
c
c ======================================================================
c
      subroutine IDCRV (d,x,t,ierr,herr)
      include 'commons.for'
      dimension x(ncmax)
      character herr*255
      ierr=0
      herr=' '
c
      z=1
      if (nc.eq.1) then
        j=1
      else
        j=0
        if (x(1).eq.1) j=1
        if (x(itwo2).eq.1) j=2
      endif
      if (j.eq.0) then
        ierr=1
        herr='IDCRV:  valid only for pure fluids'
        RETURN
      endif
      if (t.eq.0) t=tz(j)*1.5

c  New method using the slope dz/dT to get quick convergence with dT
      i=0
 10   i=i+1
      call PRESS (t,d,x,p)
      z=p/d/r/t-1.d0
      tau=tz(j)/t
      del=d/rhoz(j)
      da11=phik(j,1,1,tau,del)
      dzdt=-da11/t
      if (i.gt.1000 .or. dzdt.eq.0.d0) then
        t=0
        RETURN
      endif
      t=t-z/dzdt
      if (ABS(z).gt.1d-8) goto 10
      end                                              !subroutine IDCRV
c
c ======================================================================
c
      subroutine BLCRV (d,x,t,ierr,herr)
      include 'commons.for'
      dimension x(ncmax)
      character herr*255
      ierr=0
      herr=' '
c
      func=0
      if (nc.eq.1) then
        j=1
      else
        j=0
        if (x(1).eq.1) j=1
        if (x(itwo2).eq.1) j=2
      endif
      if (j.eq.0) stop 'BL:  not a pure fluid'
      if (t.le.0) t=tz(j)*1.5d0
      i=0
 10   i=i+1
      del=d/rhoz(j)
      tau=tz(j)/t
      phi01=PHIK(j,0,1,tau,del)
      phi02=PHIK(j,0,2,tau,del)
      phi11=PHIK(j,1,1,tau,del)
      phi12=PHIK(j,1,2,tau,del)
      func=phi01+phi02
      dfdt=-(phi11+phi12)/t
      if (i.gt.100 .or. dfdt.eq.0.d0) then
        t=0
        RETURN
      endif
      t=t-func/dfdt
      if (ABS(func).gt.1d-8) goto 10
      end                                              !subroutine BLCRV
c
c ======================================================================
c
      subroutine JTCRV (d,x,t,ierr,herr)
      include 'commons.for'
      dimension x(ncmax)
      character herr*255
      ierr=0
      herr=' '
c
      if (nc.eq.1) then
        j=1
      else
        j=0
        if (x(1).eq.1) j=1
        if (x(itwo2).eq.1) j=2
      endif
      if (j.eq.0) stop 'JTCRV:  not a pure fluid'
      if (t.eq.0) t=tz(j)*1.5d0

      i=0
 10   i=i+1
      if (t.le.0) RETURN
      del=d/rhoz(j)
      tau=tz(j)/t
      phi01=PHIK(j,0,1,tau,del)
      phi02=PHIK(j,0,2,tau,del)
      phi11=PHIK(j,1,1,tau,del)
      phi12=PHIK(j,1,2,tau,del)
      phi21=PHIK(j,2,1,tau,del)
c  Only the top part in the calculation of hjt is required, the other
c  parts do not go to zero and thus do not contribute to finding JT=0
      hjt=phi01+phi02+phi11
c  The derivative of phi11 with respect to T results in phi21+phi11,
c  thus the '2.d0*' is required below
      dfdt=-(2.d0*phi11+phi12+phi21)/t
      if (i.gt.500 .or. dfdt.eq.0.d0) then
        t=0
        RETURN
      endif
      t=t-hjt/dfdt
      if (ABS(hjt).gt.1d-8) goto 10
      end                                              !subroutine JTCRV
c
c ======================================================================
c
      subroutine JICRV (d,x,t,ierr,herr)
      include 'commons.for'
      dimension x(ncmax)
      character herr*255
      ierr=0
      herr=' '
c
      if (nc.eq.1) then
        j=1
      else
        j=0
        if (x(1).eq.1) j=1
        if (x(itwo2).eq.1) j=2
      endif
      if (j.eq.0) stop 'JICRV:  not a pure fluid'
      if (t.le.0) t=tz(j)*10

      i=0
      del=d/rhoz(j)
 10   i=i+1
      tau=tz(j)/t
c  JI -->    d(Z)/d(T) at constant rho
c     --->   del*d^2(alphar)/d(del)/d(T)
c     ----> -del*tau*d^2(alphar)/d(del)/d(tau)/T (can ingore the /T for finding JI=0)
      func =PHIK(j,1,1,tau,del)
c  d(JI)/dT  --> tau**2*del*d^3(alphar)/d(del)/d(tau)**2/T**2
c               (one of the /T must be removed to match the one removed in func)
      dfdt=-PHIK(j,2,1,tau,del)/t
      if (i.gt.500 .or. dfdt.eq.0) then
        t=0
        RETURN
      endif
      t=t-func/dfdt
      if (ABS(func).gt.1d-8 .and. t.gt.0) goto 10
      end                                              !subroutine JICRV
c
c ======================================================================
c
      subroutine CSPLINE (n,xi,fi,coeff)
c
c  cubic-spline approximation
c
c  inputs:
c        n --number of segments (nodes-1)
c     xi[n]--abscissa values of nodes
c     fi[n]--ordinate values of nodes
c
c  outputs:
c  coeff[n]--spline coefficients (second-order derivatives)
c
c  written by Matthias Kunick, NIST Thermophysics Division, Boulder, Colorado
c  09-15-11  MK, original version
c
      include 'commons.for'
      dimension xi(1000),fi(1000),coeff(1000)
      dimension g(1000),h(1000),d(1000),b(1000),c(1000)
c
c  assign the intervals and function differences
      do i=1,n
        h(i)=xi(i+1)-xi(i)
        g(i)=fi(i+1)-fi(i)
      enddo
c
c  evaluate the coefficient matrix elements
      do i=1,n-1
        d(i)=2.d0*(h(i+1)+h(i))
        b(i)=0.d0
        if (h(i).ne.0.d0 .and. h(i+1).ne.0.d0)
     &  b(i)=6.d0*(g(i+1)/h(i+1)-g(i)/h(i))
        c(i)=h(i+1)
      enddo
c
c  obtain the second-order derivatives
      call TRIDIAG (n-1,d,c,c,b,g)
      coeff(1)=0.d0
      coeff(n+1)=0.d0
      do i=2,n
        coeff(i)=g(i-1)
      enddo
c
      end                                            !subroutine CSPLINE
c
c ======================================================================
c
      subroutine TRIDIAG (j,d,e,c,b,z)
c
c  function to solve the tridiagonal linear equation set.
c
c  written by Matthias Kunick, NIST Thermophysics Division, Boulder, Colorado
c  09-15-11  MK, original version
c
      include 'commons.for'
      dimension d(1000),e(1000),c(1000),b(1000)
      dimension z(1000),y(1000),w(1000),v(1000),t(1000)
c
c  evaluate the elements in the LU decomposition
      w(1)=d(1)
      v(1)=c(1)
      t(1)=0.d0
      if (w(1).ne.0.d0) t(1)=e(1)/w(1)
      do i=2,j-1
        w(i)=d(i)-v(i-1)*t(i-1)
        v(i)=c(i)
        t(i)=0.d0
        if (w(i).ne.0.d0) t(i)=e(i)/w(i)
      enddo
      w(j)=d(j)-v(j-1)*t(j-1)
c
c  forward substitution to obtain y
      y(1)=0.d0
      if (w(1).ne.0.d0) y(1)=b(1)/w(1)
      do i=2,j
        y(i)=0.d0
        if (w(i).ne.0.d0) y(i)=(b(i)-v(i-1)*y(i-1))/w(i)
      enddo
c
c  backward substitution to obtain z
      z(j)=y(j)
      do i=j-1,1,-1
        z(i)=y(i)-t(i)*z(i+1)
      enddo
c
      end                                            !subroutine TRIDIAG
c
c ======================================================================
c
      subroutine CSPLNVAL (n,xi,fi,coeff,x,f,ierr,herr)
c
c  calculates the function value of a spline function.
c
c  inputs:
c       n --number of nodes
c    xi[n]--abscissa values of nodes
c    fi[n]--ordinate values of nodes
c coeff[n]--spline coefficients
c       x --independent variable (abscissa)
c  outputs:
c        f--function value (ordinate)
c     ierr--error flag:   0 = successful
c                       192 = x<xi(1) or x>xi(n)
c     herr--error string (character*255 variable if ierr<>0)
c
c  written by Matthias Kunick, NIST Thermophysics Division, Boulder, Colorado
c  09-15-11  MK, original version
c
      include 'commons.for'
      dimension xi(1000),fi(1000),coeff(1000)
      character*255 herr
c
      ierr=0
      herr=' '
      f=0.d0
c
      if (x.lt.xi(1) .or. x.gt.xi(n)) then
        ierr=192
        write (herr,1001) xi(1),x,xi(n)
        call ERRMSG (ierr,herr)
 1001   format ('[CSPLNVAL error 192] ',
     &          'x is out of range! xi(1)=', g12.5,
     &          ' x=',g12.5,' xi(n) =',g12.5)
        RETURN
      endif
c
      k=1
      dx=x-xi(1)
      do while (dx.ge.0.d0 .and. k.lt.n-1)
        k=k+1
        dx=x-xi(k)
      enddo
      k=k-1
      if (k.le.1) k=2
c
      dx=xi(k+1)-xi(k)
      if (dx.eq.0.) RETURN
      alpha=coeff(k+1)/(6.d0*dx)
      beta =-coeff(k)/(6.d0*dx)
      gamma=fi(k+1)/dx-dx*coeff(k+1)/6.d0
      eta  =dx*coeff(k)/6.d0-fi(k)/dx
      f    =alpha*(x-xi(k))*(x-xi(k))*(x-xi(k))
     &     +beta*(x-xi(k+1))*(x-xi(k+1))*(x-xi(k+1))
     &     +gamma*(x-xi(k))+eta*(x-xi(k+1))
c
      end                                           !subroutine CSPLNVAL
c
c ======================================================================
c
      subroutine SPLNVAL (isp,iderv,a,f,ierr,herr)
c
c  calculates the function value of a spline
c
c  inputs:
c      isp--indicator for which spline to use (1-nc: composition,
c           nc+1: temperature, nc+2: pressure, nc+3: density,
c           nc+4: enthalpy, nc+5: entropy)
c    iderv--values of -1 and -2 return lower and upper root values,
c           value of 0 returns spline function, value of 1 returns
c           derivative of spline function with respect to density
c        a--root value
c  outputs:
c        f--value of spline function at input root
c     ierr--error flag:   0 = successful
c     herr--error string (character*255)
c
c  written by E.W. Lemmon, NIST Thermophysics Division, Boulder, Colorado
c  09-20-11 EWL, original version
c  11-27-12 EWL, add enthalpy and entropy
c
      include 'commons.for'
      dimension xPnts(1000),yPnts(1000),coefs(1000)
      character herr*255
      f=300
      if (narr.lt.2) then
        ierr=1
        herr='[SPLNVAL error 1] number of points set to zero'
        RETURN
      endif
      do i=1,narr
        xPnts(i)=xarr(  0,i)
        yPnts(i)=xarr(isp,i)
        if (isp.gt.0) coefs(i)=carr(isp,i)
      enddo
      if (iderv.eq.-1) then
        if (xPnts(1).lt.100.) f=exp(xPnts(1))
      elseif (iderv.eq.-2) then
        if (xPnts(narr).lt.100.) f=exp(xPnts(narr))
      elseif (iderv.eq.0) then
        if (a.le.0) RETURN
        call CSPLNVAL(narr,xPnts,yPnts,coefs,log(a),b,ierr,herr)
        f=b
        if (isp.le.nc+3 .and. b.lt.100.) f=exp(b)   !All values except h and s are on a log basis
      else
        da=0.001d0  !Numberical derivative with dx=0.001
        if (a-da.gt.0) then
          call CSPLNVAL(narr,xPnts,yPnts,coefs,log(a+da),bp,ierr,herr)
          call CSPLNVAL(narr,xPnts,yPnts,coefs,log(a-da),bn,ierr,herr)
        else
          call CSPLNVAL(narr,xPnts,yPnts,coefs,log(a+2.d0*da),bp,
     &                  ierr,herr)
          call CSPLNVAL(narr,xPnts,yPnts,coefs,log(a),bn,ierr,herr)
        endif
        if (da.ne.0.) then
          if (isp.le.nc+3) then
            if (bp.lt.100 .and. bn.lt.100) f=(exp(bp)-exp(bn))/(2.d0*da)
          else
            f=(bp-bn)/(2.d0*da)
          endif
        endif
      endif
      end                                            !subroutine SPLNVAL
c
c ======================================================================
c
      subroutine SPLNROOT (isp,iderv,f,a,ierr,herr)
c
c  calculates the root of a given value of a spline function
c
c  inputs:
c      isp--indicator for which spline to use (1-nc: composition,
c           nc+1: temperature, nc+2: pressure, nc+3: density,
c           nc+4: enthalpy, nc+5: entropy)
c    iderv--values of -1 and -2 return lower and upper root values,
c           value of 0 returns spline root, value of 1 returns
c           root where derivative of spline with respect to rho is equal to the
c           the value of f (set f=0 to find maximum or minimum)
c        f--value of spline function
c  outputs:
c        a--root value (initial value required since some splines can be doubled valued)
c     ierr--error flag:   0 = successful
c     herr--error string (character*255)
c
c  written by E.W. Lemmon, NIST Thermophysics Division, Boulder, Colorado
c  09-20-11 EWL, original version
c
      include 'commons.for'
      character herr*255
c  get upper and lower bounds
      call SPLNVAL(isp,-1,a,alow,ierr,herr)
      call SPLNVAL(isp,-2,a,aupp,ierr,herr)
      a1=a
      a2=a1+0.1d0
      a3=a2
      call SPLNVAL(isp,iderv,a1,f1,ierr,herr)
      f2=1.d8
      j=0
      if (narr.lt.2) goto 20

c  setup bounds for false-position if needed
      al=alow
      au=aupp
      call SPLNVAL(isp,iderv,al,fl,ierr,herr)
      call SPLNVAL(isp,iderv,au,fu,ierr,herr)
      fl=fl-f
      fu=fu-f
      if (fl*fu.lt.0.d0 .and. fu.lt.fl) then
        ff=fu
        fu=fl
        fl=ff
        aa=au
        au=al
        al=aa
      endif

      do while (abs(f2).gt.1.d-7)
        call SPLNVAL(isp,iderv,a2,f2,ierr,herr)
        f2=f2-f
        if (f2.gt.fl .and. f2.lt.0.d0) then
          al=a2
          fl=f2
        elseif (f2.lt.fu .and. f2.gt.0.d0) then
          au=a2
          fu=f2
        endif
        j=j+1
        if (ierr.gt.0 .or. j.gt.100 .or. abs(f1-f2).lt.1.d-20) goto 10
        da=-f2*(a1-a2)/(f1-f2)
        a1=a2
        f1=f2
c  don't allow more than a 10% change
        if (abs(da).gt.abs(a1/10.d0)) da=da/10.d0
        if (abs(da).gt.abs(a1/10.d0)) da=da/10.d0
        if (abs(da).gt.abs(a1/10.d0)) da=da/10.d0
        a2=a1+da
        if (a2.lt.alow .or. a2.gt.aupp) a2=a1+da/2.d0
        if (a2.lt.alow .or. a2.gt.aupp) a2=a1+da/5.d0
        if (a2.lt.alow .or. a2.gt.aupp) a2=a1+da/10.d0
        if (a2.lt.alow .or. a2.gt.aupp) a2=a1+da/25.d0
        if (a2.lt.alow .or. a2.gt.aupp) a2=a1+da/100.d0
        if (a2.lt.alow .or. a2.gt.aupp) a2=a1+da/1000.d0
      enddo
      a=a2
      RETURN

 10   continue
c  iteration failed, try false-position
      a3=a2
      if (fl*fu.ge.0.d0) then
        a2=au/4.d0
        call SPLNVAL(isp,iderv,a2,f2,ierr,herr)
        f2=f2-f
        if (a.lt.a2) then
          au=a2
          fu=f2
        else
          al=a2
          fl=f2
        endif
      endif
      if (fl*fu.lt.0.d0) then
        j=0
        f2=fu
        a2=(al+au)/2.d0
        do while (abs(f2).gt.1.d-7)
          call SPLNVAL(isp,iderv,a2,f2,ierr,herr)
          f2=f2-f
          if (f2.gt.fl .and. f2.lt.0.d0) then
            al=a2
            fl=f2
            a2=au-fu*(al-au)/(fl-fu)
          elseif (f2.lt.fu .and. f2.gt.0.d0) then
            au=a2
            fu=f2
            a2=au-fu*(al-au)/(fl-fu)
          elseif (j.eq.0) then
            a2=0.9*al+0.1*au
          elseif (j.eq.1) then
            a2=0.1*al+0.9*au
          else
            goto 20
          endif
          j=j+1
          if (ierr.gt.0 .or. j.gt.200) goto 20
        enddo
        a=a2
        RETURN
      endif

20    continue
      ierr=1
      a=alow
      if (a3.gt.aupp) a=aupp
      end                                           !subroutine SPLNROOT
c
c ======================================================================
c
      subroutine MINEIGEN (n,a,u,xlamda,ierr,herr)
c
c  determine the smallest eigenvalue of the input array
c
c  inputs:
c         n--number of elements to solve
c         a--[ncmax x ncmax] array
c
c  outputs:
c         u--unit vector of size ncmax
c    xlamda--smallest eigenvalue
c      ierr--error flag
c      herr--error string (character*255 variable if ierr<>0)
c
c  written by G. Venkatarathnam, Indian Institute of Technology Madras
c  10-15-11  GV, original version
c  01-07-13 EWL, adapt code for use in REFPROP
c
      include 'commons.for'
      dimension a(ncmax,ncmax),u(ncmax),y(ncmax),a1(ncmax,ncmax)
      character*255 herr
      maxn=ncmax
      tol=1.d-12
      maxiters=20
      a1(1:n,1:n)=a(1:n,1:n)
      do i=1,n
        a1(i,i)=a1(i,i)-xlamda
      enddo
      y(1:n)=0.d0
      call LUdecomp (n,maxn,a1,y,ierr,herr)
      if (ierr.ne.0) RETURN
      iters=0
      xnorm=1.d0
      y(2:n)=0.d0
      y(1)=a1(1,1)
      do while (xnorm.gt.tol .and. iters.le.maxiters)
        iters=iters+1
        xlamdao=xlamda
        u(1:n)=y(1:n)/SQRT(SUM(y(1:n)**2))
        y(1:n)=u(1:n)
        ierr=-191
        call LUdecomp (n,maxn,a1,y,ierr,herr)
        if (ierr.ne.0) RETURN
        xlamda=DOT_PRODUCT(y(1:n),MATMUL(a(1:n,1:n),y(1:n)))/
     &       DOT_PRODUCT(y(1:n),y(1:n))
        xnorm=1.d0
        if (xlamdao.ne.0.d0) xnorm=(1.d0-xlamda/xlamdao)**2
      enddo
      if (u(1).lt.0.d0) u(1:n)=SIGN(u(1:n),-u(1:n))
      if (iters.gt.maxiters) then
        ierr=1
        herr='[MINEIGEN error 1] routine did not converge'
      endif
      RETURN
      end                                           !subroutine MINEIGEN
c
c ======================================================================
c
      subroutine PASSCMN (hvr,iset,icomp,jcomp,
     &                    hstr,ilng,dbl,arr,ierr,herr)
c
c  get or set values of variables in the common blocks
c
c  inputs:
c      hvr--character string with the common variable's name (lower case only)
c     iset--flag to indicate the get/set condition
c             0 -- > get variable value
c             1 -- > set variable value
c    icomp--component number
c    jcomp--second component number for binary mixture variables
c  inputs and outputs:
c     hstr--input or output for a character string
c     ilng--input or output for a long variable
c      dbl--input or output for a double precision variable
c      arr--input or output for a double precision array
c           note:  values in this array are not initialized to 0
c  outputs:
c     ierr--error flag:  0 = successful
c                        1 = unrecognized variable name
c     herr--error string (character*255 variable if ierr<>0)
c
c  Examples:
c  Call PASSCMN ('txeos',  0,3,0, h,i, tmx,z,   ierr,herr) - get tmax of component 3
c  Call PASSCMN ('deos',   1,2,0, h,i, dmx,z,   ierr,herr) - set dmax of component 2
c  Call PASSCMN ('tz',     0,1,0, h,i, tc, z,   ierr,herr) - get reducing temperature of component 1
c  Call PASSCMN ('ntermf', 0,1,0, h,nt,v,  z,   ierr,herr) - get number of terms in the Helmholtz equation for component 1
c  Call PASSCMN ('coefhmx',1,1,0, h,i, v,  cf,  ierr,herr) - set the coefficients in the Helmholtz equation for component 1
c  Call PASSCMN ('cpc0',   1,5,0, h,i, v,  cp0, ierr,herr) - set the coefficients in the cp0 equation for component 5
c  Call PASSCMN ('fprkij', 1,1,2, h,i, v,  fpr, ierr,herr) - set the PR coefficient for the 1,2 binary
c
c  written by Eric W. Lemmon, NIST Thermophysics Division, Boulder, Colorado
c  01-16-13 EWL, original version
c
cDEC$ ATTRIBUTES DLLEXPORT, Decorate, Alias: "PASSCMN"::PASSCMN
cDEC$ ATTRIBUTES STDCALL, REFERENCE::PASSCMN
c
      include 'commons.for'
      character*255 herr,hvar,hstr,htemp
      character hvr*(*)
      dimension arr(100),a(100)
c
      ierr=0
      herr=' '
      l=.false.
      if (iset.eq.1) l=.true.
      if (abs(icomp).gt.ncmax .or. abs(jcomp).gt.ncmax) then
        ierr=2
        herr='[PASSCMN error] inputs out of bounds'
      endif
c
      ia=0
      ij=0
      v=0.d0
      a=0.d0
      htemp=' '
      if (.not.l) then
        hstr=' '
        ilng=0
        dbl=0.d0
      endif
c
      hvar=hvr
      i=index(hvr,char(0))
      if (i.gt.1) hvar=hvr(1:i-1)
c
c  character strings
      if (hvar.eq.'heos') then
        htemp=heos
        if (l) heos=hstr
c
c  long variables
      elseif (hvar.eq.'ntermf') then
        ij=ntermf(icomp)
        if (l) ntermf(icomp)=ilng
      elseif (hvar.eq.'ncrt') then
        ij=ncrt(icomp)
        if (l) ncrt(icomp)=ilng
      elseif (hvar.eq.'ntermc') then
        ij=ntermc(icomp)
        if (l) ntermc(icomp)=ilng
      elseif (hvar.eq.'nterme') then
        ij=nterme(icomp)
        if (l) nterme(icomp)=ilng
C
c  double precision variables
      elseif (hvar.eq.'accen') then
        v=accen(icomp)
        if (l) accen(icomp)=dbl
      elseif (hvar.eq.'dcrit') then
        v=Dcrit(icomp)
        if (l) Dcrit(icomp)=dbl
      elseif (hvar.eq.'deos') then
        v=Deos(icomp)
        if (l) Deos(icomp)=dbl
      elseif (hvar.eq.'dipole') then
        v=dipole(icomp)
        if (l) dipole(icomp)=dbl
      elseif (hvar.eq.'pcfeq') then
        v=pcfeq(icomp)
        if (l) pcfeq(icomp)=dbl
      elseif (hvar.eq.'pcrit') then
        v=pcrit(icomp)
        if (l) pcrit(icomp)=dbl
      elseif (hvar.eq.'peos') then
        v=peos(icomp)
        if (l) peos(icomp)=dbl
      elseif (hvar.eq.'r') then
        v=R
        if (l) R=dbl
      elseif (hvar.eq.'rho0feq') then
        v=rho0feq(icomp)
        if (l) rho0feq(icomp)=dbl
      elseif (hvar.eq.'rhocfeq') then
        v=rhocfeq(icomp)
        if (l) rhocfeq(icomp)=dbl
      elseif (hvar.eq.'rhoz') then
        v=rhoz(icomp)
        if (l) rhoz(icomp)=dbl
      elseif (hvar.eq.'t0feq') then
        v=t0feq(icomp)
        if (l) t0feq(icomp)=dbl
      elseif (hvar.eq.'tcfeq') then
        v=tcfeq(icomp)
        if (l) tcfeq(icomp)=dbl
      elseif (hvar.eq.'tcrit') then
        v=tcrit(icomp)
        if (l) tcrit(icomp)=dbl
      elseif (hvar.eq.'tmeos') then
        v=tmeos(icomp)
        if (l) tmeos(icomp)=dbl
      elseif (hvar.eq.'tnbp') then
        v=tnbp(icomp)
        if (l) tnbp(icomp)=dbl
      elseif (hvar.eq.'ttpn') then
        v=ttpn(icomp)
        if (l) ttpn(icomp)=dbl
      elseif (hvar.eq.'txeos') then
        v=txeos(icomp)
        if (l) txeos(icomp)=dbl
      elseif (hvar.eq.'tz') then
        v=tz(icomp)
        if (l) tz(icomp)=dbl
      elseif (hvar.eq.'wmas') then
        v=wmas(icomp)
        if (l) wmas(icomp)=dbl
      elseif (hvar.eq.'zcrit') then
        v=Zcrit(icomp)
        if (l) Zcrit(icomp)=dbl
      elseif (hvar.eq.'pcpr') then
        v=pcpr(icomp)
        if (l) pcpr(icomp)=dbl
      elseif (hvar.eq.'rhocpr') then
        v=rhocpr(icomp)
        if (l) rhocpr(icomp)=dbl
      elseif (hvar.eq.'tcpr') then
        v=tcpr(icomp)
        if (l) tcpr(icomp)=dbl
      elseif (hvar.eq.'acnpr') then
        v=acnpr(icomp)
        if (l) acnpr(icomp)=dbl
c
c  arrays
      elseif (hvar.eq.'afeq') then
        ia=ntermf(icomp)+ncrt(icomp)
        do i=1,ia
          a(i) = afeq(icomp,i)
          if (l) afeq(icomp,i)=arr(i)
        enddo
      elseif (hvar.eq.'tifeq') then
        ia=ntermf(icomp)+ncrt(icomp)
        do i=1,ia
          a(i) = tifeq(icomp,i)
          if (l) tifeq(icomp,i)=arr(i)
        enddo
      elseif (hvar.eq.'difeq') then
        ia=ntermf(icomp)+ncrt(icomp)
        do i=1,ia
          a(i) = difeq(icomp,i)
          if (l) difeq(icomp,i)=arr(i)
        enddo
      elseif (hvar.eq.'dlif') then
        ia=ntermf(icomp)+ncrt(icomp)
        do i=1,ia
          a(i) = dlif(icomp,i)
          if (l) dlif(icomp,i)=arr(i)
        enddo
      elseif (hvar.eq.'cpc0') then
        ia=ntermc(icomp)+nterme(icomp)
        do i=1,ia
          a(i) = cpc0(icomp,i)
          if (l) cpc0(icomp,i)=arr(i)
        enddo
      elseif (hvar.eq.'xkc0') then
        ia=ntermc(icomp)+nterme(icomp)
        do i=1,ia
          a(i) = xkc0(icomp,i)
          if (l) xkc0(icomp,i)=arr(i)
        enddo
      elseif (hvar.eq.'prcoef') then
        ia=20
        do i=1,ia
          a(i) = prcoef(icomp,i)
          if (l) prcoef(icomp,i)=arr(i)
        enddo
      elseif (hvar.eq.'fprkij') then
        ia=nmxprb
        do i=1,ia
          a(i) = fprkij(icomp,jcomp,i)
          if (l) fprkij(icomp,jcomp,i)=arr(i)
        enddo
c
      else
        ierr=1
        herr='[PASSCMN error] variable name not recognized'
      end if
c
      if (l) then
        tsvcp0(icomp)=0.d0
        call RESETA
      else
        if (ia.gt.0) then
          arr(1:ia)=a(1:ia)
        elseif (ij.ne.0) then
          ilng=ij
        elseif (v.ne.0.d0) then
          dbl=v
        elseif (htemp.ne.' ') then
          hstr=htemp
        endif
      endif
      end                                            !subroutine PASSCMN
c
c        1         2         3         4         5         6         7
c23456789012345678901234567890123456789012345678901234567890123456789012
c
c ======================================================================
c                                                     end file utility.f
c ======================================================================
